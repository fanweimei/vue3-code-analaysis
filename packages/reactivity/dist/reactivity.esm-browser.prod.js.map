{"version":3,"file":"reactivity.esm-browser.prod.js","sources":["../../shared/src/makeMap.ts","../../shared/src/general.ts","../src/effectScope.ts","../src/effect.ts","../src/dep.ts","../src/reactiveEffect.ts","../src/baseHandlers.ts","../src/collectionHandlers.ts","../src/reactive.ts","../src/computed.ts","../src/ref.ts","../src/deferredComputed.ts","../src/constants.ts"],"sourcesContent":["/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nexport function makeMap(\r\n  str: string,\r\n  expectsLowerCase?: boolean,\r\n): (key: string) => boolean {\r\n  const set = new Set(str.split(','))\r\n  return expectsLowerCase\r\n    ? val => set.has(val.toLowerCase())\r\n    : val => set.has(val)\r\n}\r\n","import { makeMap } from './makeMap'\r\n\r\nexport const EMPTY_OBJ: { readonly [key: string]: any } = __DEV__\r\n  ? Object.freeze({})\r\n  : {}\r\nexport const EMPTY_ARR = __DEV__ ? Object.freeze([]) : []\r\n\r\nexport const NOOP = () => {}\r\n\r\n/**\r\n * Always return false.\r\n */\r\nexport const NO = () => false\r\n\r\nexport const isOn = (key: string) =>\r\n  key.charCodeAt(0) === 111 /* o */ &&\r\n  key.charCodeAt(1) === 110 /* n */ &&\r\n  // uppercase letter\r\n  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97)\r\n\r\nexport const isModelListener = (key: string) => key.startsWith('onUpdate:')\r\n\r\nexport const extend = Object.assign\r\n\r\nexport const remove = <T>(arr: T[], el: T) => {\r\n  const i = arr.indexOf(el)\r\n  if (i > -1) {\r\n    arr.splice(i, 1)\r\n  }\r\n}\r\n\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty\r\nexport const hasOwn = (\r\n  val: object,\r\n  key: string | symbol,\r\n): key is keyof typeof val => hasOwnProperty.call(val, key)\r\n\r\nexport const isArray = Array.isArray\r\nexport const isMap = (val: unknown): val is Map<any, any> =>\r\n  toTypeString(val) === '[object Map]'\r\nexport const isSet = (val: unknown): val is Set<any> =>\r\n  toTypeString(val) === '[object Set]'\r\n\r\nexport const isDate = (val: unknown): val is Date =>\r\n  toTypeString(val) === '[object Date]'\r\nexport const isRegExp = (val: unknown): val is RegExp =>\r\n  toTypeString(val) === '[object RegExp]'\r\nexport const isFunction = (val: unknown): val is Function =>\r\n  typeof val === 'function'\r\nexport const isString = (val: unknown): val is string => typeof val === 'string'\r\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\r\nexport const isObject = (val: unknown): val is Record<any, any> =>\r\n  val !== null && typeof val === 'object'\r\n\r\nexport const isPromise = <T = any>(val: unknown): val is Promise<T> => {\r\n  return (\r\n    (isObject(val) || isFunction(val)) &&\r\n    isFunction((val as any).then) &&\r\n    isFunction((val as any).catch)\r\n  )\r\n}\r\n\r\nexport const objectToString = Object.prototype.toString\r\nexport const toTypeString = (value: unknown): string =>\r\n  objectToString.call(value)\r\n\r\nexport const toRawType = (value: unknown): string => {\r\n  // extract \"RawType\" from strings like \"[object RawType]\"\r\n  return toTypeString(value).slice(8, -1)\r\n}\r\n\r\nexport const isPlainObject = (val: unknown): val is object =>\r\n  toTypeString(val) === '[object Object]'\r\n\r\nexport const isIntegerKey = (key: unknown) =>\r\n  isString(key) &&\r\n  key !== 'NaN' &&\r\n  key[0] !== '-' &&\r\n  '' + parseInt(key, 10) === key\r\n\r\nexport const isReservedProp = /*#__PURE__*/ makeMap(\r\n  // the leading comma is intentional so empty string \"\" is also included\r\n  ',key,ref,ref_for,ref_key,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted',\r\n)\r\n\r\nexport const isBuiltInDirective = /*#__PURE__*/ makeMap(\r\n  'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo',\r\n)\r\n\r\nconst cacheStringFunction = <T extends (str: string) => string>(fn: T): T => {\r\n  const cache: Record<string, string> = Object.create(null)\r\n  return ((str: string) => {\r\n    const hit = cache[str]\r\n    return hit || (cache[str] = fn(str))\r\n  }) as T\r\n}\r\n\r\nconst camelizeRE = /-(\\w)/g\r\n/**\r\n * @private\r\n */\r\nexport const camelize = cacheStringFunction((str: string): string => {\r\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\r\n})\r\n\r\nconst hyphenateRE = /\\B([A-Z])/g\r\n/**\r\n * @private\r\n */\r\nexport const hyphenate = cacheStringFunction((str: string) =>\r\n  str.replace(hyphenateRE, '-$1').toLowerCase(),\r\n)\r\n\r\n/**\r\n * @private\r\n */\r\nexport const capitalize = cacheStringFunction(<T extends string>(str: T) => {\r\n  return (str.charAt(0).toUpperCase() + str.slice(1)) as Capitalize<T>\r\n})\r\n\r\n/**\r\n * @private\r\n */\r\nexport const toHandlerKey = cacheStringFunction(<T extends string>(str: T) => {\r\n  const s = str ? `on${capitalize(str)}` : ``\r\n  return s as T extends '' ? '' : `on${Capitalize<T>}`\r\n})\r\n\r\n// compare whether a value has changed, accounting for NaN.\r\nexport const hasChanged = (value: any, oldValue: any): boolean =>\r\n  !Object.is(value, oldValue)\r\n\r\nexport const invokeArrayFns = (fns: Function[], arg?: any) => {\r\n  for (let i = 0; i < fns.length; i++) {\r\n    fns[i](arg)\r\n  }\r\n}\r\n\r\nexport const def = (obj: object, key: string | symbol, value: any) => {\r\n  Object.defineProperty(obj, key, {\r\n    configurable: true,\r\n    enumerable: false,\r\n    value,\r\n  })\r\n}\r\n\r\n/**\r\n * \"123-foo\" will be parsed to 123\r\n * This is used for the .number modifier in v-model\r\n */\r\nexport const looseToNumber = (val: any): any => {\r\n  const n = parseFloat(val)\r\n  return isNaN(n) ? val : n\r\n}\r\n\r\n/**\r\n * Only concerns number-like strings\r\n * \"123-foo\" will be returned as-is\r\n */\r\nexport const toNumber = (val: any): any => {\r\n  const n = isString(val) ? Number(val) : NaN\r\n  return isNaN(n) ? val : n\r\n}\r\n\r\nlet _globalThis: any\r\nexport const getGlobalThis = (): any => {\r\n  return (\r\n    _globalThis ||\r\n    (_globalThis =\r\n      typeof globalThis !== 'undefined'\r\n        ? globalThis\r\n        : typeof self !== 'undefined'\r\n          ? self\r\n          : typeof window !== 'undefined'\r\n            ? window\r\n            : typeof global !== 'undefined'\r\n              ? global\r\n              : {})\r\n  )\r\n}\r\n\r\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/\r\n\r\nexport function genPropsAccessExp(name: string) {\r\n  return identRE.test(name)\r\n    ? `__props.${name}`\r\n    : `__props[${JSON.stringify(name)}]`\r\n}\r\n","import type { ReactiveEffect } from './effect'\r\nimport { warn } from './warning'\r\n\r\nlet activeEffectScope: EffectScope | undefined\r\n\r\nexport class EffectScope {\r\n  /**\r\n   * @internal\r\n   */\r\n  private _active = true\r\n  /**\r\n   * @internal\r\n   */\r\n  effects: ReactiveEffect[] = []\r\n  /**\r\n   * @internal\r\n   */\r\n  cleanups: (() => void)[] = []\r\n\r\n  /**\r\n   * only assigned by undetached scope\r\n   * @internal\r\n   */\r\n  parent: EffectScope | undefined\r\n  /**\r\n   * record undetached scopes\r\n   * @internal\r\n   */\r\n  scopes: EffectScope[] | undefined\r\n  /**\r\n   * track a child scope's index in its parent's scopes array for optimized\r\n   * removal\r\n   * @internal\r\n   */\r\n  private index: number | undefined\r\n\r\n  constructor(public detached = false) {\r\n    this.parent = activeEffectScope\r\n    if (!detached && activeEffectScope) {\r\n      this.index =\r\n        (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\r\n          this,\r\n        ) - 1\r\n    }\r\n  }\r\n\r\n  get active() {\r\n    return this._active\r\n  }\r\n\r\n  run<T>(fn: () => T): T | undefined {\r\n    if (this._active) {\r\n      const currentEffectScope = activeEffectScope\r\n      try {\r\n        activeEffectScope = this\r\n        return fn()\r\n      } finally {\r\n        activeEffectScope = currentEffectScope\r\n      }\r\n    } else if (__DEV__) {\r\n      warn(`cannot run an inactive effect scope.`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This should only be called on non-detached scopes\r\n   * @internal\r\n   */\r\n  on() {\r\n    activeEffectScope = this\r\n  }\r\n\r\n  /**\r\n   * This should only be called on non-detached scopes\r\n   * @internal\r\n   */\r\n  off() {\r\n    activeEffectScope = this.parent\r\n  }\r\n\r\n  stop(fromParent?: boolean) {\r\n    if (this._active) {\r\n      let i, l\r\n      for (i = 0, l = this.effects.length; i < l; i++) {\r\n        this.effects[i].stop()\r\n      }\r\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\r\n        this.cleanups[i]()\r\n      }\r\n      if (this.scopes) {\r\n        for (i = 0, l = this.scopes.length; i < l; i++) {\r\n          this.scopes[i].stop(true)\r\n        }\r\n      }\r\n      // nested scope, dereference from parent to avoid memory leaks\r\n      if (!this.detached && this.parent && !fromParent) {\r\n        // optimized O(1) removal\r\n        const last = this.parent.scopes!.pop()\r\n        if (last && last !== this) {\r\n          this.parent.scopes![this.index!] = last\r\n          last.index = this.index!\r\n        }\r\n      }\r\n      this.parent = undefined\r\n      this._active = false\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Creates an effect scope object which can capture the reactive effects (i.e.\r\n * computed and watchers) created within it so that these effects can be\r\n * disposed together. For detailed use cases of this API, please consult its\r\n * corresponding {@link https://github.com/vuejs/rfcs/blob/master/active-rfcs/0041-reactivity-effect-scope.md | RFC}.\r\n *\r\n * @param detached - Can be used to create a \"detached\" effect scope.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#effectscope}\r\n */\r\nexport function effectScope(detached?: boolean) {\r\n  return new EffectScope(detached)\r\n}\r\n\r\nexport function recordEffectScope(\r\n  effect: ReactiveEffect,\r\n  scope: EffectScope | undefined = activeEffectScope,\r\n) {\r\n  if (scope && scope.active) {\r\n    scope.effects.push(effect)\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the current active effect scope if there is one.\r\n *\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#getcurrentscope}\r\n */\r\nexport function getCurrentScope() {\r\n  return activeEffectScope\r\n}\r\n\r\n/**\r\n * Registers a dispose callback on the current active effect scope. The\r\n * callback will be invoked when the associated effect scope is stopped.\r\n *\r\n * @param fn - The callback function to attach to the scope's cleanup.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#onscopedispose}\r\n */\r\nexport function onScopeDispose(fn: () => void) {\r\n  if (activeEffectScope) {\r\n    activeEffectScope.cleanups.push(fn)\r\n  } else if (__DEV__) {\r\n    warn(\r\n      `onScopeDispose() is called when there is no active effect scope` +\r\n        ` to be associated with.`,\r\n    )\r\n  }\r\n}\r\n","import { NOOP, extend } from '@vue/shared'\r\nimport type { ComputedRefImpl } from './computed'\r\nimport {\r\n  DirtyLevels,\r\n  type TrackOpTypes,\r\n  type TriggerOpTypes,\r\n} from './constants'\r\nimport type { Dep } from './dep'\r\nimport { type EffectScope, recordEffectScope } from './effectScope'\r\n\r\nexport type EffectScheduler = (...args: any[]) => any\r\n\r\nexport type DebuggerEvent = {\r\n  effect: ReactiveEffect\r\n} & DebuggerEventExtraInfo\r\n\r\nexport type DebuggerEventExtraInfo = {\r\n  target: object\r\n  type: TrackOpTypes | TriggerOpTypes\r\n  key: any\r\n  newValue?: any\r\n  oldValue?: any\r\n  oldTarget?: Map<any, any> | Set<any>\r\n}\r\n\r\nexport let activeEffect: ReactiveEffect | undefined\r\n\r\n// 副作用函数\r\nexport class ReactiveEffect<T = any> {\r\n  active = true\r\n  /**\r\n   * 多对多的关系，一个副作用函数可以包含多个依赖的响应对象，一个响应对象可以存在多个副作用函数中\r\n   */\r\n  deps: Dep[] = []\r\n\r\n  /**\r\n   * Can be attached after creation\r\n   * @internal\r\n   */\r\n  computed?: ComputedRefImpl<T>\r\n  /**\r\n   * @internal\r\n   */\r\n  allowRecurse?: boolean\r\n\r\n  onStop?: () => void\r\n  // dev only\r\n  onTrack?: (event: DebuggerEvent) => void\r\n  // dev only\r\n  onTrigger?: (event: DebuggerEvent) => void\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  _dirtyLevel = DirtyLevels.Dirty\r\n  /**\r\n   * @internal\r\n   */\r\n  _trackId = 0\r\n  /**\r\n   * @internal\r\n   */\r\n  _runnings = 0\r\n  /**\r\n   * @internal\r\n   */\r\n  _shouldSchedule = false\r\n  /**\r\n   * @internal\r\n   */\r\n  _depsLength = 0\r\n\r\n  constructor(\r\n    public fn: () => T,\r\n    public trigger: () => void,\r\n    public scheduler?: EffectScheduler,\r\n    scope?: EffectScope,\r\n  ) {\r\n    recordEffectScope(this, scope)\r\n  }\r\n\r\n  public get dirty() {\r\n    if (this._dirtyLevel === DirtyLevels.MaybeDirty) {\r\n      pauseTracking()\r\n      for (let i = 0; i < this._depsLength; i++) {\r\n        const dep = this.deps[i]\r\n        if (dep.computed) {\r\n          triggerComputed(dep.computed)\r\n          if (this._dirtyLevel >= DirtyLevels.Dirty) {\r\n            break\r\n          }\r\n        }\r\n      }\r\n      if (this._dirtyLevel < DirtyLevels.Dirty) {\r\n        this._dirtyLevel = DirtyLevels.NotDirty\r\n      }\r\n      resetTracking()\r\n    }\r\n    return this._dirtyLevel >= DirtyLevels.Dirty\r\n  }\r\n\r\n  public set dirty(v) {\r\n    this._dirtyLevel = v ? DirtyLevels.Dirty : DirtyLevels.NotDirty\r\n  }\r\n\r\n  // 1 last null active p1\r\n  // 2 last p1 active p2\r\n  // 3 last p2 active p3\r\n  // p3执行完 active p2\r\n  // p2环境 执行完 active p1\r\n  // p3环境执行完\r\n  /**\r\n   * 总而言之：\r\n   * 1. lastEffect和activeEffect是为了防止堆栈递归调用effect函数的情况；\r\n   * 2. preCleanupEffect和postCleanupEffect结合_trackId目的就是为了每次执行前先斩断依赖对象和副作用函数之间的关系，\r\n   * 执行之后再重新收集依赖关系，但是呢从性能上考虑清空的时候不是直接把deps数组长度清空，\r\n   * 而是先通过_depsLength设置为0，重新建立正确的依赖关系，把多余的元素再剪短依赖关系\r\n   * 3. _trackId是副作用对象的执行次数追踪id\r\n   */\r\n  run() {\r\n    this._dirtyLevel = DirtyLevels.NotDirty // 只要即将执行，就是标志为NotDirty，比如一些异步函数，如果等执行完，\r\n    if (!this.active) {\r\n      return this.fn()\r\n    }\r\n    let lastShouldTrack = shouldTrack\r\n    let lastEffect = activeEffect\r\n    try {\r\n      shouldTrack = true\r\n      activeEffect = this\r\n      this._runnings++\r\n      /**\r\n       * 通过preCleaupEffect方法\r\n       * 标识执行状态_trackId加1了，然后把_depsLength设置为零\r\n       */\r\n      preCleanupEffect(this);\r\n      /**\r\n       * 执行fn副作用函数的时候，会重新手机依赖对象\r\n       * 收集的过程有多种情况：\r\n       * （1）只是把Dep中的key对应的value（_trackId）更新，它们的依赖关系依赖没变\r\n       * （2）存在有一些依赖对象没有执行到的，那这个时候deps里面的元素是比_depsLength要多\r\n       */\r\n      return this.fn()\r\n    } finally {\r\n      /**\r\n       * 收集过程中，走到清空2，\r\n       * 通过postCleanupEffect，把deps中多余的元素清空，并且见到多余的依赖对象和副作用函数之间的关系\r\n       */\r\n      postCleanupEffect(this)\r\n      /**\r\n       * _running的作用：\r\n       * （1）如果一个副作用函数对一个key先有get,然后set操作，因为_running不为0，所以后面的set操作不会再次触发副作用函数的执行\r\n       * （2）如果副作用函数是一个异步函数，在副作用函数还没执行结束之前，就发生了依赖对象key的改变，因为_running也不会再次触发副作用函数\r\n       */\r\n      this._runnings--\r\n      activeEffect = lastEffect\r\n      shouldTrack = lastShouldTrack\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    if (this.active) {\r\n      preCleanupEffect(this)\r\n      postCleanupEffect(this)\r\n      this.onStop?.()\r\n      this.active = false\r\n    }\r\n  }\r\n}\r\n\r\nfunction triggerComputed(computed: ComputedRefImpl<any>) {\r\n  return computed.value\r\n}\r\n\r\nfunction preCleanupEffect(effect: ReactiveEffect) {\r\n  effect._trackId++\r\n  effect._depsLength = 0\r\n}\r\n\r\nfunction postCleanupEffect(effect: ReactiveEffect) {\r\n  if (effect.deps && effect.deps.length > effect._depsLength) {\r\n    for (let i = effect._depsLength; i < effect.deps.length; i++) {\r\n      cleanupDepEffect(effect.deps[i], effect)\r\n    }\r\n    effect.deps.length = effect._depsLength\r\n  }\r\n}\r\n\r\nfunction cleanupDepEffect(dep: Dep, effect: ReactiveEffect) {\r\n  const trackId = dep.get(effect)\r\n   //这里判断原因\r\n  /**\r\n   * 比如说ok text name三个属性，\r\n   * 第二次ok为true了，\r\n   * text对应的代码不会再执行到了，name就占据到deps中的第二个位置，再执行postCleanupEffect方法时候\r\n   * 第三个元素其实就是第二个元素，trackId是等于effect._trackId的\r\n   */\r\n  if (trackId !== undefined && effect._trackId !== trackId) {\r\n    dep.delete(effect)\r\n    if (dep.size === 0) {\r\n      dep.cleanup()\r\n    }\r\n  }\r\n}\r\n\r\nexport interface DebuggerOptions {\r\n  onTrack?: (event: DebuggerEvent) => void\r\n  onTrigger?: (event: DebuggerEvent) => void\r\n}\r\n\r\nexport interface ReactiveEffectOptions extends DebuggerOptions {\r\n  lazy?: boolean\r\n  scheduler?: EffectScheduler\r\n  scope?: EffectScope\r\n  allowRecurse?: boolean\r\n  onStop?: () => void\r\n}\r\n\r\nexport interface ReactiveEffectRunner<T = any> {\r\n  (): T\r\n  effect: ReactiveEffect\r\n}\r\n\r\n/**\r\n * Registers the given function to track reactive updates.\r\n *\r\n * The given function will be run once immediately. Every time any reactive\r\n * property that's accessed within it gets updated, the function will run again.\r\n *\r\n * @param fn - The function that will track reactive updates.\r\n * @param options - Allows to control the effect's behaviour.\r\n * @returns A runner that can be used to control the effect after creation.\r\n */\r\nexport function effect<T = any>(\r\n  fn: () => T,\r\n  options?: ReactiveEffectOptions,\r\n): ReactiveEffectRunner {\r\n  if ((fn as ReactiveEffectRunner).effect instanceof ReactiveEffect) {\r\n    fn = (fn as ReactiveEffectRunner).effect.fn\r\n  }\r\n\r\n  const _effect = new ReactiveEffect(fn, NOOP, () => {\r\n    if (_effect.dirty) {\r\n      _effect.run()\r\n    }\r\n  })\r\n  if (options) {\r\n    extend(_effect, options)\r\n    if (options.scope) recordEffectScope(_effect, options.scope)\r\n  }\r\n  if (!options || !options.lazy) {\r\n    _effect.run()\r\n  }\r\n  const runner = _effect.run.bind(_effect) as ReactiveEffectRunner\r\n  runner.effect = _effect\r\n  return runner\r\n}\r\n\r\n/**\r\n * Stops the effect associated with the given runner.\r\n *\r\n * @param runner - Association with the effect to stop tracking.\r\n */\r\nexport function stop(runner: ReactiveEffectRunner) {\r\n  runner.effect.stop()\r\n}\r\n\r\nexport let shouldTrack = true\r\nexport let pauseScheduleStack = 0\r\n\r\nconst trackStack: boolean[] = []\r\n\r\n/**\r\n * Temporarily pauses tracking.\r\n */\r\nexport function pauseTracking() {\r\n  trackStack.push(shouldTrack)\r\n  shouldTrack = false\r\n}\r\n\r\n/**\r\n * Re-enables effect tracking (if it was paused).\r\n */\r\nexport function enableTracking() {\r\n  trackStack.push(shouldTrack)\r\n  shouldTrack = true\r\n}\r\n\r\n/**\r\n * Resets the previous global effect tracking state.\r\n */\r\nexport function resetTracking() {\r\n  const last = trackStack.pop()\r\n  shouldTrack = last === undefined ? true : last\r\n}\r\n\r\nexport function pauseScheduling() {\r\n  pauseScheduleStack++\r\n}\r\n\r\nexport function resetScheduling() {\r\n  pauseScheduleStack--\r\n  while (!pauseScheduleStack && queueEffectSchedulers.length) {\r\n    queueEffectSchedulers.shift()!()\r\n  }\r\n}\r\n\r\nexport function trackEffect(\r\n  effect: ReactiveEffect,\r\n  dep: Dep,\r\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo,\r\n) {\r\n  /**\r\n   * 比如在一个副作用函数中两次及以上使用了同一个代理对象的key的值，那第二次进入的时候，因为已经存在了且_trackId是相同的，就不会重复添加\r\n   * effect的_trackId的作用就是一个状态id，每执行一次，_trackId就加1，这样做目的：\r\n   * 第一次执行副作用函数的时候，会记录所有依赖对象的deps，但是后面执行条件发生改变了，可能某些依赖对象根本不会执行到，所以每次执行副作用函数\r\n   * 之前需要清空副作用函数对应的依赖对象，执行后又重新创建依赖对象，通过_depsLength和deps这样每次清空的时候，不会直接先把数组给清空了\r\n   * 所以第二次执行的时候_trackId是已经改变了\r\n   */\r\n  if (dep.get(effect) !== effect._trackId) {\r\n    dep.set(effect, effect._trackId)\r\n    const oldDep = effect.deps[effect._depsLength]\r\n    if (oldDep !== dep) {\r\n      if (oldDep) {\r\n        cleanupDepEffect(oldDep, effect)\r\n      }\r\n      effect.deps[effect._depsLength++] = dep\r\n    } else {\r\n      effect._depsLength++\r\n    }\r\n    if (__DEV__) {\r\n      effect.onTrack?.(extend({ effect }, debuggerEventExtraInfo!))\r\n    }\r\n  }\r\n}\r\n\r\nconst queueEffectSchedulers: EffectScheduler[] = []\r\n\r\n/**\r\n * 比如一个副作用函数即引用了代理A对象p属性的值，又循环遍历代理对象A\r\n * 那么A对象p属性的值更改时，即会触发p属性对应的副作用，也会触发迭代器对应的副作用\r\n * 第一次_dirtyLevel是NotDirty，改为Dirty，然后把该副作用函数先计入副作用调度器队列里面\r\n * 第二次通过迭代器进入triggerEffects的时候，因为都是同一个副作用对象，因为lastDirtyLevel已经是Dirty，所以不会再进入if里面，\r\n * 避免重复执行，比如以下场景：\r\n * const observed = reactive([1,2,3]);\r\n     effect(() => {\r\n        console.log(observed[3]);\r\n        for(let item of observed) {\r\n            console.log(item);\r\n        }\r\n    });\r\n    setTimeout(() => {\r\n        observed[3] = 5;\r\n    }, 500)\r\n    属性值length和key为3都会对effect建立依赖关系，observed[3]改变的时候，length和3对应的effect都会执行，因为通过_dirtyLevel和队列的形式，副作用只会加入到队列中一次并只执行一次（队列的作用不仅仅只有这一个）。\r\n */\r\nexport function triggerEffects(\r\n  dep: Dep,\r\n  dirtyLevel: DirtyLevels,\r\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo,\r\n) {\r\n  pauseScheduling()\r\n  for (const effect of dep.keys()) {\r\n    if (\r\n      effect._dirtyLevel < dirtyLevel && // 上一次没有dirty，这一次dirty，如果上一次正在dirty中，说明上一次副作用函数还没执行完，每次执行副作用函数之前都会把dirty设置为notdirty\r\n      dep.get(effect) === effect._trackId \r\n    ) {\r\n      const lastDirtyLevel = effect._dirtyLevel\r\n      effect._dirtyLevel = dirtyLevel\r\n      if (lastDirtyLevel === DirtyLevels.NotDirty) {\r\n        effect._shouldSchedule = true\r\n        if (__DEV__) {\r\n          effect.onTrigger?.(extend({ effect }, debuggerEventExtraInfo))\r\n        }\r\n        effect.trigger()\r\n      }\r\n    }\r\n  }\r\n  scheduleEffects(dep)\r\n  resetScheduling()\r\n}\r\n\r\n/**\r\n * 如果一个副作用函数对某个key先get，再set，那么set触发trigger，进入这个函数，_runnings不为0，allowRecurse默认是false\r\n * 所以不会重新调用副作用函数，不然就有可能进入死循环\r\n */\r\nexport function scheduleEffects(dep: Dep) {\r\n  for (const effect of dep.keys()) {\r\n    if (\r\n      effect.scheduler &&\r\n      effect._shouldSchedule &&\r\n      (!effect._runnings || effect.allowRecurse) &&\r\n      dep.get(effect) === effect._trackId\r\n    ) {\r\n      effect._shouldSchedule = false\r\n      queueEffectSchedulers.push(effect.scheduler)\r\n    }\r\n  }\r\n}\r\n","import type { ReactiveEffect } from './effect'\r\nimport type { ComputedRefImpl } from './computed'\r\n\r\nexport type Dep = Map<ReactiveEffect, number> & {\r\n  cleanup: () => void\r\n  computed?: ComputedRefImpl<any>\r\n}\r\n\r\nexport const createDep = (\r\n  cleanup: () => void,\r\n  computed?: ComputedRefImpl<any>,\r\n): Dep => {\r\n  const dep = new Map() as Dep\r\n  dep.cleanup = cleanup\r\n  dep.computed = computed\r\n  return dep\r\n}\r\n","import { isArray, isIntegerKey, isMap, isSymbol } from '@vue/shared'\r\nimport { DirtyLevels, type TrackOpTypes, TriggerOpTypes } from './constants'\r\nimport { type Dep, createDep } from './dep'\r\nimport {\r\n  activeEffect,\r\n  pauseScheduling,\r\n  resetScheduling,\r\n  shouldTrack,\r\n  trackEffect,\r\n  triggerEffects,\r\n} from './effect'\r\n\r\n// The main WeakMap that stores {target -> key -> dep} connections.\r\n// Conceptually, it's easier to think of a dependency as a Dep class\r\n// which maintains a Set of subscribers, but we simply store them as\r\n// raw Maps to reduce memory overhead.\r\ntype KeyToDepMap = Map<any, Dep>\r\nconst targetMap = new WeakMap<object, KeyToDepMap>()\r\n\r\nexport const ITERATE_KEY = Symbol(__DEV__ ? 'iterate' : '')\r\nexport const MAP_KEY_ITERATE_KEY = Symbol(__DEV__ ? 'Map key iterate' : '')\r\n\r\n/**\r\n * Tracks access to a reactive property.\r\n *\r\n * This will check which effect is running at the moment and record it as dep\r\n * which records all effects that depend on the reactive property.\r\n *\r\n * @param target - Object holding the reactive property.\r\n * @param type - Defines the type of access to the reactive property.\r\n * @param key - Identifier of the reactive property to track.\r\n */\r\n/**\r\n * 有三层：\r\n * 所有的响应对象target构成一个WeapMap\r\n * 简单地说，WeakMap 对 key 是弱引用，不影响垃圾回收器的工作。据这个特性可知，一旦 key 被垃圾回收器回收，那么对应的键和值就访问不到了。所以 WeakMap 经常用于存储那些只有当 key 所引用的对象存在时（没有被回收）才有价值的信息，例如上面的场景中，如果 target 对象没有任何引用了，说明用户侧不再需要它了，这时垃圾回收器会完成回收任务。但如果使用 Map 来代替WeakMap，那么即使用户侧的代码对 target 没有任何引用，这个 target 也不会被回收，最终可能导致内存溢出。\r\n * 单个响应对象中所有key构成一个map\r\n * 单个key对应的是Dep对象，但是Dep也是一个包含cleanup方法的map\r\n * \r\n */\r\nexport function track(target: object, type: TrackOpTypes, key: unknown) {\r\n  /**\r\n   * 判断activeEffect：只要当前执行的环境是在副作用函数中才需要去手机\r\n   * 判断shouldTrack：比如对于数组，调用push方法，会先获取length（get操作获取length），再往数组中添加元素（set操作）。\r\n   * 如下场景：两个副作用之间会进入一个互相触发执行的死循环的，所以对于像push方法，应该shouldTrack标识为false，这样就不会去进行副作用的依赖收集，本质上push是改变数组的值，也不需要去track依赖\r\n   * effect(() => {\r\n        observed.push(1)\r\n      });\r\n      effect(() => {\r\n          observed.push(2)\r\n      })\r\n   */\r\n  if (shouldTrack && activeEffect) {\r\n    let depsMap = targetMap.get(target)\r\n    if (!depsMap) {\r\n      targetMap.set(target, (depsMap = new Map()))\r\n    }\r\n    let dep = depsMap.get(key)\r\n    if (!dep) {\r\n      depsMap.set(key, (dep = createDep(() => depsMap!.delete(key))))\r\n    }\r\n    trackEffect(\r\n      activeEffect,\r\n      dep,\r\n      __DEV__\r\n        ? {\r\n            target,\r\n            type,\r\n            key,\r\n          }\r\n        : void 0,\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * Finds all deps associated with the target (or a specific property) and\r\n * triggers the effects stored within.\r\n *\r\n * @param target - The reactive object.\r\n * @param type - Defines the type of the operation that needs to trigger effects.\r\n * @param key - Can be used to target a specific reactive property in the target object.\r\n */\r\nexport function trigger(\r\n  target: object,\r\n  type: TriggerOpTypes,\r\n  key?: unknown,\r\n  newValue?: unknown,\r\n  oldValue?: unknown,\r\n  oldTarget?: Map<unknown, unknown> | Set<unknown>,\r\n) {\r\n  const depsMap = targetMap.get(target)\r\n  if (!depsMap) {\r\n    // never been tracked\r\n    return\r\n  }\r\n\r\n  let deps: (Dep | undefined)[] = []\r\n  /**\r\n   * map和set对象中clear方法调用，所有元素都被清空了，所有元素对应的副作用都需要执行\r\n   */\r\n  if (type === TriggerOpTypes.CLEAR) {\r\n    // collection being cleared\r\n    // trigger all effects for target\r\n    deps = [...depsMap.values()]\r\n  } else if (key === 'length' && isArray(target)) {\r\n    /**\r\n     * for in 会在ownKeys方法中track收集length的依赖；\r\n     * for of内部会先获取length，所以会在get中收集length的依赖\r\n     * \r\n     * 这样的场景：直接改变数组的长度，除了触发length（for in/for of）的依赖副作用之外，还有超出设置长度的那些元素也会触发依赖（相当于超出长度的那些元素被删除了）\r\n     * const observed = reactive([1,2,3]);\r\n      effect(() => {\r\n          for(let key of observed) {\r\n              console.log(key)\r\n          }\r\n      });\r\n      setTimeout(() => {\r\n          observed.length = 2;\r\n      }, 1000)\r\n     */\r\n    const newLength = Number(newValue)\r\n    depsMap.forEach((dep, key) => {\r\n      if (key === 'length' || (!isSymbol(key) && key >= newLength)) {\r\n        deps.push(dep)\r\n      }\r\n    })\r\n  } else {\r\n    // schedule runs for SET | ADD | DELETE\r\n    if (key !== void 0) {\r\n      deps.push(depsMap.get(key))\r\n    }\r\n\r\n    // also run for iteration key on ADD | DELETE | Map.SET\r\n    switch (type) {\r\n      /**\r\n       * 对象添加属性、数组添加元素、Map的set方法执行、Set的add方法执行\r\n       */\r\n      case TriggerOpTypes.ADD:\r\n        if (!isArray(target)) {\r\n          /**\r\n           * ITERATE_KEY：\r\n           *（1）普通对象的for in \r\n           * (2) Map和Set的size\r\n           * (3) Map和Set的forEach\r\n           * (4) Set和Map的迭代器（values/entries)\r\n           * \r\n           * MAP_KEY_ITERATE_KEY：\r\n           * （1）Map的迭代器方法keys\r\n           */\r\n          deps.push(depsMap.get(ITERATE_KEY))\r\n          if (isMap(target)) {\r\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\r\n          }\r\n        } else if (isIntegerKey(key)) {\r\n          // 如果是数组，那么对应还需要触发length\r\n          // new index added to array -> length changes\r\n          deps.push(depsMap.get('length'))\r\n        }\r\n        break\r\n      case TriggerOpTypes.DELETE:\r\n        if (!isArray(target)) {\r\n          /**\r\n           * 原理同上\r\n           * 不会去delete 一个数组的元素\r\n           */\r\n          deps.push(depsMap.get(ITERATE_KEY))\r\n          if (isMap(target)) {\r\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\r\n          }\r\n        }\r\n        break\r\n      case TriggerOpTypes.SET:\r\n        /**\r\n         * 如果是Map，修改值的话，还需要触发对应的迭代器（values/entries/forEach）\r\n         */\r\n        if (isMap(target)) {\r\n          deps.push(depsMap.get(ITERATE_KEY))\r\n        }\r\n        break\r\n    }\r\n  }\r\n\r\n  pauseScheduling()\r\n  for (const dep of deps) {\r\n    if (dep) {\r\n      triggerEffects(\r\n        dep,\r\n        DirtyLevels.Dirty,\r\n        __DEV__\r\n          ? {\r\n              target,\r\n              type,\r\n              key,\r\n              newValue,\r\n              oldValue,\r\n              oldTarget,\r\n            }\r\n          : void 0,\r\n      )\r\n    }\r\n  }\r\n  resetScheduling()\r\n}\r\n\r\nexport function getDepFromReactive(object: any, key: string | number | symbol) {\r\n  return targetMap.get(object)?.get(key)\r\n}\r\n","import {\r\n  type Target,\r\n  isReadonly,\r\n  isShallow,\r\n  reactive,\r\n  reactiveMap,\r\n  readonly,\r\n  readonlyMap,\r\n  shallowReactiveMap,\r\n  shallowReadonlyMap,\r\n  toRaw,\r\n} from './reactive'\r\nimport { ReactiveFlags, TrackOpTypes, TriggerOpTypes } from './constants'\r\nimport {\r\n  pauseScheduling,\r\n  pauseTracking,\r\n  resetScheduling,\r\n  resetTracking,\r\n} from './effect'\r\nimport { ITERATE_KEY, track, trigger } from './reactiveEffect'\r\nimport {\r\n  hasChanged,\r\n  hasOwn,\r\n  isArray,\r\n  isIntegerKey,\r\n  isObject,\r\n  isSymbol,\r\n  makeMap,\r\n} from '@vue/shared'\r\nimport { isRef } from './ref'\r\nimport { warn } from './warning'\r\n\r\nconst isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`)\r\n\r\nconst builtInSymbols = new Set(\r\n  /*#__PURE__*/\r\n  Object.getOwnPropertyNames(Symbol)\r\n    /**\r\n     * 在iOS10.x中，Object.getOwnPropertyNames(Symbol)可以枚举\"arguments\"和\"caller\"，但是Symbol对象上访问\r\n     * 这些属性会导致TypeError，因为Symbol是一个严格模式函数\r\n     */\r\n    .filter(key => key !== 'arguments' && key !== 'caller')\r\n    .map(key => (Symbol as any)[key])\r\n    .filter(isSymbol),\r\n)\r\n\r\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations()\r\n\r\nfunction createArrayInstrumentations() {\r\n  const instrumentations: Record<string, Function> = {}\r\n  // instrument identity-sensitive Array methods to account for possible reactive\r\n  // values\r\n  ;(['includes', 'indexOf', 'lastIndexOf'] as const).forEach(key => {\r\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\r\n      const arr = toRaw(this) as any\r\n      for (let i = 0, l = this.length; i < l; i++) {\r\n        track(arr, TrackOpTypes.GET, i + '')\r\n      }\r\n      // we run the method using the original args first (which may be reactive)\r\n      const res = arr[key](...args)\r\n      if (res === -1 || res === false) {\r\n        // if that didn't work, run it again using raw values.\r\n        return arr[key](...args.map(toRaw))\r\n      } else {\r\n        return res\r\n      }\r\n    }\r\n  })\r\n  // instrument length-altering mutation methods to avoid length being tracked\r\n  // which leads to infinite loops in some cases (#2137)\r\n  ;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach(key => {\r\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\r\n      pauseTracking()\r\n      pauseScheduling()\r\n      const res = (toRaw(this) as any)[key].apply(this, args)\r\n      resetScheduling()\r\n      resetTracking()\r\n      return res\r\n    }\r\n  })\r\n  return instrumentations\r\n}\r\n\r\nfunction hasOwnProperty(this: object, key: string) {\r\n  const obj = toRaw(this)\r\n  track(obj, TrackOpTypes.HAS, key)\r\n  return obj.hasOwnProperty(key)\r\n}\r\n\r\nclass BaseReactiveHandler implements ProxyHandler<Target> {\r\n  constructor(\r\n    protected readonly _isReadonly = false,\r\n    protected readonly _shallow = false,\r\n  ) {}\r\n\r\n  // 获取对象的属性值\r\n  get(target: Target, key: string | symbol, receiver: object) {\r\n    const isReadonly = this._isReadonly,\r\n      shallow = this._shallow\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return !isReadonly\r\n    } else if (key === ReactiveFlags.IS_READONLY) {\r\n      return isReadonly\r\n    } else if (key === ReactiveFlags.IS_SHALLOW) {\r\n      return shallow\r\n    } else if (key === ReactiveFlags.RAW) {\r\n      // 判断receiver是否是target的代理对象，或者receiver和target被同一个对象代理了\r\n      // 获取原始对象\r\n      /**\r\n       * 如下情况：\r\n       * const { reactive, effect } = Vue;\r\n        const o1 = {s: 'c'};\r\n        const o2 = {id: 1, s: 'p'};\r\n        const c = reactive(o1);\r\n        const p = reactive(o2);\r\n        Object.setPrototypeOf(c, p);\r\n        effect(() => {\r\n            console.log(c.id);\r\n        }) \r\n        获取c.id的时候第一次进入child的get方法，发现没有id属性，然后就会进入parent的get方法，这个时候target是o2，但是receiver是c\r\n       */\r\n      if (\r\n        receiver ===\r\n          (isReadonly\r\n            ? shallow\r\n              ? shallowReadonlyMap\r\n              : readonlyMap\r\n            : shallow\r\n              ? shallowReactiveMap\r\n              : reactiveMap\r\n          ).get(target) ||\r\n        // receiver is not the reactive proxy, but has the same prototype\r\n        // this means the reciever is a user proxy of the reactive proxy\r\n        Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)\r\n      ) {\r\n        return target\r\n      }\r\n      // early return undefined\r\n      return\r\n    }\r\n\r\n    const targetIsArray = isArray(target)\r\n\r\n    if (!isReadonly) {\r\n      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n        return Reflect.get(arrayInstrumentations, key, receiver)\r\n      }\r\n      if (key === 'hasOwnProperty') {\r\n        return hasOwnProperty\r\n      }\r\n    }\r\n    /**\r\n     * target是原对象，\r\n     * receiver是代理对象\r\n     * 这里之所以使用Reflect\r\n     * const obj = {\r\n     *  id: 1,\r\n     *  get uuid () {\r\n     *    return this.id\r\n     * }\r\n     * }\r\n     * const proxy = new Proxy(obj)\r\n     * 方法proxy.uuid时，this始终指向代理对象\r\n     */\r\n    const res = Reflect.get(target, key, receiver)\r\n\r\n    // 是否是哪些不被追踪的属性\r\n    // 防止数组的[Symbol.iterator]被收集，for of遍历的时候会先调用[Symbol.iterator]，然后再获取内部的length，所以[Symbol.iterator]被忽略，值收集length的依赖，防止一个副作用函数被收集两次\r\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\r\n      return res\r\n    }\r\n\r\n    // 只读对象不需要追踪依赖，对象的属性值是不会改变的，所以不需要追踪\r\n    if (!isReadonly) {\r\n      track(target, TrackOpTypes.GET, key)\r\n    }\r\n    // 如果是浅依赖的就直接返回，不需要再递归创建代理\r\n    if (shallow) {\r\n      return res\r\n    }\r\n    /**\r\n     * 所以即使props中传入给子组件的值是ref也能正确取值，返回的是ref的value值\r\n     */\r\n    if (isRef(res)) {\r\n      // ref unwrapping - skip unwrap for Array + integer key.\r\n      return targetIsArray && isIntegerKey(key) ? res : res.value\r\n    }\r\n\r\n    if (isObject(res)) {\r\n      // Convert returned value into a proxy as well. we do the isObject check\r\n      // here to avoid invalid value warning. Also need to lazy access readonly\r\n      // and reactive here to avoid circular dependency.\r\n      return isReadonly ? readonly(res) : reactive(res)\r\n    }\r\n\r\n    return res\r\n  }\r\n}\r\n\r\nclass MutableReactiveHandler extends BaseReactiveHandler {\r\n  constructor(shallow = false) {\r\n    super(false, shallow)\r\n  }\r\n\r\n  // 给对象添加属性值/或者给对象修改属性值\r\n  set(\r\n    target: object,\r\n    key: string | symbol,\r\n    value: unknown,\r\n    receiver: object,\r\n  ): boolean {\r\n    let oldValue = (target as any)[key]\r\n    /**\r\n     * 如果是浅层的，那么自然只有第一层，第二层都是原始对象了\r\n     */\r\n    if (!this._shallow) {\r\n      // 原来key对应的值是响应式的，且只可读，则不允许设置\r\n      /**\r\n       * value可能本身就是oldvalue的代理对象，所以需要先把value原始的对象取出来，这样，再hasChanged比较的时候就不会有问题\r\n       * 这种情况下，hasChanged应该是false，如果不这样操作，hasChanged就会变成true，\r\n       * 反正在get方法的时候取出来会递归调用reactive，获取值的时候仍然是代理对象\r\n       * let obj = {city: 'gz', address: 'panyu'};\r\n        const d = reactive(obj);\r\n        const person = reactive({id: 1, name: 'ff', d: obj});\r\n        effect(() => {\r\n            console.log(person.d) \r\n        })\r\n        setTimeout(() => {\r\n            person.d = d; //不会触发以上的effect\r\n        }, 100)\r\n       * \r\n       * 如果oldValue是元素对象，value是oldValue的可读的对象，那说明value是不会被track/trigger，value根本不会被改变，不用担心trigger\r\n       * 如果是shallow，因为this._shallow已经是false，说明本身target创建的代理对象就是深度，而现在要给他复制shallowReactive，\r\n       * 虽然对应的是同一个代理对象，但是属性值仍然是改变了的\r\n       * let obj = {city: 'gz', address: 'panyu'};\r\n          const d = shallowReactive(obj);\r\n          const person = reactive({id: 1, name: 'ff', d: obj});\r\n          effect(() => {\r\n              console.log(person.d)\r\n          })\r\n          setTimeout(() => {\r\n              person.d = d; // 会再次触发以上的effect\r\n          }, 100)\r\n       * 这里还有一个原因就是为了防止数据污染，比如有两个响应对象p1,p2，将p2设置成p1的某个属性值，\r\n          const obj = {city: 'gz', address: 'panyu'};\r\n          const p1 = reactive(obj);\r\n          const p2 = reactive({});\r\n          p1['p2'] = p2;\r\n          effect(() => {\r\n              console.log(obj.p2.id)\r\n          });\r\n          console.log(p1.p2, obj.p2)\r\n          setTimeout(() => {\r\n              obj.p2.id = 11;\r\n          })\r\n          如果不经过这样的操作，那么obj.p2对应的就是p2响应对象，那么obj.p2.id改变的时候就会触发effect执行，\r\n          现在因为obj.p2是原始对象了，所以不会有这个数据污染问题\r\n          （把响应式数据设置到原始数据上的行为称为样式污染\r\n       */\r\n      const isOldValueReadonly = isReadonly(oldValue)\r\n      if (!isShallow(value) && !isReadonly(value)) {\r\n        oldValue = toRaw(oldValue)\r\n        value = toRaw(value)\r\n      }\r\n      // 如果对象的key值原来是ref，新的值不是ref，则将新的值赋值给原来key对应的值\r\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n        if (isOldValueReadonly) {\r\n          return false\r\n        } else {\r\n          oldValue.value = value\r\n          return true\r\n        }\r\n      }\r\n    } else {\r\n      // in shallow mode, objects are set as-is regardless of reactive or not\r\n    }\r\n\r\n    const hadKey =\r\n      isArray(target) && isIntegerKey(key)\r\n        ? Number(key) < target.length\r\n        : hasOwn(target, key)\r\n    const result = Reflect.set(target, key, value, receiver)\r\n    // don't trigger if target is something up in the prototype chain of original\r\n    if (target === toRaw(receiver)) {\r\n      if (!hadKey) {\r\n        // 如果是给对象新增加值，增加的值夜不是ref，则触发add\r\n        trigger(target, TriggerOpTypes.ADD, key, value)\r\n      } else if (hasChanged(value, oldValue)) {\r\n        // 如果是修改原来的值，则触发set\r\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)\r\n      }\r\n    }\r\n    return result\r\n  }\r\n\r\n  // delete操作触发，比如 delete observed.foo\r\n  deleteProperty(target: object, key: string | symbol): boolean {\r\n    const hadKey = hasOwn(target, key)\r\n    const oldValue = (target as any)[key]\r\n    const result = Reflect.deleteProperty(target, key)\r\n    if (result && hadKey) {\r\n      // 存在这个key并且成功删除了，才会触发delete\r\n      trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\r\n    }\r\n    return result\r\n  }\r\n\r\n  // 'foo' in observed 触发的就是has函数\r\n  has(target: object, key: string | symbol): boolean {\r\n    const result = Reflect.has(target, key)\r\n    /**\r\n     * 这里为什么要排除symbol函数呢\r\n     * 因为在for of循环遍历数组的时候，除了会触发length，还会触发symbol迭代器的方法，就会重复执行副作用函数\r\n     * 所以for of循序只记录一个length的track就可以了\r\n     */\r\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n      track(target, TrackOpTypes.HAS, key)\r\n    }\r\n    return result\r\n  }\r\n  /**\r\n   * （1）for in 触发的就是ownKeys函数\r\n   * （2）Object.keys(proxy)\r\n   */\r\n  ownKeys(target: object): (string | symbol)[] {\r\n    // for in和 in会进入到这个方法，如果是数组，只要记录length改变就行了，\r\n    /**\r\n     * 比如一个副作用函数内for in一个数组，那么后面这个数组长度改变了，都应该触发这个副作用函数的执行\r\n     * 如果是for in一个对象，那么这个对象的属性添加了或者减少了，都应该触发ITERATE_KEY，所以记录的也是ITERATE_KEY\r\n     */\r\n    track(\r\n      target,\r\n      TrackOpTypes.ITERATE,\r\n      isArray(target) ? 'length' : ITERATE_KEY,\r\n    )\r\n    return Reflect.ownKeys(target)\r\n  }\r\n}\r\n\r\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\r\n  constructor(shallow = false) {\r\n    super(true, shallow)\r\n  }\r\n\r\n  set(target: object, key: string | symbol) {\r\n    if (__DEV__) {\r\n      warn(\r\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\r\n        target,\r\n      )\r\n    }\r\n    return true\r\n  }\r\n\r\n  deleteProperty(target: object, key: string | symbol) {\r\n    if (__DEV__) {\r\n      warn(\r\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\r\n        target,\r\n      )\r\n    }\r\n    return true\r\n  }\r\n}\r\n\r\nexport const mutableHandlers: ProxyHandler<object> =\r\n  /*#__PURE__*/ new MutableReactiveHandler()\r\n\r\nexport const readonlyHandlers: ProxyHandler<object> =\r\n  /*#__PURE__*/ new ReadonlyReactiveHandler()\r\n\r\nexport const shallowReactiveHandlers = /*#__PURE__*/ new MutableReactiveHandler(\r\n  true,\r\n)\r\n\r\n// props handlers特殊之处在于它不应该解包顶层refs，但它仍然保持普通只读对象的响应性\r\nexport const shallowReadonlyHandlers =\r\n  /*#__PURE__*/ new ReadonlyReactiveHandler(true)\r\n","import { toRaw, toReactive, toReadonly } from './reactive'\r\nimport {\r\n  ITERATE_KEY,\r\n  MAP_KEY_ITERATE_KEY,\r\n  track,\r\n  trigger,\r\n} from './reactiveEffect'\r\nimport { ReactiveFlags, TrackOpTypes, TriggerOpTypes } from './constants'\r\nimport { capitalize, hasChanged, hasOwn, isMap, toRawType } from '@vue/shared'\r\n\r\ntype CollectionTypes = IterableCollections | WeakCollections\r\n\r\ntype IterableCollections = Map<any, any> | Set<any>\r\ntype WeakCollections = WeakMap<any, any> | WeakSet<any>\r\ntype MapTypes = Map<any, any> | WeakMap<any, any>\r\ntype SetTypes = Set<any> | WeakSet<any>\r\n\r\nconst toShallow = <T extends unknown>(value: T): T => value\r\n\r\nconst getProto = <T extends CollectionTypes>(v: T): any =>\r\n  Reflect.getPrototypeOf(v)\r\n\r\nfunction get(\r\n  target: MapTypes,\r\n  key: unknown,\r\n  isReadonly = false,\r\n  isShallow = false,\r\n) {\r\n  // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n  // of the value\r\n  /**\r\n   * （1）关于rawTarget和target不相等的场景：\r\n   * const map = reactive(new Map())\r\n    const roMap = readonly(map)\r\n      map.set(4, { foo: 'bar' })\r\n      effect(() => {\r\n          const roMapItem = roMap.get(5);\r\n          console.log(roMapItem)\r\n      })\r\n      setTimeout(() => {\r\n          map.set(5, 'hello')\r\n      }, 1000)\r\n      解释：readonly一个reactive响应对象，虽然roMap是readonly非响应式的，但是因为原始对象是响应式的，所以roMapItem依然是响应式的，很少会这样使用\r\n\r\n      （2）关于key和rawKey不相等的场景：key是响应式对象,rawkey是原始对象\r\n      如果map代理对象中本来包含了key响应对象，那么map.get(key)收集了key和rawKey的依赖关系，set(key, value)的时候会触发key的依赖；\r\n      如果map代理对象中没有包括key的响应对象，那么set(key, value)会触发rawKey的依赖\r\n   */\r\n  target = (target as any)[ReactiveFlags.RAW]\r\n  const rawTarget = toRaw(target)\r\n  const rawKey = toRaw(key)\r\n  if (!isReadonly) {\r\n    if (hasChanged(key, rawKey)) {\r\n      // 如果key也是响应式的对象，那么也要track key\r\n      track(rawTarget, TrackOpTypes.GET, key)\r\n    }\r\n    track(rawTarget, TrackOpTypes.GET, rawKey)\r\n  }\r\n  const { has } = getProto(rawTarget)\r\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\r\n  if (has.call(rawTarget, key)) {\r\n    return wrap(target.get(key))\r\n  } else if (has.call(rawTarget, rawKey)) {\r\n    return wrap(target.get(rawKey))\r\n  } else if (target !== rawTarget) {\r\n    // #3602 readonly(reactive(Map))\r\n    // ensure that the nested reactive `Map` can do tracking for itself\r\n    target.get(key)\r\n  }\r\n}\r\n\r\nfunction has(this: CollectionTypes, key: unknown, isReadonly = false): boolean {\r\n  const target = (this as any)[ReactiveFlags.RAW]\r\n  const rawTarget = toRaw(target)\r\n  const rawKey = toRaw(key)\r\n  if (!isReadonly) {\r\n    if (hasChanged(key, rawKey)) {\r\n      track(rawTarget, TrackOpTypes.HAS, key)\r\n    }\r\n    track(rawTarget, TrackOpTypes.HAS, rawKey)\r\n  }\r\n  return key === rawKey\r\n    ? target.has(key)\r\n    : target.has(key) || target.has(rawKey)\r\n}\r\n\r\nfunction size(target: IterableCollections, isReadonly = false) {\r\n  target = (target as any)[ReactiveFlags.RAW]\r\n  !isReadonly && track(toRaw(target), TrackOpTypes.ITERATE, ITERATE_KEY)\r\n  return Reflect.get(target, 'size', target)\r\n}\r\n\r\nfunction add(this: SetTypes, value: unknown) {\r\n  value = toRaw(value)\r\n  const target = toRaw(this)\r\n  const proto = getProto(target)\r\n  const hadKey = proto.has.call(target, value)\r\n  if (!hadKey) {\r\n    target.add(value)\r\n    trigger(target, TriggerOpTypes.ADD, value, value)\r\n  }\r\n  return this\r\n}\r\n\r\nfunction set(this: MapTypes, key: unknown, value: unknown) {\r\n  // 这里设置需要用原始对象\r\n  value = toRaw(value)\r\n  const target = toRaw(this)\r\n  const { has, get } = getProto(target)\r\n\r\n  let hadKey = has.call(target, key)\r\n  if (!hadKey) {\r\n    key = toRaw(key)\r\n    hadKey = has.call(target, key)\r\n  } else if (__DEV__) {\r\n    // key是响应式对象，并且target中包含key的原始对象\r\n    checkIdentityKeys(target, has, key)\r\n  }\r\n\r\n  const oldValue = get.call(target, key)\r\n  target.set(key, value)\r\n  if (!hadKey) {\r\n    trigger(target, TriggerOpTypes.ADD, key, value)\r\n  } else if (hasChanged(value, oldValue)) {\r\n    trigger(target, TriggerOpTypes.SET, key, value, oldValue)\r\n  }\r\n  return this\r\n}\r\n\r\nfunction deleteEntry(this: CollectionTypes, key: unknown) {\r\n  const target = toRaw(this)\r\n  const { has, get } = getProto(target)\r\n  let hadKey = has.call(target, key)\r\n  if (!hadKey) {\r\n    key = toRaw(key)\r\n    hadKey = has.call(target, key)\r\n  } else if (__DEV__) {\r\n    checkIdentityKeys(target, has, key)\r\n  }\r\n\r\n  const oldValue = get ? get.call(target, key) : undefined\r\n  // forward the operation before queueing reactions\r\n  const result = target.delete(key)\r\n  if (hadKey) {\r\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction clear(this: IterableCollections) {\r\n  const target = toRaw(this)\r\n  const hadItems = target.size !== 0\r\n  const oldTarget = __DEV__\r\n    ? isMap(target)\r\n      ? new Map(target)\r\n      : new Set(target)\r\n    : undefined\r\n  // forward the operation before queueing reactions\r\n  const result = target.clear()\r\n  if (hadItems) {\r\n    trigger(target, TriggerOpTypes.CLEAR, undefined, undefined, oldTarget)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction createForEach(isReadonly: boolean, isShallow: boolean) {\r\n  return function forEach(\r\n    this: IterableCollections,\r\n    callback: Function,\r\n    thisArg?: unknown,\r\n  ) {\r\n    const observed = this as any\r\n    const target = observed[ReactiveFlags.RAW]\r\n    const rawTarget = toRaw(target)\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\r\n    !isReadonly && track(rawTarget, TrackOpTypes.ITERATE, ITERATE_KEY)\r\n    return target.forEach((value: unknown, key: unknown) => {\r\n      // important: make sure the callback is\r\n      // 1. invoked with the reactive map as `this` and 3rd arg\r\n      // 2. the value received should be a corresponding reactive/readonly.\r\n      return callback.call(thisArg, wrap(value), wrap(key), observed)\r\n    })\r\n  }\r\n}\r\n\r\ninterface Iterable {\r\n  [Symbol.iterator](): Iterator\r\n}\r\n\r\ninterface Iterator {\r\n  next(value?: any): IterationResult\r\n}\r\n\r\ninterface IterationResult {\r\n  value: any\r\n  done: boolean\r\n}\r\n\r\nfunction createIterableMethod(\r\n  method: string | symbol,\r\n  isReadonly: boolean,\r\n  isShallow: boolean,\r\n) {\r\n  return function (\r\n    this: IterableCollections,\r\n    ...args: unknown[]\r\n  ): Iterable & Iterator {\r\n    const target = (this as any)[ReactiveFlags.RAW]\r\n    const rawTarget = toRaw(target)\r\n    const targetIsMap = isMap(rawTarget)\r\n    const isPair =\r\n      method === 'entries' || (method === Symbol.iterator && targetIsMap)\r\n    const isKeyOnly = method === 'keys' && targetIsMap\r\n    const innerIterator = target[method](...args)\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\r\n    !isReadonly &&\r\n      track(\r\n        rawTarget,\r\n        TrackOpTypes.ITERATE,\r\n        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY,\r\n      )\r\n    // return a wrapped iterator which returns observed versions of the\r\n    // values emitted from the real iterator\r\n    return {\r\n      // iterator protocol\r\n      next() {\r\n        const { value, done } = innerIterator.next()\r\n        return done\r\n          ? { value, done }\r\n          : {\r\n              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n              done,\r\n            }\r\n      },\r\n      // iterable protocol\r\n      [Symbol.iterator]() {\r\n        return this\r\n      },\r\n    }\r\n  }\r\n}\r\n\r\nfunction createReadonlyMethod(type: TriggerOpTypes): Function {\r\n  return function (this: CollectionTypes, ...args: unknown[]) {\r\n    if (__DEV__) {\r\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``\r\n      console.warn(\r\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\r\n        toRaw(this),\r\n      )\r\n    }\r\n    return type === TriggerOpTypes.DELETE\r\n      ? false\r\n      : type === TriggerOpTypes.CLEAR\r\n        ? undefined\r\n        : this\r\n  }\r\n}\r\n\r\nfunction createInstrumentations() {\r\n  const mutableInstrumentations: Record<string, Function | number> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key)\r\n    },\r\n    //获取size先track，从原始对象中获取size\r\n    get size() {\r\n      return size(this as unknown as IterableCollections)\r\n    },\r\n    has,\r\n    add,\r\n    set,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false),\r\n  }\r\n\r\n  const shallowInstrumentations: Record<string, Function | number> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key, false, true)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections)\r\n    },\r\n    has,\r\n    add,\r\n    set,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true),\r\n  }\r\n\r\n  const readonlyInstrumentations: Record<string, Function | number> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key, true)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections, true)\r\n    },\r\n    has(this: MapTypes, key: unknown) {\r\n      return has.call(this, key, true)\r\n    },\r\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\r\n    set: createReadonlyMethod(TriggerOpTypes.SET),\r\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\r\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\r\n    forEach: createForEach(true, false),\r\n  }\r\n\r\n  const shallowReadonlyInstrumentations: Record<string, Function | number> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key, true, true)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections, true)\r\n    },\r\n    has(this: MapTypes, key: unknown) {\r\n      return has.call(this, key, true)\r\n    },\r\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\r\n    set: createReadonlyMethod(TriggerOpTypes.SET),\r\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\r\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\r\n    forEach: createForEach(true, true),\r\n  }\r\n\r\n  const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator]\r\n  iteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      false,\r\n      false,\r\n    )\r\n    readonlyInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      true,\r\n      false,\r\n    )\r\n    shallowInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      false,\r\n      true,\r\n    )\r\n    shallowReadonlyInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      true,\r\n      true,\r\n    )\r\n  })\r\n\r\n  return [\r\n    mutableInstrumentations,\r\n    readonlyInstrumentations,\r\n    shallowInstrumentations,\r\n    shallowReadonlyInstrumentations,\r\n  ]\r\n}\r\n\r\nconst [\r\n  mutableInstrumentations,\r\n  readonlyInstrumentations,\r\n  shallowInstrumentations,\r\n  shallowReadonlyInstrumentations,\r\n] = /* #__PURE__*/ createInstrumentations()\r\n\r\nfunction createInstrumentationGetter(isReadonly: boolean, shallow: boolean) {\r\n  const instrumentations = shallow\r\n    ? isReadonly\r\n      ? shallowReadonlyInstrumentations\r\n      : shallowInstrumentations\r\n    : isReadonly\r\n      ? readonlyInstrumentations\r\n      : mutableInstrumentations\r\n\r\n  return (\r\n    target: CollectionTypes,\r\n    key: string | symbol,\r\n    receiver: CollectionTypes,\r\n  ) => {\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return !isReadonly\r\n    } else if (key === ReactiveFlags.IS_READONLY) {\r\n      return isReadonly\r\n    } else if (key === ReactiveFlags.RAW) {\r\n      return target\r\n    }\r\n\r\n    return Reflect.get(\r\n      hasOwn(instrumentations, key) && key in target\r\n        ? instrumentations\r\n        : target,\r\n      key,\r\n      receiver,\r\n    )\r\n  }\r\n}\r\n\r\nexport const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: /*#__PURE__*/ createInstrumentationGetter(false, false),\r\n}\r\n\r\nexport const shallowCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: /*#__PURE__*/ createInstrumentationGetter(false, true),\r\n}\r\n\r\nexport const readonlyCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: /*#__PURE__*/ createInstrumentationGetter(true, false),\r\n}\r\n\r\nexport const shallowReadonlyCollectionHandlers: ProxyHandler<CollectionTypes> =\r\n  {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true),\r\n  }\r\n\r\nfunction checkIdentityKeys(\r\n  target: CollectionTypes,\r\n  has: (key: unknown) => boolean,\r\n  key: unknown,\r\n) {\r\n  const rawKey = toRaw(key)\r\n  if (rawKey !== key && has.call(target, rawKey)) {\r\n    const type = toRawType(target)\r\n    console.warn(\r\n      `Reactive ${type} contains both the raw and reactive ` +\r\n        `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n        `which can lead to inconsistencies. ` +\r\n        `Avoid differentiating between the raw and reactive versions ` +\r\n        `of an object and only use the reactive version if possible.`,\r\n    )\r\n  }\r\n}\r\n","import { def, isObject, toRawType } from '@vue/shared'\r\nimport {\r\n  mutableHandlers,\r\n  readonlyHandlers,\r\n  shallowReactiveHandlers,\r\n  shallowReadonlyHandlers,\r\n} from './baseHandlers'\r\nimport {\r\n  mutableCollectionHandlers,\r\n  readonlyCollectionHandlers,\r\n  shallowCollectionHandlers,\r\n  shallowReadonlyCollectionHandlers,\r\n} from './collectionHandlers'\r\nimport type { RawSymbol, Ref, UnwrapRefSimple } from './ref'\r\nimport { ReactiveFlags } from './constants'\r\n\r\nexport interface Target {\r\n  [ReactiveFlags.SKIP]?: boolean\r\n  [ReactiveFlags.IS_REACTIVE]?: boolean\r\n  [ReactiveFlags.IS_READONLY]?: boolean\r\n  [ReactiveFlags.IS_SHALLOW]?: boolean\r\n  [ReactiveFlags.RAW]?: any\r\n}\r\n\r\nexport const reactiveMap = new WeakMap<Target, any>()\r\nexport const shallowReactiveMap = new WeakMap<Target, any>()\r\nexport const readonlyMap = new WeakMap<Target, any>()\r\nexport const shallowReadonlyMap = new WeakMap<Target, any>()\r\n\r\nenum TargetType {\r\n  INVALID = 0,\r\n  COMMON = 1,\r\n  COLLECTION = 2,\r\n}\r\n\r\nfunction targetTypeMap(rawType: string) {\r\n  switch (rawType) {\r\n    case 'Object':\r\n    case 'Array':\r\n      return TargetType.COMMON // 通用的类型\r\n    case 'Map':\r\n    case 'Set':\r\n    case 'WeakMap':\r\n    case 'WeakSet':\r\n      return TargetType.COLLECTION // set/map类型\r\n    default:\r\n      return TargetType.INVALID\r\n  }\r\n}\r\n\r\nfunction getTargetType(value: Target) {\r\n  // 有skip标志或者不能被扩展的就是无效的类型\r\n  return value[ReactiveFlags.SKIP] || !Object.isExtensible(value)\r\n    ? TargetType.INVALID\r\n    : targetTypeMap(toRawType(value))\r\n}\r\n\r\n// only unwrap nested ref\r\nexport type UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRefSimple<T>\r\n\r\n/**\r\n * Returns a reactive proxy of the object.\r\n *\r\n * The reactive conversion is \"deep\": it affects all nested properties. A\r\n * reactive object also deeply unwraps any properties that are refs while\r\n * maintaining reactivity.\r\n *\r\n * @example\r\n * ```js\r\n * const obj = reactive({ count: 0 })\r\n * ```\r\n *\r\n * @param target - The source object.\r\n * @see {@link https://vuejs.org/api/reactivity-core.html#reactive}\r\n */\r\nexport function reactive<T extends object>(target: T): UnwrapNestedRefs<T>\r\nexport function reactive(target: object) {\r\n  // if trying to observe a readonly proxy, return the readonly version.\r\n  // 如果创建的target本身就是reactive就直接返回\r\n  if (isReadonly(target)) {\r\n    return target\r\n  }\r\n  return createReactiveObject(\r\n    target,\r\n    false,\r\n    mutableHandlers,\r\n    mutableCollectionHandlers,\r\n    reactiveMap,\r\n  )\r\n}\r\n\r\nexport declare const ShallowReactiveMarker: unique symbol\r\n\r\nexport type ShallowReactive<T> = T & { [ShallowReactiveMarker]?: true }\r\n\r\n/**\r\n * Shallow version of {@link reactive()}.\r\n *\r\n * Unlike {@link reactive()}, there is no deep conversion: only root-level\r\n * properties are reactive for a shallow reactive object. Property values are\r\n * stored and exposed as-is - this also means properties with ref values will\r\n * not be automatically unwrapped.\r\n *\r\n * @example\r\n * ```js\r\n * const state = shallowReactive({\r\n *   foo: 1,\r\n *   nested: {\r\n *     bar: 2\r\n *   }\r\n * })\r\n *\r\n * // mutating state's own properties is reactive\r\n * state.foo++\r\n *\r\n * // ...but does not convert nested objects\r\n * isReactive(state.nested) // false\r\n *\r\n * // NOT reactive\r\n * state.nested.bar++\r\n * ```\r\n *\r\n * @param target - The source object.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#shallowreactive}\r\n */\r\nexport function shallowReactive<T extends object>(\r\n  target: T,\r\n): ShallowReactive<T> {\r\n  return createReactiveObject(\r\n    target,\r\n    false,\r\n    shallowReactiveHandlers,\r\n    shallowCollectionHandlers,\r\n    shallowReactiveMap,\r\n  )\r\n}\r\n\r\ntype Primitive = string | number | boolean | bigint | symbol | undefined | null\r\ntype Builtin = Primitive | Function | Date | Error | RegExp\r\nexport type DeepReadonly<T> = T extends Builtin\r\n  ? T\r\n  : T extends Map<infer K, infer V>\r\n    ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\r\n    : T extends ReadonlyMap<infer K, infer V>\r\n      ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\r\n      : T extends WeakMap<infer K, infer V>\r\n        ? WeakMap<DeepReadonly<K>, DeepReadonly<V>>\r\n        : T extends Set<infer U>\r\n          ? ReadonlySet<DeepReadonly<U>>\r\n          : T extends ReadonlySet<infer U>\r\n            ? ReadonlySet<DeepReadonly<U>>\r\n            : T extends WeakSet<infer U>\r\n              ? WeakSet<DeepReadonly<U>>\r\n              : T extends Promise<infer U>\r\n                ? Promise<DeepReadonly<U>>\r\n                : T extends Ref<infer U>\r\n                  ? Readonly<Ref<DeepReadonly<U>>>\r\n                  : T extends {}\r\n                    ? { readonly [K in keyof T]: DeepReadonly<T[K]> }\r\n                    : Readonly<T>\r\n\r\n/**\r\n * Takes an object (reactive or plain) or a ref and returns a readonly proxy to\r\n * the original.\r\n *\r\n * A readonly proxy is deep: any nested property accessed will be readonly as\r\n * well. It also has the same ref-unwrapping behavior as {@link reactive()},\r\n * except the unwrapped values will also be made readonly.\r\n *\r\n * @example\r\n * ```js\r\n * const original = reactive({ count: 0 })\r\n *\r\n * const copy = readonly(original)\r\n *\r\n * watchEffect(() => {\r\n *   // works for reactivity tracking\r\n *   console.log(copy.count)\r\n * })\r\n *\r\n * // mutating original will trigger watchers relying on the copy\r\n * original.count++\r\n *\r\n * // mutating the copy will fail and result in a warning\r\n * copy.count++ // warning!\r\n * ```\r\n *\r\n * @param target - The source object.\r\n * @see {@link https://vuejs.org/api/reactivity-core.html#readonly}\r\n */\r\nexport function readonly<T extends object>(\r\n  target: T,\r\n): DeepReadonly<UnwrapNestedRefs<T>> {\r\n  return createReactiveObject(\r\n    target,\r\n    true,\r\n    readonlyHandlers,\r\n    readonlyCollectionHandlers,\r\n    readonlyMap,\r\n  )\r\n}\r\n\r\n/**\r\n * Shallow version of {@link readonly()}.\r\n *\r\n * Unlike {@link readonly()}, there is no deep conversion: only root-level\r\n * properties are made readonly. Property values are stored and exposed as-is -\r\n * this also means properties with ref values will not be automatically\r\n * unwrapped.\r\n *\r\n * @example\r\n * ```js\r\n * const state = shallowReadonly({\r\n *   foo: 1,\r\n *   nested: {\r\n *     bar: 2\r\n *   }\r\n * })\r\n *\r\n * // mutating state's own properties will fail\r\n * state.foo++\r\n *\r\n * // ...but works on nested objects\r\n * isReadonly(state.nested) // false\r\n *\r\n * // works\r\n * state.nested.bar++\r\n * ```\r\n *\r\n * @param target - The source object.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#shallowreadonly}\r\n */\r\nexport function shallowReadonly<T extends object>(target: T): Readonly<T> {\r\n  return createReactiveObject(\r\n    target,\r\n    true,\r\n    shallowReadonlyHandlers,\r\n    shallowReadonlyCollectionHandlers,\r\n    shallowReadonlyMap,\r\n  )\r\n}\r\n\r\nfunction createReactiveObject(\r\n  target: Target,\r\n  isReadonly: boolean,\r\n  baseHandlers: ProxyHandler<any>,\r\n  collectionHandlers: ProxyHandler<any>,\r\n  proxyMap: WeakMap<Target, any>,\r\n) {\r\n  // 不是对象就直接返回\r\n  if (!isObject(target)) {\r\n    if (__DEV__) {\r\n      console.warn(`value cannot be made reactive: ${String(target)}`)\r\n    }\r\n    return target\r\n  }\r\n  // target is already a Proxy, return it.\r\n  // exception: calling readonly() on a reactive object\r\n  // 如果已经是一个代理对象，并且不是只读的响应式对象，直接返回\r\n  if (\r\n    target[ReactiveFlags.RAW] &&\r\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\r\n  ) {\r\n    return target\r\n  }\r\n  // target already has corresponding Proxy\r\n  const existingProxy = proxyMap.get(target)\r\n  if (existingProxy) {\r\n    return existingProxy\r\n  }\r\n  // only specific value types can be observed.\r\n  const targetType = getTargetType(target)\r\n  if (targetType === TargetType.INVALID) {\r\n    return target\r\n  }\r\n  // 创建代理\r\n  // collectionHandlers重写的是set/map对象，数组和普通对象就是走baseHandlers\r\n  const proxy = new Proxy(\r\n    target,\r\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers,\r\n  )\r\n  // 创建的代理对象都放到proxyMap中记录\r\n  proxyMap.set(target, proxy)\r\n  return proxy\r\n}\r\n\r\n/**\r\n * Checks if an object is a proxy created by {@link reactive()} or\r\n * {@link shallowReactive()} (or {@link ref()} in some cases).\r\n *\r\n * @example\r\n * ```js\r\n * isReactive(reactive({}))            // => true\r\n * isReactive(readonly(reactive({})))  // => true\r\n * isReactive(ref({}).value)           // => true\r\n * isReactive(readonly(ref({})).value) // => true\r\n * isReactive(ref(true))               // => false\r\n * isReactive(shallowRef({}).value)    // => false\r\n * isReactive(shallowReactive({}))     // => true\r\n * ```\r\n *\r\n * @param value - The value to check.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#isreactive}\r\n */\r\nexport function isReactive(value: unknown): boolean {\r\n  if (isReadonly(value)) {\r\n    return isReactive((value as Target)[ReactiveFlags.RAW])\r\n  }\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_REACTIVE])\r\n}\r\n\r\n/**\r\n * Checks whether the passed value is a readonly object. The properties of a\r\n * readonly object can change, but they can't be assigned directly via the\r\n * passed object.\r\n *\r\n * The proxies created by {@link readonly()} and {@link shallowReadonly()} are\r\n * both considered readonly, as is a computed ref without a set function.\r\n *\r\n * @param value - The value to check.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#isreadonly}\r\n */\r\nexport function isReadonly(value: unknown): boolean {\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_READONLY])\r\n}\r\n\r\nexport function isShallow(value: unknown): boolean {\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_SHALLOW])\r\n}\r\n\r\n/**\r\n * Checks if an object is a proxy created by {@link reactive},\r\n * {@link readonly}, {@link shallowReactive} or {@link shallowReadonly()}.\r\n *\r\n * @param value - The value to check.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#isproxy}\r\n */\r\nexport function isProxy(value: unknown): boolean {\r\n  return isReactive(value) || isReadonly(value)\r\n}\r\n\r\n/**\r\n * Returns the raw, original object of a Vue-created proxy.\r\n *\r\n * `toRaw()` can return the original object from proxies created by\r\n * {@link reactive()}, {@link readonly()}, {@link shallowReactive()} or\r\n * {@link shallowReadonly()}.\r\n *\r\n * This is an escape hatch that can be used to temporarily read without\r\n * incurring proxy access / tracking overhead or write without triggering\r\n * changes. It is **not** recommended to hold a persistent reference to the\r\n * original object. Use with caution.\r\n *\r\n * @example\r\n * ```js\r\n * const foo = {}\r\n * const reactiveFoo = reactive(foo)\r\n *\r\n * console.log(toRaw(reactiveFoo) === foo) // true\r\n * ```\r\n *\r\n * @param observed - The object for which the \"raw\" value is requested.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#toraw}\r\n */\r\nexport function toRaw<T>(observed: T): T {\r\n  const raw = observed && (observed as Target)[ReactiveFlags.RAW]\r\n  return raw ? toRaw(raw) : observed\r\n}\r\n\r\nexport type Raw<T> = T & { [RawSymbol]?: true }\r\n\r\n/**\r\n * Marks an object so that it will never be converted to a proxy. Returns the\r\n * object itself.\r\n *\r\n * @example\r\n * ```js\r\n * const foo = markRaw({})\r\n * console.log(isReactive(reactive(foo))) // false\r\n *\r\n * // also works when nested inside other reactive objects\r\n * const bar = reactive({ foo })\r\n * console.log(isReactive(bar.foo)) // false\r\n * ```\r\n *\r\n * **Warning:** `markRaw()` together with the shallow APIs such as\r\n * {@link shallowReactive()} allow you to selectively opt-out of the default\r\n * deep reactive/readonly conversion and embed raw, non-proxied objects in your\r\n * state graph.\r\n *\r\n * @param value - The object to be marked as \"raw\".\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#markraw}\r\n */\r\nexport function markRaw<T extends object>(value: T): Raw<T> {\r\n  def(value, ReactiveFlags.SKIP, true)\r\n  return value\r\n}\r\n\r\n/**\r\n * Returns a reactive proxy of the given value (if possible).\r\n *\r\n * If the given value is not an object, the original value itself is returned.\r\n *\r\n * @param value - The value for which a reactive proxy shall be created.\r\n */\r\nexport const toReactive = <T extends unknown>(value: T): T =>\r\n  isObject(value) ? reactive(value) : value\r\n\r\n/**\r\n * Returns a readonly proxy of the given value (if possible).\r\n *\r\n * If the given value is not an object, the original value itself is returned.\r\n *\r\n * @param value - The value for which a readonly proxy shall be created.\r\n */\r\nexport const toReadonly = <T extends unknown>(value: T): T =>\r\n  isObject(value) ? readonly(value) : value\r\n","import { type DebuggerOptions, ReactiveEffect, scheduleEffects } from './effect'\r\nimport { type Ref, trackRefValue, triggerRefValue } from './ref'\r\nimport { NOOP, hasChanged, isFunction } from '@vue/shared'\r\nimport { toRaw } from './reactive'\r\nimport type { Dep } from './dep'\r\nimport { DirtyLevels, ReactiveFlags } from './constants'\r\n\r\ndeclare const ComputedRefSymbol: unique symbol\r\n\r\nexport interface ComputedRef<T = any> extends WritableComputedRef<T> {\r\n  readonly value: T\r\n  [ComputedRefSymbol]: true\r\n}\r\n\r\nexport interface WritableComputedRef<T> extends Ref<T> {\r\n  readonly effect: ReactiveEffect<T>\r\n}\r\n\r\nexport type ComputedGetter<T> = (oldValue?: T) => T\r\nexport type ComputedSetter<T> = (newValue: T) => void\r\n\r\nexport interface WritableComputedOptions<T> {\r\n  get: ComputedGetter<T>\r\n  set: ComputedSetter<T>\r\n}\r\n\r\nexport class ComputedRefImpl<T> {\r\n  public dep?: Dep = undefined\r\n\r\n  private _value!: T\r\n  public readonly effect: ReactiveEffect<T>\r\n\r\n  public readonly __v_isRef = true\r\n  public readonly [ReactiveFlags.IS_READONLY]: boolean = false\r\n\r\n  public _cacheable: boolean\r\n\r\n  constructor(\r\n    getter: ComputedGetter<T>,\r\n    private readonly _setter: ComputedSetter<T>,\r\n    isReadonly: boolean,\r\n    isSSR: boolean,\r\n  ) {\r\n    this.effect = new ReactiveEffect(\r\n      () => getter(this._value),\r\n      () => triggerRefValue(this, DirtyLevels.MaybeDirty),\r\n      () => this.dep && scheduleEffects(this.dep),\r\n    )\r\n    this.effect.computed = this\r\n    this.effect.active = this._cacheable = !isSSR\r\n    this[ReactiveFlags.IS_READONLY] = isReadonly\r\n  }\r\n\r\n  get value() {\r\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n    const self = toRaw(this)\r\n    if (!self._cacheable || self.effect.dirty) {\r\n      if (hasChanged(self._value, (self._value = self.effect.run()!))) {\r\n        triggerRefValue(self, DirtyLevels.Dirty)\r\n      }\r\n    }\r\n    trackRefValue(self)\r\n    if (self.effect._dirtyLevel >= DirtyLevels.MaybeDirty) {\r\n      triggerRefValue(self, DirtyLevels.MaybeDirty)\r\n    }\r\n    return self._value\r\n  }\r\n\r\n  set value(newValue: T) {\r\n    this._setter(newValue)\r\n  }\r\n\r\n  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x\r\n  get _dirty() {\r\n    return this.effect.dirty\r\n  }\r\n\r\n  set _dirty(v) {\r\n    this.effect.dirty = v\r\n  }\r\n  // #endregion\r\n}\r\n\r\n/**\r\n * Takes a getter function and returns a readonly reactive ref object for the\r\n * returned value from the getter. It can also take an object with get and set\r\n * functions to create a writable ref object.\r\n *\r\n * @example\r\n * ```js\r\n * // Creating a readonly computed ref:\r\n * const count = ref(1)\r\n * const plusOne = computed(() => count.value + 1)\r\n *\r\n * console.log(plusOne.value) // 2\r\n * plusOne.value++ // error\r\n * ```\r\n *\r\n * ```js\r\n * // Creating a writable computed ref:\r\n * const count = ref(1)\r\n * const plusOne = computed({\r\n *   get: () => count.value + 1,\r\n *   set: (val) => {\r\n *     count.value = val - 1\r\n *   }\r\n * })\r\n *\r\n * plusOne.value = 1\r\n * console.log(count.value) // 0\r\n * ```\r\n *\r\n * @param getter - Function that produces the next value.\r\n * @param debugOptions - For debugging. See {@link https://vuejs.org/guide/extras/reactivity-in-depth.html#computed-debugging}.\r\n * @see {@link https://vuejs.org/api/reactivity-core.html#computed}\r\n */\r\nexport function computed<T>(\r\n  getter: ComputedGetter<T>,\r\n  debugOptions?: DebuggerOptions,\r\n): ComputedRef<T>\r\nexport function computed<T>(\r\n  options: WritableComputedOptions<T>,\r\n  debugOptions?: DebuggerOptions,\r\n): WritableComputedRef<T>\r\nexport function computed<T>(\r\n  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>,\r\n  debugOptions?: DebuggerOptions,\r\n  isSSR = false,\r\n) {\r\n  let getter: ComputedGetter<T>\r\n  let setter: ComputedSetter<T>\r\n\r\n  const onlyGetter = isFunction(getterOrOptions)\r\n  if (onlyGetter) {\r\n    getter = getterOrOptions\r\n    setter = __DEV__\r\n      ? () => {\r\n          console.warn('Write operation failed: computed value is readonly')\r\n        }\r\n      : NOOP\r\n  } else {\r\n    getter = getterOrOptions.get\r\n    setter = getterOrOptions.set\r\n  }\r\n\r\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR)\r\n\r\n  if (__DEV__ && debugOptions && !isSSR) {\r\n    cRef.effect.onTrack = debugOptions.onTrack\r\n    cRef.effect.onTrigger = debugOptions.onTrigger\r\n  }\r\n\r\n  return cRef as any\r\n}\r\n","import type { ComputedRef } from './computed'\r\nimport {\r\n  activeEffect,\r\n  shouldTrack,\r\n  trackEffect,\r\n  triggerEffects,\r\n} from './effect'\r\nimport { DirtyLevels, TrackOpTypes, TriggerOpTypes } from './constants'\r\nimport {\r\n  type IfAny,\r\n  hasChanged,\r\n  isArray,\r\n  isFunction,\r\n  isObject,\r\n} from '@vue/shared'\r\nimport {\r\n  isProxy,\r\n  isReactive,\r\n  isReadonly,\r\n  isShallow,\r\n  toRaw,\r\n  toReactive,\r\n} from './reactive'\r\nimport type { ShallowReactiveMarker } from './reactive'\r\nimport { type Dep, createDep } from './dep'\r\nimport { ComputedRefImpl } from './computed'\r\nimport { getDepFromReactive } from './reactiveEffect'\r\n\r\ndeclare const RefSymbol: unique symbol\r\nexport declare const RawSymbol: unique symbol\r\n\r\nexport interface Ref<T = any> {\r\n  value: T\r\n  /**\r\n   * Type differentiator only.\r\n   * We need this to be in public d.ts but don't want it to show up in IDE\r\n   * autocomplete, so we use a private Symbol instead.\r\n   */\r\n  [RefSymbol]: true\r\n}\r\n\r\ntype RefBase<T> = {\r\n  dep?: Dep\r\n  value: T\r\n}\r\n\r\nexport function trackRefValue(ref: RefBase<any>) {\r\n  if (shouldTrack && activeEffect) {\r\n    ref = toRaw(ref)\r\n    trackEffect(\r\n      activeEffect,\r\n      ref.dep ||\r\n        (ref.dep = createDep(\r\n          () => (ref.dep = undefined),\r\n          ref instanceof ComputedRefImpl ? ref : undefined,\r\n        )),\r\n      __DEV__\r\n        ? {\r\n            target: ref,\r\n            type: TrackOpTypes.GET,\r\n            key: 'value',\r\n          }\r\n        : void 0,\r\n    )\r\n  }\r\n}\r\n\r\nexport function triggerRefValue(\r\n  ref: RefBase<any>,\r\n  dirtyLevel: DirtyLevels = DirtyLevels.Dirty,\r\n  newVal?: any,\r\n) {\r\n  ref = toRaw(ref)\r\n  const dep = ref.dep\r\n  if (dep) {\r\n    triggerEffects(\r\n      dep,\r\n      dirtyLevel,\r\n      __DEV__\r\n        ? {\r\n            target: ref,\r\n            type: TriggerOpTypes.SET,\r\n            key: 'value',\r\n            newValue: newVal,\r\n          }\r\n        : void 0,\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if a value is a ref object.\r\n *\r\n * @param r - The value to inspect.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#isref}\r\n */\r\nexport function isRef<T>(r: Ref<T> | unknown): r is Ref<T>\r\nexport function isRef(r: any): r is Ref {\r\n  return !!(r && r.__v_isRef === true)\r\n}\r\n\r\n/**\r\n * Takes an inner value and returns a reactive and mutable ref object, which\r\n * has a single property `.value` that points to the inner value.\r\n *\r\n * @param value - The object to wrap in the ref.\r\n * @see {@link https://vuejs.org/api/reactivity-core.html#ref}\r\n */\r\nexport function ref<T>(value: T): Ref<UnwrapRef<T>>\r\nexport function ref<T = any>(): Ref<T | undefined>\r\nexport function ref(value?: unknown) {\r\n  return createRef(value, false)\r\n}\r\n\r\ndeclare const ShallowRefMarker: unique symbol\r\n\r\nexport type ShallowRef<T = any> = Ref<T> & { [ShallowRefMarker]?: true }\r\n\r\n/**\r\n * Shallow version of {@link ref()}.\r\n *\r\n * @example\r\n * ```js\r\n * const state = shallowRef({ count: 1 })\r\n *\r\n * // does NOT trigger change\r\n * state.value.count = 2\r\n *\r\n * // does trigger change\r\n * state.value = { count: 2 }\r\n * ```\r\n *\r\n * @param value - The \"inner value\" for the shallow ref.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#shallowref}\r\n */\r\nexport function shallowRef<T>(\r\n  value: T,\r\n): Ref extends T\r\n  ? T extends Ref\r\n    ? IfAny<T, ShallowRef<T>, T>\r\n    : ShallowRef<T>\r\n  : ShallowRef<T>\r\nexport function shallowRef<T = any>(): ShallowRef<T | undefined>\r\nexport function shallowRef(value?: unknown) {\r\n  return createRef(value, true)\r\n}\r\n\r\nfunction createRef(rawValue: unknown, shallow: boolean) {\r\n  if (isRef(rawValue)) {\r\n    return rawValue\r\n  }\r\n  return new RefImpl(rawValue, shallow)\r\n}\r\n\r\nclass RefImpl<T> {\r\n  private _value: T\r\n  private _rawValue: T\r\n\r\n  public dep?: Dep = undefined\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(\r\n    value: T,\r\n    public readonly __v_isShallow: boolean,\r\n  ) {\r\n    this._rawValue = __v_isShallow ? value : toRaw(value)\r\n    this._value = __v_isShallow ? value : toReactive(value)\r\n  }\r\n\r\n  get value() {\r\n    trackRefValue(this)\r\n    return this._value\r\n  }\r\n\r\n  set value(newVal) {\r\n    const useDirectValue =\r\n      this.__v_isShallow || isShallow(newVal) || isReadonly(newVal)\r\n    newVal = useDirectValue ? newVal : toRaw(newVal)\r\n    if (hasChanged(newVal, this._rawValue)) {\r\n      this._rawValue = newVal\r\n      this._value = useDirectValue ? newVal : toReactive(newVal)\r\n      triggerRefValue(this, DirtyLevels.Dirty, newVal)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Force trigger effects that depends on a shallow ref. This is typically used\r\n * after making deep mutations to the inner value of a shallow ref.\r\n *\r\n * @example\r\n * ```js\r\n * const shallow = shallowRef({\r\n *   greet: 'Hello, world'\r\n * })\r\n *\r\n * // Logs \"Hello, world\" once for the first run-through\r\n * watchEffect(() => {\r\n *   console.log(shallow.value.greet)\r\n * })\r\n *\r\n * // This won't trigger the effect because the ref is shallow\r\n * shallow.value.greet = 'Hello, universe'\r\n *\r\n * // Logs \"Hello, universe\"\r\n * triggerRef(shallow)\r\n * ```\r\n *\r\n * @param ref - The ref whose tied effects shall be executed.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#triggerref}\r\n */\r\nexport function triggerRef(ref: Ref) {\r\n  triggerRefValue(ref, DirtyLevels.Dirty, __DEV__ ? ref.value : void 0)\r\n}\r\n\r\nexport type MaybeRef<T = any> = T | Ref<T>\r\nexport type MaybeRefOrGetter<T = any> = MaybeRef<T> | (() => T)\r\n\r\n/**\r\n * Returns the inner value if the argument is a ref, otherwise return the\r\n * argument itself. This is a sugar function for\r\n * `val = isRef(val) ? val.value : val`.\r\n *\r\n * @example\r\n * ```js\r\n * function useFoo(x: number | Ref<number>) {\r\n *   const unwrapped = unref(x)\r\n *   // unwrapped is guaranteed to be number now\r\n * }\r\n * ```\r\n *\r\n * @param ref - Ref or plain value to be converted into the plain value.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#unref}\r\n */\r\nexport function unref<T>(ref: MaybeRef<T> | ComputedRef<T>): T {\r\n  return isRef(ref) ? ref.value : ref\r\n}\r\n\r\n/**\r\n * Normalizes values / refs / getters to values.\r\n * This is similar to {@link unref()}, except that it also normalizes getters.\r\n * If the argument is a getter, it will be invoked and its return value will\r\n * be returned.\r\n *\r\n * @example\r\n * ```js\r\n * toValue(1) // 1\r\n * toValue(ref(1)) // 1\r\n * toValue(() => 1) // 1\r\n * ```\r\n *\r\n * @param source - A getter, an existing ref, or a non-function value.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#tovalue}\r\n */\r\nexport function toValue<T>(source: MaybeRefOrGetter<T> | ComputedRef<T>): T {\r\n  return isFunction(source) ? source() : unref(source)\r\n}\r\n\r\nconst shallowUnwrapHandlers: ProxyHandler<any> = {\r\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n  set: (target, key, value, receiver) => {\r\n    const oldValue = target[key]\r\n    if (isRef(oldValue) && !isRef(value)) {\r\n      oldValue.value = value\r\n      return true\r\n    } else {\r\n      return Reflect.set(target, key, value, receiver)\r\n    }\r\n  },\r\n}\r\n\r\n/**\r\n * Returns a reactive proxy for the given object.\r\n *\r\n * If the object already is reactive, it's returned as-is. If not, a new\r\n * reactive proxy is created. Direct child properties that are refs are properly\r\n * handled, as well.\r\n *\r\n * @param objectWithRefs - Either an already-reactive object or a simple object\r\n * that contains refs.\r\n */\r\nexport function proxyRefs<T extends object>(\r\n  objectWithRefs: T,\r\n): ShallowUnwrapRef<T> {\r\n  return isReactive(objectWithRefs)\r\n    ? objectWithRefs\r\n    : new Proxy(objectWithRefs, shallowUnwrapHandlers)\r\n}\r\n\r\nexport type CustomRefFactory<T> = (\r\n  track: () => void,\r\n  trigger: () => void,\r\n) => {\r\n  get: () => T\r\n  set: (value: T) => void\r\n}\r\n\r\nclass CustomRefImpl<T> {\r\n  public dep?: Dep = undefined\r\n\r\n  private readonly _get: ReturnType<CustomRefFactory<T>>['get']\r\n  private readonly _set: ReturnType<CustomRefFactory<T>>['set']\r\n\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(factory: CustomRefFactory<T>) {\r\n    const { get, set } = factory(\r\n      () => trackRefValue(this),\r\n      () => triggerRefValue(this),\r\n    )\r\n    this._get = get\r\n    this._set = set\r\n  }\r\n\r\n  get value() {\r\n    return this._get()\r\n  }\r\n\r\n  set value(newVal) {\r\n    this._set(newVal)\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a customized ref with explicit control over its dependency tracking\r\n * and updates triggering.\r\n *\r\n * @param factory - The function that receives the `track` and `trigger` callbacks.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#customref}\r\n */\r\nexport function customRef<T>(factory: CustomRefFactory<T>): Ref<T> {\r\n  return new CustomRefImpl(factory) as any\r\n}\r\n\r\nexport type ToRefs<T = any> = {\r\n  [K in keyof T]: ToRef<T[K]>\r\n}\r\n\r\n/**\r\n * Converts a reactive object to a plain object where each property of the\r\n * resulting object is a ref pointing to the corresponding property of the\r\n * original object. Each individual ref is created using {@link toRef()}.\r\n *\r\n * @param object - Reactive object to be made into an object of linked refs.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#torefs}\r\n */\r\nexport function toRefs<T extends object>(object: T): ToRefs<T> {\r\n  if (__DEV__ && !isProxy(object)) {\r\n    console.warn(`toRefs() expects a reactive object but received a plain one.`)\r\n  }\r\n  const ret: any = isArray(object) ? new Array(object.length) : {}\r\n  for (const key in object) {\r\n    ret[key] = propertyToRef(object, key)\r\n  }\r\n  return ret\r\n}\r\n\r\nclass ObjectRefImpl<T extends object, K extends keyof T> {\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(\r\n    private readonly _object: T,\r\n    private readonly _key: K,\r\n    private readonly _defaultValue?: T[K],\r\n  ) {}\r\n\r\n  get value() {\r\n    const val = this._object[this._key]\r\n    return val === undefined ? this._defaultValue! : val\r\n  }\r\n\r\n  set value(newVal) {\r\n    this._object[this._key] = newVal\r\n  }\r\n\r\n  get dep(): Dep | undefined {\r\n    return getDepFromReactive(toRaw(this._object), this._key)\r\n  }\r\n}\r\n\r\nclass GetterRefImpl<T> {\r\n  public readonly __v_isRef = true\r\n  public readonly __v_isReadonly = true\r\n  constructor(private readonly _getter: () => T) {}\r\n  get value() {\r\n    return this._getter()\r\n  }\r\n}\r\n\r\nexport type ToRef<T> = IfAny<T, Ref<T>, [T] extends [Ref] ? T : Ref<T>>\r\n\r\n/**\r\n * Used to normalize values / refs / getters into refs.\r\n *\r\n * @example\r\n * ```js\r\n * // returns existing refs as-is\r\n * toRef(existingRef)\r\n *\r\n * // creates a ref that calls the getter on .value access\r\n * toRef(() => props.foo)\r\n *\r\n * // creates normal refs from non-function values\r\n * // equivalent to ref(1)\r\n * toRef(1)\r\n * ```\r\n *\r\n * Can also be used to create a ref for a property on a source reactive object.\r\n * The created ref is synced with its source property: mutating the source\r\n * property will update the ref, and vice-versa.\r\n *\r\n * @example\r\n * ```js\r\n * const state = reactive({\r\n *   foo: 1,\r\n *   bar: 2\r\n * })\r\n *\r\n * const fooRef = toRef(state, 'foo')\r\n *\r\n * // mutating the ref updates the original\r\n * fooRef.value++\r\n * console.log(state.foo) // 2\r\n *\r\n * // mutating the original also updates the ref\r\n * state.foo++\r\n * console.log(fooRef.value) // 3\r\n * ```\r\n *\r\n * @param source - A getter, an existing ref, a non-function value, or a\r\n *                 reactive object to create a property ref from.\r\n * @param [key] - (optional) Name of the property in the reactive object.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#toref}\r\n */\r\nexport function toRef<T>(\r\n  value: T,\r\n): T extends () => infer R\r\n  ? Readonly<Ref<R>>\r\n  : T extends Ref\r\n    ? T\r\n    : Ref<UnwrapRef<T>>\r\nexport function toRef<T extends object, K extends keyof T>(\r\n  object: T,\r\n  key: K,\r\n): ToRef<T[K]>\r\nexport function toRef<T extends object, K extends keyof T>(\r\n  object: T,\r\n  key: K,\r\n  defaultValue: T[K],\r\n): ToRef<Exclude<T[K], undefined>>\r\nexport function toRef(\r\n  source: Record<string, any> | MaybeRef,\r\n  key?: string,\r\n  defaultValue?: unknown,\r\n): Ref {\r\n  if (isRef(source)) {\r\n    return source\r\n  } else if (isFunction(source)) {\r\n    return new GetterRefImpl(source) as any\r\n  } else if (isObject(source) && arguments.length > 1) {\r\n    return propertyToRef(source, key!, defaultValue)\r\n  } else {\r\n    return ref(source)\r\n  }\r\n}\r\n\r\nfunction propertyToRef(\r\n  source: Record<string, any>,\r\n  key: string,\r\n  defaultValue?: unknown,\r\n) {\r\n  const val = source[key]\r\n  return isRef(val)\r\n    ? val\r\n    : (new ObjectRefImpl(source, key, defaultValue) as any)\r\n}\r\n\r\n// corner case when use narrows type\r\n// Ex. type RelativePath = string & { __brand: unknown }\r\n// RelativePath extends object -> true\r\ntype BaseTypes = string | number | boolean\r\n\r\n/**\r\n * This is a special exported interface for other packages to declare\r\n * additional types that should bail out for ref unwrapping. For example\r\n * \\@vue/runtime-dom can declare it like so in its d.ts:\r\n *\r\n * ``` ts\r\n * declare module '@vue/reactivity' {\r\n *   export interface RefUnwrapBailTypes {\r\n *     runtimeDOMBailTypes: Node | Window\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport interface RefUnwrapBailTypes {}\r\n\r\nexport type ShallowUnwrapRef<T> = {\r\n  [K in keyof T]: DistrubuteRef<T[K]>\r\n}\r\n\r\ntype DistrubuteRef<T> = T extends Ref<infer V> ? V : T\r\n\r\nexport type UnwrapRef<T> =\r\n  T extends ShallowRef<infer V>\r\n    ? V\r\n    : T extends Ref<infer V>\r\n      ? UnwrapRefSimple<V>\r\n      : UnwrapRefSimple<T>\r\n\r\nexport type UnwrapRefSimple<T> = T extends\r\n  | Function\r\n  | BaseTypes\r\n  | Ref\r\n  | RefUnwrapBailTypes[keyof RefUnwrapBailTypes]\r\n  | { [RawSymbol]?: true }\r\n  ? T\r\n  : T extends Map<infer K, infer V>\r\n    ? Map<K, UnwrapRefSimple<V>> & UnwrapRef<Omit<T, keyof Map<any, any>>>\r\n    : T extends WeakMap<infer K, infer V>\r\n      ? WeakMap<K, UnwrapRefSimple<V>> &\r\n          UnwrapRef<Omit<T, keyof WeakMap<any, any>>>\r\n      : T extends Set<infer V>\r\n        ? Set<UnwrapRefSimple<V>> & UnwrapRef<Omit<T, keyof Set<any>>>\r\n        : T extends WeakSet<infer V>\r\n          ? WeakSet<UnwrapRefSimple<V>> & UnwrapRef<Omit<T, keyof WeakSet<any>>>\r\n          : T extends ReadonlyArray<any>\r\n            ? { [K in keyof T]: UnwrapRefSimple<T[K]> }\r\n            : T extends object & { [ShallowReactiveMarker]?: never }\r\n              ? {\r\n                  [P in keyof T]: P extends symbol ? T[P] : UnwrapRef<T[P]>\r\n                }\r\n              : T\r\n","import { computed } from './computed'\r\n\r\n/**\r\n * @deprecated use `computed` instead. See #5912\r\n */\r\nexport const deferredComputed = computed\r\n","// using literal strings instead of numbers so that it's easier to inspect\r\n// debugger events\r\n\r\nexport enum TrackOpTypes {\r\n  GET = 'get',\r\n  HAS = 'has',\r\n  ITERATE = 'iterate',\r\n}\r\n\r\nexport enum TriggerOpTypes {\r\n  SET = 'set',\r\n  ADD = 'add',\r\n  DELETE = 'delete',\r\n  CLEAR = 'clear',\r\n}\r\n\r\nexport enum ReactiveFlags {\r\n  // 这个属性表示一个值是否应该被跳过，不进行响应式处理。通常在对对象进行深度遍历时，遇到某些特殊标记的值，需要跳过不处理，以避免循环引用或其他不必要的处理\r\n  SKIP = '__v_skip',\r\n  // 这个属性表示一个值是否已经被设置为响应式。在 Vue 3 的响应式系统中，会为对象的属性添加 getter 和 setter，从而实现数据的响应式变化。如果一个对象已经被设置为响应式，就会通过该标记进行标识。\r\n  IS_REACTIVE = '__v_isReactive',\r\n  // 这个属性表示一个值是否是只读的。在 Vue 3 的响应式系统中，可以通过 readonly 函数将对象转换为只读的，这样就无法对其进行修改操作。通过该标记可以进行判断，从而确定是否应该进行只读的处理。\r\n  IS_READONLY = '__v_isReadonly',\r\n  // 这个属性表示一个值是否是浅响应式的。在某些情况下，只需要对对象的顶层属性进行响应式处理，而不需要深度监听整个对象的变化。通过该标记可以进行标识，从而确定是否应该进行浅响应式处理。\r\n  IS_SHALLOW = '__v_isShallow',\r\n  // 这个属性表示一个值的原始版本。在 Vue 3 的响应式系统中，会为对象的属性添加 getter 和 setter，但有时需要获取对象的原始版本，而不是经过响应式处理后的版本。通过该标记可以进行标识，从而确定获取对象的原始版本。\r\n  RAW = '__v_raw',\r\n}\r\n\r\nexport enum DirtyLevels {\r\n  NotDirty = 0,\r\n  MaybeDirty = 1,\r\n  Dirty = 2,\r\n}\r\n"],"names":["makeMap","str","expectsLowerCase","set","Set","split","val","has","toLowerCase","NOOP","extend","Object","assign","hasOwnProperty","prototype","hasOwn","key","call","isArray","Array","isMap","toTypeString","isFunction","isSymbol","isObject","objectToString","toString","value","toRawType","slice","isIntegerKey","parseInt","hasChanged","oldValue","is","activeEffectScope","EffectScope","constructor","detached","this","__publicField","parent","index","scopes","push","active","_active","run","fn","currentEffectScope","on","off","stop","fromParent","i","l","effects","length","cleanups","last","pop","effectScope","recordEffectScope","effect","scope","getCurrentScope","onScopeDispose","activeEffect","ReactiveEffect","trigger","scheduler","dirty","_dirtyLevel","pauseTracking","_depsLength","dep","deps","computed","triggerComputed","resetTracking","v","lastShouldTrack","shouldTrack","lastEffect","_runnings","preCleanupEffect","postCleanupEffect","_a","onStop","_trackId","cleanupDepEffect","trackId","get","delete","size","cleanup","options","_effect","lazy","runner","bind","pauseScheduleStack","trackStack","enableTracking","pauseScheduling","resetScheduling","queueEffectSchedulers","shift","trackEffect","debuggerEventExtraInfo","oldDep","triggerEffects","dirtyLevel","keys","lastDirtyLevel","_shouldSchedule","scheduleEffects","allowRecurse","createDep","Map","targetMap","WeakMap","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","track","target","type","depsMap","newValue","oldTarget","values","newLength","Number","forEach","isNonTrackableKeys","builtInSymbols","getOwnPropertyNames","filter","map","arrayInstrumentations","createArrayInstrumentations","instrumentations","args","arr","toRaw","res","apply","obj","BaseReactiveHandler","_isReadonly","_shallow","receiver","isReadonly","shallow","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","getPrototypeOf","targetIsArray","Reflect","isRef","readonly","reactive","MutableReactiveHandler","super","isOldValueReadonly","isShallow","hadKey","result","deleteProperty","ownKeys","ReadonlyReactiveHandler","mutableHandlers","readonlyHandlers","shallowReactiveHandlers","shallowReadonlyHandlers","toShallow","getProto","rawTarget","rawKey","wrap","toReadonly","toReactive","add","deleteEntry","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","method","targetIsMap","isPair","iterator","isKeyOnly","innerIterator","next","done","createReadonlyMethod","createInstrumentations","mutableInstrumentations","shallowInstrumentations","readonlyInstrumentations","shallowReadonlyInstrumentations","createInstrumentationGetter","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","shallowReadonlyCollectionHandlers","createReactiveObject","shallowReactive","shallowReadonly","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","isExtensible","rawType","targetTypeMap","proxy","Proxy","isReactive","isProxy","raw","markRaw","defineProperty","configurable","enumerable","def","ComputedRefImpl","getter","_setter","isSSR","_value","triggerRefValue","_cacheable","self","trackRefValue","_dirty","getterOrOptions","debugOptions","setter","onlyGetter","ref","newVal","r","__v_isRef","createRef","shallowRef","rawValue","RefImpl","__v_isShallow","_rawValue","useDirectValue","triggerRef","unref","toValue","source","shallowUnwrapHandlers","proxyRefs","objectWithRefs","CustomRefImpl","factory","_get","_set","customRef","toRefs","object","ret","propertyToRef","ObjectRefImpl","_object","_key","_defaultValue","GetterRefImpl","_getter","toRef","defaultValue","arguments","deferredComputed","TrackOpTypes","GET","HAS","ITERATE","TriggerOpTypes","SET","ADD","DELETE","CLEAR","ReactiveFlags","SKIP","IS_REACTIVE","IS_READONLY","IS_SHALLOW","RAW"],"mappings":"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"}