{"version":3,"file":"reactivity.global.js","sources":["../../shared/src/makeMap.ts","../../shared/src/general.ts","../src/warning.ts","../src/effectScope.ts","../src/effect.ts","../src/dep.ts","../src/reactiveEffect.ts","../src/baseHandlers.ts","../src/collectionHandlers.ts","../src/reactive.ts","../src/computed.ts","../src/ref.ts","../src/deferredComputed.ts","../src/constants.ts"],"sourcesContent":["/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nexport function makeMap(\r\n  str: string,\r\n  expectsLowerCase?: boolean,\r\n): (key: string) => boolean {\r\n  const set = new Set(str.split(','))\r\n  return expectsLowerCase\r\n    ? val => set.has(val.toLowerCase())\r\n    : val => set.has(val)\r\n}\r\n","import { makeMap } from './makeMap'\r\n\r\nexport const EMPTY_OBJ: { readonly [key: string]: any } = __DEV__\r\n  ? Object.freeze({})\r\n  : {}\r\nexport const EMPTY_ARR = __DEV__ ? Object.freeze([]) : []\r\n\r\nexport const NOOP = () => {}\r\n\r\n/**\r\n * Always return false.\r\n */\r\nexport const NO = () => false\r\n\r\nexport const isOn = (key: string) =>\r\n  key.charCodeAt(0) === 111 /* o */ &&\r\n  key.charCodeAt(1) === 110 /* n */ &&\r\n  // uppercase letter\r\n  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97)\r\n\r\nexport const isModelListener = (key: string) => key.startsWith('onUpdate:')\r\n\r\nexport const extend = Object.assign\r\n\r\nexport const remove = <T>(arr: T[], el: T) => {\r\n  const i = arr.indexOf(el)\r\n  if (i > -1) {\r\n    arr.splice(i, 1)\r\n  }\r\n}\r\n\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty\r\nexport const hasOwn = (\r\n  val: object,\r\n  key: string | symbol,\r\n): key is keyof typeof val => hasOwnProperty.call(val, key)\r\n\r\nexport const isArray = Array.isArray\r\nexport const isMap = (val: unknown): val is Map<any, any> =>\r\n  toTypeString(val) === '[object Map]'\r\nexport const isSet = (val: unknown): val is Set<any> =>\r\n  toTypeString(val) === '[object Set]'\r\n\r\nexport const isDate = (val: unknown): val is Date =>\r\n  toTypeString(val) === '[object Date]'\r\nexport const isRegExp = (val: unknown): val is RegExp =>\r\n  toTypeString(val) === '[object RegExp]'\r\nexport const isFunction = (val: unknown): val is Function =>\r\n  typeof val === 'function'\r\nexport const isString = (val: unknown): val is string => typeof val === 'string'\r\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\r\nexport const isObject = (val: unknown): val is Record<any, any> =>\r\n  val !== null && typeof val === 'object'\r\n\r\nexport const isPromise = <T = any>(val: unknown): val is Promise<T> => {\r\n  return (\r\n    (isObject(val) || isFunction(val)) &&\r\n    isFunction((val as any).then) &&\r\n    isFunction((val as any).catch)\r\n  )\r\n}\r\n\r\nexport const objectToString = Object.prototype.toString\r\nexport const toTypeString = (value: unknown): string =>\r\n  objectToString.call(value)\r\n\r\nexport const toRawType = (value: unknown): string => {\r\n  // extract \"RawType\" from strings like \"[object RawType]\"\r\n  return toTypeString(value).slice(8, -1)\r\n}\r\n\r\nexport const isPlainObject = (val: unknown): val is object =>\r\n  toTypeString(val) === '[object Object]'\r\n\r\nexport const isIntegerKey = (key: unknown) =>\r\n  isString(key) &&\r\n  key !== 'NaN' &&\r\n  key[0] !== '-' &&\r\n  '' + parseInt(key, 10) === key\r\n\r\nexport const isReservedProp = /*#__PURE__*/ makeMap(\r\n  // the leading comma is intentional so empty string \"\" is also included\r\n  ',key,ref,ref_for,ref_key,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted',\r\n)\r\n\r\nexport const isBuiltInDirective = /*#__PURE__*/ makeMap(\r\n  'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo',\r\n)\r\n\r\nconst cacheStringFunction = <T extends (str: string) => string>(fn: T): T => {\r\n  const cache: Record<string, string> = Object.create(null)\r\n  return ((str: string) => {\r\n    const hit = cache[str]\r\n    return hit || (cache[str] = fn(str))\r\n  }) as T\r\n}\r\n\r\nconst camelizeRE = /-(\\w)/g\r\n/**\r\n * @private\r\n */\r\nexport const camelize = cacheStringFunction((str: string): string => {\r\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\r\n})\r\n\r\nconst hyphenateRE = /\\B([A-Z])/g\r\n/**\r\n * @private\r\n */\r\nexport const hyphenate = cacheStringFunction((str: string) =>\r\n  str.replace(hyphenateRE, '-$1').toLowerCase(),\r\n)\r\n\r\n/**\r\n * @private\r\n */\r\nexport const capitalize = cacheStringFunction(<T extends string>(str: T) => {\r\n  return (str.charAt(0).toUpperCase() + str.slice(1)) as Capitalize<T>\r\n})\r\n\r\n/**\r\n * @private\r\n */\r\nexport const toHandlerKey = cacheStringFunction(<T extends string>(str: T) => {\r\n  const s = str ? `on${capitalize(str)}` : ``\r\n  return s as T extends '' ? '' : `on${Capitalize<T>}`\r\n})\r\n\r\n// compare whether a value has changed, accounting for NaN.\r\nexport const hasChanged = (value: any, oldValue: any): boolean =>\r\n  !Object.is(value, oldValue)\r\n\r\nexport const invokeArrayFns = (fns: Function[], arg?: any) => {\r\n  for (let i = 0; i < fns.length; i++) {\r\n    fns[i](arg)\r\n  }\r\n}\r\n\r\nexport const def = (obj: object, key: string | symbol, value: any) => {\r\n  Object.defineProperty(obj, key, {\r\n    configurable: true,\r\n    enumerable: false,\r\n    value,\r\n  })\r\n}\r\n\r\n/**\r\n * \"123-foo\" will be parsed to 123\r\n * This is used for the .number modifier in v-model\r\n */\r\nexport const looseToNumber = (val: any): any => {\r\n  const n = parseFloat(val)\r\n  return isNaN(n) ? val : n\r\n}\r\n\r\n/**\r\n * Only concerns number-like strings\r\n * \"123-foo\" will be returned as-is\r\n */\r\nexport const toNumber = (val: any): any => {\r\n  const n = isString(val) ? Number(val) : NaN\r\n  return isNaN(n) ? val : n\r\n}\r\n\r\nlet _globalThis: any\r\nexport const getGlobalThis = (): any => {\r\n  return (\r\n    _globalThis ||\r\n    (_globalThis =\r\n      typeof globalThis !== 'undefined'\r\n        ? globalThis\r\n        : typeof self !== 'undefined'\r\n          ? self\r\n          : typeof window !== 'undefined'\r\n            ? window\r\n            : typeof global !== 'undefined'\r\n              ? global\r\n              : {})\r\n  )\r\n}\r\n\r\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/\r\n\r\nexport function genPropsAccessExp(name: string) {\r\n  return identRE.test(name)\r\n    ? `__props.${name}`\r\n    : `__props[${JSON.stringify(name)}]`\r\n}\r\n","export function warn(msg: string, ...args: any[]) {\r\n  console.warn(`[Vue warn] ${msg}`, ...args)\r\n}\r\n","import type { ReactiveEffect } from './effect'\r\nimport { warn } from './warning'\r\n\r\nlet activeEffectScope: EffectScope | undefined\r\n\r\nexport class EffectScope {\r\n  /**\r\n   * @internal\r\n   */\r\n  private _active = true\r\n  /**\r\n   * @internal\r\n   */\r\n  effects: ReactiveEffect[] = []\r\n  /**\r\n   * @internal\r\n   */\r\n  cleanups: (() => void)[] = []\r\n\r\n  /**\r\n   * only assigned by undetached scope\r\n   * @internal\r\n   */\r\n  parent: EffectScope | undefined\r\n  /**\r\n   * record undetached scopes\r\n   * @internal\r\n   */\r\n  scopes: EffectScope[] | undefined\r\n  /**\r\n   * track a child scope's index in its parent's scopes array for optimized\r\n   * removal\r\n   * @internal\r\n   */\r\n  private index: number | undefined\r\n\r\n  constructor(public detached = false) {\r\n    this.parent = activeEffectScope\r\n    if (!detached && activeEffectScope) {\r\n      this.index =\r\n        (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\r\n          this,\r\n        ) - 1\r\n    }\r\n  }\r\n\r\n  get active() {\r\n    return this._active\r\n  }\r\n\r\n  run<T>(fn: () => T): T | undefined {\r\n    if (this._active) {\r\n      const currentEffectScope = activeEffectScope\r\n      try {\r\n        activeEffectScope = this\r\n        return fn()\r\n      } finally {\r\n        activeEffectScope = currentEffectScope\r\n      }\r\n    } else if (__DEV__) {\r\n      warn(`cannot run an inactive effect scope.`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This should only be called on non-detached scopes\r\n   * @internal\r\n   */\r\n  on() {\r\n    activeEffectScope = this\r\n  }\r\n\r\n  /**\r\n   * This should only be called on non-detached scopes\r\n   * @internal\r\n   */\r\n  off() {\r\n    activeEffectScope = this.parent\r\n  }\r\n\r\n  stop(fromParent?: boolean) {\r\n    if (this._active) {\r\n      let i, l\r\n      for (i = 0, l = this.effects.length; i < l; i++) {\r\n        this.effects[i].stop()\r\n      }\r\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\r\n        this.cleanups[i]()\r\n      }\r\n      if (this.scopes) {\r\n        for (i = 0, l = this.scopes.length; i < l; i++) {\r\n          this.scopes[i].stop(true)\r\n        }\r\n      }\r\n      // nested scope, dereference from parent to avoid memory leaks\r\n      if (!this.detached && this.parent && !fromParent) {\r\n        // optimized O(1) removal\r\n        const last = this.parent.scopes!.pop()\r\n        if (last && last !== this) {\r\n          this.parent.scopes![this.index!] = last\r\n          last.index = this.index!\r\n        }\r\n      }\r\n      this.parent = undefined\r\n      this._active = false\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Creates an effect scope object which can capture the reactive effects (i.e.\r\n * computed and watchers) created within it so that these effects can be\r\n * disposed together. For detailed use cases of this API, please consult its\r\n * corresponding {@link https://github.com/vuejs/rfcs/blob/master/active-rfcs/0041-reactivity-effect-scope.md | RFC}.\r\n *\r\n * @param detached - Can be used to create a \"detached\" effect scope.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#effectscope}\r\n */\r\nexport function effectScope(detached?: boolean) {\r\n  return new EffectScope(detached)\r\n}\r\n\r\nexport function recordEffectScope(\r\n  effect: ReactiveEffect,\r\n  scope: EffectScope | undefined = activeEffectScope,\r\n) {\r\n  if (scope && scope.active) {\r\n    scope.effects.push(effect)\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the current active effect scope if there is one.\r\n *\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#getcurrentscope}\r\n */\r\nexport function getCurrentScope() {\r\n  return activeEffectScope\r\n}\r\n\r\n/**\r\n * Registers a dispose callback on the current active effect scope. The\r\n * callback will be invoked when the associated effect scope is stopped.\r\n *\r\n * @param fn - The callback function to attach to the scope's cleanup.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#onscopedispose}\r\n */\r\nexport function onScopeDispose(fn: () => void) {\r\n  if (activeEffectScope) {\r\n    activeEffectScope.cleanups.push(fn)\r\n  } else if (__DEV__) {\r\n    warn(\r\n      `onScopeDispose() is called when there is no active effect scope` +\r\n        ` to be associated with.`,\r\n    )\r\n  }\r\n}\r\n","import { NOOP, extend } from '@vue/shared'\r\nimport type { ComputedRefImpl } from './computed'\r\nimport {\r\n  DirtyLevels,\r\n  type TrackOpTypes,\r\n  type TriggerOpTypes,\r\n} from './constants'\r\nimport type { Dep } from './dep'\r\nimport { type EffectScope, recordEffectScope } from './effectScope'\r\n\r\nexport type EffectScheduler = (...args: any[]) => any\r\n\r\nexport type DebuggerEvent = {\r\n  effect: ReactiveEffect\r\n} & DebuggerEventExtraInfo\r\n\r\nexport type DebuggerEventExtraInfo = {\r\n  target: object\r\n  type: TrackOpTypes | TriggerOpTypes\r\n  key: any\r\n  newValue?: any\r\n  oldValue?: any\r\n  oldTarget?: Map<any, any> | Set<any>\r\n}\r\n\r\nexport let activeEffect: ReactiveEffect | undefined\r\n\r\n// 副作用函数\r\nexport class ReactiveEffect<T = any> {\r\n  active = true\r\n  /**\r\n   * 多对多的关系，一个副作用函数可以包含多个依赖的响应对象，一个响应对象可以存在多个副作用函数中\r\n   */\r\n  deps: Dep[] = []\r\n\r\n  /**\r\n   * Can be attached after creation\r\n   * @internal\r\n   */\r\n  computed?: ComputedRefImpl<T>\r\n  /**\r\n   * @internal\r\n   */\r\n  allowRecurse?: boolean\r\n\r\n  onStop?: () => void\r\n  // dev only\r\n  onTrack?: (event: DebuggerEvent) => void\r\n  // dev only\r\n  onTrigger?: (event: DebuggerEvent) => void\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  _dirtyLevel = DirtyLevels.Dirty\r\n  /**\r\n   * @internal\r\n   */\r\n  _trackId = 0\r\n  /**\r\n   * @internal\r\n   */\r\n  _runnings = 0\r\n  /**\r\n   * @internal\r\n   */\r\n  _shouldSchedule = false\r\n  /**\r\n   * @internal\r\n   */\r\n  _depsLength = 0\r\n\r\n  constructor(\r\n    public fn: () => T,\r\n    public trigger: () => void,\r\n    public scheduler?: EffectScheduler,\r\n    scope?: EffectScope,\r\n  ) {\r\n    recordEffectScope(this, scope)\r\n  }\r\n\r\n  public get dirty() {\r\n    if (this._dirtyLevel === DirtyLevels.MaybeDirty) {\r\n      pauseTracking()\r\n      for (let i = 0; i < this._depsLength; i++) {\r\n        const dep = this.deps[i]\r\n        if (dep.computed) {\r\n          triggerComputed(dep.computed)\r\n          if (this._dirtyLevel >= DirtyLevels.Dirty) {\r\n            break\r\n          }\r\n        }\r\n      }\r\n      if (this._dirtyLevel < DirtyLevels.Dirty) {\r\n        this._dirtyLevel = DirtyLevels.NotDirty\r\n      }\r\n      resetTracking()\r\n    }\r\n    return this._dirtyLevel >= DirtyLevels.Dirty\r\n  }\r\n\r\n  public set dirty(v) {\r\n    this._dirtyLevel = v ? DirtyLevels.Dirty : DirtyLevels.NotDirty\r\n  }\r\n\r\n  // 1 last null active p1\r\n  // 2 last p1 active p2\r\n  // 3 last p2 active p3\r\n  // p3执行完 active p2\r\n  // p2环境 执行完 active p1\r\n  // p3环境执行完\r\n  /**\r\n   * 总而言之：\r\n   * 1. lastEffect和activeEffect是为了防止堆栈递归调用effect函数的情况；\r\n   * 2. preCleanupEffect和postCleanupEffect结合_trackId目的就是为了每次执行前先斩断依赖对象和副作用函数之间的关系，\r\n   * 执行之后再重新收集依赖关系，但是呢从性能上考虑清空的时候不是直接把deps数组长度清空，\r\n   * 而是先通过_depsLength设置为0，重新建立正确的依赖关系，把多余的元素再剪短依赖关系\r\n   * 3. _trackId是副作用对象的执行次数追踪id\r\n   */\r\n  run() {\r\n    this._dirtyLevel = DirtyLevels.NotDirty // 只要即将执行，就是标志为NotDirty，比如一些异步函数，如果等执行完，\r\n    if (!this.active) {\r\n      return this.fn()\r\n    }\r\n    let lastShouldTrack = shouldTrack\r\n    let lastEffect = activeEffect\r\n    try {\r\n      shouldTrack = true\r\n      activeEffect = this\r\n      this._runnings++\r\n      /**\r\n       * 通过preCleaupEffect方法\r\n       * 标识执行状态_trackId加1了，然后把_depsLength设置为零\r\n       */\r\n      preCleanupEffect(this);\r\n      /**\r\n       * 执行fn副作用函数的时候，会重新手机依赖对象\r\n       * 收集的过程有多种情况：\r\n       * （1）只是把Dep中的key对应的value（_trackId）更新，它们的依赖关系依赖没变\r\n       * （2）存在有一些依赖对象没有执行到的，那这个时候deps里面的元素是比_depsLength要多\r\n       */\r\n      return this.fn()\r\n    } finally {\r\n      /**\r\n       * 收集过程中，走到清空2，\r\n       * 通过postCleanupEffect，把deps中多余的元素清空，并且见到多余的依赖对象和副作用函数之间的关系\r\n       */\r\n      postCleanupEffect(this)\r\n      /**\r\n       * _running的作用：\r\n       * （1）如果一个副作用函数对一个key先有get,然后set操作，因为_running不为0，所以后面的set操作不会再次触发副作用函数的执行\r\n       * （2）如果副作用函数是一个异步函数，在副作用函数还没执行结束之前，就发生了依赖对象key的改变，因为_running也不会再次触发副作用函数\r\n       */\r\n      this._runnings--\r\n      activeEffect = lastEffect\r\n      shouldTrack = lastShouldTrack\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    if (this.active) {\r\n      preCleanupEffect(this)\r\n      postCleanupEffect(this)\r\n      this.onStop?.()\r\n      this.active = false\r\n    }\r\n  }\r\n}\r\n\r\nfunction triggerComputed(computed: ComputedRefImpl<any>) {\r\n  return computed.value\r\n}\r\n\r\nfunction preCleanupEffect(effect: ReactiveEffect) {\r\n  effect._trackId++\r\n  effect._depsLength = 0\r\n}\r\n\r\nfunction postCleanupEffect(effect: ReactiveEffect) {\r\n  if (effect.deps && effect.deps.length > effect._depsLength) {\r\n    for (let i = effect._depsLength; i < effect.deps.length; i++) {\r\n      cleanupDepEffect(effect.deps[i], effect)\r\n    }\r\n    effect.deps.length = effect._depsLength\r\n  }\r\n}\r\n\r\nfunction cleanupDepEffect(dep: Dep, effect: ReactiveEffect) {\r\n  const trackId = dep.get(effect)\r\n   //这里判断原因\r\n  /**\r\n   * 比如说ok text name三个属性，\r\n   * 第二次ok为true了，\r\n   * text对应的代码不会再执行到了，name就占据到deps中的第二个位置，再执行postCleanupEffect方法时候\r\n   * 第三个元素其实就是第二个元素，trackId是等于effect._trackId的\r\n   */\r\n  if (trackId !== undefined && effect._trackId !== trackId) {\r\n    dep.delete(effect)\r\n    if (dep.size === 0) {\r\n      dep.cleanup()\r\n    }\r\n  }\r\n}\r\n\r\nexport interface DebuggerOptions {\r\n  onTrack?: (event: DebuggerEvent) => void\r\n  onTrigger?: (event: DebuggerEvent) => void\r\n}\r\n\r\nexport interface ReactiveEffectOptions extends DebuggerOptions {\r\n  lazy?: boolean\r\n  scheduler?: EffectScheduler\r\n  scope?: EffectScope\r\n  allowRecurse?: boolean\r\n  onStop?: () => void\r\n}\r\n\r\nexport interface ReactiveEffectRunner<T = any> {\r\n  (): T\r\n  effect: ReactiveEffect\r\n}\r\n\r\n/**\r\n * Registers the given function to track reactive updates.\r\n *\r\n * The given function will be run once immediately. Every time any reactive\r\n * property that's accessed within it gets updated, the function will run again.\r\n *\r\n * @param fn - The function that will track reactive updates.\r\n * @param options - Allows to control the effect's behaviour.\r\n * @returns A runner that can be used to control the effect after creation.\r\n */\r\nexport function effect<T = any>(\r\n  fn: () => T,\r\n  options?: ReactiveEffectOptions,\r\n): ReactiveEffectRunner {\r\n  if ((fn as ReactiveEffectRunner).effect instanceof ReactiveEffect) {\r\n    fn = (fn as ReactiveEffectRunner).effect.fn\r\n  }\r\n\r\n  const _effect = new ReactiveEffect(fn, NOOP, () => {\r\n    if (_effect.dirty) {\r\n      _effect.run()\r\n    }\r\n  })\r\n  if (options) {\r\n    extend(_effect, options)\r\n    if (options.scope) recordEffectScope(_effect, options.scope)\r\n  }\r\n  if (!options || !options.lazy) {\r\n    _effect.run()\r\n  }\r\n  const runner = _effect.run.bind(_effect) as ReactiveEffectRunner\r\n  runner.effect = _effect\r\n  return runner\r\n}\r\n\r\n/**\r\n * Stops the effect associated with the given runner.\r\n *\r\n * @param runner - Association with the effect to stop tracking.\r\n */\r\nexport function stop(runner: ReactiveEffectRunner) {\r\n  runner.effect.stop()\r\n}\r\n\r\nexport let shouldTrack = true\r\nexport let pauseScheduleStack = 0\r\n\r\nconst trackStack: boolean[] = []\r\n\r\n/**\r\n * Temporarily pauses tracking.\r\n */\r\nexport function pauseTracking() {\r\n  trackStack.push(shouldTrack)\r\n  shouldTrack = false\r\n}\r\n\r\n/**\r\n * Re-enables effect tracking (if it was paused).\r\n */\r\nexport function enableTracking() {\r\n  trackStack.push(shouldTrack)\r\n  shouldTrack = true\r\n}\r\n\r\n/**\r\n * Resets the previous global effect tracking state.\r\n */\r\nexport function resetTracking() {\r\n  const last = trackStack.pop()\r\n  shouldTrack = last === undefined ? true : last\r\n}\r\n\r\nexport function pauseScheduling() {\r\n  pauseScheduleStack++\r\n}\r\n\r\nexport function resetScheduling() {\r\n  pauseScheduleStack--\r\n  while (!pauseScheduleStack && queueEffectSchedulers.length) {\r\n    queueEffectSchedulers.shift()!()\r\n  }\r\n}\r\n\r\nexport function trackEffect(\r\n  effect: ReactiveEffect,\r\n  dep: Dep,\r\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo,\r\n) {\r\n  /**\r\n   * 比如在一个副作用函数中两次及以上使用了同一个代理对象的key的值，那第二次进入的时候，因为已经存在了且_trackId是相同的，就不会重复添加\r\n   * effect的_trackId的作用就是一个状态id，每执行一次，_trackId就加1，这样做目的：\r\n   * 第一次执行副作用函数的时候，会记录所有依赖对象的deps，但是后面执行条件发生改变了，可能某些依赖对象根本不会执行到，所以每次执行副作用函数\r\n   * 之前需要清空副作用函数对应的依赖对象，执行后又重新创建依赖对象，通过_depsLength和deps这样每次清空的时候，不会直接先把数组给清空了\r\n   * 所以第二次执行的时候_trackId是已经改变了\r\n   */\r\n  if (dep.get(effect) !== effect._trackId) {\r\n    dep.set(effect, effect._trackId)\r\n    const oldDep = effect.deps[effect._depsLength]\r\n    if (oldDep !== dep) {\r\n      if (oldDep) {\r\n        cleanupDepEffect(oldDep, effect)\r\n      }\r\n      effect.deps[effect._depsLength++] = dep\r\n    } else {\r\n      effect._depsLength++\r\n    }\r\n    if (__DEV__) {\r\n      effect.onTrack?.(extend({ effect }, debuggerEventExtraInfo!))\r\n    }\r\n  }\r\n}\r\n\r\nconst queueEffectSchedulers: EffectScheduler[] = []\r\n\r\n/**\r\n * 比如一个副作用函数即引用了代理A对象p属性的值，又循环遍历代理对象A\r\n * 那么A对象p属性的值更改时，即会触发p属性对应的副作用，也会触发迭代器对应的副作用\r\n * 第一次_dirtyLevel是NotDirty，改为Dirty，然后把该副作用函数先计入副作用调度器队列里面\r\n * 第二次通过迭代器进入triggerEffects的时候，因为都是同一个副作用对象，因为lastDirtyLevel已经是Dirty，所以不会再进入if里面，\r\n * 避免重复执行，比如以下场景：\r\n * const observed = reactive([1,2,3]);\r\n     effect(() => {\r\n        console.log(observed[3]);\r\n        for(let item of observed) {\r\n            console.log(item);\r\n        }\r\n    });\r\n    setTimeout(() => {\r\n        observed[3] = 5;\r\n    }, 500)\r\n    属性值length和key为3都会对effect建立依赖关系，observed[3]改变的时候，length和3对应的effect都会执行，因为通过_dirtyLevel和队列的形式，副作用只会加入到队列中一次并只执行一次（队列的作用不仅仅只有这一个）。\r\n */\r\nexport function triggerEffects(\r\n  dep: Dep,\r\n  dirtyLevel: DirtyLevels,\r\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo,\r\n) {\r\n  pauseScheduling()\r\n  for (const effect of dep.keys()) {\r\n    if (\r\n      effect._dirtyLevel < dirtyLevel && // 上一次没有dirty，这一次dirty，如果上一次正在dirty中，说明上一次副作用函数还没执行完，每次执行副作用函数之前都会把dirty设置为notdirty\r\n      dep.get(effect) === effect._trackId \r\n    ) {\r\n      const lastDirtyLevel = effect._dirtyLevel\r\n      effect._dirtyLevel = dirtyLevel\r\n      if (lastDirtyLevel === DirtyLevels.NotDirty) {\r\n        effect._shouldSchedule = true\r\n        if (__DEV__) {\r\n          effect.onTrigger?.(extend({ effect }, debuggerEventExtraInfo))\r\n        }\r\n        effect.trigger()\r\n      }\r\n    }\r\n  }\r\n  scheduleEffects(dep)\r\n  resetScheduling()\r\n}\r\n\r\n/**\r\n * 如果一个副作用函数对某个key先get，再set，那么set触发trigger，进入这个函数，_runnings不为0，allowRecurse默认是false\r\n * 所以不会重新调用副作用函数，不然就有可能进入死循环\r\n */\r\nexport function scheduleEffects(dep: Dep) {\r\n  for (const effect of dep.keys()) {\r\n    if (\r\n      effect.scheduler &&\r\n      effect._shouldSchedule &&\r\n      (!effect._runnings || effect.allowRecurse) &&\r\n      dep.get(effect) === effect._trackId\r\n    ) {\r\n      effect._shouldSchedule = false\r\n      queueEffectSchedulers.push(effect.scheduler)\r\n    }\r\n  }\r\n}\r\n","import type { ReactiveEffect } from './effect'\r\nimport type { ComputedRefImpl } from './computed'\r\n\r\nexport type Dep = Map<ReactiveEffect, number> & {\r\n  cleanup: () => void\r\n  computed?: ComputedRefImpl<any>\r\n}\r\n\r\nexport const createDep = (\r\n  cleanup: () => void,\r\n  computed?: ComputedRefImpl<any>,\r\n): Dep => {\r\n  const dep = new Map() as Dep\r\n  dep.cleanup = cleanup\r\n  dep.computed = computed\r\n  return dep\r\n}\r\n","import { isArray, isIntegerKey, isMap, isSymbol } from '@vue/shared'\r\nimport { DirtyLevels, type TrackOpTypes, TriggerOpTypes } from './constants'\r\nimport { type Dep, createDep } from './dep'\r\nimport {\r\n  activeEffect,\r\n  pauseScheduling,\r\n  resetScheduling,\r\n  shouldTrack,\r\n  trackEffect,\r\n  triggerEffects,\r\n} from './effect'\r\n\r\n// The main WeakMap that stores {target -> key -> dep} connections.\r\n// Conceptually, it's easier to think of a dependency as a Dep class\r\n// which maintains a Set of subscribers, but we simply store them as\r\n// raw Maps to reduce memory overhead.\r\ntype KeyToDepMap = Map<any, Dep>\r\nconst targetMap = new WeakMap<object, KeyToDepMap>()\r\n\r\nexport const ITERATE_KEY = Symbol(__DEV__ ? 'iterate' : '')\r\nexport const MAP_KEY_ITERATE_KEY = Symbol(__DEV__ ? 'Map key iterate' : '')\r\n\r\n/**\r\n * Tracks access to a reactive property.\r\n *\r\n * This will check which effect is running at the moment and record it as dep\r\n * which records all effects that depend on the reactive property.\r\n *\r\n * @param target - Object holding the reactive property.\r\n * @param type - Defines the type of access to the reactive property.\r\n * @param key - Identifier of the reactive property to track.\r\n */\r\n/**\r\n * 有三层：\r\n * 所有的响应对象target构成一个WeapMap\r\n * 简单地说，WeakMap 对 key 是弱引用，不影响垃圾回收器的工作。据这个特性可知，一旦 key 被垃圾回收器回收，那么对应的键和值就访问不到了。所以 WeakMap 经常用于存储那些只有当 key 所引用的对象存在时（没有被回收）才有价值的信息，例如上面的场景中，如果 target 对象没有任何引用了，说明用户侧不再需要它了，这时垃圾回收器会完成回收任务。但如果使用 Map 来代替WeakMap，那么即使用户侧的代码对 target 没有任何引用，这个 target 也不会被回收，最终可能导致内存溢出。\r\n * 单个响应对象中所有key构成一个map\r\n * 单个key对应的是Dep对象，但是Dep也是一个包含cleanup方法的map\r\n * \r\n */\r\nexport function track(target: object, type: TrackOpTypes, key: unknown) {\r\n  /**\r\n   * 判断activeEffect：只要当前执行的环境是在副作用函数中才需要去手机\r\n   * 判断shouldTrack：比如对于数组，调用push方法，会先获取length（get操作获取length），再往数组中添加元素（set操作）。\r\n   * 如下场景：两个副作用之间会进入一个互相触发执行的死循环的，所以对于像push方法，应该shouldTrack标识为false，这样就不会去进行副作用的依赖收集，本质上push是改变数组的值，也不需要去track依赖\r\n   * effect(() => {\r\n        observed.push(1)\r\n      });\r\n      effect(() => {\r\n          observed.push(2)\r\n      })\r\n   */\r\n  if (shouldTrack && activeEffect) {\r\n    let depsMap = targetMap.get(target)\r\n    if (!depsMap) {\r\n      targetMap.set(target, (depsMap = new Map()))\r\n    }\r\n    let dep = depsMap.get(key)\r\n    if (!dep) {\r\n      depsMap.set(key, (dep = createDep(() => depsMap!.delete(key))))\r\n    }\r\n    trackEffect(\r\n      activeEffect,\r\n      dep,\r\n      __DEV__\r\n        ? {\r\n            target,\r\n            type,\r\n            key,\r\n          }\r\n        : void 0,\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * Finds all deps associated with the target (or a specific property) and\r\n * triggers the effects stored within.\r\n *\r\n * @param target - The reactive object.\r\n * @param type - Defines the type of the operation that needs to trigger effects.\r\n * @param key - Can be used to target a specific reactive property in the target object.\r\n */\r\nexport function trigger(\r\n  target: object,\r\n  type: TriggerOpTypes,\r\n  key?: unknown,\r\n  newValue?: unknown,\r\n  oldValue?: unknown,\r\n  oldTarget?: Map<unknown, unknown> | Set<unknown>,\r\n) {\r\n  const depsMap = targetMap.get(target)\r\n  if (!depsMap) {\r\n    // never been tracked\r\n    return\r\n  }\r\n\r\n  let deps: (Dep | undefined)[] = []\r\n  /**\r\n   * map和set对象中clear方法调用，所有元素都被清空了，所有元素对应的副作用都需要执行\r\n   */\r\n  if (type === TriggerOpTypes.CLEAR) {\r\n    // collection being cleared\r\n    // trigger all effects for target\r\n    deps = [...depsMap.values()]\r\n  } else if (key === 'length' && isArray(target)) {\r\n    /**\r\n     * for in 会在ownKeys方法中track收集length的依赖；\r\n     * for of内部会先获取length，所以会在get中收集length的依赖\r\n     * \r\n     * 这样的场景：直接改变数组的长度，除了触发length（for in/for of）的依赖副作用之外，还有超出设置长度的那些元素也会触发依赖（相当于超出长度的那些元素被删除了）\r\n     * const observed = reactive([1,2,3]);\r\n      effect(() => {\r\n          for(let key of observed) {\r\n              console.log(key)\r\n          }\r\n      });\r\n      setTimeout(() => {\r\n          observed.length = 2;\r\n      }, 1000)\r\n     */\r\n    const newLength = Number(newValue)\r\n    depsMap.forEach((dep, key) => {\r\n      if (key === 'length' || (!isSymbol(key) && key >= newLength)) {\r\n        deps.push(dep)\r\n      }\r\n    })\r\n  } else {\r\n    // schedule runs for SET | ADD | DELETE\r\n    if (key !== void 0) {\r\n      deps.push(depsMap.get(key))\r\n    }\r\n\r\n    // also run for iteration key on ADD | DELETE | Map.SET\r\n    switch (type) {\r\n      /**\r\n       * 对象添加属性、数组添加元素、Map的set方法执行、Set的add方法执行\r\n       */\r\n      case TriggerOpTypes.ADD:\r\n        if (!isArray(target)) {\r\n          /**\r\n           * ITERATE_KEY：\r\n           *（1）普通对象的for in \r\n           * (2) Map和Set的size\r\n           * (3) Map和Set的forEach\r\n           * (4) Set和Map的迭代器（values/entries)\r\n           * \r\n           * MAP_KEY_ITERATE_KEY：\r\n           * （1）Map的迭代器方法keys\r\n           */\r\n          deps.push(depsMap.get(ITERATE_KEY))\r\n          if (isMap(target)) {\r\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\r\n          }\r\n        } else if (isIntegerKey(key)) {\r\n          // 如果是数组，那么对应还需要触发length\r\n          // new index added to array -> length changes\r\n          deps.push(depsMap.get('length'))\r\n        }\r\n        break\r\n      case TriggerOpTypes.DELETE:\r\n        if (!isArray(target)) {\r\n          /**\r\n           * 原理同上\r\n           * 不会去delete 一个数组的元素\r\n           */\r\n          deps.push(depsMap.get(ITERATE_KEY))\r\n          if (isMap(target)) {\r\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\r\n          }\r\n        }\r\n        break\r\n      case TriggerOpTypes.SET:\r\n        /**\r\n         * 如果是Map，修改值的话，还需要触发对应的迭代器（values/entries/forEach）\r\n         */\r\n        if (isMap(target)) {\r\n          deps.push(depsMap.get(ITERATE_KEY))\r\n        }\r\n        break\r\n    }\r\n  }\r\n\r\n  pauseScheduling()\r\n  for (const dep of deps) {\r\n    if (dep) {\r\n      triggerEffects(\r\n        dep,\r\n        DirtyLevels.Dirty,\r\n        __DEV__\r\n          ? {\r\n              target,\r\n              type,\r\n              key,\r\n              newValue,\r\n              oldValue,\r\n              oldTarget,\r\n            }\r\n          : void 0,\r\n      )\r\n    }\r\n  }\r\n  resetScheduling()\r\n}\r\n\r\nexport function getDepFromReactive(object: any, key: string | number | symbol) {\r\n  return targetMap.get(object)?.get(key)\r\n}\r\n","import {\r\n  type Target,\r\n  isReadonly,\r\n  isShallow,\r\n  reactive,\r\n  reactiveMap,\r\n  readonly,\r\n  readonlyMap,\r\n  shallowReactiveMap,\r\n  shallowReadonlyMap,\r\n  toRaw,\r\n} from './reactive'\r\nimport { ReactiveFlags, TrackOpTypes, TriggerOpTypes } from './constants'\r\nimport {\r\n  pauseScheduling,\r\n  pauseTracking,\r\n  resetScheduling,\r\n  resetTracking,\r\n} from './effect'\r\nimport { ITERATE_KEY, track, trigger } from './reactiveEffect'\r\nimport {\r\n  hasChanged,\r\n  hasOwn,\r\n  isArray,\r\n  isIntegerKey,\r\n  isObject,\r\n  isSymbol,\r\n  makeMap,\r\n} from '@vue/shared'\r\nimport { isRef } from './ref'\r\nimport { warn } from './warning'\r\n\r\nconst isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`)\r\n\r\nconst builtInSymbols = new Set(\r\n  /*#__PURE__*/\r\n  Object.getOwnPropertyNames(Symbol)\r\n    /**\r\n     * 在iOS10.x中，Object.getOwnPropertyNames(Symbol)可以枚举\"arguments\"和\"caller\"，但是Symbol对象上访问\r\n     * 这些属性会导致TypeError，因为Symbol是一个严格模式函数\r\n     */\r\n    .filter(key => key !== 'arguments' && key !== 'caller')\r\n    .map(key => (Symbol as any)[key])\r\n    .filter(isSymbol),\r\n)\r\n\r\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations()\r\n\r\nfunction createArrayInstrumentations() {\r\n  const instrumentations: Record<string, Function> = {}\r\n  // instrument identity-sensitive Array methods to account for possible reactive\r\n  // values\r\n  ;(['includes', 'indexOf', 'lastIndexOf'] as const).forEach(key => {\r\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\r\n      const arr = toRaw(this) as any\r\n      for (let i = 0, l = this.length; i < l; i++) {\r\n        track(arr, TrackOpTypes.GET, i + '')\r\n      }\r\n      // we run the method using the original args first (which may be reactive)\r\n      const res = arr[key](...args)\r\n      if (res === -1 || res === false) {\r\n        // if that didn't work, run it again using raw values.\r\n        return arr[key](...args.map(toRaw))\r\n      } else {\r\n        return res\r\n      }\r\n    }\r\n  })\r\n  // instrument length-altering mutation methods to avoid length being tracked\r\n  // which leads to infinite loops in some cases (#2137)\r\n  ;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach(key => {\r\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\r\n      pauseTracking()\r\n      pauseScheduling()\r\n      const res = (toRaw(this) as any)[key].apply(this, args)\r\n      resetScheduling()\r\n      resetTracking()\r\n      return res\r\n    }\r\n  })\r\n  return instrumentations\r\n}\r\n\r\nfunction hasOwnProperty(this: object, key: string) {\r\n  const obj = toRaw(this)\r\n  track(obj, TrackOpTypes.HAS, key)\r\n  return obj.hasOwnProperty(key)\r\n}\r\n\r\nclass BaseReactiveHandler implements ProxyHandler<Target> {\r\n  constructor(\r\n    protected readonly _isReadonly = false,\r\n    protected readonly _shallow = false,\r\n  ) {}\r\n\r\n  // 获取对象的属性值\r\n  get(target: Target, key: string | symbol, receiver: object) {\r\n    const isReadonly = this._isReadonly,\r\n      shallow = this._shallow\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return !isReadonly\r\n    } else if (key === ReactiveFlags.IS_READONLY) {\r\n      return isReadonly\r\n    } else if (key === ReactiveFlags.IS_SHALLOW) {\r\n      return shallow\r\n    } else if (key === ReactiveFlags.RAW) {\r\n      // 判断receiver是否是target的代理对象，或者receiver和target被同一个对象代理了\r\n      // 获取原始对象\r\n      /**\r\n       * 如下情况：\r\n       * const { reactive, effect } = Vue;\r\n        const o1 = {s: 'c'};\r\n        const o2 = {id: 1, s: 'p'};\r\n        const c = reactive(o1);\r\n        const p = reactive(o2);\r\n        Object.setPrototypeOf(c, p);\r\n        effect(() => {\r\n            console.log(c.id);\r\n        }) \r\n        获取c.id的时候第一次进入child的get方法，发现没有id属性，然后就会进入parent的get方法，这个时候target是o2，但是receiver是c\r\n       */\r\n      if (\r\n        receiver ===\r\n          (isReadonly\r\n            ? shallow\r\n              ? shallowReadonlyMap\r\n              : readonlyMap\r\n            : shallow\r\n              ? shallowReactiveMap\r\n              : reactiveMap\r\n          ).get(target) ||\r\n        // receiver is not the reactive proxy, but has the same prototype\r\n        // this means the reciever is a user proxy of the reactive proxy\r\n        Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)\r\n      ) {\r\n        return target\r\n      }\r\n      // early return undefined\r\n      return\r\n    }\r\n\r\n    const targetIsArray = isArray(target)\r\n\r\n    if (!isReadonly) {\r\n      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n        return Reflect.get(arrayInstrumentations, key, receiver)\r\n      }\r\n      if (key === 'hasOwnProperty') {\r\n        return hasOwnProperty\r\n      }\r\n    }\r\n    /**\r\n     * target是原对象，\r\n     * receiver是代理对象\r\n     * 这里之所以使用Reflect\r\n     * const obj = {\r\n     *  id: 1,\r\n     *  get uuid () {\r\n     *    return this.id\r\n     * }\r\n     * }\r\n     * const proxy = new Proxy(obj)\r\n     * 方法proxy.uuid时，this始终指向代理对象\r\n     */\r\n    const res = Reflect.get(target, key, receiver)\r\n\r\n    // 是否是哪些不被追踪的属性\r\n    // 防止数组的[Symbol.iterator]被收集，for of遍历的时候会先调用[Symbol.iterator]，然后再获取内部的length，所以[Symbol.iterator]被忽略，值收集length的依赖，防止一个副作用函数被收集两次\r\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\r\n      return res\r\n    }\r\n\r\n    // 只读对象不需要追踪依赖，对象的属性值是不会改变的，所以不需要追踪\r\n    if (!isReadonly) {\r\n      track(target, TrackOpTypes.GET, key)\r\n    }\r\n    // 如果是浅依赖的就直接返回，不需要再递归创建代理\r\n    if (shallow) {\r\n      return res\r\n    }\r\n    /**\r\n     * 所以即使props中传入给子组件的值是ref也能正确取值，返回的是ref的value值\r\n     */\r\n    if (isRef(res)) {\r\n      // ref unwrapping - skip unwrap for Array + integer key.\r\n      return targetIsArray && isIntegerKey(key) ? res : res.value\r\n    }\r\n\r\n    if (isObject(res)) {\r\n      // Convert returned value into a proxy as well. we do the isObject check\r\n      // here to avoid invalid value warning. Also need to lazy access readonly\r\n      // and reactive here to avoid circular dependency.\r\n      return isReadonly ? readonly(res) : reactive(res)\r\n    }\r\n\r\n    return res\r\n  }\r\n}\r\n\r\nclass MutableReactiveHandler extends BaseReactiveHandler {\r\n  constructor(shallow = false) {\r\n    super(false, shallow)\r\n  }\r\n\r\n  // 给对象添加属性值/或者给对象修改属性值\r\n  set(\r\n    target: object,\r\n    key: string | symbol,\r\n    value: unknown,\r\n    receiver: object,\r\n  ): boolean {\r\n    let oldValue = (target as any)[key]\r\n    /**\r\n     * 如果是浅层的，那么自然只有第一层，第二层都是原始对象了\r\n     */\r\n    if (!this._shallow) {\r\n      // 原来key对应的值是响应式的，且只可读，则不允许设置\r\n      /**\r\n       * value可能本身就是oldvalue的代理对象，所以需要先把value原始的对象取出来，这样，再hasChanged比较的时候就不会有问题\r\n       * 这种情况下，hasChanged应该是false，如果不这样操作，hasChanged就会变成true，\r\n       * 反正在get方法的时候取出来会递归调用reactive，获取值的时候仍然是代理对象\r\n       * let obj = {city: 'gz', address: 'panyu'};\r\n        const d = reactive(obj);\r\n        const person = reactive({id: 1, name: 'ff', d: obj});\r\n        effect(() => {\r\n            console.log(person.d) \r\n        })\r\n        setTimeout(() => {\r\n            person.d = d; //不会触发以上的effect\r\n        }, 100)\r\n       * \r\n       * 如果oldValue是元素对象，value是oldValue的可读的对象，那说明value是不会被track/trigger，value根本不会被改变，不用担心trigger\r\n       * 如果是shallow，因为this._shallow已经是false，说明本身target创建的代理对象就是深度，而现在要给他复制shallowReactive，\r\n       * 虽然对应的是同一个代理对象，但是属性值仍然是改变了的\r\n       * let obj = {city: 'gz', address: 'panyu'};\r\n          const d = shallowReactive(obj);\r\n          const person = reactive({id: 1, name: 'ff', d: obj});\r\n          effect(() => {\r\n              console.log(person.d)\r\n          })\r\n          setTimeout(() => {\r\n              person.d = d; // 会再次触发以上的effect\r\n          }, 100)\r\n       * 这里还有一个原因就是为了防止数据污染，比如有两个响应对象p1,p2，将p2设置成p1的某个属性值，\r\n          const obj = {city: 'gz', address: 'panyu'};\r\n          const p1 = reactive(obj);\r\n          const p2 = reactive({});\r\n          p1['p2'] = p2;\r\n          effect(() => {\r\n              console.log(obj.p2.id)\r\n          });\r\n          console.log(p1.p2, obj.p2)\r\n          setTimeout(() => {\r\n              obj.p2.id = 11;\r\n          })\r\n          如果不经过这样的操作，那么obj.p2对应的就是p2响应对象，那么obj.p2.id改变的时候就会触发effect执行，\r\n          现在因为obj.p2是原始对象了，所以不会有这个数据污染问题\r\n          （把响应式数据设置到原始数据上的行为称为样式污染\r\n       */\r\n      const isOldValueReadonly = isReadonly(oldValue)\r\n      if (!isShallow(value) && !isReadonly(value)) {\r\n        oldValue = toRaw(oldValue)\r\n        value = toRaw(value)\r\n      }\r\n      // 如果对象的key值原来是ref，新的值不是ref，则将新的值赋值给原来key对应的值\r\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n        if (isOldValueReadonly) {\r\n          return false\r\n        } else {\r\n          oldValue.value = value\r\n          return true\r\n        }\r\n      }\r\n    } else {\r\n      // in shallow mode, objects are set as-is regardless of reactive or not\r\n    }\r\n\r\n    const hadKey =\r\n      isArray(target) && isIntegerKey(key)\r\n        ? Number(key) < target.length\r\n        : hasOwn(target, key)\r\n    const result = Reflect.set(target, key, value, receiver)\r\n    // don't trigger if target is something up in the prototype chain of original\r\n    if (target === toRaw(receiver)) {\r\n      if (!hadKey) {\r\n        // 如果是给对象新增加值，增加的值夜不是ref，则触发add\r\n        trigger(target, TriggerOpTypes.ADD, key, value)\r\n      } else if (hasChanged(value, oldValue)) {\r\n        // 如果是修改原来的值，则触发set\r\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)\r\n      }\r\n    }\r\n    return result\r\n  }\r\n\r\n  // delete操作触发，比如 delete observed.foo\r\n  deleteProperty(target: object, key: string | symbol): boolean {\r\n    const hadKey = hasOwn(target, key)\r\n    const oldValue = (target as any)[key]\r\n    const result = Reflect.deleteProperty(target, key)\r\n    if (result && hadKey) {\r\n      // 存在这个key并且成功删除了，才会触发delete\r\n      trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\r\n    }\r\n    return result\r\n  }\r\n\r\n  // 'foo' in observed 触发的就是has函数\r\n  has(target: object, key: string | symbol): boolean {\r\n    const result = Reflect.has(target, key)\r\n    /**\r\n     * 这里为什么要排除symbol函数呢\r\n     * 因为在for of循环遍历数组的时候，除了会触发length，还会触发symbol迭代器的方法，就会重复执行副作用函数\r\n     * 所以for of循序只记录一个length的track就可以了\r\n     */\r\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n      track(target, TrackOpTypes.HAS, key)\r\n    }\r\n    return result\r\n  }\r\n  /**\r\n   * （1）for in 触发的就是ownKeys函数\r\n   * （2）Object.keys(proxy)\r\n   */\r\n  ownKeys(target: object): (string | symbol)[] {\r\n    // for in和 in会进入到这个方法，如果是数组，只要记录length改变就行了，\r\n    /**\r\n     * 比如一个副作用函数内for in一个数组，那么后面这个数组长度改变了，都应该触发这个副作用函数的执行\r\n     * 如果是for in一个对象，那么这个对象的属性添加了或者减少了，都应该触发ITERATE_KEY，所以记录的也是ITERATE_KEY\r\n     */\r\n    track(\r\n      target,\r\n      TrackOpTypes.ITERATE,\r\n      isArray(target) ? 'length' : ITERATE_KEY,\r\n    )\r\n    return Reflect.ownKeys(target)\r\n  }\r\n}\r\n\r\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\r\n  constructor(shallow = false) {\r\n    super(true, shallow)\r\n  }\r\n\r\n  set(target: object, key: string | symbol) {\r\n    if (__DEV__) {\r\n      warn(\r\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\r\n        target,\r\n      )\r\n    }\r\n    return true\r\n  }\r\n\r\n  deleteProperty(target: object, key: string | symbol) {\r\n    if (__DEV__) {\r\n      warn(\r\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\r\n        target,\r\n      )\r\n    }\r\n    return true\r\n  }\r\n}\r\n\r\nexport const mutableHandlers: ProxyHandler<object> =\r\n  /*#__PURE__*/ new MutableReactiveHandler()\r\n\r\nexport const readonlyHandlers: ProxyHandler<object> =\r\n  /*#__PURE__*/ new ReadonlyReactiveHandler()\r\n\r\nexport const shallowReactiveHandlers = /*#__PURE__*/ new MutableReactiveHandler(\r\n  true,\r\n)\r\n\r\n// props handlers特殊之处在于它不应该解包顶层refs，但它仍然保持普通只读对象的响应性\r\nexport const shallowReadonlyHandlers =\r\n  /*#__PURE__*/ new ReadonlyReactiveHandler(true)\r\n","import { toRaw, toReactive, toReadonly } from './reactive'\r\nimport {\r\n  ITERATE_KEY,\r\n  MAP_KEY_ITERATE_KEY,\r\n  track,\r\n  trigger,\r\n} from './reactiveEffect'\r\nimport { ReactiveFlags, TrackOpTypes, TriggerOpTypes } from './constants'\r\nimport { capitalize, hasChanged, hasOwn, isMap, toRawType } from '@vue/shared'\r\n\r\ntype CollectionTypes = IterableCollections | WeakCollections\r\n\r\ntype IterableCollections = Map<any, any> | Set<any>\r\ntype WeakCollections = WeakMap<any, any> | WeakSet<any>\r\ntype MapTypes = Map<any, any> | WeakMap<any, any>\r\ntype SetTypes = Set<any> | WeakSet<any>\r\n\r\nconst toShallow = <T extends unknown>(value: T): T => value\r\n\r\nconst getProto = <T extends CollectionTypes>(v: T): any =>\r\n  Reflect.getPrototypeOf(v)\r\n\r\nfunction get(\r\n  target: MapTypes,\r\n  key: unknown,\r\n  isReadonly = false,\r\n  isShallow = false,\r\n) {\r\n  // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n  // of the value\r\n  /**\r\n   * （1）关于rawTarget和target不相等的场景：\r\n   * const map = reactive(new Map())\r\n    const roMap = readonly(map)\r\n      map.set(4, { foo: 'bar' })\r\n      effect(() => {\r\n          const roMapItem = roMap.get(5);\r\n          console.log(roMapItem)\r\n      })\r\n      setTimeout(() => {\r\n          map.set(5, 'hello')\r\n      }, 1000)\r\n      解释：readonly一个reactive响应对象，虽然roMap是readonly非响应式的，但是因为原始对象是响应式的，所以roMapItem依然是响应式的，很少会这样使用\r\n\r\n      （2）关于key和rawKey不相等的场景：key是响应式对象,rawkey是原始对象\r\n      如果map代理对象中本来包含了key响应对象，那么map.get(key)收集了key和rawKey的依赖关系，set(key, value)的时候会触发key的依赖；\r\n      如果map代理对象中没有包括key的响应对象，那么set(key, value)会触发rawKey的依赖\r\n   */\r\n  target = (target as any)[ReactiveFlags.RAW]\r\n  const rawTarget = toRaw(target)\r\n  const rawKey = toRaw(key)\r\n  if (!isReadonly) {\r\n    if (hasChanged(key, rawKey)) {\r\n      // 如果key也是响应式的对象，那么也要track key\r\n      track(rawTarget, TrackOpTypes.GET, key)\r\n    }\r\n    track(rawTarget, TrackOpTypes.GET, rawKey)\r\n  }\r\n  const { has } = getProto(rawTarget)\r\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\r\n  if (has.call(rawTarget, key)) {\r\n    return wrap(target.get(key))\r\n  } else if (has.call(rawTarget, rawKey)) {\r\n    return wrap(target.get(rawKey))\r\n  } else if (target !== rawTarget) {\r\n    // #3602 readonly(reactive(Map))\r\n    // ensure that the nested reactive `Map` can do tracking for itself\r\n    target.get(key)\r\n  }\r\n}\r\n\r\nfunction has(this: CollectionTypes, key: unknown, isReadonly = false): boolean {\r\n  const target = (this as any)[ReactiveFlags.RAW]\r\n  const rawTarget = toRaw(target)\r\n  const rawKey = toRaw(key)\r\n  if (!isReadonly) {\r\n    if (hasChanged(key, rawKey)) {\r\n      track(rawTarget, TrackOpTypes.HAS, key)\r\n    }\r\n    track(rawTarget, TrackOpTypes.HAS, rawKey)\r\n  }\r\n  return key === rawKey\r\n    ? target.has(key)\r\n    : target.has(key) || target.has(rawKey)\r\n}\r\n\r\nfunction size(target: IterableCollections, isReadonly = false) {\r\n  target = (target as any)[ReactiveFlags.RAW]\r\n  !isReadonly && track(toRaw(target), TrackOpTypes.ITERATE, ITERATE_KEY)\r\n  return Reflect.get(target, 'size', target)\r\n}\r\n\r\nfunction add(this: SetTypes, value: unknown) {\r\n  value = toRaw(value)\r\n  const target = toRaw(this)\r\n  const proto = getProto(target)\r\n  const hadKey = proto.has.call(target, value)\r\n  if (!hadKey) {\r\n    target.add(value)\r\n    trigger(target, TriggerOpTypes.ADD, value, value)\r\n  }\r\n  return this\r\n}\r\n\r\nfunction set(this: MapTypes, key: unknown, value: unknown) {\r\n  // 这里设置需要用原始对象\r\n  value = toRaw(value)\r\n  const target = toRaw(this)\r\n  const { has, get } = getProto(target)\r\n\r\n  let hadKey = has.call(target, key)\r\n  if (!hadKey) {\r\n    key = toRaw(key)\r\n    hadKey = has.call(target, key)\r\n  } else if (__DEV__) {\r\n    // key是响应式对象，并且target中包含key的原始对象\r\n    checkIdentityKeys(target, has, key)\r\n  }\r\n\r\n  const oldValue = get.call(target, key)\r\n  target.set(key, value)\r\n  if (!hadKey) {\r\n    trigger(target, TriggerOpTypes.ADD, key, value)\r\n  } else if (hasChanged(value, oldValue)) {\r\n    trigger(target, TriggerOpTypes.SET, key, value, oldValue)\r\n  }\r\n  return this\r\n}\r\n\r\nfunction deleteEntry(this: CollectionTypes, key: unknown) {\r\n  const target = toRaw(this)\r\n  const { has, get } = getProto(target)\r\n  let hadKey = has.call(target, key)\r\n  if (!hadKey) {\r\n    key = toRaw(key)\r\n    hadKey = has.call(target, key)\r\n  } else if (__DEV__) {\r\n    checkIdentityKeys(target, has, key)\r\n  }\r\n\r\n  const oldValue = get ? get.call(target, key) : undefined\r\n  // forward the operation before queueing reactions\r\n  const result = target.delete(key)\r\n  if (hadKey) {\r\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction clear(this: IterableCollections) {\r\n  const target = toRaw(this)\r\n  const hadItems = target.size !== 0\r\n  const oldTarget = __DEV__\r\n    ? isMap(target)\r\n      ? new Map(target)\r\n      : new Set(target)\r\n    : undefined\r\n  // forward the operation before queueing reactions\r\n  const result = target.clear()\r\n  if (hadItems) {\r\n    trigger(target, TriggerOpTypes.CLEAR, undefined, undefined, oldTarget)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction createForEach(isReadonly: boolean, isShallow: boolean) {\r\n  return function forEach(\r\n    this: IterableCollections,\r\n    callback: Function,\r\n    thisArg?: unknown,\r\n  ) {\r\n    const observed = this as any\r\n    const target = observed[ReactiveFlags.RAW]\r\n    const rawTarget = toRaw(target)\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\r\n    !isReadonly && track(rawTarget, TrackOpTypes.ITERATE, ITERATE_KEY)\r\n    return target.forEach((value: unknown, key: unknown) => {\r\n      // important: make sure the callback is\r\n      // 1. invoked with the reactive map as `this` and 3rd arg\r\n      // 2. the value received should be a corresponding reactive/readonly.\r\n      return callback.call(thisArg, wrap(value), wrap(key), observed)\r\n    })\r\n  }\r\n}\r\n\r\ninterface Iterable {\r\n  [Symbol.iterator](): Iterator\r\n}\r\n\r\ninterface Iterator {\r\n  next(value?: any): IterationResult\r\n}\r\n\r\ninterface IterationResult {\r\n  value: any\r\n  done: boolean\r\n}\r\n\r\nfunction createIterableMethod(\r\n  method: string | symbol,\r\n  isReadonly: boolean,\r\n  isShallow: boolean,\r\n) {\r\n  return function (\r\n    this: IterableCollections,\r\n    ...args: unknown[]\r\n  ): Iterable & Iterator {\r\n    const target = (this as any)[ReactiveFlags.RAW]\r\n    const rawTarget = toRaw(target)\r\n    const targetIsMap = isMap(rawTarget)\r\n    const isPair =\r\n      method === 'entries' || (method === Symbol.iterator && targetIsMap)\r\n    const isKeyOnly = method === 'keys' && targetIsMap\r\n    const innerIterator = target[method](...args)\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\r\n    !isReadonly &&\r\n      track(\r\n        rawTarget,\r\n        TrackOpTypes.ITERATE,\r\n        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY,\r\n      )\r\n    // return a wrapped iterator which returns observed versions of the\r\n    // values emitted from the real iterator\r\n    return {\r\n      // iterator protocol\r\n      next() {\r\n        const { value, done } = innerIterator.next()\r\n        return done\r\n          ? { value, done }\r\n          : {\r\n              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n              done,\r\n            }\r\n      },\r\n      // iterable protocol\r\n      [Symbol.iterator]() {\r\n        return this\r\n      },\r\n    }\r\n  }\r\n}\r\n\r\nfunction createReadonlyMethod(type: TriggerOpTypes): Function {\r\n  return function (this: CollectionTypes, ...args: unknown[]) {\r\n    if (__DEV__) {\r\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``\r\n      console.warn(\r\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\r\n        toRaw(this),\r\n      )\r\n    }\r\n    return type === TriggerOpTypes.DELETE\r\n      ? false\r\n      : type === TriggerOpTypes.CLEAR\r\n        ? undefined\r\n        : this\r\n  }\r\n}\r\n\r\nfunction createInstrumentations() {\r\n  const mutableInstrumentations: Record<string, Function | number> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key)\r\n    },\r\n    //获取size先track，从原始对象中获取size\r\n    get size() {\r\n      return size(this as unknown as IterableCollections)\r\n    },\r\n    has,\r\n    add,\r\n    set,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false),\r\n  }\r\n\r\n  const shallowInstrumentations: Record<string, Function | number> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key, false, true)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections)\r\n    },\r\n    has,\r\n    add,\r\n    set,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true),\r\n  }\r\n\r\n  const readonlyInstrumentations: Record<string, Function | number> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key, true)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections, true)\r\n    },\r\n    has(this: MapTypes, key: unknown) {\r\n      return has.call(this, key, true)\r\n    },\r\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\r\n    set: createReadonlyMethod(TriggerOpTypes.SET),\r\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\r\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\r\n    forEach: createForEach(true, false),\r\n  }\r\n\r\n  const shallowReadonlyInstrumentations: Record<string, Function | number> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key, true, true)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections, true)\r\n    },\r\n    has(this: MapTypes, key: unknown) {\r\n      return has.call(this, key, true)\r\n    },\r\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\r\n    set: createReadonlyMethod(TriggerOpTypes.SET),\r\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\r\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\r\n    forEach: createForEach(true, true),\r\n  }\r\n\r\n  const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator]\r\n  iteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      false,\r\n      false,\r\n    )\r\n    readonlyInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      true,\r\n      false,\r\n    )\r\n    shallowInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      false,\r\n      true,\r\n    )\r\n    shallowReadonlyInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      true,\r\n      true,\r\n    )\r\n  })\r\n\r\n  return [\r\n    mutableInstrumentations,\r\n    readonlyInstrumentations,\r\n    shallowInstrumentations,\r\n    shallowReadonlyInstrumentations,\r\n  ]\r\n}\r\n\r\nconst [\r\n  mutableInstrumentations,\r\n  readonlyInstrumentations,\r\n  shallowInstrumentations,\r\n  shallowReadonlyInstrumentations,\r\n] = /* #__PURE__*/ createInstrumentations()\r\n\r\nfunction createInstrumentationGetter(isReadonly: boolean, shallow: boolean) {\r\n  const instrumentations = shallow\r\n    ? isReadonly\r\n      ? shallowReadonlyInstrumentations\r\n      : shallowInstrumentations\r\n    : isReadonly\r\n      ? readonlyInstrumentations\r\n      : mutableInstrumentations\r\n\r\n  return (\r\n    target: CollectionTypes,\r\n    key: string | symbol,\r\n    receiver: CollectionTypes,\r\n  ) => {\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return !isReadonly\r\n    } else if (key === ReactiveFlags.IS_READONLY) {\r\n      return isReadonly\r\n    } else if (key === ReactiveFlags.RAW) {\r\n      return target\r\n    }\r\n\r\n    return Reflect.get(\r\n      hasOwn(instrumentations, key) && key in target\r\n        ? instrumentations\r\n        : target,\r\n      key,\r\n      receiver,\r\n    )\r\n  }\r\n}\r\n\r\nexport const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: /*#__PURE__*/ createInstrumentationGetter(false, false),\r\n}\r\n\r\nexport const shallowCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: /*#__PURE__*/ createInstrumentationGetter(false, true),\r\n}\r\n\r\nexport const readonlyCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: /*#__PURE__*/ createInstrumentationGetter(true, false),\r\n}\r\n\r\nexport const shallowReadonlyCollectionHandlers: ProxyHandler<CollectionTypes> =\r\n  {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true),\r\n  }\r\n\r\nfunction checkIdentityKeys(\r\n  target: CollectionTypes,\r\n  has: (key: unknown) => boolean,\r\n  key: unknown,\r\n) {\r\n  const rawKey = toRaw(key)\r\n  if (rawKey !== key && has.call(target, rawKey)) {\r\n    const type = toRawType(target)\r\n    console.warn(\r\n      `Reactive ${type} contains both the raw and reactive ` +\r\n        `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n        `which can lead to inconsistencies. ` +\r\n        `Avoid differentiating between the raw and reactive versions ` +\r\n        `of an object and only use the reactive version if possible.`,\r\n    )\r\n  }\r\n}\r\n","import { def, isObject, toRawType } from '@vue/shared'\r\nimport {\r\n  mutableHandlers,\r\n  readonlyHandlers,\r\n  shallowReactiveHandlers,\r\n  shallowReadonlyHandlers,\r\n} from './baseHandlers'\r\nimport {\r\n  mutableCollectionHandlers,\r\n  readonlyCollectionHandlers,\r\n  shallowCollectionHandlers,\r\n  shallowReadonlyCollectionHandlers,\r\n} from './collectionHandlers'\r\nimport type { RawSymbol, Ref, UnwrapRefSimple } from './ref'\r\nimport { ReactiveFlags } from './constants'\r\n\r\nexport interface Target {\r\n  [ReactiveFlags.SKIP]?: boolean\r\n  [ReactiveFlags.IS_REACTIVE]?: boolean\r\n  [ReactiveFlags.IS_READONLY]?: boolean\r\n  [ReactiveFlags.IS_SHALLOW]?: boolean\r\n  [ReactiveFlags.RAW]?: any\r\n}\r\n\r\nexport const reactiveMap = new WeakMap<Target, any>()\r\nexport const shallowReactiveMap = new WeakMap<Target, any>()\r\nexport const readonlyMap = new WeakMap<Target, any>()\r\nexport const shallowReadonlyMap = new WeakMap<Target, any>()\r\n\r\nenum TargetType {\r\n  INVALID = 0,\r\n  COMMON = 1,\r\n  COLLECTION = 2,\r\n}\r\n\r\nfunction targetTypeMap(rawType: string) {\r\n  switch (rawType) {\r\n    case 'Object':\r\n    case 'Array':\r\n      return TargetType.COMMON // 通用的类型\r\n    case 'Map':\r\n    case 'Set':\r\n    case 'WeakMap':\r\n    case 'WeakSet':\r\n      return TargetType.COLLECTION // set/map类型\r\n    default:\r\n      return TargetType.INVALID\r\n  }\r\n}\r\n\r\nfunction getTargetType(value: Target) {\r\n  // 有skip标志或者不能被扩展的就是无效的类型\r\n  return value[ReactiveFlags.SKIP] || !Object.isExtensible(value)\r\n    ? TargetType.INVALID\r\n    : targetTypeMap(toRawType(value))\r\n}\r\n\r\n// only unwrap nested ref\r\nexport type UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRefSimple<T>\r\n\r\n/**\r\n * Returns a reactive proxy of the object.\r\n *\r\n * The reactive conversion is \"deep\": it affects all nested properties. A\r\n * reactive object also deeply unwraps any properties that are refs while\r\n * maintaining reactivity.\r\n *\r\n * @example\r\n * ```js\r\n * const obj = reactive({ count: 0 })\r\n * ```\r\n *\r\n * @param target - The source object.\r\n * @see {@link https://vuejs.org/api/reactivity-core.html#reactive}\r\n */\r\nexport function reactive<T extends object>(target: T): UnwrapNestedRefs<T>\r\nexport function reactive(target: object) {\r\n  // if trying to observe a readonly proxy, return the readonly version.\r\n  // 如果创建的target本身就是reactive就直接返回\r\n  if (isReadonly(target)) {\r\n    return target\r\n  }\r\n  return createReactiveObject(\r\n    target,\r\n    false,\r\n    mutableHandlers,\r\n    mutableCollectionHandlers,\r\n    reactiveMap,\r\n  )\r\n}\r\n\r\nexport declare const ShallowReactiveMarker: unique symbol\r\n\r\nexport type ShallowReactive<T> = T & { [ShallowReactiveMarker]?: true }\r\n\r\n/**\r\n * Shallow version of {@link reactive()}.\r\n *\r\n * Unlike {@link reactive()}, there is no deep conversion: only root-level\r\n * properties are reactive for a shallow reactive object. Property values are\r\n * stored and exposed as-is - this also means properties with ref values will\r\n * not be automatically unwrapped.\r\n *\r\n * @example\r\n * ```js\r\n * const state = shallowReactive({\r\n *   foo: 1,\r\n *   nested: {\r\n *     bar: 2\r\n *   }\r\n * })\r\n *\r\n * // mutating state's own properties is reactive\r\n * state.foo++\r\n *\r\n * // ...but does not convert nested objects\r\n * isReactive(state.nested) // false\r\n *\r\n * // NOT reactive\r\n * state.nested.bar++\r\n * ```\r\n *\r\n * @param target - The source object.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#shallowreactive}\r\n */\r\nexport function shallowReactive<T extends object>(\r\n  target: T,\r\n): ShallowReactive<T> {\r\n  return createReactiveObject(\r\n    target,\r\n    false,\r\n    shallowReactiveHandlers,\r\n    shallowCollectionHandlers,\r\n    shallowReactiveMap,\r\n  )\r\n}\r\n\r\ntype Primitive = string | number | boolean | bigint | symbol | undefined | null\r\ntype Builtin = Primitive | Function | Date | Error | RegExp\r\nexport type DeepReadonly<T> = T extends Builtin\r\n  ? T\r\n  : T extends Map<infer K, infer V>\r\n    ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\r\n    : T extends ReadonlyMap<infer K, infer V>\r\n      ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\r\n      : T extends WeakMap<infer K, infer V>\r\n        ? WeakMap<DeepReadonly<K>, DeepReadonly<V>>\r\n        : T extends Set<infer U>\r\n          ? ReadonlySet<DeepReadonly<U>>\r\n          : T extends ReadonlySet<infer U>\r\n            ? ReadonlySet<DeepReadonly<U>>\r\n            : T extends WeakSet<infer U>\r\n              ? WeakSet<DeepReadonly<U>>\r\n              : T extends Promise<infer U>\r\n                ? Promise<DeepReadonly<U>>\r\n                : T extends Ref<infer U>\r\n                  ? Readonly<Ref<DeepReadonly<U>>>\r\n                  : T extends {}\r\n                    ? { readonly [K in keyof T]: DeepReadonly<T[K]> }\r\n                    : Readonly<T>\r\n\r\n/**\r\n * Takes an object (reactive or plain) or a ref and returns a readonly proxy to\r\n * the original.\r\n *\r\n * A readonly proxy is deep: any nested property accessed will be readonly as\r\n * well. It also has the same ref-unwrapping behavior as {@link reactive()},\r\n * except the unwrapped values will also be made readonly.\r\n *\r\n * @example\r\n * ```js\r\n * const original = reactive({ count: 0 })\r\n *\r\n * const copy = readonly(original)\r\n *\r\n * watchEffect(() => {\r\n *   // works for reactivity tracking\r\n *   console.log(copy.count)\r\n * })\r\n *\r\n * // mutating original will trigger watchers relying on the copy\r\n * original.count++\r\n *\r\n * // mutating the copy will fail and result in a warning\r\n * copy.count++ // warning!\r\n * ```\r\n *\r\n * @param target - The source object.\r\n * @see {@link https://vuejs.org/api/reactivity-core.html#readonly}\r\n */\r\nexport function readonly<T extends object>(\r\n  target: T,\r\n): DeepReadonly<UnwrapNestedRefs<T>> {\r\n  return createReactiveObject(\r\n    target,\r\n    true,\r\n    readonlyHandlers,\r\n    readonlyCollectionHandlers,\r\n    readonlyMap,\r\n  )\r\n}\r\n\r\n/**\r\n * Shallow version of {@link readonly()}.\r\n *\r\n * Unlike {@link readonly()}, there is no deep conversion: only root-level\r\n * properties are made readonly. Property values are stored and exposed as-is -\r\n * this also means properties with ref values will not be automatically\r\n * unwrapped.\r\n *\r\n * @example\r\n * ```js\r\n * const state = shallowReadonly({\r\n *   foo: 1,\r\n *   nested: {\r\n *     bar: 2\r\n *   }\r\n * })\r\n *\r\n * // mutating state's own properties will fail\r\n * state.foo++\r\n *\r\n * // ...but works on nested objects\r\n * isReadonly(state.nested) // false\r\n *\r\n * // works\r\n * state.nested.bar++\r\n * ```\r\n *\r\n * @param target - The source object.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#shallowreadonly}\r\n */\r\nexport function shallowReadonly<T extends object>(target: T): Readonly<T> {\r\n  return createReactiveObject(\r\n    target,\r\n    true,\r\n    shallowReadonlyHandlers,\r\n    shallowReadonlyCollectionHandlers,\r\n    shallowReadonlyMap,\r\n  )\r\n}\r\n\r\nfunction createReactiveObject(\r\n  target: Target,\r\n  isReadonly: boolean,\r\n  baseHandlers: ProxyHandler<any>,\r\n  collectionHandlers: ProxyHandler<any>,\r\n  proxyMap: WeakMap<Target, any>,\r\n) {\r\n  // 不是对象就直接返回\r\n  if (!isObject(target)) {\r\n    if (__DEV__) {\r\n      console.warn(`value cannot be made reactive: ${String(target)}`)\r\n    }\r\n    return target\r\n  }\r\n  // target is already a Proxy, return it.\r\n  // exception: calling readonly() on a reactive object\r\n  // 如果已经是一个代理对象，并且不是只读的响应式对象，直接返回\r\n  if (\r\n    target[ReactiveFlags.RAW] &&\r\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\r\n  ) {\r\n    return target\r\n  }\r\n  // target already has corresponding Proxy\r\n  const existingProxy = proxyMap.get(target)\r\n  if (existingProxy) {\r\n    return existingProxy\r\n  }\r\n  // only specific value types can be observed.\r\n  const targetType = getTargetType(target)\r\n  if (targetType === TargetType.INVALID) {\r\n    return target\r\n  }\r\n  // 创建代理\r\n  // collectionHandlers重写的是set/map对象，数组和普通对象就是走baseHandlers\r\n  const proxy = new Proxy(\r\n    target,\r\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers,\r\n  )\r\n  // 创建的代理对象都放到proxyMap中记录\r\n  proxyMap.set(target, proxy)\r\n  return proxy\r\n}\r\n\r\n/**\r\n * Checks if an object is a proxy created by {@link reactive()} or\r\n * {@link shallowReactive()} (or {@link ref()} in some cases).\r\n *\r\n * @example\r\n * ```js\r\n * isReactive(reactive({}))            // => true\r\n * isReactive(readonly(reactive({})))  // => true\r\n * isReactive(ref({}).value)           // => true\r\n * isReactive(readonly(ref({})).value) // => true\r\n * isReactive(ref(true))               // => false\r\n * isReactive(shallowRef({}).value)    // => false\r\n * isReactive(shallowReactive({}))     // => true\r\n * ```\r\n *\r\n * @param value - The value to check.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#isreactive}\r\n */\r\nexport function isReactive(value: unknown): boolean {\r\n  if (isReadonly(value)) {\r\n    return isReactive((value as Target)[ReactiveFlags.RAW])\r\n  }\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_REACTIVE])\r\n}\r\n\r\n/**\r\n * Checks whether the passed value is a readonly object. The properties of a\r\n * readonly object can change, but they can't be assigned directly via the\r\n * passed object.\r\n *\r\n * The proxies created by {@link readonly()} and {@link shallowReadonly()} are\r\n * both considered readonly, as is a computed ref without a set function.\r\n *\r\n * @param value - The value to check.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#isreadonly}\r\n */\r\nexport function isReadonly(value: unknown): boolean {\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_READONLY])\r\n}\r\n\r\nexport function isShallow(value: unknown): boolean {\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_SHALLOW])\r\n}\r\n\r\n/**\r\n * Checks if an object is a proxy created by {@link reactive},\r\n * {@link readonly}, {@link shallowReactive} or {@link shallowReadonly()}.\r\n *\r\n * @param value - The value to check.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#isproxy}\r\n */\r\nexport function isProxy(value: unknown): boolean {\r\n  return isReactive(value) || isReadonly(value)\r\n}\r\n\r\n/**\r\n * Returns the raw, original object of a Vue-created proxy.\r\n *\r\n * `toRaw()` can return the original object from proxies created by\r\n * {@link reactive()}, {@link readonly()}, {@link shallowReactive()} or\r\n * {@link shallowReadonly()}.\r\n *\r\n * This is an escape hatch that can be used to temporarily read without\r\n * incurring proxy access / tracking overhead or write without triggering\r\n * changes. It is **not** recommended to hold a persistent reference to the\r\n * original object. Use with caution.\r\n *\r\n * @example\r\n * ```js\r\n * const foo = {}\r\n * const reactiveFoo = reactive(foo)\r\n *\r\n * console.log(toRaw(reactiveFoo) === foo) // true\r\n * ```\r\n *\r\n * @param observed - The object for which the \"raw\" value is requested.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#toraw}\r\n */\r\nexport function toRaw<T>(observed: T): T {\r\n  const raw = observed && (observed as Target)[ReactiveFlags.RAW]\r\n  return raw ? toRaw(raw) : observed\r\n}\r\n\r\nexport type Raw<T> = T & { [RawSymbol]?: true }\r\n\r\n/**\r\n * Marks an object so that it will never be converted to a proxy. Returns the\r\n * object itself.\r\n *\r\n * @example\r\n * ```js\r\n * const foo = markRaw({})\r\n * console.log(isReactive(reactive(foo))) // false\r\n *\r\n * // also works when nested inside other reactive objects\r\n * const bar = reactive({ foo })\r\n * console.log(isReactive(bar.foo)) // false\r\n * ```\r\n *\r\n * **Warning:** `markRaw()` together with the shallow APIs such as\r\n * {@link shallowReactive()} allow you to selectively opt-out of the default\r\n * deep reactive/readonly conversion and embed raw, non-proxied objects in your\r\n * state graph.\r\n *\r\n * @param value - The object to be marked as \"raw\".\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#markraw}\r\n */\r\nexport function markRaw<T extends object>(value: T): Raw<T> {\r\n  def(value, ReactiveFlags.SKIP, true)\r\n  return value\r\n}\r\n\r\n/**\r\n * Returns a reactive proxy of the given value (if possible).\r\n *\r\n * If the given value is not an object, the original value itself is returned.\r\n *\r\n * @param value - The value for which a reactive proxy shall be created.\r\n */\r\nexport const toReactive = <T extends unknown>(value: T): T =>\r\n  isObject(value) ? reactive(value) : value\r\n\r\n/**\r\n * Returns a readonly proxy of the given value (if possible).\r\n *\r\n * If the given value is not an object, the original value itself is returned.\r\n *\r\n * @param value - The value for which a readonly proxy shall be created.\r\n */\r\nexport const toReadonly = <T extends unknown>(value: T): T =>\r\n  isObject(value) ? readonly(value) : value\r\n","import { type DebuggerOptions, ReactiveEffect, scheduleEffects } from './effect'\r\nimport { type Ref, trackRefValue, triggerRefValue } from './ref'\r\nimport { NOOP, hasChanged, isFunction } from '@vue/shared'\r\nimport { toRaw } from './reactive'\r\nimport type { Dep } from './dep'\r\nimport { DirtyLevels, ReactiveFlags } from './constants'\r\n\r\ndeclare const ComputedRefSymbol: unique symbol\r\n\r\nexport interface ComputedRef<T = any> extends WritableComputedRef<T> {\r\n  readonly value: T\r\n  [ComputedRefSymbol]: true\r\n}\r\n\r\nexport interface WritableComputedRef<T> extends Ref<T> {\r\n  readonly effect: ReactiveEffect<T>\r\n}\r\n\r\nexport type ComputedGetter<T> = (oldValue?: T) => T\r\nexport type ComputedSetter<T> = (newValue: T) => void\r\n\r\nexport interface WritableComputedOptions<T> {\r\n  get: ComputedGetter<T>\r\n  set: ComputedSetter<T>\r\n}\r\n\r\nexport class ComputedRefImpl<T> {\r\n  public dep?: Dep = undefined\r\n\r\n  private _value!: T\r\n  public readonly effect: ReactiveEffect<T>\r\n\r\n  public readonly __v_isRef = true\r\n  public readonly [ReactiveFlags.IS_READONLY]: boolean = false\r\n\r\n  public _cacheable: boolean\r\n\r\n  constructor(\r\n    getter: ComputedGetter<T>,\r\n    private readonly _setter: ComputedSetter<T>,\r\n    isReadonly: boolean,\r\n    isSSR: boolean,\r\n  ) {\r\n    this.effect = new ReactiveEffect(\r\n      () => getter(this._value),\r\n      () => triggerRefValue(this, DirtyLevels.MaybeDirty),\r\n      () => this.dep && scheduleEffects(this.dep),\r\n    )\r\n    this.effect.computed = this\r\n    this.effect.active = this._cacheable = !isSSR\r\n    this[ReactiveFlags.IS_READONLY] = isReadonly\r\n  }\r\n\r\n  get value() {\r\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n    const self = toRaw(this)\r\n    if (!self._cacheable || self.effect.dirty) {\r\n      if (hasChanged(self._value, (self._value = self.effect.run()!))) {\r\n        triggerRefValue(self, DirtyLevels.Dirty)\r\n      }\r\n    }\r\n    trackRefValue(self)\r\n    if (self.effect._dirtyLevel >= DirtyLevels.MaybeDirty) {\r\n      triggerRefValue(self, DirtyLevels.MaybeDirty)\r\n    }\r\n    return self._value\r\n  }\r\n\r\n  set value(newValue: T) {\r\n    this._setter(newValue)\r\n  }\r\n\r\n  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x\r\n  get _dirty() {\r\n    return this.effect.dirty\r\n  }\r\n\r\n  set _dirty(v) {\r\n    this.effect.dirty = v\r\n  }\r\n  // #endregion\r\n}\r\n\r\n/**\r\n * Takes a getter function and returns a readonly reactive ref object for the\r\n * returned value from the getter. It can also take an object with get and set\r\n * functions to create a writable ref object.\r\n *\r\n * @example\r\n * ```js\r\n * // Creating a readonly computed ref:\r\n * const count = ref(1)\r\n * const plusOne = computed(() => count.value + 1)\r\n *\r\n * console.log(plusOne.value) // 2\r\n * plusOne.value++ // error\r\n * ```\r\n *\r\n * ```js\r\n * // Creating a writable computed ref:\r\n * const count = ref(1)\r\n * const plusOne = computed({\r\n *   get: () => count.value + 1,\r\n *   set: (val) => {\r\n *     count.value = val - 1\r\n *   }\r\n * })\r\n *\r\n * plusOne.value = 1\r\n * console.log(count.value) // 0\r\n * ```\r\n *\r\n * @param getter - Function that produces the next value.\r\n * @param debugOptions - For debugging. See {@link https://vuejs.org/guide/extras/reactivity-in-depth.html#computed-debugging}.\r\n * @see {@link https://vuejs.org/api/reactivity-core.html#computed}\r\n */\r\nexport function computed<T>(\r\n  getter: ComputedGetter<T>,\r\n  debugOptions?: DebuggerOptions,\r\n): ComputedRef<T>\r\nexport function computed<T>(\r\n  options: WritableComputedOptions<T>,\r\n  debugOptions?: DebuggerOptions,\r\n): WritableComputedRef<T>\r\nexport function computed<T>(\r\n  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>,\r\n  debugOptions?: DebuggerOptions,\r\n  isSSR = false,\r\n) {\r\n  let getter: ComputedGetter<T>\r\n  let setter: ComputedSetter<T>\r\n\r\n  const onlyGetter = isFunction(getterOrOptions)\r\n  if (onlyGetter) {\r\n    getter = getterOrOptions\r\n    setter = __DEV__\r\n      ? () => {\r\n          console.warn('Write operation failed: computed value is readonly')\r\n        }\r\n      : NOOP\r\n  } else {\r\n    getter = getterOrOptions.get\r\n    setter = getterOrOptions.set\r\n  }\r\n\r\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR)\r\n\r\n  if (__DEV__ && debugOptions && !isSSR) {\r\n    cRef.effect.onTrack = debugOptions.onTrack\r\n    cRef.effect.onTrigger = debugOptions.onTrigger\r\n  }\r\n\r\n  return cRef as any\r\n}\r\n","import type { ComputedRef } from './computed'\r\nimport {\r\n  activeEffect,\r\n  shouldTrack,\r\n  trackEffect,\r\n  triggerEffects,\r\n} from './effect'\r\nimport { DirtyLevels, TrackOpTypes, TriggerOpTypes } from './constants'\r\nimport {\r\n  type IfAny,\r\n  hasChanged,\r\n  isArray,\r\n  isFunction,\r\n  isObject,\r\n} from '@vue/shared'\r\nimport {\r\n  isProxy,\r\n  isReactive,\r\n  isReadonly,\r\n  isShallow,\r\n  toRaw,\r\n  toReactive,\r\n} from './reactive'\r\nimport type { ShallowReactiveMarker } from './reactive'\r\nimport { type Dep, createDep } from './dep'\r\nimport { ComputedRefImpl } from './computed'\r\nimport { getDepFromReactive } from './reactiveEffect'\r\n\r\ndeclare const RefSymbol: unique symbol\r\nexport declare const RawSymbol: unique symbol\r\n\r\nexport interface Ref<T = any> {\r\n  value: T\r\n  /**\r\n   * Type differentiator only.\r\n   * We need this to be in public d.ts but don't want it to show up in IDE\r\n   * autocomplete, so we use a private Symbol instead.\r\n   */\r\n  [RefSymbol]: true\r\n}\r\n\r\ntype RefBase<T> = {\r\n  dep?: Dep\r\n  value: T\r\n}\r\n\r\nexport function trackRefValue(ref: RefBase<any>) {\r\n  if (shouldTrack && activeEffect) {\r\n    ref = toRaw(ref)\r\n    trackEffect(\r\n      activeEffect,\r\n      ref.dep ||\r\n        (ref.dep = createDep(\r\n          () => (ref.dep = undefined),\r\n          ref instanceof ComputedRefImpl ? ref : undefined,\r\n        )),\r\n      __DEV__\r\n        ? {\r\n            target: ref,\r\n            type: TrackOpTypes.GET,\r\n            key: 'value',\r\n          }\r\n        : void 0,\r\n    )\r\n  }\r\n}\r\n\r\nexport function triggerRefValue(\r\n  ref: RefBase<any>,\r\n  dirtyLevel: DirtyLevels = DirtyLevels.Dirty,\r\n  newVal?: any,\r\n) {\r\n  ref = toRaw(ref)\r\n  const dep = ref.dep\r\n  if (dep) {\r\n    triggerEffects(\r\n      dep,\r\n      dirtyLevel,\r\n      __DEV__\r\n        ? {\r\n            target: ref,\r\n            type: TriggerOpTypes.SET,\r\n            key: 'value',\r\n            newValue: newVal,\r\n          }\r\n        : void 0,\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if a value is a ref object.\r\n *\r\n * @param r - The value to inspect.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#isref}\r\n */\r\nexport function isRef<T>(r: Ref<T> | unknown): r is Ref<T>\r\nexport function isRef(r: any): r is Ref {\r\n  return !!(r && r.__v_isRef === true)\r\n}\r\n\r\n/**\r\n * Takes an inner value and returns a reactive and mutable ref object, which\r\n * has a single property `.value` that points to the inner value.\r\n *\r\n * @param value - The object to wrap in the ref.\r\n * @see {@link https://vuejs.org/api/reactivity-core.html#ref}\r\n */\r\nexport function ref<T>(value: T): Ref<UnwrapRef<T>>\r\nexport function ref<T = any>(): Ref<T | undefined>\r\nexport function ref(value?: unknown) {\r\n  return createRef(value, false)\r\n}\r\n\r\ndeclare const ShallowRefMarker: unique symbol\r\n\r\nexport type ShallowRef<T = any> = Ref<T> & { [ShallowRefMarker]?: true }\r\n\r\n/**\r\n * Shallow version of {@link ref()}.\r\n *\r\n * @example\r\n * ```js\r\n * const state = shallowRef({ count: 1 })\r\n *\r\n * // does NOT trigger change\r\n * state.value.count = 2\r\n *\r\n * // does trigger change\r\n * state.value = { count: 2 }\r\n * ```\r\n *\r\n * @param value - The \"inner value\" for the shallow ref.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#shallowref}\r\n */\r\nexport function shallowRef<T>(\r\n  value: T,\r\n): Ref extends T\r\n  ? T extends Ref\r\n    ? IfAny<T, ShallowRef<T>, T>\r\n    : ShallowRef<T>\r\n  : ShallowRef<T>\r\nexport function shallowRef<T = any>(): ShallowRef<T | undefined>\r\nexport function shallowRef(value?: unknown) {\r\n  return createRef(value, true)\r\n}\r\n\r\nfunction createRef(rawValue: unknown, shallow: boolean) {\r\n  if (isRef(rawValue)) {\r\n    return rawValue\r\n  }\r\n  return new RefImpl(rawValue, shallow)\r\n}\r\n\r\nclass RefImpl<T> {\r\n  private _value: T\r\n  private _rawValue: T\r\n\r\n  public dep?: Dep = undefined\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(\r\n    value: T,\r\n    public readonly __v_isShallow: boolean,\r\n  ) {\r\n    this._rawValue = __v_isShallow ? value : toRaw(value)\r\n    this._value = __v_isShallow ? value : toReactive(value)\r\n  }\r\n\r\n  get value() {\r\n    trackRefValue(this)\r\n    return this._value\r\n  }\r\n\r\n  set value(newVal) {\r\n    const useDirectValue =\r\n      this.__v_isShallow || isShallow(newVal) || isReadonly(newVal)\r\n    newVal = useDirectValue ? newVal : toRaw(newVal)\r\n    if (hasChanged(newVal, this._rawValue)) {\r\n      this._rawValue = newVal\r\n      this._value = useDirectValue ? newVal : toReactive(newVal)\r\n      triggerRefValue(this, DirtyLevels.Dirty, newVal)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Force trigger effects that depends on a shallow ref. This is typically used\r\n * after making deep mutations to the inner value of a shallow ref.\r\n *\r\n * @example\r\n * ```js\r\n * const shallow = shallowRef({\r\n *   greet: 'Hello, world'\r\n * })\r\n *\r\n * // Logs \"Hello, world\" once for the first run-through\r\n * watchEffect(() => {\r\n *   console.log(shallow.value.greet)\r\n * })\r\n *\r\n * // This won't trigger the effect because the ref is shallow\r\n * shallow.value.greet = 'Hello, universe'\r\n *\r\n * // Logs \"Hello, universe\"\r\n * triggerRef(shallow)\r\n * ```\r\n *\r\n * @param ref - The ref whose tied effects shall be executed.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#triggerref}\r\n */\r\nexport function triggerRef(ref: Ref) {\r\n  triggerRefValue(ref, DirtyLevels.Dirty, __DEV__ ? ref.value : void 0)\r\n}\r\n\r\nexport type MaybeRef<T = any> = T | Ref<T>\r\nexport type MaybeRefOrGetter<T = any> = MaybeRef<T> | (() => T)\r\n\r\n/**\r\n * Returns the inner value if the argument is a ref, otherwise return the\r\n * argument itself. This is a sugar function for\r\n * `val = isRef(val) ? val.value : val`.\r\n *\r\n * @example\r\n * ```js\r\n * function useFoo(x: number | Ref<number>) {\r\n *   const unwrapped = unref(x)\r\n *   // unwrapped is guaranteed to be number now\r\n * }\r\n * ```\r\n *\r\n * @param ref - Ref or plain value to be converted into the plain value.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#unref}\r\n */\r\nexport function unref<T>(ref: MaybeRef<T> | ComputedRef<T>): T {\r\n  return isRef(ref) ? ref.value : ref\r\n}\r\n\r\n/**\r\n * Normalizes values / refs / getters to values.\r\n * This is similar to {@link unref()}, except that it also normalizes getters.\r\n * If the argument is a getter, it will be invoked and its return value will\r\n * be returned.\r\n *\r\n * @example\r\n * ```js\r\n * toValue(1) // 1\r\n * toValue(ref(1)) // 1\r\n * toValue(() => 1) // 1\r\n * ```\r\n *\r\n * @param source - A getter, an existing ref, or a non-function value.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#tovalue}\r\n */\r\nexport function toValue<T>(source: MaybeRefOrGetter<T> | ComputedRef<T>): T {\r\n  return isFunction(source) ? source() : unref(source)\r\n}\r\n\r\nconst shallowUnwrapHandlers: ProxyHandler<any> = {\r\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n  set: (target, key, value, receiver) => {\r\n    const oldValue = target[key]\r\n    if (isRef(oldValue) && !isRef(value)) {\r\n      oldValue.value = value\r\n      return true\r\n    } else {\r\n      return Reflect.set(target, key, value, receiver)\r\n    }\r\n  },\r\n}\r\n\r\n/**\r\n * Returns a reactive proxy for the given object.\r\n *\r\n * If the object already is reactive, it's returned as-is. If not, a new\r\n * reactive proxy is created. Direct child properties that are refs are properly\r\n * handled, as well.\r\n *\r\n * @param objectWithRefs - Either an already-reactive object or a simple object\r\n * that contains refs.\r\n */\r\nexport function proxyRefs<T extends object>(\r\n  objectWithRefs: T,\r\n): ShallowUnwrapRef<T> {\r\n  return isReactive(objectWithRefs)\r\n    ? objectWithRefs\r\n    : new Proxy(objectWithRefs, shallowUnwrapHandlers)\r\n}\r\n\r\nexport type CustomRefFactory<T> = (\r\n  track: () => void,\r\n  trigger: () => void,\r\n) => {\r\n  get: () => T\r\n  set: (value: T) => void\r\n}\r\n\r\nclass CustomRefImpl<T> {\r\n  public dep?: Dep = undefined\r\n\r\n  private readonly _get: ReturnType<CustomRefFactory<T>>['get']\r\n  private readonly _set: ReturnType<CustomRefFactory<T>>['set']\r\n\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(factory: CustomRefFactory<T>) {\r\n    const { get, set } = factory(\r\n      () => trackRefValue(this),\r\n      () => triggerRefValue(this),\r\n    )\r\n    this._get = get\r\n    this._set = set\r\n  }\r\n\r\n  get value() {\r\n    return this._get()\r\n  }\r\n\r\n  set value(newVal) {\r\n    this._set(newVal)\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a customized ref with explicit control over its dependency tracking\r\n * and updates triggering.\r\n *\r\n * @param factory - The function that receives the `track` and `trigger` callbacks.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#customref}\r\n */\r\nexport function customRef<T>(factory: CustomRefFactory<T>): Ref<T> {\r\n  return new CustomRefImpl(factory) as any\r\n}\r\n\r\nexport type ToRefs<T = any> = {\r\n  [K in keyof T]: ToRef<T[K]>\r\n}\r\n\r\n/**\r\n * Converts a reactive object to a plain object where each property of the\r\n * resulting object is a ref pointing to the corresponding property of the\r\n * original object. Each individual ref is created using {@link toRef()}.\r\n *\r\n * @param object - Reactive object to be made into an object of linked refs.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#torefs}\r\n */\r\nexport function toRefs<T extends object>(object: T): ToRefs<T> {\r\n  if (__DEV__ && !isProxy(object)) {\r\n    console.warn(`toRefs() expects a reactive object but received a plain one.`)\r\n  }\r\n  const ret: any = isArray(object) ? new Array(object.length) : {}\r\n  for (const key in object) {\r\n    ret[key] = propertyToRef(object, key)\r\n  }\r\n  return ret\r\n}\r\n\r\nclass ObjectRefImpl<T extends object, K extends keyof T> {\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(\r\n    private readonly _object: T,\r\n    private readonly _key: K,\r\n    private readonly _defaultValue?: T[K],\r\n  ) {}\r\n\r\n  get value() {\r\n    const val = this._object[this._key]\r\n    return val === undefined ? this._defaultValue! : val\r\n  }\r\n\r\n  set value(newVal) {\r\n    this._object[this._key] = newVal\r\n  }\r\n\r\n  get dep(): Dep | undefined {\r\n    return getDepFromReactive(toRaw(this._object), this._key)\r\n  }\r\n}\r\n\r\nclass GetterRefImpl<T> {\r\n  public readonly __v_isRef = true\r\n  public readonly __v_isReadonly = true\r\n  constructor(private readonly _getter: () => T) {}\r\n  get value() {\r\n    return this._getter()\r\n  }\r\n}\r\n\r\nexport type ToRef<T> = IfAny<T, Ref<T>, [T] extends [Ref] ? T : Ref<T>>\r\n\r\n/**\r\n * Used to normalize values / refs / getters into refs.\r\n *\r\n * @example\r\n * ```js\r\n * // returns existing refs as-is\r\n * toRef(existingRef)\r\n *\r\n * // creates a ref that calls the getter on .value access\r\n * toRef(() => props.foo)\r\n *\r\n * // creates normal refs from non-function values\r\n * // equivalent to ref(1)\r\n * toRef(1)\r\n * ```\r\n *\r\n * Can also be used to create a ref for a property on a source reactive object.\r\n * The created ref is synced with its source property: mutating the source\r\n * property will update the ref, and vice-versa.\r\n *\r\n * @example\r\n * ```js\r\n * const state = reactive({\r\n *   foo: 1,\r\n *   bar: 2\r\n * })\r\n *\r\n * const fooRef = toRef(state, 'foo')\r\n *\r\n * // mutating the ref updates the original\r\n * fooRef.value++\r\n * console.log(state.foo) // 2\r\n *\r\n * // mutating the original also updates the ref\r\n * state.foo++\r\n * console.log(fooRef.value) // 3\r\n * ```\r\n *\r\n * @param source - A getter, an existing ref, a non-function value, or a\r\n *                 reactive object to create a property ref from.\r\n * @param [key] - (optional) Name of the property in the reactive object.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#toref}\r\n */\r\nexport function toRef<T>(\r\n  value: T,\r\n): T extends () => infer R\r\n  ? Readonly<Ref<R>>\r\n  : T extends Ref\r\n    ? T\r\n    : Ref<UnwrapRef<T>>\r\nexport function toRef<T extends object, K extends keyof T>(\r\n  object: T,\r\n  key: K,\r\n): ToRef<T[K]>\r\nexport function toRef<T extends object, K extends keyof T>(\r\n  object: T,\r\n  key: K,\r\n  defaultValue: T[K],\r\n): ToRef<Exclude<T[K], undefined>>\r\nexport function toRef(\r\n  source: Record<string, any> | MaybeRef,\r\n  key?: string,\r\n  defaultValue?: unknown,\r\n): Ref {\r\n  if (isRef(source)) {\r\n    return source\r\n  } else if (isFunction(source)) {\r\n    return new GetterRefImpl(source) as any\r\n  } else if (isObject(source) && arguments.length > 1) {\r\n    return propertyToRef(source, key!, defaultValue)\r\n  } else {\r\n    return ref(source)\r\n  }\r\n}\r\n\r\nfunction propertyToRef(\r\n  source: Record<string, any>,\r\n  key: string,\r\n  defaultValue?: unknown,\r\n) {\r\n  const val = source[key]\r\n  return isRef(val)\r\n    ? val\r\n    : (new ObjectRefImpl(source, key, defaultValue) as any)\r\n}\r\n\r\n// corner case when use narrows type\r\n// Ex. type RelativePath = string & { __brand: unknown }\r\n// RelativePath extends object -> true\r\ntype BaseTypes = string | number | boolean\r\n\r\n/**\r\n * This is a special exported interface for other packages to declare\r\n * additional types that should bail out for ref unwrapping. For example\r\n * \\@vue/runtime-dom can declare it like so in its d.ts:\r\n *\r\n * ``` ts\r\n * declare module '@vue/reactivity' {\r\n *   export interface RefUnwrapBailTypes {\r\n *     runtimeDOMBailTypes: Node | Window\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport interface RefUnwrapBailTypes {}\r\n\r\nexport type ShallowUnwrapRef<T> = {\r\n  [K in keyof T]: DistrubuteRef<T[K]>\r\n}\r\n\r\ntype DistrubuteRef<T> = T extends Ref<infer V> ? V : T\r\n\r\nexport type UnwrapRef<T> =\r\n  T extends ShallowRef<infer V>\r\n    ? V\r\n    : T extends Ref<infer V>\r\n      ? UnwrapRefSimple<V>\r\n      : UnwrapRefSimple<T>\r\n\r\nexport type UnwrapRefSimple<T> = T extends\r\n  | Function\r\n  | BaseTypes\r\n  | Ref\r\n  | RefUnwrapBailTypes[keyof RefUnwrapBailTypes]\r\n  | { [RawSymbol]?: true }\r\n  ? T\r\n  : T extends Map<infer K, infer V>\r\n    ? Map<K, UnwrapRefSimple<V>> & UnwrapRef<Omit<T, keyof Map<any, any>>>\r\n    : T extends WeakMap<infer K, infer V>\r\n      ? WeakMap<K, UnwrapRefSimple<V>> &\r\n          UnwrapRef<Omit<T, keyof WeakMap<any, any>>>\r\n      : T extends Set<infer V>\r\n        ? Set<UnwrapRefSimple<V>> & UnwrapRef<Omit<T, keyof Set<any>>>\r\n        : T extends WeakSet<infer V>\r\n          ? WeakSet<UnwrapRefSimple<V>> & UnwrapRef<Omit<T, keyof WeakSet<any>>>\r\n          : T extends ReadonlyArray<any>\r\n            ? { [K in keyof T]: UnwrapRefSimple<T[K]> }\r\n            : T extends object & { [ShallowReactiveMarker]?: never }\r\n              ? {\r\n                  [P in keyof T]: P extends symbol ? T[P] : UnwrapRef<T[P]>\r\n                }\r\n              : T\r\n","import { computed } from './computed'\r\n\r\n/**\r\n * @deprecated use `computed` instead. See #5912\r\n */\r\nexport const deferredComputed = computed\r\n","// using literal strings instead of numbers so that it's easier to inspect\r\n// debugger events\r\n\r\nexport enum TrackOpTypes {\r\n  GET = 'get',\r\n  HAS = 'has',\r\n  ITERATE = 'iterate',\r\n}\r\n\r\nexport enum TriggerOpTypes {\r\n  SET = 'set',\r\n  ADD = 'add',\r\n  DELETE = 'delete',\r\n  CLEAR = 'clear',\r\n}\r\n\r\nexport enum ReactiveFlags {\r\n  // 这个属性表示一个值是否应该被跳过，不进行响应式处理。通常在对对象进行深度遍历时，遇到某些特殊标记的值，需要跳过不处理，以避免循环引用或其他不必要的处理\r\n  SKIP = '__v_skip',\r\n  // 这个属性表示一个值是否已经被设置为响应式。在 Vue 3 的响应式系统中，会为对象的属性添加 getter 和 setter，从而实现数据的响应式变化。如果一个对象已经被设置为响应式，就会通过该标记进行标识。\r\n  IS_REACTIVE = '__v_isReactive',\r\n  // 这个属性表示一个值是否是只读的。在 Vue 3 的响应式系统中，可以通过 readonly 函数将对象转换为只读的，这样就无法对其进行修改操作。通过该标记可以进行判断，从而确定是否应该进行只读的处理。\r\n  IS_READONLY = '__v_isReadonly',\r\n  // 这个属性表示一个值是否是浅响应式的。在某些情况下，只需要对对象的顶层属性进行响应式处理，而不需要深度监听整个对象的变化。通过该标记可以进行标识，从而确定是否应该进行浅响应式处理。\r\n  IS_SHALLOW = '__v_isShallow',\r\n  // 这个属性表示一个值的原始版本。在 Vue 3 的响应式系统中，会为对象的属性添加 getter 和 setter，但有时需要获取对象的原始版本，而不是经过响应式处理后的版本。通过该标记可以进行标识，从而确定获取对象的原始版本。\r\n  RAW = '__v_raw',\r\n}\r\n\r\nexport enum DirtyLevels {\r\n  NotDirty = 0,\r\n  MaybeDirty = 1,\r\n  Dirty = 2,\r\n}\r\n"],"names":["hasOwnProperty","__publicField","effect","key","isReadonly","has","get","mutableInstrumentations","shallowInstrumentations","readonlyInstrumentations","shallowReadonlyInstrumentations","ref"],"mappings":"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"}