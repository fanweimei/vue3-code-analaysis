{"version":3,"file":"compiler-dom.global.prod.js","sources":["../../shared/src/makeMap.ts","../../shared/src/general.ts","../../shared/src/normalizeProp.ts","../../shared/src/domTagConfig.ts","../../compiler-core/src/runtimeHelpers.ts","../../compiler-core/src/ast.ts","../../compiler-core/src/tokenizer.ts","../../compiler-core/src/compat/compatConfig.ts","../../compiler-core/src/errors.ts","../../compiler-core/src/babelUtils.ts","../../compiler-core/src/utils.ts","../../compiler-core/src/parser.ts","../../compiler-core/src/transforms/hoistStatic.ts","../../compiler-core/src/transform.ts","../../compiler-core/src/codegen.ts","../../compiler-core/src/transforms/transformExpression.ts","../../compiler-core/src/transforms/vIf.ts","../../compiler-core/src/transforms/vFor.ts","../../compiler-core/src/transforms/vSlot.ts","../../compiler-core/src/transforms/transformElement.ts","../../compiler-core/src/transforms/transformSlotOutlet.ts","../../compiler-core/src/transforms/vOn.ts","../../compiler-core/src/transforms/vBind.ts","../../compiler-core/src/transforms/transformText.ts","../../compiler-core/src/transforms/vOnce.ts","../../compiler-core/src/transforms/vModel.ts","../../compiler-core/src/compat/transformFilter.ts","../../compiler-core/src/transforms/vMemo.ts","../../compiler-core/src/compile.ts","../../compiler-core/src/options.ts","../../compiler-core/src/transforms/noopDirectiveTransform.ts","../src/runtimeHelpers.ts","../src/decodeHtmlBrowser.ts","../src/parserOptions.ts","../src/transforms/transformStyle.ts","../src/errors.ts","../src/transforms/vOn.ts","../src/transforms/ignoreSideEffectTags.ts","../src/index.ts","../src/transforms/vHtml.ts","../src/transforms/vText.ts","../src/transforms/vModel.ts","../src/transforms/vShow.ts","../../shared/src/codeframe.ts"],"sourcesContent":["/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nexport function makeMap(\r\n  str: string,\r\n  expectsLowerCase?: boolean,\r\n): (key: string) => boolean {\r\n  const set = new Set(str.split(','))\r\n  return expectsLowerCase\r\n    ? val => set.has(val.toLowerCase())\r\n    : val => set.has(val)\r\n}\r\n","import { makeMap } from './makeMap'\r\n\r\nexport const EMPTY_OBJ: { readonly [key: string]: any } = __DEV__\r\n  ? Object.freeze({})\r\n  : {}\r\nexport const EMPTY_ARR = __DEV__ ? Object.freeze([]) : []\r\n\r\nexport const NOOP = () => {}\r\n\r\n/**\r\n * Always return false.\r\n */\r\nexport const NO = () => false\r\n\r\nexport const isOn = (key: string) =>\r\n  key.charCodeAt(0) === 111 /* o */ &&\r\n  key.charCodeAt(1) === 110 /* n */ &&\r\n  // uppercase letter\r\n  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97)\r\n\r\nexport const isModelListener = (key: string) => key.startsWith('onUpdate:')\r\n\r\nexport const extend = Object.assign\r\n\r\nexport const remove = <T>(arr: T[], el: T) => {\r\n  const i = arr.indexOf(el)\r\n  if (i > -1) {\r\n    arr.splice(i, 1)\r\n  }\r\n}\r\n\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty\r\nexport const hasOwn = (\r\n  val: object,\r\n  key: string | symbol,\r\n): key is keyof typeof val => hasOwnProperty.call(val, key)\r\n\r\nexport const isArray = Array.isArray\r\nexport const isMap = (val: unknown): val is Map<any, any> =>\r\n  toTypeString(val) === '[object Map]'\r\nexport const isSet = (val: unknown): val is Set<any> =>\r\n  toTypeString(val) === '[object Set]'\r\n\r\nexport const isDate = (val: unknown): val is Date =>\r\n  toTypeString(val) === '[object Date]'\r\nexport const isRegExp = (val: unknown): val is RegExp =>\r\n  toTypeString(val) === '[object RegExp]'\r\nexport const isFunction = (val: unknown): val is Function =>\r\n  typeof val === 'function'\r\nexport const isString = (val: unknown): val is string => typeof val === 'string'\r\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\r\nexport const isObject = (val: unknown): val is Record<any, any> =>\r\n  val !== null && typeof val === 'object'\r\n\r\nexport const isPromise = <T = any>(val: unknown): val is Promise<T> => {\r\n  return (\r\n    (isObject(val) || isFunction(val)) &&\r\n    isFunction((val as any).then) &&\r\n    isFunction((val as any).catch)\r\n  )\r\n}\r\n\r\nexport const objectToString = Object.prototype.toString\r\nexport const toTypeString = (value: unknown): string =>\r\n  objectToString.call(value)\r\n\r\nexport const toRawType = (value: unknown): string => {\r\n  // extract \"RawType\" from strings like \"[object RawType]\"\r\n  return toTypeString(value).slice(8, -1)\r\n}\r\n\r\nexport const isPlainObject = (val: unknown): val is object =>\r\n  toTypeString(val) === '[object Object]'\r\n\r\nexport const isIntegerKey = (key: unknown) =>\r\n  isString(key) &&\r\n  key !== 'NaN' &&\r\n  key[0] !== '-' &&\r\n  '' + parseInt(key, 10) === key\r\n\r\nexport const isReservedProp = /*#__PURE__*/ makeMap(\r\n  // the leading comma is intentional so empty string \"\" is also included\r\n  ',key,ref,ref_for,ref_key,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted',\r\n)\r\n\r\nexport const isBuiltInDirective = /*#__PURE__*/ makeMap(\r\n  'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo',\r\n)\r\n\r\nconst cacheStringFunction = <T extends (str: string) => string>(fn: T): T => {\r\n  const cache: Record<string, string> = Object.create(null)\r\n  return ((str: string) => {\r\n    const hit = cache[str]\r\n    return hit || (cache[str] = fn(str))\r\n  }) as T\r\n}\r\n\r\nconst camelizeRE = /-(\\w)/g\r\n/**\r\n * @private\r\n */\r\nexport const camelize = cacheStringFunction((str: string): string => {\r\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\r\n})\r\n\r\nconst hyphenateRE = /\\B([A-Z])/g\r\n/**\r\n * @private\r\n */\r\nexport const hyphenate = cacheStringFunction((str: string) =>\r\n  str.replace(hyphenateRE, '-$1').toLowerCase(),\r\n)\r\n\r\n/**\r\n * @private\r\n */\r\nexport const capitalize = cacheStringFunction(<T extends string>(str: T) => {\r\n  return (str.charAt(0).toUpperCase() + str.slice(1)) as Capitalize<T>\r\n})\r\n\r\n/**\r\n * @private\r\n */\r\nexport const toHandlerKey = cacheStringFunction(<T extends string>(str: T) => {\r\n  const s = str ? `on${capitalize(str)}` : ``\r\n  return s as T extends '' ? '' : `on${Capitalize<T>}`\r\n})\r\n\r\n// compare whether a value has changed, accounting for NaN.\r\nexport const hasChanged = (value: any, oldValue: any): boolean =>\r\n  !Object.is(value, oldValue)\r\n\r\nexport const invokeArrayFns = (fns: Function[], arg?: any) => {\r\n  for (let i = 0; i < fns.length; i++) {\r\n    fns[i](arg)\r\n  }\r\n}\r\n\r\nexport const def = (obj: object, key: string | symbol, value: any) => {\r\n  Object.defineProperty(obj, key, {\r\n    configurable: true,\r\n    enumerable: false,\r\n    value,\r\n  })\r\n}\r\n\r\n/**\r\n * \"123-foo\" will be parsed to 123\r\n * This is used for the .number modifier in v-model\r\n */\r\nexport const looseToNumber = (val: any): any => {\r\n  const n = parseFloat(val)\r\n  return isNaN(n) ? val : n\r\n}\r\n\r\n/**\r\n * Only concerns number-like strings\r\n * \"123-foo\" will be returned as-is\r\n */\r\nexport const toNumber = (val: any): any => {\r\n  const n = isString(val) ? Number(val) : NaN\r\n  return isNaN(n) ? val : n\r\n}\r\n\r\nlet _globalThis: any\r\nexport const getGlobalThis = (): any => {\r\n  return (\r\n    _globalThis ||\r\n    (_globalThis =\r\n      typeof globalThis !== 'undefined'\r\n        ? globalThis\r\n        : typeof self !== 'undefined'\r\n          ? self\r\n          : typeof window !== 'undefined'\r\n            ? window\r\n            : typeof global !== 'undefined'\r\n              ? global\r\n              : {})\r\n  )\r\n}\r\n\r\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/\r\n\r\nexport function genPropsAccessExp(name: string) {\r\n  return identRE.test(name)\r\n    ? `__props.${name}`\r\n    : `__props[${JSON.stringify(name)}]`\r\n}\r\n","import { hyphenate, isArray, isObject, isString } from './general'\r\n\r\nexport type NormalizedStyle = Record<string, string | number>\r\n\r\nexport function normalizeStyle(\r\n  value: unknown,\r\n): NormalizedStyle | string | undefined {\r\n  if (isArray(value)) {\r\n    const res: NormalizedStyle = {}\r\n    for (let i = 0; i < value.length; i++) {\r\n      const item = value[i]\r\n      const normalized = isString(item)\r\n        ? parseStringStyle(item)\r\n        : (normalizeStyle(item) as NormalizedStyle)\r\n      if (normalized) {\r\n        for (const key in normalized) {\r\n          res[key] = normalized[key]\r\n        }\r\n      }\r\n    }\r\n    return res\r\n  } else if (isString(value) || isObject(value)) {\r\n    return value\r\n  }\r\n}\r\n\r\nconst listDelimiterRE = /;(?![^(]*\\))/g\r\nconst propertyDelimiterRE = /:([^]+)/\r\nconst styleCommentRE = /\\/\\*[^]*?\\*\\//g\r\n\r\nexport function parseStringStyle(cssText: string): NormalizedStyle {\r\n  const ret: NormalizedStyle = {}\r\n  cssText\r\n    .replace(styleCommentRE, '')\r\n    .split(listDelimiterRE)\r\n    .forEach(item => {\r\n      if (item) {\r\n        const tmp = item.split(propertyDelimiterRE)\r\n        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim())\r\n      }\r\n    })\r\n  return ret\r\n}\r\n\r\nexport function stringifyStyle(\r\n  styles: NormalizedStyle | string | undefined,\r\n): string {\r\n  let ret = ''\r\n  if (!styles || isString(styles)) {\r\n    return ret\r\n  }\r\n  for (const key in styles) {\r\n    const value = styles[key]\r\n    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key)\r\n    if (isString(value) || typeof value === 'number') {\r\n      // only render valid values\r\n      ret += `${normalizedKey}:${value};`\r\n    }\r\n  }\r\n  return ret\r\n}\r\n\r\nexport function normalizeClass(value: unknown): string {\r\n  let res = ''\r\n  if (isString(value)) {\r\n    res = value\r\n  } else if (isArray(value)) {\r\n    for (let i = 0; i < value.length; i++) {\r\n      const normalized = normalizeClass(value[i])\r\n      if (normalized) {\r\n        res += normalized + ' '\r\n      }\r\n    }\r\n  } else if (isObject(value)) {\r\n    for (const name in value) {\r\n      if (value[name]) {\r\n        res += name + ' '\r\n      }\r\n    }\r\n  }\r\n  return res.trim()\r\n}\r\n\r\nexport function normalizeProps(props: Record<string, any> | null) {\r\n  if (!props) return null\r\n  let { class: klass, style } = props\r\n  if (klass && !isString(klass)) {\r\n    props.class = normalizeClass(klass)\r\n  }\r\n  if (style) {\r\n    props.style = normalizeStyle(style)\r\n  }\r\n  return props\r\n}\r\n","// These tag configs are shared between compiler-dom and runtime-dom, so they\r\n// must be extracted in shared to avoid creating a dependency between the two.\r\nimport { makeMap } from './makeMap'\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\r\nconst HTML_TAGS =\r\n  'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\r\n  'header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\r\n  'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\r\n  'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\r\n  'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\r\n  'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\r\n  'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\r\n  'option,output,progress,select,textarea,details,dialog,menu,' +\r\n  'summary,template,blockquote,iframe,tfoot'\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\r\nconst SVG_TAGS =\r\n  'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\r\n  'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\r\n  'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\r\n  'feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\r\n  'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\r\n  'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\r\n  'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\r\n  'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\r\n  'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\r\n  'text,textPath,title,tspan,unknown,use,view'\r\n\r\n// https://www.w3.org/TR/mathml4/ (content elements excluded)\r\nconst MATH_TAGS =\r\n  'annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,' +\r\n  'merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,' +\r\n  'mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,' +\r\n  'mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,' +\r\n  'msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics'\r\n\r\nconst VOID_TAGS =\r\n  'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'\r\n\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `__DEV__` flag.\r\n */\r\nexport const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS)\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `__DEV__` flag.\r\n */\r\nexport const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS)\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `__DEV__` flag.\r\n */\r\nexport const isMathMLTag = /*#__PURE__*/ makeMap(MATH_TAGS)\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `__DEV__` flag.\r\n */\r\nexport const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS)\r\n","export const FRAGMENT = Symbol(__DEV__ ? `Fragment` : ``)\r\nexport const TELEPORT = Symbol(__DEV__ ? `Teleport` : ``)\r\nexport const SUSPENSE = Symbol(__DEV__ ? `Suspense` : ``)\r\nexport const KEEP_ALIVE = Symbol(__DEV__ ? `KeepAlive` : ``)\r\nexport const BASE_TRANSITION = Symbol(__DEV__ ? `BaseTransition` : ``)\r\nexport const OPEN_BLOCK = Symbol(__DEV__ ? `openBlock` : ``)\r\nexport const CREATE_BLOCK = Symbol(__DEV__ ? `createBlock` : ``)\r\nexport const CREATE_ELEMENT_BLOCK = Symbol(__DEV__ ? `createElementBlock` : ``)\r\nexport const CREATE_VNODE = Symbol(__DEV__ ? `createVNode` : ``)\r\nexport const CREATE_ELEMENT_VNODE = Symbol(__DEV__ ? `createElementVNode` : ``)\r\nexport const CREATE_COMMENT = Symbol(__DEV__ ? `createCommentVNode` : ``)\r\nexport const CREATE_TEXT = Symbol(__DEV__ ? `createTextVNode` : ``)\r\nexport const CREATE_STATIC = Symbol(__DEV__ ? `createStaticVNode` : ``)\r\nexport const RESOLVE_COMPONENT = Symbol(__DEV__ ? `resolveComponent` : ``)\r\nexport const RESOLVE_DYNAMIC_COMPONENT = Symbol(\r\n  __DEV__ ? `resolveDynamicComponent` : ``,\r\n)\r\nexport const RESOLVE_DIRECTIVE = Symbol(__DEV__ ? `resolveDirective` : ``)\r\nexport const RESOLVE_FILTER = Symbol(__DEV__ ? `resolveFilter` : ``)\r\nexport const WITH_DIRECTIVES = Symbol(__DEV__ ? `withDirectives` : ``)\r\nexport const RENDER_LIST = Symbol(__DEV__ ? `renderList` : ``)\r\nexport const RENDER_SLOT = Symbol(__DEV__ ? `renderSlot` : ``)\r\nexport const CREATE_SLOTS = Symbol(__DEV__ ? `createSlots` : ``)\r\nexport const TO_DISPLAY_STRING = Symbol(__DEV__ ? `toDisplayString` : ``)\r\nexport const MERGE_PROPS = Symbol(__DEV__ ? `mergeProps` : ``)\r\nexport const NORMALIZE_CLASS = Symbol(__DEV__ ? `normalizeClass` : ``)\r\nexport const NORMALIZE_STYLE = Symbol(__DEV__ ? `normalizeStyle` : ``)\r\nexport const NORMALIZE_PROPS = Symbol(__DEV__ ? `normalizeProps` : ``)\r\nexport const GUARD_REACTIVE_PROPS = Symbol(__DEV__ ? `guardReactiveProps` : ``)\r\nexport const TO_HANDLERS = Symbol(__DEV__ ? `toHandlers` : ``)\r\nexport const CAMELIZE = Symbol(__DEV__ ? `camelize` : ``)\r\nexport const CAPITALIZE = Symbol(__DEV__ ? `capitalize` : ``)\r\nexport const TO_HANDLER_KEY = Symbol(__DEV__ ? `toHandlerKey` : ``)\r\nexport const SET_BLOCK_TRACKING = Symbol(__DEV__ ? `setBlockTracking` : ``)\r\nexport const PUSH_SCOPE_ID = Symbol(__DEV__ ? `pushScopeId` : ``)\r\nexport const POP_SCOPE_ID = Symbol(__DEV__ ? `popScopeId` : ``)\r\nexport const WITH_CTX = Symbol(__DEV__ ? `withCtx` : ``)\r\nexport const UNREF = Symbol(__DEV__ ? `unref` : ``)\r\nexport const IS_REF = Symbol(__DEV__ ? `isRef` : ``)\r\nexport const WITH_MEMO = Symbol(__DEV__ ? `withMemo` : ``)\r\nexport const IS_MEMO_SAME = Symbol(__DEV__ ? `isMemoSame` : ``)\r\n\r\n// Name mapping for runtime helpers that need to be imported from 'vue' in\r\n// generated code. Make sure these are correctly exported in the runtime!\r\nexport const helperNameMap: Record<symbol, string> = {\r\n  [FRAGMENT]: `Fragment`,\r\n  [TELEPORT]: `Teleport`,\r\n  [SUSPENSE]: `Suspense`,\r\n  [KEEP_ALIVE]: `KeepAlive`,\r\n  [BASE_TRANSITION]: `BaseTransition`,\r\n  [OPEN_BLOCK]: `openBlock`,\r\n  [CREATE_BLOCK]: `createBlock`,\r\n  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,\r\n  [CREATE_VNODE]: `createVNode`,\r\n  [CREATE_ELEMENT_VNODE]: `createElementVNode`,\r\n  [CREATE_COMMENT]: `createCommentVNode`,\r\n  [CREATE_TEXT]: `createTextVNode`,\r\n  [CREATE_STATIC]: `createStaticVNode`,\r\n  [RESOLVE_COMPONENT]: `resolveComponent`,\r\n  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,\r\n  [RESOLVE_DIRECTIVE]: `resolveDirective`,\r\n  [RESOLVE_FILTER]: `resolveFilter`,\r\n  [WITH_DIRECTIVES]: `withDirectives`,\r\n  [RENDER_LIST]: `renderList`,\r\n  [RENDER_SLOT]: `renderSlot`,\r\n  [CREATE_SLOTS]: `createSlots`,\r\n  [TO_DISPLAY_STRING]: `toDisplayString`,\r\n  [MERGE_PROPS]: `mergeProps`,\r\n  [NORMALIZE_CLASS]: `normalizeClass`,\r\n  [NORMALIZE_STYLE]: `normalizeStyle`,\r\n  [NORMALIZE_PROPS]: `normalizeProps`,\r\n  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,\r\n  [TO_HANDLERS]: `toHandlers`,\r\n  [CAMELIZE]: `camelize`,\r\n  [CAPITALIZE]: `capitalize`,\r\n  [TO_HANDLER_KEY]: `toHandlerKey`,\r\n  [SET_BLOCK_TRACKING]: `setBlockTracking`,\r\n  [PUSH_SCOPE_ID]: `pushScopeId`,\r\n  [POP_SCOPE_ID]: `popScopeId`,\r\n  [WITH_CTX]: `withCtx`,\r\n  [UNREF]: `unref`,\r\n  [IS_REF]: `isRef`,\r\n  [WITH_MEMO]: `withMemo`,\r\n  [IS_MEMO_SAME]: `isMemoSame`,\r\n}\r\n\r\nexport function registerRuntimeHelpers(helpers: Record<symbol, string>) {\r\n  Object.getOwnPropertySymbols(helpers).forEach(s => {\r\n    helperNameMap[s] = helpers[s]\r\n  })\r\n}\r\n","import { isString } from '@vue/shared'\r\nimport {\r\n  CREATE_BLOCK,\r\n  CREATE_ELEMENT_BLOCK,\r\n  CREATE_ELEMENT_VNODE,\r\n  type CREATE_SLOTS,\r\n  CREATE_VNODE,\r\n  type FRAGMENT,\r\n  OPEN_BLOCK,\r\n  type RENDER_LIST,\r\n  type RENDER_SLOT,\r\n  WITH_DIRECTIVES,\r\n  type WITH_MEMO,\r\n} from './runtimeHelpers'\r\nimport type { PropsExpression } from './transforms/transformElement'\r\nimport type { ImportItem, TransformContext } from './transform'\r\nimport type { Node as BabelNode } from '@babel/types'\r\n\r\n// Vue template is a platform-agnostic superset of HTML (syntax only).\r\n// More namespaces can be declared by platform specific compilers.\r\nexport type Namespace = number\r\n\r\nexport enum Namespaces {\r\n  HTML,\r\n  SVG,\r\n  MATH_ML,\r\n}\r\n\r\nexport enum NodeTypes {\r\n  ROOT,\r\n  ELEMENT,\r\n  TEXT,\r\n  COMMENT,\r\n  SIMPLE_EXPRESSION,\r\n  INTERPOLATION,\r\n  ATTRIBUTE,\r\n  DIRECTIVE,\r\n  // containers\r\n  COMPOUND_EXPRESSION,\r\n  IF,\r\n  IF_BRANCH,\r\n  FOR,\r\n  TEXT_CALL,\r\n  // codegen\r\n  VNODE_CALL,\r\n  JS_CALL_EXPRESSION,\r\n  JS_OBJECT_EXPRESSION,\r\n  JS_PROPERTY,\r\n  JS_ARRAY_EXPRESSION,\r\n  JS_FUNCTION_EXPRESSION,\r\n  JS_CONDITIONAL_EXPRESSION,\r\n  JS_CACHE_EXPRESSION,\r\n\r\n  // ssr codegen\r\n  JS_BLOCK_STATEMENT,\r\n  JS_TEMPLATE_LITERAL,\r\n  JS_IF_STATEMENT,\r\n  JS_ASSIGNMENT_EXPRESSION,\r\n  JS_SEQUENCE_EXPRESSION,\r\n  JS_RETURN_STATEMENT,\r\n}\r\n\r\nexport enum ElementTypes {\r\n  ELEMENT,\r\n  COMPONENT,\r\n  SLOT,\r\n  TEMPLATE,\r\n}\r\n\r\nexport interface Node {\r\n  type: NodeTypes\r\n  loc: SourceLocation\r\n}\r\n\r\n// The node's range. The `start` is inclusive and `end` is exclusive.\r\n// [start, end)\r\nexport interface SourceLocation {\r\n  start: Position\r\n  end: Position\r\n  source: string\r\n}\r\n\r\nexport interface Position {\r\n  offset: number // from start of file\r\n  line: number\r\n  column: number\r\n}\r\n\r\nexport type ParentNode = RootNode | ElementNode | IfBranchNode | ForNode\r\n\r\nexport type ExpressionNode = SimpleExpressionNode | CompoundExpressionNode\r\n\r\nexport type TemplateChildNode =\r\n  | ElementNode\r\n  | InterpolationNode\r\n  | CompoundExpressionNode\r\n  | TextNode\r\n  | CommentNode\r\n  | IfNode\r\n  | IfBranchNode\r\n  | ForNode\r\n  | TextCallNode\r\n\r\nexport interface RootNode extends Node {\r\n  type: NodeTypes.ROOT\r\n  source: string\r\n  children: TemplateChildNode[]\r\n  helpers: Set<symbol>\r\n  components: string[]\r\n  directives: string[]\r\n  hoists: (JSChildNode | null)[]\r\n  imports: ImportItem[]\r\n  cached: number\r\n  temps: number\r\n  ssrHelpers?: symbol[]\r\n  codegenNode?: TemplateChildNode | JSChildNode | BlockStatement\r\n  transformed?: boolean\r\n\r\n  // v2 compat only\r\n  filters?: string[]\r\n}\r\n\r\nexport type ElementNode =\r\n  | PlainElementNode\r\n  | ComponentNode\r\n  | SlotOutletNode\r\n  | TemplateNode\r\n\r\nexport interface BaseElementNode extends Node {\r\n  type: NodeTypes.ELEMENT\r\n  ns: Namespace\r\n  tag: string\r\n  tagType: ElementTypes\r\n  props: Array<AttributeNode | DirectiveNode>\r\n  children: TemplateChildNode[]\r\n  isSelfClosing?: boolean\r\n  innerLoc?: SourceLocation // only for SFC root level elements\r\n}\r\n\r\nexport interface PlainElementNode extends BaseElementNode {\r\n  tagType: ElementTypes.ELEMENT\r\n  codegenNode:\r\n    | VNodeCall\r\n    | SimpleExpressionNode // when hoisted\r\n    | CacheExpression // when cached by v-once\r\n    | MemoExpression // when cached by v-memo\r\n    | undefined\r\n  ssrCodegenNode?: TemplateLiteral\r\n}\r\n\r\nexport interface ComponentNode extends BaseElementNode {\r\n  tagType: ElementTypes.COMPONENT\r\n  codegenNode:\r\n    | VNodeCall\r\n    | CacheExpression // when cached by v-once\r\n    | MemoExpression // when cached by v-memo\r\n    | undefined\r\n  ssrCodegenNode?: CallExpression\r\n}\r\n\r\nexport interface SlotOutletNode extends BaseElementNode {\r\n  tagType: ElementTypes.SLOT\r\n  codegenNode:\r\n    | RenderSlotCall\r\n    | CacheExpression // when cached by v-once\r\n    | undefined\r\n  ssrCodegenNode?: CallExpression\r\n}\r\n\r\nexport interface TemplateNode extends BaseElementNode {\r\n  tagType: ElementTypes.TEMPLATE\r\n  // TemplateNode is a container type that always gets compiled away\r\n  codegenNode: undefined\r\n}\r\n\r\nexport interface TextNode extends Node {\r\n  type: NodeTypes.TEXT\r\n  content: string\r\n}\r\n\r\nexport interface CommentNode extends Node {\r\n  type: NodeTypes.COMMENT\r\n  content: string\r\n}\r\n\r\nexport interface AttributeNode extends Node {\r\n  type: NodeTypes.ATTRIBUTE\r\n  name: string\r\n  nameLoc: SourceLocation\r\n  value: TextNode | undefined\r\n}\r\n\r\nexport interface DirectiveNode extends Node {\r\n  type: NodeTypes.DIRECTIVE\r\n  /**\r\n   * the normalized name without prefix or shorthands, e.g. \"bind\", \"on\"\r\n   */\r\n  name: string\r\n  /**\r\n   * the raw attribute name, preserving shorthand, and including arg & modifiers\r\n   * this is only used during parse.\r\n   */\r\n  rawName?: string\r\n  exp: ExpressionNode | undefined\r\n  arg: ExpressionNode | undefined\r\n  modifiers: string[]\r\n  /**\r\n   * optional property to cache the expression parse result for v-for\r\n   */\r\n  forParseResult?: ForParseResult\r\n}\r\n\r\n/**\r\n * Static types have several levels.\r\n * Higher levels implies lower levels. e.g. a node that can be stringified\r\n * can always be hoisted and skipped for patch.\r\n */\r\nexport enum ConstantTypes {\r\n  NOT_CONSTANT = 0,\r\n  CAN_SKIP_PATCH,\r\n  CAN_HOIST,\r\n  CAN_STRINGIFY,\r\n}\r\n\r\nexport interface SimpleExpressionNode extends Node {\r\n  type: NodeTypes.SIMPLE_EXPRESSION\r\n  content: string\r\n  isStatic: boolean\r\n  constType: ConstantTypes\r\n  /**\r\n   * - `null` means the expression is a simple identifier that doesn't need\r\n   *    parsing\r\n   * - `false` means there was a parsing error\r\n   */\r\n  ast?: BabelNode | null | false\r\n  /**\r\n   * Indicates this is an identifier for a hoist vnode call and points to the\r\n   * hoisted node.\r\n   */\r\n  hoisted?: JSChildNode\r\n  /**\r\n   * an expression parsed as the params of a function will track\r\n   * the identifiers declared inside the function body.\r\n   */\r\n  identifiers?: string[]\r\n  isHandlerKey?: boolean\r\n}\r\n\r\nexport interface InterpolationNode extends Node {\r\n  type: NodeTypes.INTERPOLATION\r\n  content: ExpressionNode\r\n}\r\n\r\nexport interface CompoundExpressionNode extends Node {\r\n  type: NodeTypes.COMPOUND_EXPRESSION\r\n  /**\r\n   * - `null` means the expression is a simple identifier that doesn't need\r\n   *    parsing\r\n   * - `false` means there was a parsing error\r\n   */\r\n  ast?: BabelNode | null | false\r\n  children: (\r\n    | SimpleExpressionNode\r\n    | CompoundExpressionNode\r\n    | InterpolationNode\r\n    | TextNode\r\n    | string\r\n    | symbol\r\n  )[]\r\n\r\n  /**\r\n   * an expression parsed as the params of a function will track\r\n   * the identifiers declared inside the function body.\r\n   */\r\n  identifiers?: string[]\r\n  isHandlerKey?: boolean\r\n}\r\n\r\nexport interface IfNode extends Node {\r\n  type: NodeTypes.IF\r\n  branches: IfBranchNode[]\r\n  codegenNode?: IfConditionalExpression | CacheExpression // <div v-if v-once>\r\n}\r\n\r\nexport interface IfBranchNode extends Node {\r\n  type: NodeTypes.IF_BRANCH\r\n  condition: ExpressionNode | undefined // else\r\n  children: TemplateChildNode[]\r\n  userKey?: AttributeNode | DirectiveNode\r\n  isTemplateIf?: boolean\r\n}\r\n\r\nexport interface ForNode extends Node {\r\n  type: NodeTypes.FOR\r\n  source: ExpressionNode\r\n  valueAlias: ExpressionNode | undefined\r\n  keyAlias: ExpressionNode | undefined\r\n  objectIndexAlias: ExpressionNode | undefined\r\n  parseResult: ForParseResult\r\n  children: TemplateChildNode[]\r\n  codegenNode?: ForCodegenNode\r\n}\r\n\r\nexport interface ForParseResult {\r\n  source: ExpressionNode\r\n  value: ExpressionNode | undefined\r\n  key: ExpressionNode | undefined\r\n  index: ExpressionNode | undefined\r\n  finalized: boolean\r\n}\r\n\r\nexport interface TextCallNode extends Node {\r\n  type: NodeTypes.TEXT_CALL\r\n  content: TextNode | InterpolationNode | CompoundExpressionNode\r\n  codegenNode: CallExpression | SimpleExpressionNode // when hoisted\r\n}\r\n\r\nexport type TemplateTextChildNode =\r\n  | TextNode\r\n  | InterpolationNode\r\n  | CompoundExpressionNode\r\n\r\nexport interface VNodeCall extends Node {\r\n  type: NodeTypes.VNODE_CALL\r\n  tag: string | symbol | CallExpression\r\n  props: PropsExpression | undefined\r\n  children:\r\n    | TemplateChildNode[] // multiple children\r\n    | TemplateTextChildNode // single text child\r\n    | SlotsExpression // component slots\r\n    | ForRenderListExpression // v-for fragment call\r\n    | SimpleExpressionNode // hoisted\r\n    | undefined\r\n  patchFlag: string | undefined\r\n  dynamicProps: string | SimpleExpressionNode | undefined\r\n  directives: DirectiveArguments | undefined\r\n  isBlock: boolean\r\n  disableTracking: boolean\r\n  isComponent: boolean\r\n}\r\n\r\n// JS Node Types ---------------------------------------------------------------\r\n\r\n// We also include a number of JavaScript AST nodes for code generation.\r\n// The AST is an intentionally minimal subset just to meet the exact needs of\r\n// Vue render function generation.\r\n\r\nexport type JSChildNode =\r\n  | VNodeCall\r\n  | CallExpression\r\n  | ObjectExpression\r\n  | ArrayExpression\r\n  | ExpressionNode\r\n  | FunctionExpression\r\n  | ConditionalExpression\r\n  | CacheExpression\r\n  | AssignmentExpression\r\n  | SequenceExpression\r\n\r\nexport interface CallExpression extends Node {\r\n  type: NodeTypes.JS_CALL_EXPRESSION\r\n  callee: string | symbol\r\n  arguments: (\r\n    | string\r\n    | symbol\r\n    | JSChildNode\r\n    | SSRCodegenNode\r\n    | TemplateChildNode\r\n    | TemplateChildNode[]\r\n  )[]\r\n}\r\n\r\nexport interface ObjectExpression extends Node {\r\n  type: NodeTypes.JS_OBJECT_EXPRESSION\r\n  properties: Array<Property>\r\n}\r\n\r\nexport interface Property extends Node {\r\n  type: NodeTypes.JS_PROPERTY\r\n  key: ExpressionNode\r\n  value: JSChildNode\r\n}\r\n\r\nexport interface ArrayExpression extends Node {\r\n  type: NodeTypes.JS_ARRAY_EXPRESSION\r\n  elements: Array<string | Node>\r\n}\r\n\r\nexport interface FunctionExpression extends Node {\r\n  type: NodeTypes.JS_FUNCTION_EXPRESSION\r\n  params: ExpressionNode | string | (ExpressionNode | string)[] | undefined\r\n  returns?: TemplateChildNode | TemplateChildNode[] | JSChildNode\r\n  body?: BlockStatement | IfStatement\r\n  newline: boolean\r\n  /**\r\n   * This flag is for codegen to determine whether it needs to generate the\r\n   * withScopeId() wrapper\r\n   */\r\n  isSlot: boolean\r\n  /**\r\n   * __COMPAT__ only, indicates a slot function that should be excluded from\r\n   * the legacy $scopedSlots instance property.\r\n   */\r\n  isNonScopedSlot?: boolean\r\n}\r\n\r\nexport interface ConditionalExpression extends Node {\r\n  type: NodeTypes.JS_CONDITIONAL_EXPRESSION\r\n  test: JSChildNode\r\n  consequent: JSChildNode\r\n  alternate: JSChildNode\r\n  newline: boolean\r\n}\r\n\r\nexport interface CacheExpression extends Node {\r\n  type: NodeTypes.JS_CACHE_EXPRESSION\r\n  index: number\r\n  value: JSChildNode\r\n  isVNode: boolean\r\n}\r\n\r\nexport interface MemoExpression extends CallExpression {\r\n  callee: typeof WITH_MEMO\r\n  arguments: [ExpressionNode, MemoFactory, string, string]\r\n}\r\n\r\ninterface MemoFactory extends FunctionExpression {\r\n  returns: BlockCodegenNode\r\n}\r\n\r\n// SSR-specific Node Types -----------------------------------------------------\r\n\r\nexport type SSRCodegenNode =\r\n  | BlockStatement\r\n  | TemplateLiteral\r\n  | IfStatement\r\n  | AssignmentExpression\r\n  | ReturnStatement\r\n  | SequenceExpression\r\n\r\nexport interface BlockStatement extends Node {\r\n  type: NodeTypes.JS_BLOCK_STATEMENT\r\n  body: (JSChildNode | IfStatement)[]\r\n}\r\n\r\nexport interface TemplateLiteral extends Node {\r\n  type: NodeTypes.JS_TEMPLATE_LITERAL\r\n  elements: (string | JSChildNode)[]\r\n}\r\n\r\nexport interface IfStatement extends Node {\r\n  type: NodeTypes.JS_IF_STATEMENT\r\n  test: ExpressionNode\r\n  consequent: BlockStatement\r\n  alternate: IfStatement | BlockStatement | ReturnStatement | undefined\r\n}\r\n\r\nexport interface AssignmentExpression extends Node {\r\n  type: NodeTypes.JS_ASSIGNMENT_EXPRESSION\r\n  left: SimpleExpressionNode\r\n  right: JSChildNode\r\n}\r\n\r\nexport interface SequenceExpression extends Node {\r\n  type: NodeTypes.JS_SEQUENCE_EXPRESSION\r\n  expressions: JSChildNode[]\r\n}\r\n\r\nexport interface ReturnStatement extends Node {\r\n  type: NodeTypes.JS_RETURN_STATEMENT\r\n  returns: TemplateChildNode | TemplateChildNode[] | JSChildNode\r\n}\r\n\r\n// Codegen Node Types ----------------------------------------------------------\r\n\r\nexport interface DirectiveArguments extends ArrayExpression {\r\n  elements: DirectiveArgumentNode[]\r\n}\r\n\r\nexport interface DirectiveArgumentNode extends ArrayExpression {\r\n  elements: // dir, exp, arg, modifiers\r\n  | [string]\r\n    | [string, ExpressionNode]\r\n    | [string, ExpressionNode, ExpressionNode]\r\n    | [string, ExpressionNode, ExpressionNode, ObjectExpression]\r\n}\r\n\r\n// renderSlot(...)\r\nexport interface RenderSlotCall extends CallExpression {\r\n  callee: typeof RENDER_SLOT\r\n  arguments: // $slots, name, props, fallback\r\n  | [string, string | ExpressionNode]\r\n    | [string, string | ExpressionNode, PropsExpression]\r\n    | [\r\n        string,\r\n        string | ExpressionNode,\r\n        PropsExpression | '{}',\r\n        TemplateChildNode[],\r\n      ]\r\n}\r\n\r\nexport type SlotsExpression = SlotsObjectExpression | DynamicSlotsExpression\r\n\r\n// { foo: () => [...] }\r\nexport interface SlotsObjectExpression extends ObjectExpression {\r\n  properties: SlotsObjectProperty[]\r\n}\r\n\r\nexport interface SlotsObjectProperty extends Property {\r\n  value: SlotFunctionExpression\r\n}\r\n\r\nexport interface SlotFunctionExpression extends FunctionExpression {\r\n  returns: TemplateChildNode[]\r\n}\r\n\r\n// createSlots({ ... }, [\r\n//    foo ? () => [] : undefined,\r\n//    renderList(list, i => () => [i])\r\n// ])\r\nexport interface DynamicSlotsExpression extends CallExpression {\r\n  callee: typeof CREATE_SLOTS\r\n  arguments: [SlotsObjectExpression, DynamicSlotEntries]\r\n}\r\n\r\nexport interface DynamicSlotEntries extends ArrayExpression {\r\n  elements: (ConditionalDynamicSlotNode | ListDynamicSlotNode)[]\r\n}\r\n\r\nexport interface ConditionalDynamicSlotNode extends ConditionalExpression {\r\n  consequent: DynamicSlotNode\r\n  alternate: DynamicSlotNode | SimpleExpressionNode\r\n}\r\n\r\nexport interface ListDynamicSlotNode extends CallExpression {\r\n  callee: typeof RENDER_LIST\r\n  arguments: [ExpressionNode, ListDynamicSlotIterator]\r\n}\r\n\r\nexport interface ListDynamicSlotIterator extends FunctionExpression {\r\n  returns: DynamicSlotNode\r\n}\r\n\r\nexport interface DynamicSlotNode extends ObjectExpression {\r\n  properties: [Property, DynamicSlotFnProperty]\r\n}\r\n\r\nexport interface DynamicSlotFnProperty extends Property {\r\n  value: SlotFunctionExpression\r\n}\r\n\r\nexport type BlockCodegenNode = VNodeCall | RenderSlotCall\r\n\r\nexport interface IfConditionalExpression extends ConditionalExpression {\r\n  consequent: BlockCodegenNode | MemoExpression\r\n  alternate: BlockCodegenNode | IfConditionalExpression | MemoExpression\r\n}\r\n\r\nexport interface ForCodegenNode extends VNodeCall {\r\n  isBlock: true\r\n  tag: typeof FRAGMENT\r\n  props: undefined\r\n  children: ForRenderListExpression\r\n  patchFlag: string\r\n  disableTracking: boolean\r\n}\r\n\r\nexport interface ForRenderListExpression extends CallExpression {\r\n  callee: typeof RENDER_LIST\r\n  arguments: [ExpressionNode, ForIteratorExpression]\r\n}\r\n\r\nexport interface ForIteratorExpression extends FunctionExpression {\r\n  returns: BlockCodegenNode\r\n}\r\n\r\n// AST Utilities ---------------------------------------------------------------\r\n\r\n// Some expressions, e.g. sequence and conditional expressions, are never\r\n// associated with template nodes, so their source locations are just a stub.\r\n// Container types like CompoundExpression also don't need a real location.\r\nexport const locStub: SourceLocation = {\r\n  start: { line: 1, column: 1, offset: 0 },\r\n  end: { line: 1, column: 1, offset: 0 },\r\n  source: '',\r\n}\r\n\r\nexport function createRoot(\r\n  children: TemplateChildNode[],\r\n  source = '',\r\n): RootNode {\r\n  return {\r\n    type: NodeTypes.ROOT,\r\n    source,\r\n    children,\r\n    helpers: new Set(),\r\n    components: [],\r\n    directives: [],\r\n    hoists: [],\r\n    imports: [],\r\n    cached: 0,\r\n    temps: 0,\r\n    codegenNode: undefined,\r\n    loc: locStub,\r\n  }\r\n}\r\n\r\nexport function createVNodeCall(\r\n  context: TransformContext | null,\r\n  tag: VNodeCall['tag'],\r\n  props?: VNodeCall['props'],\r\n  children?: VNodeCall['children'],\r\n  patchFlag?: VNodeCall['patchFlag'],\r\n  dynamicProps?: VNodeCall['dynamicProps'],\r\n  directives?: VNodeCall['directives'],\r\n  isBlock: VNodeCall['isBlock'] = false,\r\n  disableTracking: VNodeCall['disableTracking'] = false,\r\n  isComponent: VNodeCall['isComponent'] = false,\r\n  loc = locStub,\r\n): VNodeCall {\r\n  if (context) {\r\n    if (isBlock) {\r\n      context.helper(OPEN_BLOCK)\r\n      context.helper(getVNodeBlockHelper(context.inSSR, isComponent))\r\n    } else {\r\n      context.helper(getVNodeHelper(context.inSSR, isComponent))\r\n    }\r\n    if (directives) {\r\n      context.helper(WITH_DIRECTIVES)\r\n    }\r\n  }\r\n\r\n  return {\r\n    type: NodeTypes.VNODE_CALL,\r\n    tag,\r\n    props,\r\n    children,\r\n    patchFlag,\r\n    dynamicProps,\r\n    directives,\r\n    isBlock,\r\n    disableTracking,\r\n    isComponent,\r\n    loc,\r\n  }\r\n}\r\n\r\nexport function createArrayExpression(\r\n  elements: ArrayExpression['elements'],\r\n  loc: SourceLocation = locStub,\r\n): ArrayExpression {\r\n  return {\r\n    type: NodeTypes.JS_ARRAY_EXPRESSION,\r\n    loc,\r\n    elements,\r\n  }\r\n}\r\n\r\nexport function createObjectExpression(\r\n  properties: ObjectExpression['properties'],\r\n  loc: SourceLocation = locStub,\r\n): ObjectExpression {\r\n  return {\r\n    type: NodeTypes.JS_OBJECT_EXPRESSION,\r\n    loc,\r\n    properties,\r\n  }\r\n}\r\n\r\nexport function createObjectProperty(\r\n  key: Property['key'] | string,\r\n  value: Property['value'],\r\n): Property {\r\n  return {\r\n    type: NodeTypes.JS_PROPERTY,\r\n    loc: locStub,\r\n    key: isString(key) ? createSimpleExpression(key, true) : key,\r\n    value,\r\n  }\r\n}\r\n\r\nexport function createSimpleExpression(\r\n  content: SimpleExpressionNode['content'],\r\n  isStatic: SimpleExpressionNode['isStatic'] = false,\r\n  loc: SourceLocation = locStub,\r\n  constType: ConstantTypes = ConstantTypes.NOT_CONSTANT,\r\n): SimpleExpressionNode {\r\n  return {\r\n    type: NodeTypes.SIMPLE_EXPRESSION,\r\n    loc,\r\n    content,\r\n    isStatic,\r\n    constType: isStatic ? ConstantTypes.CAN_STRINGIFY : constType,\r\n  }\r\n}\r\n\r\nexport function createInterpolation(\r\n  content: InterpolationNode['content'] | string,\r\n  loc: SourceLocation,\r\n): InterpolationNode {\r\n  return {\r\n    type: NodeTypes.INTERPOLATION,\r\n    loc,\r\n    content: isString(content)\r\n      ? createSimpleExpression(content, false, loc)\r\n      : content,\r\n  }\r\n}\r\n\r\nexport function createCompoundExpression(\r\n  children: CompoundExpressionNode['children'],\r\n  loc: SourceLocation = locStub,\r\n): CompoundExpressionNode {\r\n  return {\r\n    type: NodeTypes.COMPOUND_EXPRESSION,\r\n    loc,\r\n    children,\r\n  }\r\n}\r\n\r\ntype InferCodegenNodeType<T> = T extends typeof RENDER_SLOT\r\n  ? RenderSlotCall\r\n  : CallExpression\r\n\r\nexport function createCallExpression<T extends CallExpression['callee']>(\r\n  callee: T,\r\n  args: CallExpression['arguments'] = [],\r\n  loc: SourceLocation = locStub,\r\n): InferCodegenNodeType<T> {\r\n  return {\r\n    type: NodeTypes.JS_CALL_EXPRESSION,\r\n    loc,\r\n    callee,\r\n    arguments: args,\r\n  } as InferCodegenNodeType<T>\r\n}\r\n\r\nexport function createFunctionExpression(\r\n  params: FunctionExpression['params'],\r\n  returns: FunctionExpression['returns'] = undefined,\r\n  newline: boolean = false,\r\n  isSlot: boolean = false,\r\n  loc: SourceLocation = locStub,\r\n): FunctionExpression {\r\n  return {\r\n    type: NodeTypes.JS_FUNCTION_EXPRESSION,\r\n    params,\r\n    returns,\r\n    newline,\r\n    isSlot,\r\n    loc,\r\n  }\r\n}\r\n\r\nexport function createConditionalExpression(\r\n  test: ConditionalExpression['test'],\r\n  consequent: ConditionalExpression['consequent'],\r\n  alternate: ConditionalExpression['alternate'],\r\n  newline = true,\r\n): ConditionalExpression {\r\n  return {\r\n    type: NodeTypes.JS_CONDITIONAL_EXPRESSION,\r\n    test,\r\n    consequent,\r\n    alternate,\r\n    newline,\r\n    loc: locStub,\r\n  }\r\n}\r\n\r\nexport function createCacheExpression(\r\n  index: number,\r\n  value: JSChildNode,\r\n  isVNode: boolean = false,\r\n): CacheExpression {\r\n  return {\r\n    type: NodeTypes.JS_CACHE_EXPRESSION,\r\n    index,\r\n    value,\r\n    isVNode,\r\n    loc: locStub,\r\n  }\r\n}\r\n\r\nexport function createBlockStatement(\r\n  body: BlockStatement['body'],\r\n): BlockStatement {\r\n  return {\r\n    type: NodeTypes.JS_BLOCK_STATEMENT,\r\n    body,\r\n    loc: locStub,\r\n  }\r\n}\r\n\r\nexport function createTemplateLiteral(\r\n  elements: TemplateLiteral['elements'],\r\n): TemplateLiteral {\r\n  return {\r\n    type: NodeTypes.JS_TEMPLATE_LITERAL,\r\n    elements,\r\n    loc: locStub,\r\n  }\r\n}\r\n\r\nexport function createIfStatement(\r\n  test: IfStatement['test'],\r\n  consequent: IfStatement['consequent'],\r\n  alternate?: IfStatement['alternate'],\r\n): IfStatement {\r\n  return {\r\n    type: NodeTypes.JS_IF_STATEMENT,\r\n    test,\r\n    consequent,\r\n    alternate,\r\n    loc: locStub,\r\n  }\r\n}\r\n\r\nexport function createAssignmentExpression(\r\n  left: AssignmentExpression['left'],\r\n  right: AssignmentExpression['right'],\r\n): AssignmentExpression {\r\n  return {\r\n    type: NodeTypes.JS_ASSIGNMENT_EXPRESSION,\r\n    left,\r\n    right,\r\n    loc: locStub,\r\n  }\r\n}\r\n\r\nexport function createSequenceExpression(\r\n  expressions: SequenceExpression['expressions'],\r\n): SequenceExpression {\r\n  return {\r\n    type: NodeTypes.JS_SEQUENCE_EXPRESSION,\r\n    expressions,\r\n    loc: locStub,\r\n  }\r\n}\r\n\r\nexport function createReturnStatement(\r\n  returns: ReturnStatement['returns'],\r\n): ReturnStatement {\r\n  return {\r\n    type: NodeTypes.JS_RETURN_STATEMENT,\r\n    returns,\r\n    loc: locStub,\r\n  }\r\n}\r\n\r\nexport function getVNodeHelper(ssr: boolean, isComponent: boolean) {\r\n  return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE\r\n}\r\n\r\nexport function getVNodeBlockHelper(ssr: boolean, isComponent: boolean) {\r\n  return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK\r\n}\r\n\r\nexport function convertToBlock(\r\n  node: VNodeCall,\r\n  { helper, removeHelper, inSSR }: TransformContext,\r\n) {\r\n  if (!node.isBlock) {\r\n    node.isBlock = true\r\n    removeHelper(getVNodeHelper(inSSR, node.isComponent))\r\n    helper(OPEN_BLOCK)\r\n    helper(getVNodeBlockHelper(inSSR, node.isComponent))\r\n  }\r\n}\r\n","/**\r\n * This Tokenizer is adapted from htmlparser2 under the MIT License listed at\r\n * https://github.com/fb55/htmlparser2/blob/master/LICENSE\r\n\r\nCopyright 2010, 2011, Chris Winberry <chris@winberry.net>. All rights reserved.\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to\r\ndeal in the Software without restriction, including without limitation the\r\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\r\nsell copies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\r\nIN THE SOFTWARE.\r\n */\r\n\r\nimport { ErrorCodes } from './errors'\r\nimport type { ElementNode, Position } from './ast'\r\n\r\n/**\r\n * Note: entities is a non-browser-build-only dependency.\r\n * In the browser, we use an HTML element to do the decoding.\r\n * Make sure all imports from entities are only used in non-browser branches\r\n * so that it can be properly treeshaken.\r\n */\r\nimport {\r\n  DecodingMode,\r\n  EntityDecoder,\r\n  fromCodePoint,\r\n  htmlDecodeTree,\r\n} from 'entities/lib/decode.js'\r\n\r\nexport enum ParseMode {\r\n  BASE,\r\n  HTML,\r\n  SFC,\r\n}\r\n\r\nexport enum CharCodes {\r\n  Tab = 0x9, // \"\\t\"\r\n  NewLine = 0xa, // \"\\n\"\r\n  FormFeed = 0xc, // \"\\f\"\r\n  CarriageReturn = 0xd, // \"\\r\"\r\n  Space = 0x20, // \" \"\r\n  ExclamationMark = 0x21, // \"!\"\r\n  Number = 0x23, // \"#\"\r\n  Amp = 0x26, // \"&\"\r\n  SingleQuote = 0x27, // \"'\"\r\n  DoubleQuote = 0x22, // '\"'\r\n  GraveAccent = 96, // \"`\"\r\n  Dash = 0x2d, // \"-\"\r\n  Slash = 0x2f, // \"/\"\r\n  Zero = 0x30, // \"0\"\r\n  Nine = 0x39, // \"9\"\r\n  Semi = 0x3b, // \";\"\r\n  Lt = 0x3c, // \"<\"\r\n  Eq = 0x3d, // \"=\"\r\n  Gt = 0x3e, // \">\"\r\n  Questionmark = 0x3f, // \"?\"\r\n  UpperA = 0x41, // \"A\"\r\n  LowerA = 0x61, // \"a\"\r\n  UpperF = 0x46, // \"F\"\r\n  LowerF = 0x66, // \"f\"\r\n  UpperZ = 0x5a, // \"Z\"\r\n  LowerZ = 0x7a, // \"z\"\r\n  LowerX = 0x78, // \"x\"\r\n  LowerV = 0x76, // \"v\"\r\n  Dot = 0x2e, // \".\"\r\n  Colon = 0x3a, // \":\"\r\n  At = 0x40, // \"@\"\r\n  LeftSquare = 91, // \"[\"\r\n  RightSquare = 93, // \"]\"\r\n}\r\n\r\nconst defaultDelimitersOpen = new Uint8Array([123, 123]) // \"{{\"\r\nconst defaultDelimitersClose = new Uint8Array([125, 125]) // \"}}\"\r\n\r\n/** All the states the tokenizer can be in. */\r\nexport enum State {\r\n  Text = 1,\r\n\r\n  // interpolation\r\n  InterpolationOpen,\r\n  Interpolation,\r\n  InterpolationClose,\r\n\r\n  // Tags\r\n  BeforeTagName, // After <\r\n  InTagName,\r\n  InSelfClosingTag,\r\n  BeforeClosingTagName,\r\n  InClosingTagName,\r\n  AfterClosingTagName,\r\n\r\n  // Attrs\r\n  BeforeAttrName,\r\n  InAttrName,\r\n  InDirName,\r\n  InDirArg,\r\n  InDirDynamicArg,\r\n  InDirModifier,\r\n  AfterAttrName,\r\n  BeforeAttrValue,\r\n  InAttrValueDq, // \"\r\n  InAttrValueSq, // '\r\n  InAttrValueNq,\r\n\r\n  // Declarations\r\n  BeforeDeclaration, // !\r\n  InDeclaration,\r\n\r\n  // Processing instructions\r\n  InProcessingInstruction, // ?\r\n\r\n  // Comments & CDATA\r\n  BeforeComment,\r\n  CDATASequence,\r\n  InSpecialComment,\r\n  InCommentLike,\r\n\r\n  // Special tags\r\n  BeforeSpecialS, // Decide if we deal with `<script` or `<style`\r\n  BeforeSpecialT, // Decide if we deal with `<title` or `<textarea`\r\n  SpecialStartSequence,\r\n  InRCDATA,\r\n\r\n  InEntity,\r\n\r\n  InSFCRootTagName,\r\n}\r\n\r\n/**\r\n * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a\r\n * tag name.\r\n */\r\nfunction isTagStartChar(c: number): boolean {\r\n  return (\r\n    (c >= CharCodes.LowerA && c <= CharCodes.LowerZ) ||\r\n    (c >= CharCodes.UpperA && c <= CharCodes.UpperZ)\r\n  )\r\n}\r\n\r\nexport function isWhitespace(c: number): boolean {\r\n  return (\r\n    c === CharCodes.Space ||\r\n    c === CharCodes.NewLine ||\r\n    c === CharCodes.Tab ||\r\n    c === CharCodes.FormFeed ||\r\n    c === CharCodes.CarriageReturn\r\n  )\r\n}\r\n\r\nfunction isEndOfTagSection(c: number): boolean {\r\n  return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c)\r\n}\r\n\r\nexport function toCharCodes(str: string): Uint8Array {\r\n  const ret = new Uint8Array(str.length)\r\n  for (let i = 0; i < str.length; i++) {\r\n    ret[i] = str.charCodeAt(i)\r\n  }\r\n  return ret\r\n}\r\n\r\nexport enum QuoteType {\r\n  NoValue = 0,\r\n  Unquoted = 1,\r\n  Single = 2,\r\n  Double = 3,\r\n}\r\n\r\nexport interface Callbacks {\r\n  ontext(start: number, endIndex: number): void\r\n  ontextentity(char: string, start: number, endIndex: number): void\r\n\r\n  oninterpolation(start: number, endIndex: number): void\r\n\r\n  onopentagname(start: number, endIndex: number): void\r\n  onopentagend(endIndex: number): void\r\n  onselfclosingtag(endIndex: number): void\r\n  onclosetag(start: number, endIndex: number): void\r\n\r\n  onattribdata(start: number, endIndex: number): void\r\n  onattribentity(char: string, start: number, end: number): void\r\n  onattribend(quote: QuoteType, endIndex: number): void\r\n  onattribname(start: number, endIndex: number): void\r\n  onattribnameend(endIndex: number): void\r\n\r\n  ondirname(start: number, endIndex: number): void\r\n  ondirarg(start: number, endIndex: number): void\r\n  ondirmodifier(start: number, endIndex: number): void\r\n\r\n  oncomment(start: number, endIndex: number): void\r\n  oncdata(start: number, endIndex: number): void\r\n\r\n  onprocessinginstruction(start: number, endIndex: number): void\r\n  // ondeclaration(start: number, endIndex: number): void\r\n  onend(): void\r\n  onerr(code: ErrorCodes, index: number): void\r\n}\r\n\r\n/**\r\n * Sequences used to match longer strings.\r\n *\r\n * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End\r\n * sequences with an increased offset.\r\n */\r\nexport const Sequences = {\r\n  Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]), // CDATA[\r\n  CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]), // ]]>\r\n  CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]), // `-->`\r\n  ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]), // `</script`\r\n  StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]), // `</style`\r\n  TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]), // `</title`\r\n  TextareaEnd: new Uint8Array([\r\n    0x3c, 0x2f, 116, 101, 120, 116, 97, 114, 101, 97,\r\n  ]), // `</textarea\r\n}\r\n\r\nexport default class Tokenizer {\r\n  /** The current state the tokenizer is in. */\r\n  public state = State.Text\r\n  /** The read buffer. */\r\n  private buffer = ''\r\n  /** The beginning of the section that is currently being read. */\r\n  public sectionStart = 0\r\n  /** The index within the buffer that we are currently looking at. */\r\n  private index = 0\r\n  /** The start of the last entity. */\r\n  private entityStart = 0\r\n  /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */\r\n  private baseState = State.Text\r\n  /** For special parsing behavior inside of script and style tags. */\r\n  public inRCDATA = false\r\n  /** For disabling RCDATA tags handling */\r\n  public inXML = false\r\n  /** For disabling interpolation parsing in v-pre */\r\n  public inVPre = false\r\n  /** Record newline positions for fast line / column calculation */\r\n  private newlines: number[] = []\r\n\r\n  private readonly entityDecoder?: EntityDecoder\r\n\r\n  public mode = ParseMode.BASE\r\n  public get inSFCRoot() {\r\n    return this.mode === ParseMode.SFC && this.stack.length === 0\r\n  }\r\n\r\n  constructor(\r\n    private readonly stack: ElementNode[],\r\n    private readonly cbs: Callbacks,\r\n  ) {\r\n    if (!__BROWSER__) {\r\n      this.entityDecoder = new EntityDecoder(htmlDecodeTree, (cp, consumed) =>\r\n        this.emitCodePoint(cp, consumed),\r\n      )\r\n    }\r\n  }\r\n\r\n  public reset(): void {\r\n    this.state = State.Text\r\n    this.mode = ParseMode.BASE\r\n    this.buffer = ''\r\n    this.sectionStart = 0\r\n    this.index = 0\r\n    this.baseState = State.Text\r\n    this.inRCDATA = false\r\n    this.currentSequence = undefined!\r\n    this.newlines.length = 0\r\n    this.delimiterOpen = defaultDelimitersOpen\r\n    this.delimiterClose = defaultDelimitersClose\r\n  }\r\n\r\n  /**\r\n   * Generate Position object with line / column information using recorded\r\n   * newline positions. We know the index is always going to be an already\r\n   * processed index, so all the newlines up to this index should have been\r\n   * recorded.\r\n   */\r\n  public getPos(index: number): Position {\r\n    let line = 1\r\n    let column = index + 1\r\n    for (let i = this.newlines.length - 1; i >= 0; i--) {\r\n      const newlineIndex = this.newlines[i]\r\n      if (index > newlineIndex) {\r\n        line = i + 2\r\n        column = index - newlineIndex\r\n        break\r\n      }\r\n    }\r\n    return {\r\n      column,\r\n      line,\r\n      offset: index,\r\n    }\r\n  }\r\n\r\n  private peek() {\r\n    return this.buffer.charCodeAt(this.index + 1)\r\n  }\r\n\r\n  private stateText(c: number): void {\r\n    if (c === CharCodes.Lt) {\r\n      if (this.index > this.sectionStart) {\r\n        this.cbs.ontext(this.sectionStart, this.index)\r\n      }\r\n      this.state = State.BeforeTagName\r\n      this.sectionStart = this.index\r\n    } else if (!__BROWSER__ && c === CharCodes.Amp) {\r\n      this.startEntity()\r\n    } else if (!this.inVPre && c === this.delimiterOpen[0]) {\r\n      this.state = State.InterpolationOpen\r\n      this.delimiterIndex = 0\r\n      this.stateInterpolationOpen(c)\r\n    }\r\n  }\r\n\r\n  public delimiterOpen: Uint8Array = defaultDelimitersOpen\r\n  public delimiterClose: Uint8Array = defaultDelimitersClose\r\n  private delimiterIndex = -1\r\n\r\n  private stateInterpolationOpen(c: number): void {\r\n    if (c === this.delimiterOpen[this.delimiterIndex]) {\r\n      if (this.delimiterIndex === this.delimiterOpen.length - 1) {\r\n        const start = this.index + 1 - this.delimiterOpen.length\r\n        if (start > this.sectionStart) {\r\n          this.cbs.ontext(this.sectionStart, start)\r\n        }\r\n        this.state = State.Interpolation\r\n        this.sectionStart = start\r\n      } else {\r\n        this.delimiterIndex++\r\n      }\r\n    } else if (this.inRCDATA) {\r\n      this.state = State.InRCDATA\r\n      this.stateInRCDATA(c)\r\n    } else {\r\n      this.state = State.Text\r\n      this.stateText(c)\r\n    }\r\n  }\r\n\r\n  private stateInterpolation(c: number): void {\r\n    if (c === this.delimiterClose[0]) {\r\n      this.state = State.InterpolationClose\r\n      this.delimiterIndex = 0\r\n      this.stateInterpolationClose(c)\r\n    }\r\n  }\r\n\r\n  private stateInterpolationClose(c: number) {\r\n    if (c === this.delimiterClose[this.delimiterIndex]) {\r\n      if (this.delimiterIndex === this.delimiterClose.length - 1) {\r\n        this.cbs.oninterpolation(this.sectionStart, this.index + 1)\r\n        if (this.inRCDATA) {\r\n          this.state = State.InRCDATA\r\n        } else {\r\n          this.state = State.Text\r\n        }\r\n        this.sectionStart = this.index + 1\r\n      } else {\r\n        this.delimiterIndex++\r\n      }\r\n    } else {\r\n      this.state = State.Interpolation\r\n      this.stateInterpolation(c)\r\n    }\r\n  }\r\n\r\n  public currentSequence: Uint8Array = undefined!\r\n  private sequenceIndex = 0\r\n  private stateSpecialStartSequence(c: number): void {\r\n    const isEnd = this.sequenceIndex === this.currentSequence.length\r\n    const isMatch = isEnd\r\n      ? // If we are at the end of the sequence, make sure the tag name has ended\r\n        isEndOfTagSection(c)\r\n      : // Otherwise, do a case-insensitive comparison\r\n        (c | 0x20) === this.currentSequence[this.sequenceIndex]\r\n\r\n    if (!isMatch) {\r\n      this.inRCDATA = false\r\n    } else if (!isEnd) {\r\n      this.sequenceIndex++\r\n      return\r\n    }\r\n\r\n    this.sequenceIndex = 0\r\n    this.state = State.InTagName\r\n    this.stateInTagName(c)\r\n  }\r\n\r\n  /** Look for an end tag. For <title> and <textarea>, also decode entities. */\r\n  private stateInRCDATA(c: number): void {\r\n    if (this.sequenceIndex === this.currentSequence.length) {\r\n      if (c === CharCodes.Gt || isWhitespace(c)) {\r\n        const endOfText = this.index - this.currentSequence.length\r\n\r\n        if (this.sectionStart < endOfText) {\r\n          // Spoof the index so that reported locations match up.\r\n          const actualIndex = this.index\r\n          this.index = endOfText\r\n          this.cbs.ontext(this.sectionStart, endOfText)\r\n          this.index = actualIndex\r\n        }\r\n\r\n        this.sectionStart = endOfText + 2 // Skip over the `</`\r\n        this.stateInClosingTagName(c)\r\n        this.inRCDATA = false\r\n        return // We are done; skip the rest of the function.\r\n      }\r\n\r\n      this.sequenceIndex = 0\r\n    }\r\n\r\n    if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {\r\n      this.sequenceIndex += 1\r\n    } else if (this.sequenceIndex === 0) {\r\n      if (\r\n        this.currentSequence === Sequences.TitleEnd ||\r\n        (this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot)\r\n      ) {\r\n        // We have to parse entities in <title> and <textarea> tags.\r\n        if (!__BROWSER__ && c === CharCodes.Amp) {\r\n          this.startEntity()\r\n        } else if (c === this.delimiterOpen[0]) {\r\n          // We also need to handle interpolation\r\n          this.state = State.InterpolationOpen\r\n          this.delimiterIndex = 0\r\n          this.stateInterpolationOpen(c)\r\n        }\r\n      } else if (this.fastForwardTo(CharCodes.Lt)) {\r\n        // Outside of <title> and <textarea> tags, we can fast-forward.\r\n        this.sequenceIndex = 1\r\n      }\r\n    } else {\r\n      // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.\r\n      this.sequenceIndex = Number(c === CharCodes.Lt)\r\n    }\r\n  }\r\n\r\n  private stateCDATASequence(c: number): void {\r\n    if (c === Sequences.Cdata[this.sequenceIndex]) {\r\n      if (++this.sequenceIndex === Sequences.Cdata.length) {\r\n        this.state = State.InCommentLike\r\n        this.currentSequence = Sequences.CdataEnd\r\n        this.sequenceIndex = 0\r\n        this.sectionStart = this.index + 1\r\n      }\r\n    } else {\r\n      this.sequenceIndex = 0\r\n      this.state = State.InDeclaration\r\n      this.stateInDeclaration(c) // Reconsume the character\r\n    }\r\n  }\r\n\r\n  /**\r\n   * When we wait for one specific character, we can speed things up\r\n   * by skipping through the buffer until we find it.\r\n   *\r\n   * @returns Whether the character was found.\r\n   */\r\n  private fastForwardTo(c: number): boolean {\r\n    while (++this.index < this.buffer.length) {\r\n      const cc = this.buffer.charCodeAt(this.index)\r\n      if (cc === CharCodes.NewLine) {\r\n        this.newlines.push(this.index)\r\n      }\r\n      if (cc === c) {\r\n        return true\r\n      }\r\n    }\r\n\r\n    /*\r\n     * We increment the index at the end of the `parse` loop,\r\n     * so set it to `buffer.length - 1` here.\r\n     *\r\n     * TODO: Refactor `parse` to increment index before calling states.\r\n     */\r\n    this.index = this.buffer.length - 1\r\n\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Comments and CDATA end with `-->` and `]]>`.\r\n   *\r\n   * Their common qualities are:\r\n   * - Their end sequences have a distinct character they start with.\r\n   * - That character is then repeated, so we have to check multiple repeats.\r\n   * - All characters but the start character of the sequence can be skipped.\r\n   */\r\n  private stateInCommentLike(c: number): void {\r\n    if (c === this.currentSequence[this.sequenceIndex]) {\r\n      if (++this.sequenceIndex === this.currentSequence.length) {\r\n        if (this.currentSequence === Sequences.CdataEnd) {\r\n          this.cbs.oncdata(this.sectionStart, this.index - 2)\r\n        } else {\r\n          this.cbs.oncomment(this.sectionStart, this.index - 2)\r\n        }\r\n\r\n        this.sequenceIndex = 0\r\n        this.sectionStart = this.index + 1\r\n        this.state = State.Text\r\n      }\r\n    } else if (this.sequenceIndex === 0) {\r\n      // Fast-forward to the first character of the sequence\r\n      if (this.fastForwardTo(this.currentSequence[0])) {\r\n        this.sequenceIndex = 1\r\n      }\r\n    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {\r\n      // Allow long sequences, eg. --->, ]]]>\r\n      this.sequenceIndex = 0\r\n    }\r\n  }\r\n\r\n  private startSpecial(sequence: Uint8Array, offset: number) {\r\n    this.enterRCDATA(sequence, offset)\r\n    this.state = State.SpecialStartSequence\r\n  }\r\n\r\n  public enterRCDATA(sequence: Uint8Array, offset: number) {\r\n    this.inRCDATA = true\r\n    this.currentSequence = sequence\r\n    this.sequenceIndex = offset\r\n  }\r\n\r\n  private stateBeforeTagName(c: number): void {\r\n    if (c === CharCodes.ExclamationMark) {\r\n      this.state = State.BeforeDeclaration\r\n      this.sectionStart = this.index + 1\r\n    } else if (c === CharCodes.Questionmark) {\r\n      this.state = State.InProcessingInstruction\r\n      this.sectionStart = this.index + 1\r\n    } else if (isTagStartChar(c)) {\r\n      this.sectionStart = this.index\r\n      if (this.mode === ParseMode.BASE) {\r\n        // no special tags in base mode\r\n        this.state = State.InTagName\r\n      } else if (this.inSFCRoot) {\r\n        // SFC mode + root level\r\n        // - everything except <template> is RAWTEXT\r\n        // - <template> with lang other than html is also RAWTEXT\r\n        this.state = State.InSFCRootTagName\r\n      } else if (!this.inXML) {\r\n        // HTML mode\r\n        // - <script>, <style> RAWTEXT\r\n        // - <title>, <textarea> RCDATA\r\n        const lower = c | 0x20\r\n        if (lower === 116 /* t */) {\r\n          this.state = State.BeforeSpecialT\r\n        } else {\r\n          this.state =\r\n            lower === 115 /* s */ ? State.BeforeSpecialS : State.InTagName\r\n        }\r\n      } else {\r\n        this.state = State.InTagName\r\n      }\r\n    } else if (c === CharCodes.Slash) {\r\n      this.state = State.BeforeClosingTagName\r\n    } else {\r\n      this.state = State.Text\r\n      this.stateText(c)\r\n    }\r\n  }\r\n  private stateInTagName(c: number): void {\r\n    if (isEndOfTagSection(c)) {\r\n      this.handleTagName(c)\r\n    }\r\n  }\r\n  private stateInSFCRootTagName(c: number): void {\r\n    if (isEndOfTagSection(c)) {\r\n      const tag = this.buffer.slice(this.sectionStart, this.index)\r\n      if (tag !== 'template') {\r\n        this.enterRCDATA(toCharCodes(`</` + tag), 0)\r\n      }\r\n      this.handleTagName(c)\r\n    }\r\n  }\r\n  private handleTagName(c: number) {\r\n    this.cbs.onopentagname(this.sectionStart, this.index)\r\n    this.sectionStart = -1\r\n    this.state = State.BeforeAttrName\r\n    this.stateBeforeAttrName(c)\r\n  }\r\n  private stateBeforeClosingTagName(c: number): void {\r\n    if (isWhitespace(c)) {\r\n      // Ignore\r\n    } else if (c === CharCodes.Gt) {\r\n      if (__DEV__ || !__BROWSER__) {\r\n        this.cbs.onerr(ErrorCodes.MISSING_END_TAG_NAME, this.index)\r\n      }\r\n      this.state = State.Text\r\n      // Ignore\r\n      this.sectionStart = this.index + 1\r\n    } else {\r\n      this.state = isTagStartChar(c)\r\n        ? State.InClosingTagName\r\n        : State.InSpecialComment\r\n      this.sectionStart = this.index\r\n    }\r\n  }\r\n  private stateInClosingTagName(c: number): void {\r\n    if (c === CharCodes.Gt || isWhitespace(c)) {\r\n      this.cbs.onclosetag(this.sectionStart, this.index)\r\n      this.sectionStart = -1\r\n      this.state = State.AfterClosingTagName\r\n      this.stateAfterClosingTagName(c)\r\n    }\r\n  }\r\n  private stateAfterClosingTagName(c: number): void {\r\n    // Skip everything until \">\"\r\n    if (c === CharCodes.Gt) {\r\n      this.state = State.Text\r\n      this.sectionStart = this.index + 1\r\n    }\r\n  }\r\n  private stateBeforeAttrName(c: number): void {\r\n    if (c === CharCodes.Gt) {\r\n      this.cbs.onopentagend(this.index)\r\n      if (this.inRCDATA) {\r\n        this.state = State.InRCDATA\r\n      } else {\r\n        this.state = State.Text\r\n      }\r\n      this.sectionStart = this.index + 1\r\n    } else if (c === CharCodes.Slash) {\r\n      this.state = State.InSelfClosingTag\r\n      if ((__DEV__ || !__BROWSER__) && this.peek() !== CharCodes.Gt) {\r\n        this.cbs.onerr(ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG, this.index)\r\n      }\r\n    } else if (c === CharCodes.Lt && this.peek() === CharCodes.Slash) {\r\n      // special handling for </ appearing in open tag state\r\n      // this is different from standard HTML parsing but makes practical sense\r\n      // especially for parsing intermediate input state in IDEs.\r\n      this.cbs.onopentagend(this.index)\r\n      this.state = State.BeforeTagName\r\n      this.sectionStart = this.index\r\n    } else if (!isWhitespace(c)) {\r\n      if ((__DEV__ || !__BROWSER__) && c === CharCodes.Eq) {\r\n        this.cbs.onerr(\r\n          ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME,\r\n          this.index,\r\n        )\r\n      }\r\n      this.handleAttrStart(c)\r\n    }\r\n  }\r\n  private handleAttrStart(c: number) {\r\n    if (c === CharCodes.LowerV && this.peek() === CharCodes.Dash) {\r\n      this.state = State.InDirName\r\n      this.sectionStart = this.index\r\n    } else if (\r\n      c === CharCodes.Dot ||\r\n      c === CharCodes.Colon ||\r\n      c === CharCodes.At ||\r\n      c === CharCodes.Number\r\n    ) {\r\n      this.cbs.ondirname(this.index, this.index + 1)\r\n      this.state = State.InDirArg\r\n      this.sectionStart = this.index + 1\r\n    } else {\r\n      this.state = State.InAttrName\r\n      this.sectionStart = this.index\r\n    }\r\n  }\r\n  private stateInSelfClosingTag(c: number): void {\r\n    if (c === CharCodes.Gt) {\r\n      this.cbs.onselfclosingtag(this.index)\r\n      this.state = State.Text\r\n      this.sectionStart = this.index + 1\r\n      this.inRCDATA = false // Reset special state, in case of self-closing special tags\r\n    } else if (!isWhitespace(c)) {\r\n      this.state = State.BeforeAttrName\r\n      this.stateBeforeAttrName(c)\r\n    }\r\n  }\r\n  private stateInAttrName(c: number): void {\r\n    if (c === CharCodes.Eq || isEndOfTagSection(c)) {\r\n      this.cbs.onattribname(this.sectionStart, this.index)\r\n      this.handleAttrNameEnd(c)\r\n    } else if (\r\n      (__DEV__ || !__BROWSER__) &&\r\n      (c === CharCodes.DoubleQuote ||\r\n        c === CharCodes.SingleQuote ||\r\n        c === CharCodes.Lt)\r\n    ) {\r\n      this.cbs.onerr(\r\n        ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME,\r\n        this.index,\r\n      )\r\n    }\r\n  }\r\n  private stateInDirName(c: number): void {\r\n    if (c === CharCodes.Eq || isEndOfTagSection(c)) {\r\n      this.cbs.ondirname(this.sectionStart, this.index)\r\n      this.handleAttrNameEnd(c)\r\n    } else if (c === CharCodes.Colon) {\r\n      this.cbs.ondirname(this.sectionStart, this.index)\r\n      this.state = State.InDirArg\r\n      this.sectionStart = this.index + 1\r\n    } else if (c === CharCodes.Dot) {\r\n      this.cbs.ondirname(this.sectionStart, this.index)\r\n      this.state = State.InDirModifier\r\n      this.sectionStart = this.index + 1\r\n    }\r\n  }\r\n  private stateInDirArg(c: number): void {\r\n    if (c === CharCodes.Eq || isEndOfTagSection(c)) {\r\n      this.cbs.ondirarg(this.sectionStart, this.index)\r\n      this.handleAttrNameEnd(c)\r\n    } else if (c === CharCodes.LeftSquare) {\r\n      this.state = State.InDirDynamicArg\r\n    } else if (c === CharCodes.Dot) {\r\n      this.cbs.ondirarg(this.sectionStart, this.index)\r\n      this.state = State.InDirModifier\r\n      this.sectionStart = this.index + 1\r\n    }\r\n  }\r\n  private stateInDynamicDirArg(c: number): void {\r\n    if (c === CharCodes.RightSquare) {\r\n      this.state = State.InDirArg\r\n    } else if (c === CharCodes.Eq || isEndOfTagSection(c)) {\r\n      this.cbs.ondirarg(this.sectionStart, this.index + 1)\r\n      this.handleAttrNameEnd(c)\r\n      if (__DEV__ || !__BROWSER__) {\r\n        this.cbs.onerr(\r\n          ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END,\r\n          this.index,\r\n        )\r\n      }\r\n    }\r\n  }\r\n  private stateInDirModifier(c: number): void {\r\n    if (c === CharCodes.Eq || isEndOfTagSection(c)) {\r\n      this.cbs.ondirmodifier(this.sectionStart, this.index)\r\n      this.handleAttrNameEnd(c)\r\n    } else if (c === CharCodes.Dot) {\r\n      this.cbs.ondirmodifier(this.sectionStart, this.index)\r\n      this.sectionStart = this.index + 1\r\n    }\r\n  }\r\n  private handleAttrNameEnd(c: number): void {\r\n    this.sectionStart = this.index\r\n    this.state = State.AfterAttrName\r\n    this.cbs.onattribnameend(this.index)\r\n    this.stateAfterAttrName(c)\r\n  }\r\n  private stateAfterAttrName(c: number): void {\r\n    if (c === CharCodes.Eq) {\r\n      this.state = State.BeforeAttrValue\r\n    } else if (c === CharCodes.Slash || c === CharCodes.Gt) {\r\n      this.cbs.onattribend(QuoteType.NoValue, this.sectionStart)\r\n      this.sectionStart = -1\r\n      this.state = State.BeforeAttrName\r\n      this.stateBeforeAttrName(c)\r\n    } else if (!isWhitespace(c)) {\r\n      this.cbs.onattribend(QuoteType.NoValue, this.sectionStart)\r\n      this.handleAttrStart(c)\r\n    }\r\n  }\r\n  private stateBeforeAttrValue(c: number): void {\r\n    if (c === CharCodes.DoubleQuote) {\r\n      this.state = State.InAttrValueDq\r\n      this.sectionStart = this.index + 1\r\n    } else if (c === CharCodes.SingleQuote) {\r\n      this.state = State.InAttrValueSq\r\n      this.sectionStart = this.index + 1\r\n    } else if (!isWhitespace(c)) {\r\n      this.sectionStart = this.index\r\n      this.state = State.InAttrValueNq\r\n      this.stateInAttrValueNoQuotes(c) // Reconsume token\r\n    }\r\n  }\r\n  private handleInAttrValue(c: number, quote: number) {\r\n    if (c === quote || (__BROWSER__ && this.fastForwardTo(quote))) {\r\n      this.cbs.onattribdata(this.sectionStart, this.index)\r\n      this.sectionStart = -1\r\n      this.cbs.onattribend(\r\n        quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single,\r\n        this.index + 1,\r\n      )\r\n      this.state = State.BeforeAttrName\r\n    } else if (!__BROWSER__ && c === CharCodes.Amp) {\r\n      this.startEntity()\r\n    }\r\n  }\r\n  private stateInAttrValueDoubleQuotes(c: number): void {\r\n    this.handleInAttrValue(c, CharCodes.DoubleQuote)\r\n  }\r\n  private stateInAttrValueSingleQuotes(c: number): void {\r\n    this.handleInAttrValue(c, CharCodes.SingleQuote)\r\n  }\r\n  private stateInAttrValueNoQuotes(c: number): void {\r\n    if (isWhitespace(c) || c === CharCodes.Gt) {\r\n      this.cbs.onattribdata(this.sectionStart, this.index)\r\n      this.sectionStart = -1\r\n      this.cbs.onattribend(QuoteType.Unquoted, this.index)\r\n      this.state = State.BeforeAttrName\r\n      this.stateBeforeAttrName(c)\r\n    } else if (\r\n      ((__DEV__ || !__BROWSER__) && c === CharCodes.DoubleQuote) ||\r\n      c === CharCodes.SingleQuote ||\r\n      c === CharCodes.Lt ||\r\n      c === CharCodes.Eq ||\r\n      c === CharCodes.GraveAccent\r\n    ) {\r\n      this.cbs.onerr(\r\n        ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE,\r\n        this.index,\r\n      )\r\n    } else if (!__BROWSER__ && c === CharCodes.Amp) {\r\n      this.startEntity()\r\n    }\r\n  }\r\n  private stateBeforeDeclaration(c: number): void {\r\n    if (c === CharCodes.LeftSquare) {\r\n      this.state = State.CDATASequence\r\n      this.sequenceIndex = 0\r\n    } else {\r\n      this.state =\r\n        c === CharCodes.Dash ? State.BeforeComment : State.InDeclaration\r\n    }\r\n  }\r\n  private stateInDeclaration(c: number): void {\r\n    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\r\n      // this.cbs.ondeclaration(this.sectionStart, this.index)\r\n      this.state = State.Text\r\n      this.sectionStart = this.index + 1\r\n    }\r\n  }\r\n  private stateInProcessingInstruction(c: number): void {\r\n    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\r\n      this.cbs.onprocessinginstruction(this.sectionStart, this.index)\r\n      this.state = State.Text\r\n      this.sectionStart = this.index + 1\r\n    }\r\n  }\r\n  private stateBeforeComment(c: number): void {\r\n    if (c === CharCodes.Dash) {\r\n      this.state = State.InCommentLike\r\n      this.currentSequence = Sequences.CommentEnd\r\n      // Allow short comments (eg. <!-->)\r\n      this.sequenceIndex = 2\r\n      this.sectionStart = this.index + 1\r\n    } else {\r\n      this.state = State.InDeclaration\r\n    }\r\n  }\r\n  private stateInSpecialComment(c: number): void {\r\n    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\r\n      this.cbs.oncomment(this.sectionStart, this.index)\r\n      this.state = State.Text\r\n      this.sectionStart = this.index + 1\r\n    }\r\n  }\r\n  private stateBeforeSpecialS(c: number): void {\r\n    const lower = c | 0x20\r\n    if (lower === Sequences.ScriptEnd[3]) {\r\n      this.startSpecial(Sequences.ScriptEnd, 4)\r\n    } else if (lower === Sequences.StyleEnd[3]) {\r\n      this.startSpecial(Sequences.StyleEnd, 4)\r\n    } else {\r\n      this.state = State.InTagName\r\n      this.stateInTagName(c) // Consume the token again\r\n    }\r\n  }\r\n  private stateBeforeSpecialT(c: number): void {\r\n    const lower = c | 0x20\r\n    if (lower === Sequences.TitleEnd[3]) {\r\n      this.startSpecial(Sequences.TitleEnd, 4)\r\n    } else if (lower === Sequences.TextareaEnd[3]) {\r\n      this.startSpecial(Sequences.TextareaEnd, 4)\r\n    } else {\r\n      this.state = State.InTagName\r\n      this.stateInTagName(c) // Consume the token again\r\n    }\r\n  }\r\n\r\n  private startEntity() {\r\n    if (!__BROWSER__) {\r\n      this.baseState = this.state\r\n      this.state = State.InEntity\r\n      this.entityStart = this.index\r\n      this.entityDecoder!.startEntity(\r\n        this.baseState === State.Text || this.baseState === State.InRCDATA\r\n          ? DecodingMode.Legacy\r\n          : DecodingMode.Attribute,\r\n      )\r\n    }\r\n  }\r\n\r\n  private stateInEntity(): void {\r\n    if (!__BROWSER__) {\r\n      const length = this.entityDecoder!.write(this.buffer, this.index)\r\n\r\n      // If `length` is positive, we are done with the entity.\r\n      if (length >= 0) {\r\n        this.state = this.baseState\r\n\r\n        if (length === 0) {\r\n          this.index = this.entityStart\r\n        }\r\n      } else {\r\n        // Mark buffer as consumed.\r\n        this.index = this.buffer.length - 1\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Iterates through the buffer, calling the function corresponding to the current state.\r\n   *\r\n   * States that are more likely to be hit are higher up, as a performance improvement.\r\n   */\r\n  public parse(input: string) {\r\n    this.buffer = input\r\n    while (this.index < this.buffer.length) {\r\n      const c = this.buffer.charCodeAt(this.index)\r\n      if (c === CharCodes.NewLine) {\r\n        this.newlines.push(this.index)\r\n      }\r\n      switch (this.state) {\r\n        case State.Text: {\r\n          this.stateText(c)\r\n          break\r\n        }\r\n        case State.InterpolationOpen: {\r\n          this.stateInterpolationOpen(c)\r\n          break\r\n        }\r\n        case State.Interpolation: {\r\n          this.stateInterpolation(c)\r\n          break\r\n        }\r\n        case State.InterpolationClose: {\r\n          this.stateInterpolationClose(c)\r\n          break\r\n        }\r\n        case State.SpecialStartSequence: {\r\n          this.stateSpecialStartSequence(c)\r\n          break\r\n        }\r\n        case State.InRCDATA: {\r\n          this.stateInRCDATA(c)\r\n          break\r\n        }\r\n        case State.CDATASequence: {\r\n          this.stateCDATASequence(c)\r\n          break\r\n        }\r\n        case State.InAttrValueDq: {\r\n          this.stateInAttrValueDoubleQuotes(c)\r\n          break\r\n        }\r\n        case State.InAttrName: {\r\n          this.stateInAttrName(c)\r\n          break\r\n        }\r\n        case State.InDirName: {\r\n          this.stateInDirName(c)\r\n          break\r\n        }\r\n        case State.InDirArg: {\r\n          this.stateInDirArg(c)\r\n          break\r\n        }\r\n        case State.InDirDynamicArg: {\r\n          this.stateInDynamicDirArg(c)\r\n          break\r\n        }\r\n        case State.InDirModifier: {\r\n          this.stateInDirModifier(c)\r\n          break\r\n        }\r\n        case State.InCommentLike: {\r\n          this.stateInCommentLike(c)\r\n          break\r\n        }\r\n        case State.InSpecialComment: {\r\n          this.stateInSpecialComment(c)\r\n          break\r\n        }\r\n        case State.BeforeAttrName: {\r\n          this.stateBeforeAttrName(c)\r\n          break\r\n        }\r\n        case State.InTagName: {\r\n          this.stateInTagName(c)\r\n          break\r\n        }\r\n        case State.InSFCRootTagName: {\r\n          this.stateInSFCRootTagName(c)\r\n          break\r\n        }\r\n        case State.InClosingTagName: {\r\n          this.stateInClosingTagName(c)\r\n          break\r\n        }\r\n        case State.BeforeTagName: {\r\n          this.stateBeforeTagName(c)\r\n          break\r\n        }\r\n        case State.AfterAttrName: {\r\n          this.stateAfterAttrName(c)\r\n          break\r\n        }\r\n        case State.InAttrValueSq: {\r\n          this.stateInAttrValueSingleQuotes(c)\r\n          break\r\n        }\r\n        case State.BeforeAttrValue: {\r\n          this.stateBeforeAttrValue(c)\r\n          break\r\n        }\r\n        case State.BeforeClosingTagName: {\r\n          this.stateBeforeClosingTagName(c)\r\n          break\r\n        }\r\n        case State.AfterClosingTagName: {\r\n          this.stateAfterClosingTagName(c)\r\n          break\r\n        }\r\n        case State.BeforeSpecialS: {\r\n          this.stateBeforeSpecialS(c)\r\n          break\r\n        }\r\n        case State.BeforeSpecialT: {\r\n          this.stateBeforeSpecialT(c)\r\n          break\r\n        }\r\n        case State.InAttrValueNq: {\r\n          this.stateInAttrValueNoQuotes(c)\r\n          break\r\n        }\r\n        case State.InSelfClosingTag: {\r\n          this.stateInSelfClosingTag(c)\r\n          break\r\n        }\r\n        case State.InDeclaration: {\r\n          this.stateInDeclaration(c)\r\n          break\r\n        }\r\n        case State.BeforeDeclaration: {\r\n          this.stateBeforeDeclaration(c)\r\n          break\r\n        }\r\n        case State.BeforeComment: {\r\n          this.stateBeforeComment(c)\r\n          break\r\n        }\r\n        case State.InProcessingInstruction: {\r\n          this.stateInProcessingInstruction(c)\r\n          break\r\n        }\r\n        case State.InEntity: {\r\n          this.stateInEntity()\r\n          break\r\n        }\r\n      }\r\n      this.index++\r\n    }\r\n    this.cleanup()\r\n    this.finish()\r\n  }\r\n\r\n  /**\r\n   * Remove data that has already been consumed from the buffer.\r\n   */\r\n  private cleanup() {\r\n    // If we are inside of text or attributes, emit what we already have.\r\n    if (this.sectionStart !== this.index) {\r\n      if (\r\n        this.state === State.Text ||\r\n        (this.state === State.InRCDATA && this.sequenceIndex === 0)\r\n      ) {\r\n        this.cbs.ontext(this.sectionStart, this.index)\r\n        this.sectionStart = this.index\r\n      } else if (\r\n        this.state === State.InAttrValueDq ||\r\n        this.state === State.InAttrValueSq ||\r\n        this.state === State.InAttrValueNq\r\n      ) {\r\n        this.cbs.onattribdata(this.sectionStart, this.index)\r\n        this.sectionStart = this.index\r\n      }\r\n    }\r\n  }\r\n\r\n  private finish() {\r\n    if (!__BROWSER__ && this.state === State.InEntity) {\r\n      this.entityDecoder!.end()\r\n      this.state = this.baseState\r\n    }\r\n\r\n    this.handleTrailingData()\r\n\r\n    this.cbs.onend()\r\n  }\r\n\r\n  /** Handle any trailing data. */\r\n  private handleTrailingData() {\r\n    const endIndex = this.buffer.length\r\n\r\n    // If there is no remaining data, we are done.\r\n    if (this.sectionStart >= endIndex) {\r\n      return\r\n    }\r\n\r\n    if (this.state === State.InCommentLike) {\r\n      if (this.currentSequence === Sequences.CdataEnd) {\r\n        this.cbs.oncdata(this.sectionStart, endIndex)\r\n      } else {\r\n        this.cbs.oncomment(this.sectionStart, endIndex)\r\n      }\r\n    } else if (\r\n      this.state === State.InTagName ||\r\n      this.state === State.BeforeAttrName ||\r\n      this.state === State.BeforeAttrValue ||\r\n      this.state === State.AfterAttrName ||\r\n      this.state === State.InAttrName ||\r\n      this.state === State.InDirName ||\r\n      this.state === State.InDirArg ||\r\n      this.state === State.InDirDynamicArg ||\r\n      this.state === State.InDirModifier ||\r\n      this.state === State.InAttrValueSq ||\r\n      this.state === State.InAttrValueDq ||\r\n      this.state === State.InAttrValueNq ||\r\n      this.state === State.InClosingTagName\r\n    ) {\r\n      /*\r\n       * If we are currently in an opening or closing tag, us not calling the\r\n       * respective callback signals that the tag should be ignored.\r\n       */\r\n    } else {\r\n      this.cbs.ontext(this.sectionStart, endIndex)\r\n    }\r\n  }\r\n\r\n  private emitCodePoint(cp: number, consumed: number): void {\r\n    if (!__BROWSER__) {\r\n      if (this.baseState !== State.Text && this.baseState !== State.InRCDATA) {\r\n        if (this.sectionStart < this.entityStart) {\r\n          this.cbs.onattribdata(this.sectionStart, this.entityStart)\r\n        }\r\n        this.sectionStart = this.entityStart + consumed\r\n        this.index = this.sectionStart - 1\r\n\r\n        this.cbs.onattribentity(\r\n          fromCodePoint(cp),\r\n          this.entityStart,\r\n          this.sectionStart,\r\n        )\r\n      } else {\r\n        if (this.sectionStart < this.entityStart) {\r\n          this.cbs.ontext(this.sectionStart, this.entityStart)\r\n        }\r\n        this.sectionStart = this.entityStart + consumed\r\n        this.index = this.sectionStart - 1\r\n\r\n        this.cbs.ontextentity(\r\n          fromCodePoint(cp),\r\n          this.entityStart,\r\n          this.sectionStart,\r\n        )\r\n      }\r\n    }\r\n  }\r\n}\r\n","import type { SourceLocation } from '../ast'\r\nimport type { CompilerError } from '../errors'\r\nimport type { MergedParserOptions } from '../parser'\r\nimport type { TransformContext } from '../transform'\r\n\r\nexport type CompilerCompatConfig = Partial<\r\n  Record<CompilerDeprecationTypes, boolean | 'suppress-warning'>\r\n> & {\r\n  MODE?: 2 | 3\r\n}\r\n\r\nexport interface CompilerCompatOptions {\r\n  compatConfig?: CompilerCompatConfig\r\n}\r\n\r\nexport enum CompilerDeprecationTypes {\r\n  COMPILER_IS_ON_ELEMENT = 'COMPILER_IS_ON_ELEMENT',\r\n  COMPILER_V_BIND_SYNC = 'COMPILER_V_BIND_SYNC',\r\n  COMPILER_V_BIND_OBJECT_ORDER = 'COMPILER_V_BIND_OBJECT_ORDER',\r\n  COMPILER_V_ON_NATIVE = 'COMPILER_V_ON_NATIVE',\r\n  COMPILER_V_IF_V_FOR_PRECEDENCE = 'COMPILER_V_IF_V_FOR_PRECEDENCE',\r\n  COMPILER_NATIVE_TEMPLATE = 'COMPILER_NATIVE_TEMPLATE',\r\n  COMPILER_INLINE_TEMPLATE = 'COMPILER_INLINE_TEMPLATE',\r\n  COMPILER_FILTERS = 'COMPILER_FILTERS',\r\n}\r\n\r\ntype DeprecationData = {\r\n  message: string | ((...args: any[]) => string)\r\n  link?: string\r\n}\r\n\r\nconst deprecationData: Record<CompilerDeprecationTypes, DeprecationData> = {\r\n  [CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT]: {\r\n    message:\r\n      `Platform-native elements with \"is\" prop will no longer be ` +\r\n      `treated as components in Vue 3 unless the \"is\" value is explicitly ` +\r\n      `prefixed with \"vue:\".`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`,\r\n  },\r\n\r\n  [CompilerDeprecationTypes.COMPILER_V_BIND_SYNC]: {\r\n    message: key =>\r\n      `.sync modifier for v-bind has been removed. Use v-model with ` +\r\n      `argument instead. \\`v-bind:${key}.sync\\` should be changed to ` +\r\n      `\\`v-model:${key}\\`.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`,\r\n  },\r\n\r\n  [CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER]: {\r\n    message:\r\n      `v-bind=\"obj\" usage is now order sensitive and behaves like JavaScript ` +\r\n      `object spread: it will now overwrite an existing non-mergeable attribute ` +\r\n      `that appears before v-bind in the case of conflict. ` +\r\n      `To retain 2.x behavior, move v-bind to make it the first attribute. ` +\r\n      `You can also suppress this warning if the usage is intended.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`,\r\n  },\r\n\r\n  [CompilerDeprecationTypes.COMPILER_V_ON_NATIVE]: {\r\n    message: `.native modifier for v-on has been removed as is no longer necessary.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`,\r\n  },\r\n\r\n  [CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE]: {\r\n    message:\r\n      `v-if / v-for precedence when used on the same element has changed ` +\r\n      `in Vue 3: v-if now takes higher precedence and will no longer have ` +\r\n      `access to v-for scope variables. It is best to avoid the ambiguity ` +\r\n      `with <template> tags or use a computed property that filters v-for ` +\r\n      `data source.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`,\r\n  },\r\n\r\n  [CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE]: {\r\n    message:\r\n      `<template> with no special directives will render as a native template ` +\r\n      `element instead of its inner content in Vue 3.`,\r\n  },\r\n\r\n  [CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE]: {\r\n    message: `\"inline-template\" has been removed in Vue 3.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`,\r\n  },\r\n\r\n  [CompilerDeprecationTypes.COMPILER_FILTERS]: {\r\n    message:\r\n      `filters have been removed in Vue 3. ` +\r\n      `The \"|\" symbol will be treated as native JavaScript bitwise OR operator. ` +\r\n      `Use method calls or computed properties instead.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`,\r\n  },\r\n}\r\n\r\nfunction getCompatValue(\r\n  key: CompilerDeprecationTypes | 'MODE',\r\n  { compatConfig }: MergedParserOptions | TransformContext,\r\n) {\r\n  const value = compatConfig && compatConfig[key]\r\n  if (key === 'MODE') {\r\n    return value || 3 // compiler defaults to v3 behavior\r\n  } else {\r\n    return value\r\n  }\r\n}\r\n\r\nexport function isCompatEnabled(\r\n  key: CompilerDeprecationTypes,\r\n  context: MergedParserOptions | TransformContext,\r\n) {\r\n  const mode = getCompatValue('MODE', context)\r\n  const value = getCompatValue(key, context)\r\n  // in v3 mode, only enable if explicitly set to true\r\n  // otherwise enable for any non-false value\r\n  return mode === 3 ? value === true : value !== false\r\n}\r\n\r\nexport function checkCompatEnabled(\r\n  key: CompilerDeprecationTypes,\r\n  context: MergedParserOptions | TransformContext,\r\n  loc: SourceLocation | null,\r\n  ...args: any[]\r\n): boolean {\r\n  const enabled = isCompatEnabled(key, context)\r\n  if (__DEV__ && enabled) {\r\n    warnDeprecation(key, context, loc, ...args)\r\n  }\r\n  return enabled\r\n}\r\n\r\nexport function warnDeprecation(\r\n  key: CompilerDeprecationTypes,\r\n  context: MergedParserOptions | TransformContext,\r\n  loc: SourceLocation | null,\r\n  ...args: any[]\r\n) {\r\n  const val = getCompatValue(key, context)\r\n  if (val === 'suppress-warning') {\r\n    return\r\n  }\r\n  const { message, link } = deprecationData[key]\r\n  const msg = `(deprecation ${key}) ${\r\n    typeof message === 'function' ? message(...args) : message\r\n  }${link ? `\\n  Details: ${link}` : ``}`\r\n\r\n  const err = new SyntaxError(msg) as CompilerError\r\n  err.code = key\r\n  if (loc) err.loc = loc\r\n  context.onWarn(err)\r\n}\r\n","import type { SourceLocation } from './ast'\r\n\r\nexport interface CompilerError extends SyntaxError {\r\n  code: number | string\r\n  loc?: SourceLocation\r\n}\r\n\r\nexport interface CoreCompilerError extends CompilerError {\r\n  code: ErrorCodes\r\n}\r\n\r\nexport function defaultOnError(error: CompilerError) {\r\n  throw error\r\n}\r\n\r\nexport function defaultOnWarn(msg: CompilerError) {\r\n  __DEV__ && console.warn(`[Vue warn] ${msg.message}`)\r\n}\r\n\r\ntype InferCompilerError<T> = T extends ErrorCodes\r\n  ? CoreCompilerError\r\n  : CompilerError\r\n\r\nexport function createCompilerError<T extends number>(\r\n  code: T,\r\n  loc?: SourceLocation,\r\n  messages?: { [code: number]: string },\r\n  additionalMessage?: string,\r\n): InferCompilerError<T> {\r\n  const msg =\r\n    __DEV__ || !__BROWSER__\r\n      ? (messages || errorMessages)[code] + (additionalMessage || ``)\r\n      : `https://vuejs.org/error-reference/#compiler-${code}`\r\n  const error = new SyntaxError(String(msg)) as InferCompilerError<T>\r\n  error.code = code\r\n  error.loc = loc\r\n  return error\r\n}\r\n\r\nexport enum ErrorCodes {\r\n  // parse errors\r\n  ABRUPT_CLOSING_OF_EMPTY_COMMENT,\r\n  CDATA_IN_HTML_CONTENT,\r\n  DUPLICATE_ATTRIBUTE,\r\n  END_TAG_WITH_ATTRIBUTES,\r\n  END_TAG_WITH_TRAILING_SOLIDUS,\r\n  EOF_BEFORE_TAG_NAME,\r\n  EOF_IN_CDATA,\r\n  EOF_IN_COMMENT,\r\n  EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT,\r\n  EOF_IN_TAG,\r\n  INCORRECTLY_CLOSED_COMMENT,\r\n  INCORRECTLY_OPENED_COMMENT,\r\n  INVALID_FIRST_CHARACTER_OF_TAG_NAME,\r\n  MISSING_ATTRIBUTE_VALUE,\r\n  MISSING_END_TAG_NAME,\r\n  MISSING_WHITESPACE_BETWEEN_ATTRIBUTES,\r\n  NESTED_COMMENT,\r\n  UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME,\r\n  UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE,\r\n  UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME,\r\n  UNEXPECTED_NULL_CHARACTER,\r\n  UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,\r\n  UNEXPECTED_SOLIDUS_IN_TAG,\r\n\r\n  // Vue-specific parse errors\r\n  X_INVALID_END_TAG,\r\n  X_MISSING_END_TAG,\r\n  X_MISSING_INTERPOLATION_END,\r\n  X_MISSING_DIRECTIVE_NAME,\r\n  X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END,\r\n\r\n  // transform errors\r\n  X_V_IF_NO_EXPRESSION,\r\n  X_V_IF_SAME_KEY,\r\n  X_V_ELSE_NO_ADJACENT_IF,\r\n  X_V_FOR_NO_EXPRESSION,\r\n  X_V_FOR_MALFORMED_EXPRESSION,\r\n  X_V_FOR_TEMPLATE_KEY_PLACEMENT,\r\n  X_V_BIND_NO_EXPRESSION,\r\n  X_V_ON_NO_EXPRESSION,\r\n  X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET,\r\n  X_V_SLOT_MIXED_SLOT_USAGE,\r\n  X_V_SLOT_DUPLICATE_SLOT_NAMES,\r\n  X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN,\r\n  X_V_SLOT_MISPLACED,\r\n  X_V_MODEL_NO_EXPRESSION,\r\n  X_V_MODEL_MALFORMED_EXPRESSION,\r\n  X_V_MODEL_ON_SCOPE_VARIABLE,\r\n  X_V_MODEL_ON_PROPS,\r\n  X_INVALID_EXPRESSION,\r\n  X_KEEP_ALIVE_INVALID_CHILDREN,\r\n\r\n  // generic errors\r\n  X_PREFIX_ID_NOT_SUPPORTED,\r\n  X_MODULE_MODE_NOT_SUPPORTED,\r\n  X_CACHE_HANDLER_NOT_SUPPORTED,\r\n  X_SCOPE_ID_NOT_SUPPORTED,\r\n  X_VNODE_HOOKS,\r\n\r\n  // Special value for higher-order compilers to pick up the last code\r\n  // to avoid collision of error codes. This should always be kept as the last\r\n  // item.\r\n  __EXTEND_POINT__,\r\n}\r\n\r\nexport const errorMessages: Record<ErrorCodes, string> = {\r\n  // parse errors\r\n  [ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT]: 'Illegal comment.',\r\n  [ErrorCodes.CDATA_IN_HTML_CONTENT]:\r\n    'CDATA section is allowed only in XML context.',\r\n  [ErrorCodes.DUPLICATE_ATTRIBUTE]: 'Duplicate attribute.',\r\n  [ErrorCodes.END_TAG_WITH_ATTRIBUTES]: 'End tag cannot have attributes.',\r\n  [ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS]: \"Illegal '/' in tags.\",\r\n  [ErrorCodes.EOF_BEFORE_TAG_NAME]: 'Unexpected EOF in tag.',\r\n  [ErrorCodes.EOF_IN_CDATA]: 'Unexpected EOF in CDATA section.',\r\n  [ErrorCodes.EOF_IN_COMMENT]: 'Unexpected EOF in comment.',\r\n  [ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT]:\r\n    'Unexpected EOF in script.',\r\n  [ErrorCodes.EOF_IN_TAG]: 'Unexpected EOF in tag.',\r\n  [ErrorCodes.INCORRECTLY_CLOSED_COMMENT]: 'Incorrectly closed comment.',\r\n  [ErrorCodes.INCORRECTLY_OPENED_COMMENT]: 'Incorrectly opened comment.',\r\n  [ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME]:\r\n    \"Illegal tag name. Use '&lt;' to print '<'.\",\r\n  [ErrorCodes.MISSING_ATTRIBUTE_VALUE]: 'Attribute value was expected.',\r\n  [ErrorCodes.MISSING_END_TAG_NAME]: 'End tag name was expected.',\r\n  [ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES]:\r\n    'Whitespace was expected.',\r\n  [ErrorCodes.NESTED_COMMENT]: \"Unexpected '<!--' in comment.\",\r\n  [ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME]:\r\n    'Attribute name cannot contain U+0022 (\"), U+0027 (\\'), and U+003C (<).',\r\n  [ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE]:\r\n    'Unquoted attribute value cannot contain U+0022 (\"), U+0027 (\\'), U+003C (<), U+003D (=), and U+0060 (`).',\r\n  [ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME]:\r\n    \"Attribute name cannot start with '='.\",\r\n  [ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME]:\r\n    \"'<?' is allowed only in XML context.\",\r\n  [ErrorCodes.UNEXPECTED_NULL_CHARACTER]: `Unexpected null character.`,\r\n  [ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG]: \"Illegal '/' in tags.\",\r\n\r\n  // Vue-specific parse errors\r\n  [ErrorCodes.X_INVALID_END_TAG]: 'Invalid end tag.',\r\n  [ErrorCodes.X_MISSING_END_TAG]: 'Element is missing end tag.',\r\n  [ErrorCodes.X_MISSING_INTERPOLATION_END]:\r\n    'Interpolation end sign was not found.',\r\n  [ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END]:\r\n    'End bracket for dynamic directive argument was not found. ' +\r\n    'Note that dynamic directive argument cannot contain spaces.',\r\n  [ErrorCodes.X_MISSING_DIRECTIVE_NAME]: 'Legal directive name was expected.',\r\n\r\n  // transform errors\r\n  [ErrorCodes.X_V_IF_NO_EXPRESSION]: `v-if/v-else-if is missing expression.`,\r\n  [ErrorCodes.X_V_IF_SAME_KEY]: `v-if/else branches must use unique keys.`,\r\n  [ErrorCodes.X_V_ELSE_NO_ADJACENT_IF]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,\r\n  [ErrorCodes.X_V_FOR_NO_EXPRESSION]: `v-for is missing expression.`,\r\n  [ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION]: `v-for has invalid expression.`,\r\n  [ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT]: `<template v-for> key should be placed on the <template> tag.`,\r\n  [ErrorCodes.X_V_BIND_NO_EXPRESSION]: `v-bind is missing expression.`,\r\n  [ErrorCodes.X_V_ON_NO_EXPRESSION]: `v-on is missing expression.`,\r\n  [ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET]: `Unexpected custom directive on <slot> outlet.`,\r\n  [ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE]:\r\n    `Mixed v-slot usage on both the component and nested <template>. ` +\r\n    `When there are multiple named slots, all slots should use <template> ` +\r\n    `syntax to avoid scope ambiguity.`,\r\n  [ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES]: `Duplicate slot names found. `,\r\n  [ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN]:\r\n    `Extraneous children found when component already has explicitly named ` +\r\n    `default slot. These children will be ignored.`,\r\n  [ErrorCodes.X_V_SLOT_MISPLACED]: `v-slot can only be used on components or <template> tags.`,\r\n  [ErrorCodes.X_V_MODEL_NO_EXPRESSION]: `v-model is missing expression.`,\r\n  [ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION]: `v-model value must be a valid JavaScript member expression.`,\r\n  [ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,\r\n  [ErrorCodes.X_V_MODEL_ON_PROPS]: `v-model cannot be used on a prop, because local prop bindings are not writable.\\nUse a v-bind binding combined with a v-on listener that emits update:x event instead.`,\r\n  [ErrorCodes.X_INVALID_EXPRESSION]: `Error parsing JavaScript expression: `,\r\n  [ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN]: `<KeepAlive> expects exactly one child component.`,\r\n  [ErrorCodes.X_VNODE_HOOKS]: `@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.`,\r\n\r\n  // generic errors\r\n  [ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED]: `\"prefixIdentifiers\" option is not supported in this build of compiler.`,\r\n  [ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED]: `ES module mode is not supported in this build of compiler.`,\r\n  [ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED]: `\"cacheHandlers\" option is only supported when the \"prefixIdentifiers\" option is enabled.`,\r\n  [ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED]: `\"scopeId\" option is only supported in module mode.`,\r\n\r\n  // just to fulfill types\r\n  [ErrorCodes.__EXTEND_POINT__]: ``,\r\n}\r\n","// should only use types from @babel/types\r\n// do not import runtime methods\r\nimport type {\r\n  BlockStatement,\r\n  Function,\r\n  Identifier,\r\n  Node,\r\n  ObjectProperty,\r\n  Program,\r\n} from '@babel/types'\r\nimport { walk } from 'estree-walker'\r\n\r\nexport function walkIdentifiers(\r\n  root: Node,\r\n  onIdentifier: (\r\n    node: Identifier,\r\n    parent: Node,\r\n    parentStack: Node[],\r\n    isReference: boolean,\r\n    isLocal: boolean,\r\n  ) => void,\r\n  includeAll = false,\r\n  parentStack: Node[] = [],\r\n  knownIds: Record<string, number> = Object.create(null),\r\n) {\r\n  if (__BROWSER__) {\r\n    return\r\n  }\r\n\r\n  const rootExp =\r\n    root.type === 'Program'\r\n      ? root.body[0].type === 'ExpressionStatement' && root.body[0].expression\r\n      : root\r\n\r\n  walk(root, {\r\n    enter(node: Node & { scopeIds?: Set<string> }, parent: Node | undefined) {\r\n      parent && parentStack.push(parent)\r\n      if (\r\n        parent &&\r\n        parent.type.startsWith('TS') &&\r\n        !TS_NODE_TYPES.includes(parent.type)\r\n      ) {\r\n        return this.skip()\r\n      }\r\n      if (node.type === 'Identifier') {\r\n        const isLocal = !!knownIds[node.name]\r\n        const isRefed = isReferencedIdentifier(node, parent!, parentStack)\r\n        if (includeAll || (isRefed && !isLocal)) {\r\n          onIdentifier(node, parent!, parentStack, isRefed, isLocal)\r\n        }\r\n      } else if (\r\n        node.type === 'ObjectProperty' &&\r\n        parent?.type === 'ObjectPattern'\r\n      ) {\r\n        // mark property in destructure pattern\r\n        ;(node as any).inPattern = true\r\n      } else if (isFunctionType(node)) {\r\n        if (node.scopeIds) {\r\n          node.scopeIds.forEach(id => markKnownIds(id, knownIds))\r\n        } else {\r\n          // walk function expressions and add its arguments to known identifiers\r\n          // so that we don't prefix them\r\n          walkFunctionParams(node, id =>\r\n            markScopeIdentifier(node, id, knownIds),\r\n          )\r\n        }\r\n      } else if (node.type === 'BlockStatement') {\r\n        if (node.scopeIds) {\r\n          node.scopeIds.forEach(id => markKnownIds(id, knownIds))\r\n        } else {\r\n          // #3445 record block-level local variables\r\n          walkBlockDeclarations(node, id =>\r\n            markScopeIdentifier(node, id, knownIds),\r\n          )\r\n        }\r\n      }\r\n    },\r\n    leave(node: Node & { scopeIds?: Set<string> }, parent: Node | undefined) {\r\n      parent && parentStack.pop()\r\n      if (node !== rootExp && node.scopeIds) {\r\n        for (const id of node.scopeIds) {\r\n          knownIds[id]--\r\n          if (knownIds[id] === 0) {\r\n            delete knownIds[id]\r\n          }\r\n        }\r\n      }\r\n    },\r\n  })\r\n}\r\n\r\nexport function isReferencedIdentifier(\r\n  id: Identifier,\r\n  parent: Node | null,\r\n  parentStack: Node[],\r\n) {\r\n  if (__BROWSER__) {\r\n    return false\r\n  }\r\n\r\n  if (!parent) {\r\n    return true\r\n  }\r\n\r\n  // is a special keyword but parsed as identifier\r\n  if (id.name === 'arguments') {\r\n    return false\r\n  }\r\n\r\n  if (isReferenced(id, parent)) {\r\n    return true\r\n  }\r\n\r\n  // babel's isReferenced check returns false for ids being assigned to, so we\r\n  // need to cover those cases here\r\n  switch (parent.type) {\r\n    case 'AssignmentExpression':\r\n    case 'AssignmentPattern':\r\n      return true\r\n    case 'ObjectPattern':\r\n    case 'ArrayPattern':\r\n      return isInDestructureAssignment(parent, parentStack)\r\n  }\r\n\r\n  return false\r\n}\r\n\r\nexport function isInDestructureAssignment(\r\n  parent: Node,\r\n  parentStack: Node[],\r\n): boolean {\r\n  if (\r\n    parent &&\r\n    (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')\r\n  ) {\r\n    let i = parentStack.length\r\n    while (i--) {\r\n      const p = parentStack[i]\r\n      if (p.type === 'AssignmentExpression') {\r\n        return true\r\n      } else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {\r\n        break\r\n      }\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nexport function isInNewExpression(parentStack: Node[]): boolean {\r\n  let i = parentStack.length\r\n  while (i--) {\r\n    const p = parentStack[i]\r\n    if (p.type === 'NewExpression') {\r\n      return true\r\n    } else if (p.type !== 'MemberExpression') {\r\n      break\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nexport function walkFunctionParams(\r\n  node: Function,\r\n  onIdent: (id: Identifier) => void,\r\n) {\r\n  for (const p of node.params) {\r\n    for (const id of extractIdentifiers(p)) {\r\n      onIdent(id)\r\n    }\r\n  }\r\n}\r\n\r\nexport function walkBlockDeclarations(\r\n  block: BlockStatement | Program,\r\n  onIdent: (node: Identifier) => void,\r\n) {\r\n  for (const stmt of block.body) {\r\n    if (stmt.type === 'VariableDeclaration') {\r\n      if (stmt.declare) continue\r\n      for (const decl of stmt.declarations) {\r\n        for (const id of extractIdentifiers(decl.id)) {\r\n          onIdent(id)\r\n        }\r\n      }\r\n    } else if (\r\n      stmt.type === 'FunctionDeclaration' ||\r\n      stmt.type === 'ClassDeclaration'\r\n    ) {\r\n      if (stmt.declare || !stmt.id) continue\r\n      onIdent(stmt.id)\r\n    } else if (\r\n      stmt.type === 'ForOfStatement' ||\r\n      stmt.type === 'ForInStatement' ||\r\n      stmt.type === 'ForStatement'\r\n    ) {\r\n      const variable = stmt.type === 'ForStatement' ? stmt.init : stmt.left\r\n      if (variable && variable.type === 'VariableDeclaration') {\r\n        for (const decl of variable.declarations) {\r\n          for (const id of extractIdentifiers(decl.id)) {\r\n            onIdent(id)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function extractIdentifiers(\r\n  param: Node,\r\n  nodes: Identifier[] = [],\r\n): Identifier[] {\r\n  switch (param.type) {\r\n    case 'Identifier':\r\n      nodes.push(param)\r\n      break\r\n\r\n    case 'MemberExpression':\r\n      let object: any = param\r\n      while (object.type === 'MemberExpression') {\r\n        object = object.object\r\n      }\r\n      nodes.push(object)\r\n      break\r\n\r\n    case 'ObjectPattern':\r\n      for (const prop of param.properties) {\r\n        if (prop.type === 'RestElement') {\r\n          extractIdentifiers(prop.argument, nodes)\r\n        } else {\r\n          extractIdentifiers(prop.value, nodes)\r\n        }\r\n      }\r\n      break\r\n\r\n    case 'ArrayPattern':\r\n      param.elements.forEach(element => {\r\n        if (element) extractIdentifiers(element, nodes)\r\n      })\r\n      break\r\n\r\n    case 'RestElement':\r\n      extractIdentifiers(param.argument, nodes)\r\n      break\r\n\r\n    case 'AssignmentPattern':\r\n      extractIdentifiers(param.left, nodes)\r\n      break\r\n  }\r\n\r\n  return nodes\r\n}\r\n\r\nfunction markKnownIds(name: string, knownIds: Record<string, number>) {\r\n  if (name in knownIds) {\r\n    knownIds[name]++\r\n  } else {\r\n    knownIds[name] = 1\r\n  }\r\n}\r\n\r\nfunction markScopeIdentifier(\r\n  node: Node & { scopeIds?: Set<string> },\r\n  child: Identifier,\r\n  knownIds: Record<string, number>,\r\n) {\r\n  const { name } = child\r\n  if (node.scopeIds && node.scopeIds.has(name)) {\r\n    return\r\n  }\r\n  markKnownIds(name, knownIds)\r\n  ;(node.scopeIds || (node.scopeIds = new Set())).add(name)\r\n}\r\n\r\nexport const isFunctionType = (node: Node): node is Function => {\r\n  return /Function(?:Expression|Declaration)$|Method$/.test(node.type)\r\n}\r\n\r\nexport const isStaticProperty = (node: Node): node is ObjectProperty =>\r\n  node &&\r\n  (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') &&\r\n  !node.computed\r\n\r\nexport const isStaticPropertyKey = (node: Node, parent: Node) =>\r\n  isStaticProperty(parent) && parent.key === node\r\n\r\n/**\r\n * Copied from https://github.com/babel/babel/blob/main/packages/babel-types/src/validators/isReferenced.ts\r\n * To avoid runtime dependency on @babel/types (which includes process references)\r\n * This file should not change very often in babel but we may need to keep it\r\n * up-to-date from time to time.\r\n *\r\n * https://github.com/babel/babel/blob/main/LICENSE\r\n *\r\n */\r\nfunction isReferenced(node: Node, parent: Node, grandparent?: Node): boolean {\r\n  switch (parent.type) {\r\n    // yes: PARENT[NODE]\r\n    // yes: NODE.child\r\n    // no: parent.NODE\r\n    case 'MemberExpression':\r\n    case 'OptionalMemberExpression':\r\n      if (parent.property === node) {\r\n        return !!parent.computed\r\n      }\r\n      return parent.object === node\r\n\r\n    case 'JSXMemberExpression':\r\n      return parent.object === node\r\n    // no: let NODE = init;\r\n    // yes: let id = NODE;\r\n    case 'VariableDeclarator':\r\n      return parent.init === node\r\n\r\n    // yes: () => NODE\r\n    // no: (NODE) => {}\r\n    case 'ArrowFunctionExpression':\r\n      return parent.body === node\r\n\r\n    // no: class { #NODE; }\r\n    // no: class { get #NODE() {} }\r\n    // no: class { #NODE() {} }\r\n    // no: class { fn() { return this.#NODE; } }\r\n    case 'PrivateName':\r\n      return false\r\n\r\n    // no: class { NODE() {} }\r\n    // yes: class { [NODE]() {} }\r\n    // no: class { foo(NODE) {} }\r\n    case 'ClassMethod':\r\n    case 'ClassPrivateMethod':\r\n    case 'ObjectMethod':\r\n      if (parent.key === node) {\r\n        return !!parent.computed\r\n      }\r\n      return false\r\n\r\n    // yes: { [NODE]: \"\" }\r\n    // no: { NODE: \"\" }\r\n    // depends: { NODE }\r\n    // depends: { key: NODE }\r\n    case 'ObjectProperty':\r\n      if (parent.key === node) {\r\n        return !!parent.computed\r\n      }\r\n      // parent.value === node\r\n      return !grandparent || grandparent.type !== 'ObjectPattern'\r\n    // no: class { NODE = value; }\r\n    // yes: class { [NODE] = value; }\r\n    // yes: class { key = NODE; }\r\n    case 'ClassProperty':\r\n      if (parent.key === node) {\r\n        return !!parent.computed\r\n      }\r\n      return true\r\n    case 'ClassPrivateProperty':\r\n      return parent.key !== node\r\n\r\n    // no: class NODE {}\r\n    // yes: class Foo extends NODE {}\r\n    case 'ClassDeclaration':\r\n    case 'ClassExpression':\r\n      return parent.superClass === node\r\n\r\n    // yes: left = NODE;\r\n    // no: NODE = right;\r\n    case 'AssignmentExpression':\r\n      return parent.right === node\r\n\r\n    // no: [NODE = foo] = [];\r\n    // yes: [foo = NODE] = [];\r\n    case 'AssignmentPattern':\r\n      return parent.right === node\r\n\r\n    // no: NODE: for (;;) {}\r\n    case 'LabeledStatement':\r\n      return false\r\n\r\n    // no: try {} catch (NODE) {}\r\n    case 'CatchClause':\r\n      return false\r\n\r\n    // no: function foo(...NODE) {}\r\n    case 'RestElement':\r\n      return false\r\n\r\n    case 'BreakStatement':\r\n    case 'ContinueStatement':\r\n      return false\r\n\r\n    // no: function NODE() {}\r\n    // no: function foo(NODE) {}\r\n    case 'FunctionDeclaration':\r\n    case 'FunctionExpression':\r\n      return false\r\n\r\n    // no: export NODE from \"foo\";\r\n    // no: export * as NODE from \"foo\";\r\n    case 'ExportNamespaceSpecifier':\r\n    case 'ExportDefaultSpecifier':\r\n      return false\r\n\r\n    // no: export { foo as NODE };\r\n    // yes: export { NODE as foo };\r\n    // no: export { NODE as foo } from \"foo\";\r\n    case 'ExportSpecifier':\r\n      // @ts-expect-error\r\n      if (grandparent?.source) {\r\n        return false\r\n      }\r\n      return parent.local === node\r\n\r\n    // no: import NODE from \"foo\";\r\n    // no: import * as NODE from \"foo\";\r\n    // no: import { NODE as foo } from \"foo\";\r\n    // no: import { foo as NODE } from \"foo\";\r\n    // no: import NODE from \"bar\";\r\n    case 'ImportDefaultSpecifier':\r\n    case 'ImportNamespaceSpecifier':\r\n    case 'ImportSpecifier':\r\n      return false\r\n\r\n    // no: import \"foo\" assert { NODE: \"json\" }\r\n    case 'ImportAttribute':\r\n      return false\r\n\r\n    // no: <div NODE=\"foo\" />\r\n    case 'JSXAttribute':\r\n      return false\r\n\r\n    // no: [NODE] = [];\r\n    // no: ({ NODE }) = [];\r\n    case 'ObjectPattern':\r\n    case 'ArrayPattern':\r\n      return false\r\n\r\n    // no: new.NODE\r\n    // no: NODE.target\r\n    case 'MetaProperty':\r\n      return false\r\n\r\n    // yes: type X = { someProperty: NODE }\r\n    // no: type X = { NODE: OtherType }\r\n    case 'ObjectTypeProperty':\r\n      return parent.key !== node\r\n\r\n    // yes: enum X { Foo = NODE }\r\n    // no: enum X { NODE }\r\n    case 'TSEnumMember':\r\n      return parent.id !== node\r\n\r\n    // yes: { [NODE]: value }\r\n    // no: { NODE: value }\r\n    case 'TSPropertySignature':\r\n      if (parent.key === node) {\r\n        return !!parent.computed\r\n      }\r\n\r\n      return true\r\n  }\r\n\r\n  return true\r\n}\r\n\r\nexport const TS_NODE_TYPES = [\r\n  'TSAsExpression', // foo as number\r\n  'TSTypeAssertion', // (<number>foo)\r\n  'TSNonNullExpression', // foo!\r\n  'TSInstantiationExpression', // foo<string>\r\n  'TSSatisfiesExpression', // foo satisfies T\r\n]\r\n\r\nexport function unwrapTSNode(node: Node): Node {\r\n  if (TS_NODE_TYPES.includes(node.type)) {\r\n    return unwrapTSNode((node as any).expression)\r\n  } else {\r\n    return node\r\n  }\r\n}\r\n","import {\r\n  type BlockCodegenNode,\r\n  type CallExpression,\r\n  type DirectiveNode,\r\n  type ElementNode,\r\n  ElementTypes,\r\n  type ExpressionNode,\r\n  type IfBranchNode,\r\n  type InterpolationNode,\r\n  type JSChildNode,\r\n  type MemoExpression,\r\n  NodeTypes,\r\n  type ObjectExpression,\r\n  type Position,\r\n  type Property,\r\n  type RenderSlotCall,\r\n  type RootNode,\r\n  type SimpleExpressionNode,\r\n  type SlotOutletNode,\r\n  type TemplateChildNode,\r\n  type TemplateNode,\r\n  type TextNode,\r\n  type VNodeCall,\r\n  createCallExpression,\r\n  createObjectExpression,\r\n} from './ast'\r\nimport type { TransformContext } from './transform'\r\nimport {\r\n  BASE_TRANSITION,\r\n  GUARD_REACTIVE_PROPS,\r\n  KEEP_ALIVE,\r\n  MERGE_PROPS,\r\n  NORMALIZE_PROPS,\r\n  SUSPENSE,\r\n  TELEPORT,\r\n  TO_HANDLERS,\r\n  WITH_MEMO,\r\n} from './runtimeHelpers'\r\nimport { NOOP, isObject, isString } from '@vue/shared'\r\nimport type { PropsExpression } from './transforms/transformElement'\r\nimport { parseExpression } from '@babel/parser'\r\nimport type { Expression } from '@babel/types'\r\nimport { unwrapTSNode } from './babelUtils'\r\n\r\nexport const isStaticExp = (p: JSChildNode): p is SimpleExpressionNode =>\r\n  p.type === NodeTypes.SIMPLE_EXPRESSION && p.isStatic\r\n\r\nexport function isCoreComponent(tag: string): symbol | void {\r\n  switch (tag) {\r\n    case 'Teleport':\r\n    case 'teleport':\r\n      return TELEPORT\r\n    case 'Suspense':\r\n    case 'suspense':\r\n      return SUSPENSE\r\n    case 'KeepAlive':\r\n    case 'keep-alive':\r\n      return KEEP_ALIVE\r\n    case 'BaseTransition':\r\n    case 'base-transition':\r\n      return BASE_TRANSITION\r\n  }\r\n}\r\n\r\nconst nonIdentifierRE = /^\\d|[^\\$\\w]/\r\nexport const isSimpleIdentifier = (name: string): boolean =>\r\n  !nonIdentifierRE.test(name)\r\n\r\nenum MemberExpLexState {\r\n  inMemberExp,\r\n  inBrackets,\r\n  inParens,\r\n  inString,\r\n}\r\n\r\nconst validFirstIdentCharRE = /[A-Za-z_$\\xA0-\\uFFFF]/\r\nconst validIdentCharRE = /[\\.\\?\\w$\\xA0-\\uFFFF]/\r\nconst whitespaceRE = /\\s+[.[]\\s*|\\s*[.[]\\s+/g\r\n\r\n/**\r\n * Simple lexer to check if an expression is a member expression. This is\r\n * lax and only checks validity at the root level (i.e. does not validate exps\r\n * inside square brackets), but it's ok since these are only used on template\r\n * expressions and false positives are invalid expressions in the first place.\r\n */\r\nexport const isMemberExpressionBrowser = (path: string): boolean => {\r\n  // remove whitespaces around . or [ first\r\n  path = path.trim().replace(whitespaceRE, s => s.trim())\r\n\r\n  let state = MemberExpLexState.inMemberExp\r\n  let stateStack: MemberExpLexState[] = []\r\n  let currentOpenBracketCount = 0\r\n  let currentOpenParensCount = 0\r\n  let currentStringType: \"'\" | '\"' | '`' | null = null\r\n\r\n  for (let i = 0; i < path.length; i++) {\r\n    const char = path.charAt(i)\r\n    switch (state) {\r\n      case MemberExpLexState.inMemberExp:\r\n        if (char === '[') {\r\n          stateStack.push(state)\r\n          state = MemberExpLexState.inBrackets\r\n          currentOpenBracketCount++\r\n        } else if (char === '(') {\r\n          stateStack.push(state)\r\n          state = MemberExpLexState.inParens\r\n          currentOpenParensCount++\r\n        } else if (\r\n          !(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)\r\n        ) {\r\n          return false\r\n        }\r\n        break\r\n      case MemberExpLexState.inBrackets:\r\n        if (char === `'` || char === `\"` || char === '`') {\r\n          stateStack.push(state)\r\n          state = MemberExpLexState.inString\r\n          currentStringType = char\r\n        } else if (char === `[`) {\r\n          currentOpenBracketCount++\r\n        } else if (char === `]`) {\r\n          if (!--currentOpenBracketCount) {\r\n            state = stateStack.pop()!\r\n          }\r\n        }\r\n        break\r\n      case MemberExpLexState.inParens:\r\n        if (char === `'` || char === `\"` || char === '`') {\r\n          stateStack.push(state)\r\n          state = MemberExpLexState.inString\r\n          currentStringType = char\r\n        } else if (char === `(`) {\r\n          currentOpenParensCount++\r\n        } else if (char === `)`) {\r\n          // if the exp ends as a call then it should not be considered valid\r\n          if (i === path.length - 1) {\r\n            return false\r\n          }\r\n          if (!--currentOpenParensCount) {\r\n            state = stateStack.pop()!\r\n          }\r\n        }\r\n        break\r\n      case MemberExpLexState.inString:\r\n        if (char === currentStringType) {\r\n          state = stateStack.pop()!\r\n          currentStringType = null\r\n        }\r\n        break\r\n    }\r\n  }\r\n  return !currentOpenBracketCount && !currentOpenParensCount\r\n}\r\n\r\nexport const isMemberExpressionNode = __BROWSER__\r\n  ? (NOOP as any as (path: string, context: TransformContext) => boolean)\r\n  : (path: string, context: TransformContext): boolean => {\r\n      try {\r\n        let ret: Expression = parseExpression(path, {\r\n          plugins: context.expressionPlugins,\r\n        })\r\n        ret = unwrapTSNode(ret) as Expression\r\n        return (\r\n          ret.type === 'MemberExpression' ||\r\n          ret.type === 'OptionalMemberExpression' ||\r\n          (ret.type === 'Identifier' && ret.name !== 'undefined')\r\n        )\r\n      } catch (e) {\r\n        return false\r\n      }\r\n    }\r\n\r\nexport const isMemberExpression = __BROWSER__\r\n  ? isMemberExpressionBrowser\r\n  : isMemberExpressionNode\r\n\r\nexport function advancePositionWithClone(\r\n  pos: Position,\r\n  source: string,\r\n  numberOfCharacters: number = source.length,\r\n): Position {\r\n  return advancePositionWithMutation(\r\n    {\r\n      offset: pos.offset,\r\n      line: pos.line,\r\n      column: pos.column,\r\n    },\r\n    source,\r\n    numberOfCharacters,\r\n  )\r\n}\r\n\r\n// advance by mutation without cloning (for performance reasons), since this\r\n// gets called a lot in the parser\r\nexport function advancePositionWithMutation(\r\n  pos: Position,\r\n  source: string,\r\n  numberOfCharacters: number = source.length,\r\n): Position {\r\n  let linesCount = 0\r\n  let lastNewLinePos = -1\r\n  for (let i = 0; i < numberOfCharacters; i++) {\r\n    if (source.charCodeAt(i) === 10 /* newline char code */) {\r\n      linesCount++\r\n      lastNewLinePos = i\r\n    }\r\n  }\r\n\r\n  pos.offset += numberOfCharacters\r\n  pos.line += linesCount\r\n  pos.column =\r\n    lastNewLinePos === -1\r\n      ? pos.column + numberOfCharacters\r\n      : numberOfCharacters - lastNewLinePos\r\n\r\n  return pos\r\n}\r\n\r\nexport function assert(condition: boolean, msg?: string) {\r\n  /* istanbul ignore if */\r\n  if (!condition) {\r\n    throw new Error(msg || `unexpected compiler condition`)\r\n  }\r\n}\r\n\r\nexport function findDir(\r\n  node: ElementNode,\r\n  name: string | RegExp,\r\n  allowEmpty: boolean = false,\r\n): DirectiveNode | undefined {\r\n  for (let i = 0; i < node.props.length; i++) {\r\n    const p = node.props[i]\r\n    if (\r\n      p.type === NodeTypes.DIRECTIVE &&\r\n      (allowEmpty || p.exp) &&\r\n      (isString(name) ? p.name === name : name.test(p.name))\r\n    ) {\r\n      return p\r\n    }\r\n  }\r\n}\r\n\r\nexport function findProp(\r\n  node: ElementNode,\r\n  name: string,\r\n  dynamicOnly: boolean = false,\r\n  allowEmpty: boolean = false,\r\n): ElementNode['props'][0] | undefined {\r\n  for (let i = 0; i < node.props.length; i++) {\r\n    const p = node.props[i]\r\n    if (p.type === NodeTypes.ATTRIBUTE) {\r\n      if (dynamicOnly) continue\r\n      if (p.name === name && (p.value || allowEmpty)) {\r\n        return p\r\n      }\r\n    } else if (\r\n      p.name === 'bind' &&\r\n      (p.exp || allowEmpty) &&\r\n      isStaticArgOf(p.arg, name)\r\n    ) {\r\n      return p\r\n    }\r\n  }\r\n}\r\n\r\nexport function isStaticArgOf(\r\n  arg: DirectiveNode['arg'],\r\n  name: string,\r\n): boolean {\r\n  return !!(arg && isStaticExp(arg) && arg.content === name)\r\n}\r\n\r\nexport function hasDynamicKeyVBind(node: ElementNode): boolean {\r\n  return node.props.some(\r\n    p =>\r\n      p.type === NodeTypes.DIRECTIVE &&\r\n      p.name === 'bind' &&\r\n      (!p.arg || // v-bind=\"obj\"\r\n        p.arg.type !== NodeTypes.SIMPLE_EXPRESSION || // v-bind:[_ctx.foo]\r\n        !p.arg.isStatic), // v-bind:[foo]\r\n  )\r\n}\r\n\r\nexport function isText(\r\n  node: TemplateChildNode,\r\n): node is TextNode | InterpolationNode {\r\n  return node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT\r\n}\r\n\r\nexport function isVSlot(p: ElementNode['props'][0]): p is DirectiveNode {\r\n  return p.type === NodeTypes.DIRECTIVE && p.name === 'slot'\r\n}\r\n\r\nexport function isTemplateNode(\r\n  node: RootNode | TemplateChildNode,\r\n): node is TemplateNode {\r\n  return (\r\n    node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.TEMPLATE\r\n  )\r\n}\r\n\r\nexport function isSlotOutlet(\r\n  node: RootNode | TemplateChildNode,\r\n): node is SlotOutletNode {\r\n  return node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.SLOT\r\n}\r\n\r\nconst propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS])\r\n\r\nfunction getUnnormalizedProps(\r\n  props: PropsExpression | '{}',\r\n  callPath: CallExpression[] = [],\r\n): [PropsExpression | '{}', CallExpression[]] {\r\n  if (\r\n    props &&\r\n    !isString(props) &&\r\n    props.type === NodeTypes.JS_CALL_EXPRESSION\r\n  ) {\r\n    const callee = props.callee\r\n    if (!isString(callee) && propsHelperSet.has(callee)) {\r\n      return getUnnormalizedProps(\r\n        props.arguments[0] as PropsExpression,\r\n        callPath.concat(props),\r\n      )\r\n    }\r\n  }\r\n  return [props, callPath]\r\n}\r\nexport function injectProp(\r\n  node: VNodeCall | RenderSlotCall,\r\n  prop: Property,\r\n  context: TransformContext,\r\n) {\r\n  let propsWithInjection: ObjectExpression | CallExpression | undefined\r\n  /**\r\n   * 1. mergeProps(...)\r\n   * 2. toHandlers(...)\r\n   * 3. normalizeProps(...)\r\n   * 4. normalizeProps(guardReactiveProps(...))\r\n   *\r\n   * we need to get the real props before normalization\r\n   */\r\n  let props =\r\n    node.type === NodeTypes.VNODE_CALL ? node.props : node.arguments[2]\r\n  let callPath: CallExpression[] = []\r\n  let parentCall: CallExpression | undefined\r\n  if (\r\n    props &&\r\n    !isString(props) &&\r\n    props.type === NodeTypes.JS_CALL_EXPRESSION\r\n  ) {\r\n    const ret = getUnnormalizedProps(props)\r\n    props = ret[0]\r\n    callPath = ret[1]\r\n    parentCall = callPath[callPath.length - 1]\r\n  }\r\n\r\n  if (props == null || isString(props)) {\r\n    propsWithInjection = createObjectExpression([prop])\r\n  } else if (props.type === NodeTypes.JS_CALL_EXPRESSION) {\r\n    // merged props... add ours\r\n    // only inject key to object literal if it's the first argument so that\r\n    // if doesn't override user provided keys\r\n    const first = props.arguments[0] as string | JSChildNode\r\n    if (!isString(first) && first.type === NodeTypes.JS_OBJECT_EXPRESSION) {\r\n      // #6631\r\n      if (!hasProp(prop, first)) {\r\n        first.properties.unshift(prop)\r\n      }\r\n    } else {\r\n      if (props.callee === TO_HANDLERS) {\r\n        // #2366\r\n        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\r\n          createObjectExpression([prop]),\r\n          props,\r\n        ])\r\n      } else {\r\n        props.arguments.unshift(createObjectExpression([prop]))\r\n      }\r\n    }\r\n    !propsWithInjection && (propsWithInjection = props)\r\n  } else if (props.type === NodeTypes.JS_OBJECT_EXPRESSION) {\r\n    if (!hasProp(prop, props)) {\r\n      props.properties.unshift(prop)\r\n    }\r\n    propsWithInjection = props\r\n  } else {\r\n    // single v-bind with expression, return a merged replacement\r\n    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\r\n      createObjectExpression([prop]),\r\n      props,\r\n    ])\r\n    // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,\r\n    // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,\r\n    // the `guardReactiveProps` will no longer be needed\r\n    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {\r\n      parentCall = callPath[callPath.length - 2]\r\n    }\r\n  }\r\n  if (node.type === NodeTypes.VNODE_CALL) {\r\n    if (parentCall) {\r\n      parentCall.arguments[0] = propsWithInjection\r\n    } else {\r\n      node.props = propsWithInjection\r\n    }\r\n  } else {\r\n    if (parentCall) {\r\n      parentCall.arguments[0] = propsWithInjection\r\n    } else {\r\n      node.arguments[2] = propsWithInjection\r\n    }\r\n  }\r\n}\r\n\r\n// check existing key to avoid overriding user provided keys\r\nfunction hasProp(prop: Property, props: ObjectExpression) {\r\n  let result = false\r\n  if (prop.key.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n    const propKeyName = prop.key.content\r\n    result = props.properties.some(\r\n      p =>\r\n        p.key.type === NodeTypes.SIMPLE_EXPRESSION &&\r\n        p.key.content === propKeyName,\r\n    )\r\n  }\r\n  return result\r\n}\r\n\r\nexport function toValidAssetId(\r\n  name: string,\r\n  type: 'component' | 'directive' | 'filter',\r\n): string {\r\n  // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character\r\n  return `_${type}_${name.replace(/[^\\w]/g, (searchValue, replaceValue) => {\r\n    return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString()\r\n  })}`\r\n}\r\n\r\n// Check if a node contains expressions that reference current context scope ids\r\nexport function hasScopeRef(\r\n  node: TemplateChildNode | IfBranchNode | ExpressionNode | undefined,\r\n  ids: TransformContext['identifiers'],\r\n): boolean {\r\n  if (!node || Object.keys(ids).length === 0) {\r\n    return false\r\n  }\r\n  switch (node.type) {\r\n    case NodeTypes.ELEMENT:\r\n      for (let i = 0; i < node.props.length; i++) {\r\n        const p = node.props[i]\r\n        if (\r\n          p.type === NodeTypes.DIRECTIVE &&\r\n          (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))\r\n        ) {\r\n          return true\r\n        }\r\n      }\r\n      return node.children.some(c => hasScopeRef(c, ids))\r\n    case NodeTypes.FOR:\r\n      if (hasScopeRef(node.source, ids)) {\r\n        return true\r\n      }\r\n      return node.children.some(c => hasScopeRef(c, ids))\r\n    case NodeTypes.IF:\r\n      return node.branches.some(b => hasScopeRef(b, ids))\r\n    case NodeTypes.IF_BRANCH:\r\n      if (hasScopeRef(node.condition, ids)) {\r\n        return true\r\n      }\r\n      return node.children.some(c => hasScopeRef(c, ids))\r\n    case NodeTypes.SIMPLE_EXPRESSION:\r\n      return (\r\n        !node.isStatic &&\r\n        isSimpleIdentifier(node.content) &&\r\n        !!ids[node.content]\r\n      )\r\n    case NodeTypes.COMPOUND_EXPRESSION:\r\n      return node.children.some(c => isObject(c) && hasScopeRef(c, ids))\r\n    case NodeTypes.INTERPOLATION:\r\n    case NodeTypes.TEXT_CALL:\r\n      return hasScopeRef(node.content, ids)\r\n    case NodeTypes.TEXT:\r\n    case NodeTypes.COMMENT:\r\n      return false\r\n    default:\r\n      if (__DEV__) {\r\n        const exhaustiveCheck: never = node\r\n        exhaustiveCheck\r\n      }\r\n      return false\r\n  }\r\n}\r\n\r\nexport function getMemoedVNodeCall(node: BlockCodegenNode | MemoExpression) {\r\n  if (node.type === NodeTypes.JS_CALL_EXPRESSION && node.callee === WITH_MEMO) {\r\n    return node.arguments[1].returns as VNodeCall\r\n  } else {\r\n    return node\r\n  }\r\n}\r\n\r\nexport const forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/\r\n","import {\r\n  type AttributeNode,\r\n  ConstantTypes,\r\n  type DirectiveNode,\r\n  type ElementNode,\r\n  ElementTypes,\r\n  type ForParseResult,\r\n  Namespaces,\r\n  NodeTypes,\r\n  type RootNode,\r\n  type SimpleExpressionNode,\r\n  type SourceLocation,\r\n  type TemplateChildNode,\r\n  createRoot,\r\n  createSimpleExpression,\r\n} from './ast'\r\nimport type { ParserOptions } from './options'\r\nimport Tokenizer, {\r\n  CharCodes,\r\n  ParseMode,\r\n  QuoteType,\r\n  Sequences,\r\n  State,\r\n  isWhitespace,\r\n  toCharCodes,\r\n} from './tokenizer'\r\nimport {\r\n  type CompilerCompatOptions,\r\n  CompilerDeprecationTypes,\r\n  checkCompatEnabled,\r\n  isCompatEnabled,\r\n  warnDeprecation,\r\n} from './compat/compatConfig'\r\nimport { NO, extend } from '@vue/shared'\r\nimport {\r\n  ErrorCodes,\r\n  createCompilerError,\r\n  defaultOnError,\r\n  defaultOnWarn,\r\n} from './errors'\r\nimport {\r\n  forAliasRE,\r\n  isCoreComponent,\r\n  isSimpleIdentifier,\r\n  isStaticArgOf,\r\n} from './utils'\r\nimport { decodeHTML } from 'entities/lib/decode.js'\r\nimport {\r\n  type ParserOptions as BabelOptions,\r\n  parse,\r\n  parseExpression,\r\n} from '@babel/parser'\r\n\r\ntype OptionalOptions =\r\n  | 'decodeEntities'\r\n  | 'whitespace'\r\n  | 'isNativeTag'\r\n  | 'isBuiltInComponent'\r\n  | 'expressionPlugins'\r\n  | keyof CompilerCompatOptions\r\n\r\nexport type MergedParserOptions = Omit<\r\n  Required<ParserOptions>,\r\n  OptionalOptions\r\n> &\r\n  Pick<ParserOptions, OptionalOptions>\r\n\r\nexport const defaultParserOptions: MergedParserOptions = {\r\n  parseMode: 'base',\r\n  ns: Namespaces.HTML,\r\n  delimiters: [`{{`, `}}`],\r\n  getNamespace: () => Namespaces.HTML,\r\n  isVoidTag: NO,\r\n  isPreTag: NO,\r\n  isCustomElement: NO,\r\n  onError: defaultOnError,\r\n  onWarn: defaultOnWarn,\r\n  comments: __DEV__,\r\n  prefixIdentifiers: false,\r\n}\r\n\r\nlet currentOptions: MergedParserOptions = defaultParserOptions\r\nlet currentRoot: RootNode | null = null\r\n\r\n// parser state\r\nlet currentInput = ''\r\nlet currentOpenTag: ElementNode | null = null\r\nlet currentProp: AttributeNode | DirectiveNode | null = null\r\nlet currentAttrValue = ''\r\nlet currentAttrStartIndex = -1\r\nlet currentAttrEndIndex = -1\r\nlet inPre = 0\r\nlet inVPre = false\r\nlet currentVPreBoundary: ElementNode | null = null\r\nconst stack: ElementNode[] = []\r\n\r\nconst tokenizer = new Tokenizer(stack, {\r\n  onerr: emitError,\r\n\r\n  ontext(start, end) {\r\n    onText(getSlice(start, end), start, end)\r\n  },\r\n\r\n  ontextentity(char, start, end) {\r\n    onText(char, start, end)\r\n  },\r\n\r\n  oninterpolation(start, end) {\r\n    if (inVPre) {\r\n      return onText(getSlice(start, end), start, end)\r\n    }\r\n    let innerStart = start + tokenizer.delimiterOpen.length\r\n    let innerEnd = end - tokenizer.delimiterClose.length\r\n    while (isWhitespace(currentInput.charCodeAt(innerStart))) {\r\n      innerStart++\r\n    }\r\n    while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) {\r\n      innerEnd--\r\n    }\r\n    let exp = getSlice(innerStart, innerEnd)\r\n    // decode entities for backwards compat\r\n    if (exp.includes('&')) {\r\n      if (__BROWSER__) {\r\n        exp = currentOptions.decodeEntities!(exp, false)\r\n      } else {\r\n        exp = decodeHTML(exp)\r\n      }\r\n    }\r\n    addNode({\r\n      type: NodeTypes.INTERPOLATION,\r\n      content: createExp(exp, false, getLoc(innerStart, innerEnd)),\r\n      loc: getLoc(start, end),\r\n    })\r\n  },\r\n\r\n  onopentagname(start, end) {\r\n    const name = getSlice(start, end)\r\n    currentOpenTag = {\r\n      type: NodeTypes.ELEMENT,\r\n      tag: name,\r\n      ns: currentOptions.getNamespace(name, stack[0], currentOptions.ns),\r\n      tagType: ElementTypes.ELEMENT, // will be refined on tag close\r\n      props: [],\r\n      children: [],\r\n      loc: getLoc(start - 1, end),\r\n      codegenNode: undefined,\r\n    }\r\n  },\r\n\r\n  onopentagend(end) {\r\n    endOpenTag(end)\r\n  },\r\n\r\n  onclosetag(start, end) {\r\n    const name = getSlice(start, end)\r\n    if (!currentOptions.isVoidTag(name)) {\r\n      let found = false\r\n      for (let i = 0; i < stack.length; i++) {\r\n        const e = stack[i]\r\n        if (e.tag.toLowerCase() === name.toLowerCase()) {\r\n          found = true\r\n          if (i > 0) {\r\n            emitError(ErrorCodes.X_MISSING_END_TAG, stack[0].loc.start.offset)\r\n          }\r\n          for (let j = 0; j <= i; j++) {\r\n            const el = stack.shift()!\r\n            onCloseTag(el, end, j < i)\r\n          }\r\n          break\r\n        }\r\n      }\r\n      if (!found) {\r\n        emitError(ErrorCodes.X_INVALID_END_TAG, backTrack(start, CharCodes.Lt))\r\n      }\r\n    }\r\n  },\r\n\r\n  onselfclosingtag(end) {\r\n    const name = currentOpenTag!.tag\r\n    currentOpenTag!.isSelfClosing = true\r\n    endOpenTag(end)\r\n    if (stack[0]?.tag === name) {\r\n      onCloseTag(stack.shift()!, end)\r\n    }\r\n  },\r\n\r\n  onattribname(start, end) {\r\n    // plain attribute\r\n    currentProp = {\r\n      type: NodeTypes.ATTRIBUTE,\r\n      name: getSlice(start, end),\r\n      nameLoc: getLoc(start, end),\r\n      value: undefined,\r\n      loc: getLoc(start),\r\n    }\r\n  },\r\n\r\n  ondirname(start, end) {\r\n    const raw = getSlice(start, end)\r\n    const name =\r\n      raw === '.' || raw === ':'\r\n        ? 'bind'\r\n        : raw === '@'\r\n          ? 'on'\r\n          : raw === '#'\r\n            ? 'slot'\r\n            : raw.slice(2)\r\n\r\n    if (!inVPre && name === '') {\r\n      emitError(ErrorCodes.X_MISSING_DIRECTIVE_NAME, start)\r\n    }\r\n\r\n    if (inVPre || name === '') {\r\n      currentProp = {\r\n        type: NodeTypes.ATTRIBUTE,\r\n        name: raw,\r\n        nameLoc: getLoc(start, end),\r\n        value: undefined,\r\n        loc: getLoc(start),\r\n      }\r\n    } else {\r\n      currentProp = {\r\n        type: NodeTypes.DIRECTIVE,\r\n        name,\r\n        rawName: raw,\r\n        exp: undefined,\r\n        arg: undefined,\r\n        modifiers: raw === '.' ? ['prop'] : [],\r\n        loc: getLoc(start),\r\n      }\r\n      if (name === 'pre') {\r\n        inVPre = tokenizer.inVPre = true\r\n        currentVPreBoundary = currentOpenTag\r\n        // convert dirs before this one to attributes\r\n        const props = currentOpenTag!.props\r\n        for (let i = 0; i < props.length; i++) {\r\n          if (props[i].type === NodeTypes.DIRECTIVE) {\r\n            props[i] = dirToAttr(props[i] as DirectiveNode)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  ondirarg(start, end) {\r\n    if (start === end) return\r\n    const arg = getSlice(start, end)\r\n    if (inVPre) {\r\n      ;(currentProp as AttributeNode).name += arg\r\n      setLocEnd((currentProp as AttributeNode).nameLoc, end)\r\n    } else {\r\n      const isStatic = arg[0] !== `[`\r\n      ;(currentProp as DirectiveNode).arg = createExp(\r\n        isStatic ? arg : arg.slice(1, -1),\r\n        isStatic,\r\n        getLoc(start, end),\r\n        isStatic ? ConstantTypes.CAN_STRINGIFY : ConstantTypes.NOT_CONSTANT,\r\n      )\r\n    }\r\n  },\r\n\r\n  ondirmodifier(start, end) {\r\n    const mod = getSlice(start, end)\r\n    if (inVPre) {\r\n      ;(currentProp as AttributeNode).name += '.' + mod\r\n      setLocEnd((currentProp as AttributeNode).nameLoc, end)\r\n    } else if ((currentProp as DirectiveNode).name === 'slot') {\r\n      // slot has no modifiers, special case for edge cases like\r\n      // https://github.com/vuejs/language-tools/issues/2710\r\n      const arg = (currentProp as DirectiveNode).arg\r\n      if (arg) {\r\n        ;(arg as SimpleExpressionNode).content += '.' + mod\r\n        setLocEnd(arg.loc, end)\r\n      }\r\n    } else {\r\n      ;(currentProp as DirectiveNode).modifiers.push(mod)\r\n    }\r\n  },\r\n\r\n  onattribdata(start, end) {\r\n    currentAttrValue += getSlice(start, end)\r\n    if (currentAttrStartIndex < 0) currentAttrStartIndex = start\r\n    currentAttrEndIndex = end\r\n  },\r\n\r\n  onattribentity(char, start, end) {\r\n    currentAttrValue += char\r\n    if (currentAttrStartIndex < 0) currentAttrStartIndex = start\r\n    currentAttrEndIndex = end\r\n  },\r\n\r\n  onattribnameend(end) {\r\n    const start = currentProp!.loc.start.offset\r\n    const name = getSlice(start, end)\r\n    if (currentProp!.type === NodeTypes.DIRECTIVE) {\r\n      currentProp!.rawName = name\r\n    }\r\n    // check duplicate attrs\r\n    if (\r\n      currentOpenTag!.props.some(\r\n        p => (p.type === NodeTypes.DIRECTIVE ? p.rawName : p.name) === name,\r\n      )\r\n    ) {\r\n      emitError(ErrorCodes.DUPLICATE_ATTRIBUTE, start)\r\n    }\r\n  },\r\n\r\n  onattribend(quote, end) {\r\n    if (currentOpenTag && currentProp) {\r\n      // finalize end pos\r\n      setLocEnd(currentProp.loc, end)\r\n\r\n      if (quote !== QuoteType.NoValue) {\r\n        if (__BROWSER__ && currentAttrValue.includes('&')) {\r\n          currentAttrValue = currentOptions.decodeEntities!(\r\n            currentAttrValue,\r\n            true,\r\n          )\r\n        }\r\n\r\n        if (currentProp.type === NodeTypes.ATTRIBUTE) {\r\n          // assign value\r\n\r\n          // condense whitespaces in class\r\n          if (currentProp!.name === 'class') {\r\n            currentAttrValue = condense(currentAttrValue).trim()\r\n          }\r\n\r\n          if (quote === QuoteType.Unquoted && !currentAttrValue) {\r\n            emitError(ErrorCodes.MISSING_ATTRIBUTE_VALUE, end)\r\n          }\r\n\r\n          currentProp!.value = {\r\n            type: NodeTypes.TEXT,\r\n            content: currentAttrValue,\r\n            loc:\r\n              quote === QuoteType.Unquoted\r\n                ? getLoc(currentAttrStartIndex, currentAttrEndIndex)\r\n                : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1),\r\n          }\r\n          if (\r\n            tokenizer.inSFCRoot &&\r\n            currentOpenTag.tag === 'template' &&\r\n            currentProp.name === 'lang' &&\r\n            currentAttrValue &&\r\n            currentAttrValue !== 'html'\r\n          ) {\r\n            // SFC root template with preprocessor lang, force tokenizer to\r\n            // RCDATA mode\r\n            tokenizer.enterRCDATA(toCharCodes(`</template`), 0)\r\n          }\r\n        } else {\r\n          // directive\r\n          let expParseMode = ExpParseMode.Normal\r\n          if (!__BROWSER__) {\r\n            if (currentProp.name === 'for') {\r\n              expParseMode = ExpParseMode.Skip\r\n            } else if (currentProp.name === 'slot') {\r\n              expParseMode = ExpParseMode.Params\r\n            } else if (\r\n              currentProp.name === 'on' &&\r\n              currentAttrValue.includes(';')\r\n            ) {\r\n              expParseMode = ExpParseMode.Statements\r\n            }\r\n          }\r\n          currentProp.exp = createExp(\r\n            currentAttrValue,\r\n            false,\r\n            getLoc(currentAttrStartIndex, currentAttrEndIndex),\r\n            ConstantTypes.NOT_CONSTANT,\r\n            expParseMode,\r\n          )\r\n          if (currentProp.name === 'for') {\r\n            currentProp.forParseResult = parseForExpression(currentProp.exp)\r\n          }\r\n          // 2.x compat v-bind:foo.sync -> v-model:foo\r\n          let syncIndex = -1\r\n          if (\r\n            __COMPAT__ &&\r\n            currentProp.name === 'bind' &&\r\n            (syncIndex = currentProp.modifiers.indexOf('sync')) > -1 &&\r\n            checkCompatEnabled(\r\n              CompilerDeprecationTypes.COMPILER_V_BIND_SYNC,\r\n              currentOptions,\r\n              currentProp.loc,\r\n              currentProp.rawName,\r\n            )\r\n          ) {\r\n            currentProp.name = 'model'\r\n            currentProp.modifiers.splice(syncIndex, 1)\r\n          }\r\n        }\r\n      }\r\n      if (\r\n        currentProp.type !== NodeTypes.DIRECTIVE ||\r\n        currentProp.name !== 'pre'\r\n      ) {\r\n        currentOpenTag.props.push(currentProp)\r\n      }\r\n    }\r\n    currentAttrValue = ''\r\n    currentAttrStartIndex = currentAttrEndIndex = -1\r\n  },\r\n\r\n  oncomment(start, end) {\r\n    if (currentOptions.comments) {\r\n      addNode({\r\n        type: NodeTypes.COMMENT,\r\n        content: getSlice(start, end),\r\n        loc: getLoc(start - 4, end + 3),\r\n      })\r\n    }\r\n  },\r\n\r\n  onend() {\r\n    const end = currentInput.length\r\n    // EOF ERRORS\r\n    if ((__DEV__ || !__BROWSER__) && tokenizer.state !== State.Text) {\r\n      switch (tokenizer.state) {\r\n        case State.BeforeTagName:\r\n        case State.BeforeClosingTagName:\r\n          emitError(ErrorCodes.EOF_BEFORE_TAG_NAME, end)\r\n          break\r\n        case State.Interpolation:\r\n        case State.InterpolationClose:\r\n          emitError(\r\n            ErrorCodes.X_MISSING_INTERPOLATION_END,\r\n            tokenizer.sectionStart,\r\n          )\r\n          break\r\n        case State.InCommentLike:\r\n          if (tokenizer.currentSequence === Sequences.CdataEnd) {\r\n            emitError(ErrorCodes.EOF_IN_CDATA, end)\r\n          } else {\r\n            emitError(ErrorCodes.EOF_IN_COMMENT, end)\r\n          }\r\n          break\r\n        case State.InTagName:\r\n        case State.InSelfClosingTag:\r\n        case State.InClosingTagName:\r\n        case State.BeforeAttrName:\r\n        case State.InAttrName:\r\n        case State.InDirName:\r\n        case State.InDirArg:\r\n        case State.InDirDynamicArg:\r\n        case State.InDirModifier:\r\n        case State.AfterAttrName:\r\n        case State.BeforeAttrValue:\r\n        case State.InAttrValueDq: // \"\r\n        case State.InAttrValueSq: // '\r\n        case State.InAttrValueNq:\r\n          emitError(ErrorCodes.EOF_IN_TAG, end)\r\n          break\r\n        default:\r\n          // console.log(tokenizer.state)\r\n          break\r\n      }\r\n    }\r\n    for (let index = 0; index < stack.length; index++) {\r\n      onCloseTag(stack[index], end - 1)\r\n      emitError(ErrorCodes.X_MISSING_END_TAG, stack[index].loc.start.offset)\r\n    }\r\n  },\r\n\r\n  oncdata(start, end) {\r\n    if (stack[0].ns !== Namespaces.HTML) {\r\n      onText(getSlice(start, end), start, end)\r\n    } else {\r\n      emitError(ErrorCodes.CDATA_IN_HTML_CONTENT, start - 9)\r\n    }\r\n  },\r\n\r\n  onprocessinginstruction(start) {\r\n    // ignore as we do not have runtime handling for this, only check error\r\n    if ((stack[0] ? stack[0].ns : currentOptions.ns) === Namespaces.HTML) {\r\n      emitError(\r\n        ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,\r\n        start - 1,\r\n      )\r\n    }\r\n  },\r\n})\r\n\r\n// This regex doesn't cover the case if key or index aliases have destructuring,\r\n// but those do not make sense in the first place, so this works in practice.\r\nconst forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/\r\nconst stripParensRE = /^\\(|\\)$/g\r\n\r\nfunction parseForExpression(\r\n  input: SimpleExpressionNode,\r\n): ForParseResult | undefined {\r\n  const loc = input.loc\r\n  const exp = input.content\r\n  const inMatch = exp.match(forAliasRE)\r\n  if (!inMatch) return\r\n\r\n  const [, LHS, RHS] = inMatch\r\n\r\n  const createAliasExpression = (\r\n    content: string,\r\n    offset: number,\r\n    asParam = false,\r\n  ) => {\r\n    const start = loc.start.offset + offset\r\n    const end = start + content.length\r\n    return createExp(\r\n      content,\r\n      false,\r\n      getLoc(start, end),\r\n      ConstantTypes.NOT_CONSTANT,\r\n      asParam ? ExpParseMode.Params : ExpParseMode.Normal,\r\n    )\r\n  }\r\n\r\n  const result: ForParseResult = {\r\n    source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),\r\n    value: undefined,\r\n    key: undefined,\r\n    index: undefined,\r\n    finalized: false,\r\n  }\r\n\r\n  let valueContent = LHS.trim().replace(stripParensRE, '').trim()\r\n  const trimmedOffset = LHS.indexOf(valueContent)\r\n\r\n  const iteratorMatch = valueContent.match(forIteratorRE)\r\n  if (iteratorMatch) {\r\n    valueContent = valueContent.replace(forIteratorRE, '').trim()\r\n\r\n    const keyContent = iteratorMatch[1].trim()\r\n    let keyOffset: number | undefined\r\n    if (keyContent) {\r\n      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length)\r\n      result.key = createAliasExpression(keyContent, keyOffset, true)\r\n    }\r\n\r\n    if (iteratorMatch[2]) {\r\n      const indexContent = iteratorMatch[2].trim()\r\n\r\n      if (indexContent) {\r\n        result.index = createAliasExpression(\r\n          indexContent,\r\n          exp.indexOf(\r\n            indexContent,\r\n            result.key\r\n              ? keyOffset! + keyContent.length\r\n              : trimmedOffset + valueContent.length,\r\n          ),\r\n          true,\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  if (valueContent) {\r\n    result.value = createAliasExpression(valueContent, trimmedOffset, true)\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nfunction getSlice(start: number, end: number) {\r\n  return currentInput.slice(start, end)\r\n}\r\n\r\nfunction endOpenTag(end: number) {\r\n  if (tokenizer.inSFCRoot) {\r\n    // in SFC mode, generate locations for root-level tags' inner content.\r\n    currentOpenTag!.innerLoc = getLoc(end + 1, end + 1)\r\n  }\r\n  addNode(currentOpenTag!)\r\n  const { tag, ns } = currentOpenTag!\r\n  if (ns === Namespaces.HTML && currentOptions.isPreTag(tag)) {\r\n    inPre++\r\n  }\r\n  if (currentOptions.isVoidTag(tag)) {\r\n    onCloseTag(currentOpenTag!, end)\r\n  } else {\r\n    stack.unshift(currentOpenTag!)\r\n    if (ns === Namespaces.SVG || ns === Namespaces.MATH_ML) {\r\n      tokenizer.inXML = true\r\n    }\r\n  }\r\n  currentOpenTag = null\r\n}\r\n\r\nfunction onText(content: string, start: number, end: number) {\r\n  if (__BROWSER__) {\r\n    const tag = stack[0]?.tag\r\n    if (tag !== 'script' && tag !== 'style' && content.includes('&')) {\r\n      content = currentOptions.decodeEntities!(content, false)\r\n    }\r\n  }\r\n  const parent = stack[0] || currentRoot\r\n  const lastNode = parent.children[parent.children.length - 1]\r\n  if (lastNode?.type === NodeTypes.TEXT) {\r\n    // merge\r\n    lastNode.content += content\r\n    setLocEnd(lastNode.loc, end)\r\n  } else {\r\n    parent.children.push({\r\n      type: NodeTypes.TEXT,\r\n      content,\r\n      loc: getLoc(start, end),\r\n    })\r\n  }\r\n}\r\n\r\nfunction onCloseTag(el: ElementNode, end: number, isImplied = false) {\r\n  // attach end position\r\n  if (isImplied) {\r\n    // implied close, end should be backtracked to close\r\n    setLocEnd(el.loc, backTrack(end, CharCodes.Lt))\r\n  } else {\r\n    setLocEnd(el.loc, end + 1)\r\n  }\r\n\r\n  if (tokenizer.inSFCRoot) {\r\n    // SFC root tag, resolve inner end\r\n    if (el.children.length) {\r\n      el.innerLoc!.end = extend({}, el.children[el.children.length - 1].loc.end)\r\n    } else {\r\n      el.innerLoc!.end = extend({}, el.innerLoc!.start)\r\n    }\r\n    el.innerLoc!.source = getSlice(\r\n      el.innerLoc!.start.offset,\r\n      el.innerLoc!.end.offset,\r\n    )\r\n  }\r\n\r\n  // refine element type\r\n  const { tag, ns } = el\r\n  if (!inVPre) {\r\n    if (tag === 'slot') {\r\n      el.tagType = ElementTypes.SLOT\r\n    } else if (isFragmentTemplate(el)) {\r\n      el.tagType = ElementTypes.TEMPLATE\r\n    } else if (isComponent(el)) {\r\n      el.tagType = ElementTypes.COMPONENT\r\n    }\r\n  }\r\n\r\n  // whitespace management\r\n  if (!tokenizer.inRCDATA) {\r\n    el.children = condenseWhitespace(el.children, el.tag)\r\n  }\r\n  if (ns === Namespaces.HTML && currentOptions.isPreTag(tag)) {\r\n    inPre--\r\n  }\r\n  if (currentVPreBoundary === el) {\r\n    inVPre = tokenizer.inVPre = false\r\n    currentVPreBoundary = null\r\n  }\r\n  if (\r\n    tokenizer.inXML &&\r\n    (stack[0] ? stack[0].ns : currentOptions.ns) === Namespaces.HTML\r\n  ) {\r\n    tokenizer.inXML = false\r\n  }\r\n\r\n  // 2.x compat / deprecation checks\r\n  if (__COMPAT__) {\r\n    const props = el.props\r\n    if (\r\n      __DEV__ &&\r\n      isCompatEnabled(\r\n        CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE,\r\n        currentOptions,\r\n      )\r\n    ) {\r\n      let hasIf = false\r\n      let hasFor = false\r\n      for (let i = 0; i < props.length; i++) {\r\n        const p = props[i]\r\n        if (p.type === NodeTypes.DIRECTIVE) {\r\n          if (p.name === 'if') {\r\n            hasIf = true\r\n          } else if (p.name === 'for') {\r\n            hasFor = true\r\n          }\r\n        }\r\n        if (hasIf && hasFor) {\r\n          warnDeprecation(\r\n            CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE,\r\n            currentOptions,\r\n            el.loc,\r\n          )\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    if (\r\n      !tokenizer.inSFCRoot &&\r\n      isCompatEnabled(\r\n        CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE,\r\n        currentOptions,\r\n      ) &&\r\n      el.tag === 'template' &&\r\n      !isFragmentTemplate(el)\r\n    ) {\r\n      __DEV__ &&\r\n        warnDeprecation(\r\n          CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE,\r\n          currentOptions,\r\n          el.loc,\r\n        )\r\n      // unwrap\r\n      const parent = stack[0] || currentRoot\r\n      const index = parent.children.indexOf(el)\r\n      parent.children.splice(index, 1, ...el.children)\r\n    }\r\n\r\n    const inlineTemplateProp = props.find(\r\n      p => p.type === NodeTypes.ATTRIBUTE && p.name === 'inline-template',\r\n    ) as AttributeNode\r\n    if (\r\n      inlineTemplateProp &&\r\n      checkCompatEnabled(\r\n        CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE,\r\n        currentOptions,\r\n        inlineTemplateProp.loc,\r\n      ) &&\r\n      el.children.length\r\n    ) {\r\n      inlineTemplateProp.value = {\r\n        type: NodeTypes.TEXT,\r\n        content: getSlice(\r\n          el.children[0].loc.start.offset,\r\n          el.children[el.children.length - 1].loc.end.offset,\r\n        ),\r\n        loc: inlineTemplateProp.loc,\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction backTrack(index: number, c: number) {\r\n  let i = index\r\n  while (currentInput.charCodeAt(i) !== c && i >= 0) i--\r\n  return i\r\n}\r\n\r\nconst specialTemplateDir = new Set(['if', 'else', 'else-if', 'for', 'slot'])\r\nfunction isFragmentTemplate({ tag, props }: ElementNode): boolean {\r\n  if (tag === 'template') {\r\n    for (let i = 0; i < props.length; i++) {\r\n      if (\r\n        props[i].type === NodeTypes.DIRECTIVE &&\r\n        specialTemplateDir.has((props[i] as DirectiveNode).name)\r\n      ) {\r\n        return true\r\n      }\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nfunction isComponent({ tag, props }: ElementNode): boolean {\r\n  if (currentOptions.isCustomElement(tag)) {\r\n    return false\r\n  }\r\n  if (\r\n    tag === 'component' ||\r\n    isUpperCase(tag.charCodeAt(0)) ||\r\n    isCoreComponent(tag) ||\r\n    currentOptions.isBuiltInComponent?.(tag) ||\r\n    (currentOptions.isNativeTag && !currentOptions.isNativeTag(tag))\r\n  ) {\r\n    return true\r\n  }\r\n  // at this point the tag should be a native tag, but check for potential \"is\"\r\n  // casting\r\n  for (let i = 0; i < props.length; i++) {\r\n    const p = props[i]\r\n    if (p.type === NodeTypes.ATTRIBUTE) {\r\n      if (p.name === 'is' && p.value) {\r\n        if (p.value.content.startsWith('vue:')) {\r\n          return true\r\n        } else if (\r\n          __COMPAT__ &&\r\n          checkCompatEnabled(\r\n            CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\r\n            currentOptions,\r\n            p.loc,\r\n          )\r\n        ) {\r\n          return true\r\n        }\r\n      }\r\n    } else if (\r\n      __COMPAT__ &&\r\n      // :is on plain element - only treat as component in compat mode\r\n      p.name === 'bind' &&\r\n      isStaticArgOf(p.arg, 'is') &&\r\n      checkCompatEnabled(\r\n        CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\r\n        currentOptions,\r\n        p.loc,\r\n      )\r\n    ) {\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nfunction isUpperCase(c: number) {\r\n  return c > 64 && c < 91\r\n}\r\n\r\nconst windowsNewlineRE = /\\r\\n/g\r\nfunction condenseWhitespace(\r\n  nodes: TemplateChildNode[],\r\n  tag?: string,\r\n): TemplateChildNode[] {\r\n  const shouldCondense = currentOptions.whitespace !== 'preserve'\r\n  let removedWhitespace = false\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    const node = nodes[i]\r\n    if (node.type === NodeTypes.TEXT) {\r\n      if (!inPre) {\r\n        if (isAllWhitespace(node.content)) {\r\n          const prev = nodes[i - 1]?.type\r\n          const next = nodes[i + 1]?.type\r\n          // Remove if:\r\n          // - the whitespace is the first or last node, or:\r\n          // - (condense mode) the whitespace is between two comments, or:\r\n          // - (condense mode) the whitespace is between comment and element, or:\r\n          // - (condense mode) the whitespace is between two elements AND contains newline\r\n          if (\r\n            !prev ||\r\n            !next ||\r\n            (shouldCondense &&\r\n              ((prev === NodeTypes.COMMENT &&\r\n                (next === NodeTypes.COMMENT || next === NodeTypes.ELEMENT)) ||\r\n                (prev === NodeTypes.ELEMENT &&\r\n                  (next === NodeTypes.COMMENT ||\r\n                    (next === NodeTypes.ELEMENT &&\r\n                      hasNewlineChar(node.content))))))\r\n          ) {\r\n            removedWhitespace = true\r\n            nodes[i] = null as any\r\n          } else {\r\n            // Otherwise, the whitespace is condensed into a single space\r\n            node.content = ' '\r\n          }\r\n        } else if (shouldCondense) {\r\n          // in condense mode, consecutive whitespaces in text are condensed\r\n          // down to a single space.\r\n          node.content = condense(node.content)\r\n        }\r\n      } else {\r\n        // #6410 normalize windows newlines in <pre>:\r\n        // in SSR, browsers normalize server-rendered \\r\\n into a single \\n\r\n        // in the DOM\r\n        node.content = node.content.replace(windowsNewlineRE, '\\n')\r\n      }\r\n    }\r\n  }\r\n  if (inPre && tag && currentOptions.isPreTag(tag)) {\r\n    // remove leading newline per html spec\r\n    // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element\r\n    const first = nodes[0]\r\n    if (first && first.type === NodeTypes.TEXT) {\r\n      first.content = first.content.replace(/^\\r?\\n/, '')\r\n    }\r\n  }\r\n  return removedWhitespace ? nodes.filter(Boolean) : nodes\r\n}\r\n\r\nfunction isAllWhitespace(str: string) {\r\n  for (let i = 0; i < str.length; i++) {\r\n    if (!isWhitespace(str.charCodeAt(i))) {\r\n      return false\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\nfunction hasNewlineChar(str: string) {\r\n  for (let i = 0; i < str.length; i++) {\r\n    const c = str.charCodeAt(i)\r\n    if (c === CharCodes.NewLine || c === CharCodes.CarriageReturn) {\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nfunction condense(str: string) {\r\n  let ret = ''\r\n  let prevCharIsWhitespace = false\r\n  for (let i = 0; i < str.length; i++) {\r\n    if (isWhitespace(str.charCodeAt(i))) {\r\n      if (!prevCharIsWhitespace) {\r\n        ret += ' '\r\n        prevCharIsWhitespace = true\r\n      }\r\n    } else {\r\n      ret += str[i]\r\n      prevCharIsWhitespace = false\r\n    }\r\n  }\r\n  return ret\r\n}\r\n\r\nfunction addNode(node: TemplateChildNode) {\r\n  ;(stack[0] || currentRoot).children.push(node)\r\n}\r\n\r\nfunction getLoc(start: number, end?: number): SourceLocation {\r\n  return {\r\n    start: tokenizer.getPos(start),\r\n    // @ts-expect-error allow late attachment\r\n    end: end == null ? end : tokenizer.getPos(end),\r\n    // @ts-expect-error allow late attachment\r\n    source: end == null ? end : getSlice(start, end),\r\n  }\r\n}\r\n\r\nfunction setLocEnd(loc: SourceLocation, end: number) {\r\n  loc.end = tokenizer.getPos(end)\r\n  loc.source = getSlice(loc.start.offset, end)\r\n}\r\n\r\nfunction dirToAttr(dir: DirectiveNode): AttributeNode {\r\n  const attr: AttributeNode = {\r\n    type: NodeTypes.ATTRIBUTE,\r\n    name: dir.rawName!,\r\n    nameLoc: getLoc(\r\n      dir.loc.start.offset,\r\n      dir.loc.start.offset + dir.rawName!.length,\r\n    ),\r\n    value: undefined,\r\n    loc: dir.loc,\r\n  }\r\n  if (dir.exp) {\r\n    // account for quotes\r\n    const loc = dir.exp.loc\r\n    if (loc.end.offset < dir.loc.end.offset) {\r\n      loc.start.offset--\r\n      loc.start.column--\r\n      loc.end.offset++\r\n      loc.end.column++\r\n    }\r\n    attr.value = {\r\n      type: NodeTypes.TEXT,\r\n      content: (dir.exp as SimpleExpressionNode).content,\r\n      loc,\r\n    }\r\n  }\r\n  return attr\r\n}\r\n\r\nenum ExpParseMode {\r\n  Normal,\r\n  Params,\r\n  Statements,\r\n  Skip,\r\n}\r\n\r\nfunction createExp(\r\n  content: SimpleExpressionNode['content'],\r\n  isStatic: SimpleExpressionNode['isStatic'] = false,\r\n  loc: SourceLocation,\r\n  constType: ConstantTypes = ConstantTypes.NOT_CONSTANT,\r\n  parseMode = ExpParseMode.Normal,\r\n) {\r\n  const exp = createSimpleExpression(content, isStatic, loc, constType)\r\n  if (\r\n    !__BROWSER__ &&\r\n    !isStatic &&\r\n    currentOptions.prefixIdentifiers &&\r\n    parseMode !== ExpParseMode.Skip &&\r\n    content.trim()\r\n  ) {\r\n    if (isSimpleIdentifier(content)) {\r\n      exp.ast = null // fast path\r\n      return exp\r\n    }\r\n    try {\r\n      const plugins = currentOptions.expressionPlugins\r\n      const options: BabelOptions = {\r\n        plugins: plugins ? [...plugins, 'typescript'] : ['typescript'],\r\n      }\r\n      if (parseMode === ExpParseMode.Statements) {\r\n        // v-on with multi-inline-statements, pad 1 char\r\n        exp.ast = parse(` ${content} `, options).program\r\n      } else if (parseMode === ExpParseMode.Params) {\r\n        exp.ast = parseExpression(`(${content})=>{}`, options)\r\n      } else {\r\n        // normal exp, wrap with parens\r\n        exp.ast = parseExpression(`(${content})`, options)\r\n      }\r\n    } catch (e: any) {\r\n      exp.ast = false // indicate an error\r\n      emitError(ErrorCodes.X_INVALID_EXPRESSION, loc.start.offset, e.message)\r\n    }\r\n  }\r\n  return exp\r\n}\r\n\r\nfunction emitError(code: ErrorCodes, index: number, message?: string) {\r\n  currentOptions.onError(\r\n    createCompilerError(code, getLoc(index, index), undefined, message),\r\n  )\r\n}\r\n\r\nfunction reset() {\r\n  tokenizer.reset()\r\n  currentOpenTag = null\r\n  currentProp = null\r\n  currentAttrValue = ''\r\n  currentAttrStartIndex = -1\r\n  currentAttrEndIndex = -1\r\n  stack.length = 0\r\n}\r\n\r\nexport function baseParse(input: string, options?: ParserOptions): RootNode {\r\n  reset()\r\n  currentInput = input\r\n  currentOptions = extend({}, defaultParserOptions)\r\n\r\n  if (options) {\r\n    let key: keyof ParserOptions\r\n    for (key in options) {\r\n      if (options[key] != null) {\r\n        // @ts-expect-error\r\n        currentOptions[key] = options[key]\r\n      }\r\n    }\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (!__BROWSER__ && currentOptions.decodeEntities) {\r\n      console.warn(\r\n        `[@vue/compiler-core] decodeEntities option is passed but will be ` +\r\n          `ignored in non-browser builds.`,\r\n      )\r\n    } else if (__BROWSER__ && !currentOptions.decodeEntities) {\r\n      throw new Error(\r\n        `[@vue/compiler-core] decodeEntities option is required in browser builds.`,\r\n      )\r\n    }\r\n  }\r\n\r\n  tokenizer.mode =\r\n    currentOptions.parseMode === 'html'\r\n      ? ParseMode.HTML\r\n      : currentOptions.parseMode === 'sfc'\r\n        ? ParseMode.SFC\r\n        : ParseMode.BASE\r\n\r\n  tokenizer.inXML =\r\n    currentOptions.ns === Namespaces.SVG ||\r\n    currentOptions.ns === Namespaces.MATH_ML\r\n\r\n  const delimiters = options?.delimiters\r\n  if (delimiters) {\r\n    tokenizer.delimiterOpen = toCharCodes(delimiters[0])\r\n    tokenizer.delimiterClose = toCharCodes(delimiters[1])\r\n  }\r\n\r\n  const root = (currentRoot = createRoot([], input))\r\n  tokenizer.parse(currentInput)\r\n  root.loc = getLoc(0, input.length)\r\n  root.children = condenseWhitespace(root.children)\r\n  currentRoot = null\r\n  return root\r\n}\r\n","import {\r\n  type CallExpression,\r\n  type ComponentNode,\r\n  ConstantTypes,\r\n  ElementTypes,\r\n  type JSChildNode,\r\n  NodeTypes,\r\n  type ParentNode,\r\n  type PlainElementNode,\r\n  type RootNode,\r\n  type SimpleExpressionNode,\r\n  type TemplateChildNode,\r\n  type TemplateNode,\r\n  type VNodeCall,\r\n  createArrayExpression,\r\n  getVNodeBlockHelper,\r\n  getVNodeHelper,\r\n} from '../ast'\r\nimport type { TransformContext } from '../transform'\r\nimport { PatchFlags, isArray, isString, isSymbol } from '@vue/shared'\r\nimport { isSlotOutlet } from '../utils'\r\nimport {\r\n  GUARD_REACTIVE_PROPS,\r\n  NORMALIZE_CLASS,\r\n  NORMALIZE_PROPS,\r\n  NORMALIZE_STYLE,\r\n  OPEN_BLOCK,\r\n} from '../runtimeHelpers'\r\n\r\nexport function hoistStatic(root: RootNode, context: TransformContext) {\r\n  walk(\r\n    root,\r\n    context,\r\n    // Root node is unfortunately non-hoistable due to potential parent\r\n    // fallthrough attributes.\r\n    isSingleElementRoot(root, root.children[0]),\r\n  )\r\n}\r\n\r\nexport function isSingleElementRoot(\r\n  root: RootNode,\r\n  child: TemplateChildNode,\r\n): child is PlainElementNode | ComponentNode | TemplateNode {\r\n  const { children } = root\r\n  return (\r\n    children.length === 1 &&\r\n    child.type === NodeTypes.ELEMENT &&\r\n    !isSlotOutlet(child)\r\n  )\r\n}\r\n\r\nfunction walk(\r\n  node: ParentNode,\r\n  context: TransformContext,\r\n  doNotHoistNode: boolean = false,\r\n) {\r\n  const { children } = node\r\n  const originalCount = children.length\r\n  let hoistedCount = 0\r\n\r\n  for (let i = 0; i < children.length; i++) {\r\n    const child = children[i]\r\n    // only plain elements & text calls are eligible for hoisting.\r\n    if (\r\n      child.type === NodeTypes.ELEMENT &&\r\n      child.tagType === ElementTypes.ELEMENT\r\n    ) {\r\n      const constantType = doNotHoistNode\r\n        ? ConstantTypes.NOT_CONSTANT\r\n        : getConstantType(child, context)\r\n      if (constantType > ConstantTypes.NOT_CONSTANT) {\r\n        if (constantType >= ConstantTypes.CAN_HOIST) {\r\n          ;(child.codegenNode as VNodeCall).patchFlag =\r\n            PatchFlags.HOISTED + (__DEV__ ? ` /* HOISTED */` : ``)\r\n          child.codegenNode = context.hoist(child.codegenNode!)\r\n          hoistedCount++\r\n          continue\r\n        }\r\n      } else {\r\n        // node may contain dynamic children, but its props may be eligible for\r\n        // hoisting.\r\n        const codegenNode = child.codegenNode!\r\n        if (codegenNode.type === NodeTypes.VNODE_CALL) {\r\n          const flag = getPatchFlag(codegenNode)\r\n          if (\r\n            (!flag ||\r\n              flag === PatchFlags.NEED_PATCH ||\r\n              flag === PatchFlags.TEXT) &&\r\n            getGeneratedPropsConstantType(child, context) >=\r\n              ConstantTypes.CAN_HOIST\r\n          ) {\r\n            const props = getNodeProps(child)\r\n            if (props) {\r\n              codegenNode.props = context.hoist(props)\r\n            }\r\n          }\r\n          if (codegenNode.dynamicProps) {\r\n            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // walk further\r\n    if (child.type === NodeTypes.ELEMENT) {\r\n      const isComponent = child.tagType === ElementTypes.COMPONENT\r\n      if (isComponent) {\r\n        context.scopes.vSlot++\r\n      }\r\n      walk(child, context)\r\n      if (isComponent) {\r\n        context.scopes.vSlot--\r\n      }\r\n    } else if (child.type === NodeTypes.FOR) {\r\n      // Do not hoist v-for single child because it has to be a block\r\n      walk(child, context, child.children.length === 1)\r\n    } else if (child.type === NodeTypes.IF) {\r\n      for (let i = 0; i < child.branches.length; i++) {\r\n        // Do not hoist v-if single child because it has to be a block\r\n        walk(\r\n          child.branches[i],\r\n          context,\r\n          child.branches[i].children.length === 1,\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  if (hoistedCount && context.transformHoist) {\r\n    context.transformHoist(children, context, node)\r\n  }\r\n\r\n  // all children were hoisted - the entire children array is hoistable.\r\n  if (\r\n    hoistedCount &&\r\n    hoistedCount === originalCount &&\r\n    node.type === NodeTypes.ELEMENT &&\r\n    node.tagType === ElementTypes.ELEMENT &&\r\n    node.codegenNode &&\r\n    node.codegenNode.type === NodeTypes.VNODE_CALL &&\r\n    isArray(node.codegenNode.children)\r\n  ) {\r\n    const hoisted = context.hoist(\r\n      createArrayExpression(node.codegenNode.children),\r\n    )\r\n    // #6978, #7138, #7114\r\n    // a hoisted children array inside v-for can caused HMR errors since\r\n    // it might be mutated when mounting the v-for list\r\n    if (context.hmr) {\r\n      hoisted.content = `[...${hoisted.content}]`\r\n    }\r\n    node.codegenNode.children = hoisted\r\n  }\r\n}\r\n\r\nexport function getConstantType(\r\n  node: TemplateChildNode | SimpleExpressionNode,\r\n  context: TransformContext,\r\n): ConstantTypes {\r\n  const { constantCache } = context\r\n  switch (node.type) {\r\n    case NodeTypes.ELEMENT:\r\n      if (node.tagType !== ElementTypes.ELEMENT) {\r\n        return ConstantTypes.NOT_CONSTANT\r\n      }\r\n      const cached = constantCache.get(node)\r\n      if (cached !== undefined) {\r\n        return cached\r\n      }\r\n      const codegenNode = node.codegenNode!\r\n      if (codegenNode.type !== NodeTypes.VNODE_CALL) {\r\n        return ConstantTypes.NOT_CONSTANT\r\n      }\r\n      if (\r\n        codegenNode.isBlock &&\r\n        node.tag !== 'svg' &&\r\n        node.tag !== 'foreignObject'\r\n      ) {\r\n        return ConstantTypes.NOT_CONSTANT\r\n      }\r\n      const flag = getPatchFlag(codegenNode)\r\n      if (!flag) {\r\n        let returnType = ConstantTypes.CAN_STRINGIFY\r\n\r\n        // Element itself has no patch flag. However we still need to check:\r\n\r\n        // 1. Even for a node with no patch flag, it is possible for it to contain\r\n        // non-hoistable expressions that refers to scope variables, e.g. compiler\r\n        // injected keys or cached event handlers. Therefore we need to always\r\n        // check the codegenNode's props to be sure.\r\n        const generatedPropsType = getGeneratedPropsConstantType(node, context)\r\n        if (generatedPropsType === ConstantTypes.NOT_CONSTANT) {\r\n          constantCache.set(node, ConstantTypes.NOT_CONSTANT)\r\n          return ConstantTypes.NOT_CONSTANT\r\n        }\r\n        if (generatedPropsType < returnType) {\r\n          returnType = generatedPropsType\r\n        }\r\n\r\n        // 2. its children.\r\n        for (let i = 0; i < node.children.length; i++) {\r\n          const childType = getConstantType(node.children[i], context)\r\n          if (childType === ConstantTypes.NOT_CONSTANT) {\r\n            constantCache.set(node, ConstantTypes.NOT_CONSTANT)\r\n            return ConstantTypes.NOT_CONSTANT\r\n          }\r\n          if (childType < returnType) {\r\n            returnType = childType\r\n          }\r\n        }\r\n\r\n        // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0\r\n        // type, check if any of the props can cause the type to be lowered\r\n        // we can skip can_patch because it's guaranteed by the absence of a\r\n        // patchFlag.\r\n        if (returnType > ConstantTypes.CAN_SKIP_PATCH) {\r\n          for (let i = 0; i < node.props.length; i++) {\r\n            const p = node.props[i]\r\n            if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind' && p.exp) {\r\n              const expType = getConstantType(p.exp, context)\r\n              if (expType === ConstantTypes.NOT_CONSTANT) {\r\n                constantCache.set(node, ConstantTypes.NOT_CONSTANT)\r\n                return ConstantTypes.NOT_CONSTANT\r\n              }\r\n              if (expType < returnType) {\r\n                returnType = expType\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        // only svg/foreignObject could be block here, however if they are\r\n        // static then they don't need to be blocks since there will be no\r\n        // nested updates.\r\n        if (codegenNode.isBlock) {\r\n          // except set custom directives.\r\n          for (let i = 0; i < node.props.length; i++) {\r\n            const p = node.props[i]\r\n            if (p.type === NodeTypes.DIRECTIVE) {\r\n              constantCache.set(node, ConstantTypes.NOT_CONSTANT)\r\n              return ConstantTypes.NOT_CONSTANT\r\n            }\r\n          }\r\n\r\n          context.removeHelper(OPEN_BLOCK)\r\n          context.removeHelper(\r\n            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent),\r\n          )\r\n          codegenNode.isBlock = false\r\n          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent))\r\n        }\r\n\r\n        constantCache.set(node, returnType)\r\n        return returnType\r\n      } else {\r\n        constantCache.set(node, ConstantTypes.NOT_CONSTANT)\r\n        return ConstantTypes.NOT_CONSTANT\r\n      }\r\n    case NodeTypes.TEXT:\r\n    case NodeTypes.COMMENT:\r\n      return ConstantTypes.CAN_STRINGIFY\r\n    case NodeTypes.IF:\r\n    case NodeTypes.FOR:\r\n    case NodeTypes.IF_BRANCH:\r\n      return ConstantTypes.NOT_CONSTANT\r\n    case NodeTypes.INTERPOLATION:\r\n    case NodeTypes.TEXT_CALL:\r\n      return getConstantType(node.content, context)\r\n    case NodeTypes.SIMPLE_EXPRESSION:\r\n      return node.constType\r\n    case NodeTypes.COMPOUND_EXPRESSION:\r\n      let returnType = ConstantTypes.CAN_STRINGIFY\r\n      for (let i = 0; i < node.children.length; i++) {\r\n        const child = node.children[i]\r\n        if (isString(child) || isSymbol(child)) {\r\n          continue\r\n        }\r\n        const childType = getConstantType(child, context)\r\n        if (childType === ConstantTypes.NOT_CONSTANT) {\r\n          return ConstantTypes.NOT_CONSTANT\r\n        } else if (childType < returnType) {\r\n          returnType = childType\r\n        }\r\n      }\r\n      return returnType\r\n    default:\r\n      if (__DEV__) {\r\n        const exhaustiveCheck: never = node\r\n        exhaustiveCheck\r\n      }\r\n      return ConstantTypes.NOT_CONSTANT\r\n  }\r\n}\r\n\r\nconst allowHoistedHelperSet = new Set([\r\n  NORMALIZE_CLASS,\r\n  NORMALIZE_STYLE,\r\n  NORMALIZE_PROPS,\r\n  GUARD_REACTIVE_PROPS,\r\n])\r\n\r\nfunction getConstantTypeOfHelperCall(\r\n  value: CallExpression,\r\n  context: TransformContext,\r\n): ConstantTypes {\r\n  if (\r\n    value.type === NodeTypes.JS_CALL_EXPRESSION &&\r\n    !isString(value.callee) &&\r\n    allowHoistedHelperSet.has(value.callee)\r\n  ) {\r\n    const arg = value.arguments[0] as JSChildNode\r\n    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n      return getConstantType(arg, context)\r\n    } else if (arg.type === NodeTypes.JS_CALL_EXPRESSION) {\r\n      // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`\r\n      return getConstantTypeOfHelperCall(arg, context)\r\n    }\r\n  }\r\n  return ConstantTypes.NOT_CONSTANT\r\n}\r\n\r\nfunction getGeneratedPropsConstantType(\r\n  node: PlainElementNode,\r\n  context: TransformContext,\r\n): ConstantTypes {\r\n  let returnType = ConstantTypes.CAN_STRINGIFY\r\n  const props = getNodeProps(node)\r\n  if (props && props.type === NodeTypes.JS_OBJECT_EXPRESSION) {\r\n    const { properties } = props\r\n    for (let i = 0; i < properties.length; i++) {\r\n      const { key, value } = properties[i]\r\n      const keyType = getConstantType(key, context)\r\n      if (keyType === ConstantTypes.NOT_CONSTANT) {\r\n        return keyType\r\n      }\r\n      if (keyType < returnType) {\r\n        returnType = keyType\r\n      }\r\n      let valueType: ConstantTypes\r\n      if (value.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n        valueType = getConstantType(value, context)\r\n      } else if (value.type === NodeTypes.JS_CALL_EXPRESSION) {\r\n        // some helper calls can be hoisted,\r\n        // such as the `normalizeProps` generated by the compiler for pre-normalize class,\r\n        // in this case we need to respect the ConstantType of the helper's arguments\r\n        valueType = getConstantTypeOfHelperCall(value, context)\r\n      } else {\r\n        valueType = ConstantTypes.NOT_CONSTANT\r\n      }\r\n      if (valueType === ConstantTypes.NOT_CONSTANT) {\r\n        return valueType\r\n      }\r\n      if (valueType < returnType) {\r\n        returnType = valueType\r\n      }\r\n    }\r\n  }\r\n  return returnType\r\n}\r\n\r\nfunction getNodeProps(node: PlainElementNode) {\r\n  const codegenNode = node.codegenNode!\r\n  if (codegenNode.type === NodeTypes.VNODE_CALL) {\r\n    return codegenNode.props\r\n  }\r\n}\r\n\r\nfunction getPatchFlag(node: VNodeCall): number | undefined {\r\n  const flag = node.patchFlag\r\n  return flag ? parseInt(flag, 10) : undefined\r\n}\r\n","import type { TransformOptions } from './options'\r\nimport {\r\n  type ArrayExpression,\r\n  type CacheExpression,\r\n  ConstantTypes,\r\n  type DirectiveNode,\r\n  type ElementNode,\r\n  ElementTypes,\r\n  type ExpressionNode,\r\n  type JSChildNode,\r\n  NodeTypes,\r\n  type ParentNode,\r\n  type Property,\r\n  type RootNode,\r\n  type SimpleExpressionNode,\r\n  type TemplateChildNode,\r\n  type TemplateLiteral,\r\n  convertToBlock,\r\n  createCacheExpression,\r\n  createSimpleExpression,\r\n  createVNodeCall,\r\n} from './ast'\r\nimport {\r\n  EMPTY_OBJ,\r\n  NOOP,\r\n  PatchFlagNames,\r\n  PatchFlags,\r\n  camelize,\r\n  capitalize,\r\n  isArray,\r\n  isString,\r\n} from '@vue/shared'\r\nimport { defaultOnError, defaultOnWarn } from './errors'\r\nimport {\r\n  CREATE_COMMENT,\r\n  FRAGMENT,\r\n  TO_DISPLAY_STRING,\r\n  helperNameMap,\r\n} from './runtimeHelpers'\r\nimport { isVSlot } from './utils'\r\nimport { hoistStatic, isSingleElementRoot } from './transforms/hoistStatic'\r\nimport type { CompilerCompatOptions } from './compat/compatConfig'\r\n\r\n// There are two types of transforms:\r\n//\r\n// - NodeTransform:\r\n//   Transforms that operate directly on a ChildNode. NodeTransforms may mutate,\r\n//   replace or remove the node being processed.\r\nexport type NodeTransform = (\r\n  node: RootNode | TemplateChildNode,\r\n  context: TransformContext,\r\n) => void | (() => void) | (() => void)[]\r\n\r\n// - DirectiveTransform:\r\n//   Transforms that handles a single directive attribute on an element.\r\n//   It translates the raw directive into actual props for the VNode.\r\nexport type DirectiveTransform = (\r\n  dir: DirectiveNode,\r\n  node: ElementNode,\r\n  context: TransformContext,\r\n  // a platform specific compiler can import the base transform and augment\r\n  // it by passing in this optional argument.\r\n  augmentor?: (ret: DirectiveTransformResult) => DirectiveTransformResult,\r\n) => DirectiveTransformResult\r\n\r\nexport interface DirectiveTransformResult {\r\n  props: Property[]\r\n  needRuntime?: boolean | symbol\r\n  ssrTagParts?: TemplateLiteral['elements']\r\n}\r\n\r\n// A structural directive transform is technically also a NodeTransform;\r\n// Only v-if and v-for fall into this category.\r\nexport type StructuralDirectiveTransform = (\r\n  node: ElementNode,\r\n  dir: DirectiveNode,\r\n  context: TransformContext,\r\n) => void | (() => void)\r\n\r\nexport interface ImportItem {\r\n  exp: string | ExpressionNode\r\n  path: string\r\n}\r\n\r\nexport interface TransformContext\r\n  extends Required<Omit<TransformOptions, keyof CompilerCompatOptions>>,\r\n    CompilerCompatOptions {\r\n  selfName: string | null\r\n  root: RootNode\r\n  helpers: Map<symbol, number>\r\n  components: Set<string>\r\n  directives: Set<string>\r\n  hoists: (JSChildNode | null)[]\r\n  imports: ImportItem[]\r\n  temps: number\r\n  cached: number\r\n  identifiers: { [name: string]: number | undefined }\r\n  scopes: {\r\n    vFor: number\r\n    vSlot: number\r\n    vPre: number\r\n    vOnce: number\r\n  }\r\n  parent: ParentNode | null\r\n  childIndex: number\r\n  currentNode: RootNode | TemplateChildNode | null\r\n  inVOnce: boolean\r\n  helper<T extends symbol>(name: T): T\r\n  removeHelper<T extends symbol>(name: T): void\r\n  helperString(name: symbol): string\r\n  replaceNode(node: TemplateChildNode): void\r\n  removeNode(node?: TemplateChildNode): void\r\n  onNodeRemoved(): void\r\n  addIdentifiers(exp: ExpressionNode | string): void\r\n  removeIdentifiers(exp: ExpressionNode | string): void\r\n  hoist(exp: string | JSChildNode | ArrayExpression): SimpleExpressionNode\r\n  cache<T extends JSChildNode>(exp: T, isVNode?: boolean): CacheExpression | T\r\n  constantCache: WeakMap<TemplateChildNode, ConstantTypes>\r\n\r\n  // 2.x Compat only\r\n  filters?: Set<string>\r\n}\r\n\r\nexport function createTransformContext(\r\n  root: RootNode,\r\n  {\r\n    filename = '',\r\n    prefixIdentifiers = false,\r\n    hoistStatic = false,\r\n    hmr = false,\r\n    cacheHandlers = false,\r\n    nodeTransforms = [],\r\n    directiveTransforms = {},\r\n    transformHoist = null,\r\n    isBuiltInComponent = NOOP,\r\n    isCustomElement = NOOP,\r\n    expressionPlugins = [],\r\n    scopeId = null,\r\n    slotted = true,\r\n    ssr = false,\r\n    inSSR = false,\r\n    ssrCssVars = ``,\r\n    bindingMetadata = EMPTY_OBJ,\r\n    inline = false,\r\n    isTS = false,\r\n    onError = defaultOnError,\r\n    onWarn = defaultOnWarn,\r\n    compatConfig,\r\n  }: TransformOptions,\r\n): TransformContext {\r\n  const nameMatch = filename.replace(/\\?.*$/, '').match(/([^/\\\\]+)\\.\\w+$/)\r\n  const context: TransformContext = {\r\n    // options\r\n    filename,\r\n    selfName: nameMatch && capitalize(camelize(nameMatch[1])),\r\n    prefixIdentifiers,\r\n    hoistStatic,\r\n    hmr,\r\n    cacheHandlers,\r\n    nodeTransforms,\r\n    directiveTransforms,\r\n    transformHoist,\r\n    isBuiltInComponent,\r\n    isCustomElement,\r\n    expressionPlugins,\r\n    scopeId,\r\n    slotted,\r\n    ssr,\r\n    inSSR,\r\n    ssrCssVars,\r\n    bindingMetadata,\r\n    inline,\r\n    isTS,\r\n    onError,\r\n    onWarn,\r\n    compatConfig,\r\n\r\n    // state\r\n    root,\r\n    helpers: new Map(),\r\n    components: new Set(),\r\n    directives: new Set(),\r\n    hoists: [],\r\n    imports: [],\r\n    constantCache: new WeakMap(),\r\n    temps: 0,\r\n    cached: 0,\r\n    identifiers: Object.create(null),\r\n    scopes: {\r\n      vFor: 0,\r\n      vSlot: 0,\r\n      vPre: 0,\r\n      vOnce: 0,\r\n    },\r\n    parent: null,\r\n    currentNode: root,\r\n    childIndex: 0,\r\n    inVOnce: false,\r\n\r\n    // methods\r\n    helper(name) {\r\n      const count = context.helpers.get(name) || 0\r\n      context.helpers.set(name, count + 1)\r\n      return name\r\n    },\r\n    removeHelper(name) {\r\n      const count = context.helpers.get(name)\r\n      if (count) {\r\n        const currentCount = count - 1\r\n        if (!currentCount) {\r\n          context.helpers.delete(name)\r\n        } else {\r\n          context.helpers.set(name, currentCount)\r\n        }\r\n      }\r\n    },\r\n    helperString(name) {\r\n      return `_${helperNameMap[context.helper(name)]}`\r\n    },\r\n    replaceNode(node) {\r\n      /* istanbul ignore if */\r\n      if (__DEV__) {\r\n        if (!context.currentNode) {\r\n          throw new Error(`Node being replaced is already removed.`)\r\n        }\r\n        if (!context.parent) {\r\n          throw new Error(`Cannot replace root node.`)\r\n        }\r\n      }\r\n      context.parent!.children[context.childIndex] = context.currentNode = node\r\n    },\r\n    removeNode(node) {\r\n      if (__DEV__ && !context.parent) {\r\n        throw new Error(`Cannot remove root node.`)\r\n      }\r\n      const list = context.parent!.children\r\n      const removalIndex = node\r\n        ? list.indexOf(node)\r\n        : context.currentNode\r\n          ? context.childIndex\r\n          : -1\r\n      /* istanbul ignore if */\r\n      if (__DEV__ && removalIndex < 0) {\r\n        throw new Error(`node being removed is not a child of current parent`)\r\n      }\r\n      if (!node || node === context.currentNode) {\r\n        // current node removed\r\n        context.currentNode = null\r\n        context.onNodeRemoved()\r\n      } else {\r\n        // sibling node removed\r\n        if (context.childIndex > removalIndex) {\r\n          context.childIndex--\r\n          context.onNodeRemoved()\r\n        }\r\n      }\r\n      context.parent!.children.splice(removalIndex, 1)\r\n    },\r\n    onNodeRemoved: NOOP,\r\n    addIdentifiers(exp) {\r\n      // identifier tracking only happens in non-browser builds.\r\n      if (!__BROWSER__) {\r\n        if (isString(exp)) {\r\n          addId(exp)\r\n        } else if (exp.identifiers) {\r\n          exp.identifiers.forEach(addId)\r\n        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n          addId(exp.content)\r\n        }\r\n      }\r\n    },\r\n    removeIdentifiers(exp) {\r\n      if (!__BROWSER__) {\r\n        if (isString(exp)) {\r\n          removeId(exp)\r\n        } else if (exp.identifiers) {\r\n          exp.identifiers.forEach(removeId)\r\n        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n          removeId(exp.content)\r\n        }\r\n      }\r\n    },\r\n    hoist(exp) {\r\n      if (isString(exp)) exp = createSimpleExpression(exp)\r\n      context.hoists.push(exp)\r\n      const identifier = createSimpleExpression(\r\n        `_hoisted_${context.hoists.length}`,\r\n        false,\r\n        exp.loc,\r\n        ConstantTypes.CAN_HOIST,\r\n      )\r\n      identifier.hoisted = exp\r\n      return identifier\r\n    },\r\n    cache(exp, isVNode = false) {\r\n      return createCacheExpression(context.cached++, exp, isVNode)\r\n    },\r\n  }\r\n\r\n  if (__COMPAT__) {\r\n    context.filters = new Set()\r\n  }\r\n\r\n  function addId(id: string) {\r\n    const { identifiers } = context\r\n    if (identifiers[id] === undefined) {\r\n      identifiers[id] = 0\r\n    }\r\n    identifiers[id]!++\r\n  }\r\n\r\n  function removeId(id: string) {\r\n    context.identifiers[id]!--\r\n  }\r\n\r\n  return context\r\n}\r\n\r\nexport function transform(root: RootNode, options: TransformOptions) {\r\n  const context = createTransformContext(root, options)\r\n  traverseNode(root, context)\r\n  if (options.hoistStatic) {\r\n    hoistStatic(root, context)\r\n  }\r\n  if (!options.ssr) {\r\n    createRootCodegen(root, context)\r\n  }\r\n  // finalize meta information\r\n  root.helpers = new Set([...context.helpers.keys()])\r\n  root.components = [...context.components]\r\n  root.directives = [...context.directives]\r\n  root.imports = context.imports\r\n  root.hoists = context.hoists\r\n  root.temps = context.temps\r\n  root.cached = context.cached\r\n  root.transformed = true\r\n\r\n  if (__COMPAT__) {\r\n    root.filters = [...context.filters!]\r\n  }\r\n}\r\n\r\nfunction createRootCodegen(root: RootNode, context: TransformContext) {\r\n  const { helper } = context\r\n  const { children } = root\r\n  if (children.length === 1) {\r\n    const child = children[0]\r\n    // if the single child is an element, turn it into a block.\r\n    if (isSingleElementRoot(root, child) && child.codegenNode) {\r\n      // single element root is never hoisted so codegenNode will never be\r\n      // SimpleExpressionNode\r\n      const codegenNode = child.codegenNode\r\n      if (codegenNode.type === NodeTypes.VNODE_CALL) {\r\n        convertToBlock(codegenNode, context)\r\n      }\r\n      root.codegenNode = codegenNode\r\n    } else {\r\n      // - single <slot/>, IfNode, ForNode: already blocks.\r\n      // - single text node: always patched.\r\n      // root codegen falls through via genNode()\r\n      root.codegenNode = child\r\n    }\r\n  } else if (children.length > 1) {\r\n    // root has multiple nodes - return a fragment block.\r\n    let patchFlag = PatchFlags.STABLE_FRAGMENT\r\n    let patchFlagText = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]\r\n    // check if the fragment actually contains a single valid child with\r\n    // the rest being comments\r\n    if (\r\n      __DEV__ &&\r\n      children.filter(c => c.type !== NodeTypes.COMMENT).length === 1\r\n    ) {\r\n      patchFlag |= PatchFlags.DEV_ROOT_FRAGMENT\r\n      patchFlagText += `, ${PatchFlagNames[PatchFlags.DEV_ROOT_FRAGMENT]}`\r\n    }\r\n    root.codegenNode = createVNodeCall(\r\n      context,\r\n      helper(FRAGMENT),\r\n      undefined,\r\n      root.children,\r\n      patchFlag + (__DEV__ ? ` /* ${patchFlagText} */` : ``),\r\n      undefined,\r\n      undefined,\r\n      true,\r\n      undefined,\r\n      false /* isComponent */,\r\n    )\r\n  } else {\r\n    // no children = noop. codegen will return null.\r\n  }\r\n}\r\n\r\nexport function traverseChildren(\r\n  parent: ParentNode,\r\n  context: TransformContext,\r\n) {\r\n  let i = 0\r\n  const nodeRemoved = () => {\r\n    i--\r\n  }\r\n  for (; i < parent.children.length; i++) {\r\n    const child = parent.children[i]\r\n    if (isString(child)) continue\r\n    context.parent = parent\r\n    context.childIndex = i\r\n    context.onNodeRemoved = nodeRemoved\r\n    traverseNode(child, context)\r\n  }\r\n}\r\n\r\nexport function traverseNode(\r\n  node: RootNode | TemplateChildNode,\r\n  context: TransformContext,\r\n) {\r\n  context.currentNode = node\r\n  // apply transform plugins\r\n  const { nodeTransforms } = context\r\n  const exitFns = []\r\n  for (let i = 0; i < nodeTransforms.length; i++) {\r\n    const onExit = nodeTransforms[i](node, context)\r\n    if (onExit) {\r\n      if (isArray(onExit)) {\r\n        exitFns.push(...onExit)\r\n      } else {\r\n        exitFns.push(onExit)\r\n      }\r\n    }\r\n    if (!context.currentNode) {\r\n      // node was removed\r\n      return\r\n    } else {\r\n      // node may have been replaced\r\n      node = context.currentNode\r\n    }\r\n  }\r\n\r\n  switch (node.type) {\r\n    case NodeTypes.COMMENT:\r\n      if (!context.ssr) {\r\n        // inject import for the Comment symbol, which is needed for creating\r\n        // comment nodes with `createVNode`\r\n        context.helper(CREATE_COMMENT)\r\n      }\r\n      break\r\n    case NodeTypes.INTERPOLATION:\r\n      // no need to traverse, but we need to inject toString helper\r\n      if (!context.ssr) {\r\n        context.helper(TO_DISPLAY_STRING)\r\n      }\r\n      break\r\n\r\n    // for container types, further traverse downwards\r\n    case NodeTypes.IF:\r\n      for (let i = 0; i < node.branches.length; i++) {\r\n        traverseNode(node.branches[i], context)\r\n      }\r\n      break\r\n    case NodeTypes.IF_BRANCH:\r\n    case NodeTypes.FOR:\r\n    case NodeTypes.ELEMENT:\r\n    case NodeTypes.ROOT:\r\n      traverseChildren(node, context)\r\n      break\r\n  }\r\n\r\n  // exit transforms\r\n  context.currentNode = node\r\n  let i = exitFns.length\r\n  while (i--) {\r\n    exitFns[i]()\r\n  }\r\n}\r\n\r\nexport function createStructuralDirectiveTransform(\r\n  name: string | RegExp,\r\n  fn: StructuralDirectiveTransform,\r\n): NodeTransform {\r\n  const matches = isString(name)\r\n    ? (n: string) => n === name\r\n    : (n: string) => name.test(n)\r\n\r\n  return (node, context) => {\r\n    if (node.type === NodeTypes.ELEMENT) {\r\n      const { props } = node\r\n      // structural directive transforms are not concerned with slots\r\n      // as they are handled separately in vSlot.ts\r\n      if (node.tagType === ElementTypes.TEMPLATE && props.some(isVSlot)) {\r\n        return\r\n      }\r\n      const exitFns = []\r\n      for (let i = 0; i < props.length; i++) {\r\n        const prop = props[i]\r\n        if (prop.type === NodeTypes.DIRECTIVE && matches(prop.name)) {\r\n          // structural directives are removed to avoid infinite recursion\r\n          // also we remove them *before* applying so that it can further\r\n          // traverse itself in case it moves the node around\r\n          props.splice(i, 1)\r\n          i--\r\n          const onExit = fn(node, prop, context)\r\n          if (onExit) exitFns.push(onExit)\r\n        }\r\n      }\r\n      return exitFns\r\n    }\r\n  }\r\n}\r\n","import type { CodegenOptions } from './options'\r\nimport {\r\n  type ArrayExpression,\r\n  type AssignmentExpression,\r\n  type CacheExpression,\r\n  type CallExpression,\r\n  type CommentNode,\r\n  type CompoundExpressionNode,\r\n  type ConditionalExpression,\r\n  type ExpressionNode,\r\n  type FunctionExpression,\r\n  type IfStatement,\r\n  type InterpolationNode,\r\n  type JSChildNode,\r\n  NodeTypes,\r\n  type ObjectExpression,\r\n  type Position,\r\n  type ReturnStatement,\r\n  type RootNode,\r\n  type SSRCodegenNode,\r\n  type SequenceExpression,\r\n  type SimpleExpressionNode,\r\n  type TemplateChildNode,\r\n  type TemplateLiteral,\r\n  type TextNode,\r\n  type VNodeCall,\r\n  getVNodeBlockHelper,\r\n  getVNodeHelper,\r\n  locStub,\r\n} from './ast'\r\nimport { type RawSourceMap, SourceMapGenerator } from 'source-map-js'\r\nimport {\r\n  advancePositionWithMutation,\r\n  assert,\r\n  isSimpleIdentifier,\r\n  toValidAssetId,\r\n} from './utils'\r\nimport { isArray, isString, isSymbol } from '@vue/shared'\r\nimport {\r\n  CREATE_COMMENT,\r\n  CREATE_ELEMENT_VNODE,\r\n  CREATE_STATIC,\r\n  CREATE_TEXT,\r\n  CREATE_VNODE,\r\n  OPEN_BLOCK,\r\n  POP_SCOPE_ID,\r\n  PUSH_SCOPE_ID,\r\n  RESOLVE_COMPONENT,\r\n  RESOLVE_DIRECTIVE,\r\n  RESOLVE_FILTER,\r\n  SET_BLOCK_TRACKING,\r\n  TO_DISPLAY_STRING,\r\n  WITH_CTX,\r\n  WITH_DIRECTIVES,\r\n  helperNameMap,\r\n} from './runtimeHelpers'\r\nimport type { ImportItem } from './transform'\r\n\r\nconst PURE_ANNOTATION = `/*#__PURE__*/`\r\n\r\nconst aliasHelper = (s: symbol) => `${helperNameMap[s]}: _${helperNameMap[s]}`\r\n\r\ntype CodegenNode = TemplateChildNode | JSChildNode | SSRCodegenNode\r\n\r\nexport interface CodegenResult {\r\n  code: string\r\n  preamble: string\r\n  ast: RootNode\r\n  map?: RawSourceMap\r\n}\r\n\r\nenum NewlineType {\r\n  Start = 0,\r\n  End = -1,\r\n  None = -2,\r\n  Unknown = -3,\r\n}\r\n\r\nexport interface CodegenContext\r\n  extends Omit<Required<CodegenOptions>, 'bindingMetadata' | 'inline'> {\r\n  source: string\r\n  code: string\r\n  line: number\r\n  column: number\r\n  offset: number\r\n  indentLevel: number\r\n  pure: boolean\r\n  map?: SourceMapGenerator\r\n  helper(key: symbol): string\r\n  push(code: string, newlineIndex?: number, node?: CodegenNode): void\r\n  indent(): void\r\n  deindent(withoutNewLine?: boolean): void\r\n  newline(): void\r\n}\r\n\r\nfunction createCodegenContext(\r\n  ast: RootNode,\r\n  {\r\n    mode = 'function',\r\n    prefixIdentifiers = mode === 'module',\r\n    sourceMap = false,\r\n    filename = `template.vue.html`,\r\n    scopeId = null,\r\n    optimizeImports = false,\r\n    runtimeGlobalName = `Vue`,\r\n    runtimeModuleName = `vue`,\r\n    ssrRuntimeModuleName = 'vue/server-renderer',\r\n    ssr = false,\r\n    isTS = false,\r\n    inSSR = false,\r\n  }: CodegenOptions,\r\n): CodegenContext {\r\n  const context: CodegenContext = {\r\n    mode,\r\n    prefixIdentifiers,\r\n    sourceMap,\r\n    filename,\r\n    scopeId,\r\n    optimizeImports,\r\n    runtimeGlobalName,\r\n    runtimeModuleName,\r\n    ssrRuntimeModuleName,\r\n    ssr,\r\n    isTS,\r\n    inSSR,\r\n    source: ast.source,\r\n    code: ``,\r\n    column: 1,\r\n    line: 1,\r\n    offset: 0,\r\n    indentLevel: 0,\r\n    pure: false,\r\n    map: undefined,\r\n    helper(key) {\r\n      return `_${helperNameMap[key]}`\r\n    },\r\n    push(code, newlineIndex = NewlineType.None, node) {\r\n      context.code += code\r\n      if (!__BROWSER__ && context.map) {\r\n        if (node) {\r\n          let name\r\n          if (node.type === NodeTypes.SIMPLE_EXPRESSION && !node.isStatic) {\r\n            const content = node.content.replace(/^_ctx\\./, '')\r\n            if (content !== node.content && isSimpleIdentifier(content)) {\r\n              name = content\r\n            }\r\n          }\r\n          addMapping(node.loc.start, name)\r\n        }\r\n        if (newlineIndex === NewlineType.Unknown) {\r\n          // multiple newlines, full iteration\r\n          advancePositionWithMutation(context, code)\r\n        } else {\r\n          // fast paths\r\n          context.offset += code.length\r\n          if (newlineIndex === NewlineType.None) {\r\n            // no newlines; fast path to avoid newline detection\r\n            if (__TEST__ && code.includes('\\n')) {\r\n              throw new Error(\r\n                `CodegenContext.push() called newlineIndex: none, but contains` +\r\n                  `newlines: ${code.replace(/\\n/g, '\\\\n')}`,\r\n              )\r\n            }\r\n            context.column += code.length\r\n          } else {\r\n            // single newline at known index\r\n            if (newlineIndex === NewlineType.End) {\r\n              newlineIndex = code.length - 1\r\n            }\r\n            if (\r\n              __TEST__ &&\r\n              (code.charAt(newlineIndex) !== '\\n' ||\r\n                code.slice(0, newlineIndex).includes('\\n') ||\r\n                code.slice(newlineIndex + 1).includes('\\n'))\r\n            ) {\r\n              throw new Error(\r\n                `CodegenContext.push() called with newlineIndex: ${newlineIndex} ` +\r\n                  `but does not conform: ${code.replace(/\\n/g, '\\\\n')}`,\r\n              )\r\n            }\r\n            context.line++\r\n            context.column = code.length - newlineIndex\r\n          }\r\n        }\r\n        if (node && node.loc !== locStub) {\r\n          addMapping(node.loc.end)\r\n        }\r\n      }\r\n    },\r\n    indent() {\r\n      newline(++context.indentLevel)\r\n    },\r\n    deindent(withoutNewLine = false) {\r\n      if (withoutNewLine) {\r\n        --context.indentLevel\r\n      } else {\r\n        newline(--context.indentLevel)\r\n      }\r\n    },\r\n    newline() {\r\n      newline(context.indentLevel)\r\n    },\r\n  }\r\n\r\n  function newline(n: number) {\r\n    context.push('\\n' + `  `.repeat(n), NewlineType.Start)\r\n  }\r\n\r\n  function addMapping(loc: Position, name: string | null = null) {\r\n    // we use the private property to directly add the mapping\r\n    // because the addMapping() implementation in source-map-js has a bunch of\r\n    // unnecessary arg and validation checks that are pure overhead in our case.\r\n    const { _names, _mappings } = context.map!\r\n    if (name !== null && !_names.has(name)) _names.add(name)\r\n    _mappings.add({\r\n      originalLine: loc.line,\r\n      originalColumn: loc.column - 1, // source-map column is 0 based\r\n      generatedLine: context.line,\r\n      generatedColumn: context.column - 1,\r\n      source: filename,\r\n      // @ts-expect-error it is possible to be null\r\n      name,\r\n    })\r\n  }\r\n\r\n  if (!__BROWSER__ && sourceMap) {\r\n    // lazy require source-map implementation, only in non-browser builds\r\n    context.map = new SourceMapGenerator()\r\n    context.map.setSourceContent(filename, context.source)\r\n    context.map._sources.add(filename)\r\n  }\r\n\r\n  return context\r\n}\r\n\r\nexport function generate(\r\n  ast: RootNode,\r\n  options: CodegenOptions & {\r\n    onContextCreated?: (context: CodegenContext) => void\r\n  } = {},\r\n): CodegenResult {\r\n  const context = createCodegenContext(ast, options)\r\n  if (options.onContextCreated) options.onContextCreated(context)\r\n  const {\r\n    mode,\r\n    push,\r\n    prefixIdentifiers,\r\n    indent,\r\n    deindent,\r\n    newline,\r\n    scopeId,\r\n    ssr,\r\n  } = context\r\n\r\n  const helpers = Array.from(ast.helpers)\r\n  const hasHelpers = helpers.length > 0\r\n  const useWithBlock = !prefixIdentifiers && mode !== 'module'\r\n  const genScopeId = !__BROWSER__ && scopeId != null && mode === 'module'\r\n  const isSetupInlined = !__BROWSER__ && !!options.inline\r\n\r\n  // preambles\r\n  // in setup() inline mode, the preamble is generated in a sub context\r\n  // and returned separately.\r\n  const preambleContext = isSetupInlined\r\n    ? createCodegenContext(ast, options)\r\n    : context\r\n  if (!__BROWSER__ && mode === 'module') {\r\n    genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined)\r\n  } else {\r\n    genFunctionPreamble(ast, preambleContext)\r\n  }\r\n  // enter render function\r\n  const functionName = ssr ? `ssrRender` : `render`\r\n  const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache']\r\n  if (!__BROWSER__ && options.bindingMetadata && !options.inline) {\r\n    // binding optimization args\r\n    args.push('$props', '$setup', '$data', '$options')\r\n  }\r\n  const signature =\r\n    !__BROWSER__ && options.isTS\r\n      ? args.map(arg => `${arg}: any`).join(',')\r\n      : args.join(', ')\r\n\r\n  if (isSetupInlined) {\r\n    push(`(${signature}) => {`)\r\n  } else {\r\n    push(`function ${functionName}(${signature}) {`)\r\n  }\r\n  indent()\r\n\r\n  if (useWithBlock) {\r\n    push(`with (_ctx) {`)\r\n    indent()\r\n    // function mode const declarations should be inside with block\r\n    // also they should be renamed to avoid collision with user properties\r\n    if (hasHelpers) {\r\n      push(\r\n        `const { ${helpers.map(aliasHelper).join(', ')} } = _Vue\\n`,\r\n        NewlineType.End,\r\n      )\r\n      newline()\r\n    }\r\n  }\r\n\r\n  // generate asset resolution statements\r\n  if (ast.components.length) {\r\n    genAssets(ast.components, 'component', context)\r\n    if (ast.directives.length || ast.temps > 0) {\r\n      newline()\r\n    }\r\n  }\r\n  if (ast.directives.length) {\r\n    genAssets(ast.directives, 'directive', context)\r\n    if (ast.temps > 0) {\r\n      newline()\r\n    }\r\n  }\r\n  if (__COMPAT__ && ast.filters && ast.filters.length) {\r\n    newline()\r\n    genAssets(ast.filters, 'filter', context)\r\n    newline()\r\n  }\r\n\r\n  if (ast.temps > 0) {\r\n    push(`let `)\r\n    for (let i = 0; i < ast.temps; i++) {\r\n      push(`${i > 0 ? `, ` : ``}_temp${i}`)\r\n    }\r\n  }\r\n  if (ast.components.length || ast.directives.length || ast.temps) {\r\n    push(`\\n`, NewlineType.Start)\r\n    newline()\r\n  }\r\n\r\n  // generate the VNode tree expression\r\n  if (!ssr) {\r\n    push(`return `)\r\n  }\r\n  if (ast.codegenNode) {\r\n    genNode(ast.codegenNode, context)\r\n  } else {\r\n    push(`null`)\r\n  }\r\n\r\n  if (useWithBlock) {\r\n    deindent()\r\n    push(`}`)\r\n  }\r\n\r\n  deindent()\r\n  push(`}`)\r\n\r\n  return {\r\n    ast,\r\n    code: context.code,\r\n    preamble: isSetupInlined ? preambleContext.code : ``,\r\n    map: context.map ? context.map.toJSON() : undefined,\r\n  }\r\n}\r\n\r\nfunction genFunctionPreamble(ast: RootNode, context: CodegenContext) {\r\n  const {\r\n    ssr,\r\n    prefixIdentifiers,\r\n    push,\r\n    newline,\r\n    runtimeModuleName,\r\n    runtimeGlobalName,\r\n    ssrRuntimeModuleName,\r\n  } = context\r\n  const VueBinding =\r\n    !__BROWSER__ && ssr\r\n      ? `require(${JSON.stringify(runtimeModuleName)})`\r\n      : runtimeGlobalName\r\n  // Generate const declaration for helpers\r\n  // In prefix mode, we place the const declaration at top so it's done\r\n  // only once; But if we not prefixing, we place the declaration inside the\r\n  // with block so it doesn't incur the `in` check cost for every helper access.\r\n  const helpers = Array.from(ast.helpers)\r\n  if (helpers.length > 0) {\r\n    if (!__BROWSER__ && prefixIdentifiers) {\r\n      push(\r\n        `const { ${helpers.map(aliasHelper).join(', ')} } = ${VueBinding}\\n`,\r\n        NewlineType.End,\r\n      )\r\n    } else {\r\n      // \"with\" mode.\r\n      // save Vue in a separate variable to avoid collision\r\n      push(`const _Vue = ${VueBinding}\\n`, NewlineType.End)\r\n      // in \"with\" mode, helpers are declared inside the with block to avoid\r\n      // has check cost, but hoists are lifted out of the function - we need\r\n      // to provide the helper here.\r\n      if (ast.hoists.length) {\r\n        const staticHelpers = [\r\n          CREATE_VNODE,\r\n          CREATE_ELEMENT_VNODE,\r\n          CREATE_COMMENT,\r\n          CREATE_TEXT,\r\n          CREATE_STATIC,\r\n        ]\r\n          .filter(helper => helpers.includes(helper))\r\n          .map(aliasHelper)\r\n          .join(', ')\r\n        push(`const { ${staticHelpers} } = _Vue\\n`, NewlineType.End)\r\n      }\r\n    }\r\n  }\r\n  // generate variables for ssr helpers\r\n  if (!__BROWSER__ && ast.ssrHelpers && ast.ssrHelpers.length) {\r\n    // ssr guarantees prefixIdentifier: true\r\n    push(\r\n      `const { ${ast.ssrHelpers\r\n        .map(aliasHelper)\r\n        .join(', ')} } = require(\"${ssrRuntimeModuleName}\")\\n`,\r\n      NewlineType.End,\r\n    )\r\n  }\r\n  genHoists(ast.hoists, context)\r\n  newline()\r\n  push(`return `)\r\n}\r\n\r\nfunction genModulePreamble(\r\n  ast: RootNode,\r\n  context: CodegenContext,\r\n  genScopeId: boolean,\r\n  inline?: boolean,\r\n) {\r\n  const {\r\n    push,\r\n    newline,\r\n    optimizeImports,\r\n    runtimeModuleName,\r\n    ssrRuntimeModuleName,\r\n  } = context\r\n\r\n  if (genScopeId && ast.hoists.length) {\r\n    ast.helpers.add(PUSH_SCOPE_ID)\r\n    ast.helpers.add(POP_SCOPE_ID)\r\n  }\r\n\r\n  // generate import statements for helpers\r\n  if (ast.helpers.size) {\r\n    const helpers = Array.from(ast.helpers)\r\n    if (optimizeImports) {\r\n      // when bundled with webpack with code-split, calling an import binding\r\n      // as a function leads to it being wrapped with `Object(a.b)` or `(0,a.b)`,\r\n      // incurring both payload size increase and potential perf overhead.\r\n      // therefore we assign the imports to variables (which is a constant ~50b\r\n      // cost per-component instead of scaling with template size)\r\n      push(\r\n        `import { ${helpers\r\n          .map(s => helperNameMap[s])\r\n          .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\\n`,\r\n        NewlineType.End,\r\n      )\r\n      push(\r\n        `\\n// Binding optimization for webpack code-split\\nconst ${helpers\r\n          .map(s => `_${helperNameMap[s]} = ${helperNameMap[s]}`)\r\n          .join(', ')}\\n`,\r\n        NewlineType.End,\r\n      )\r\n    } else {\r\n      push(\r\n        `import { ${helpers\r\n          .map(s => `${helperNameMap[s]} as _${helperNameMap[s]}`)\r\n          .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\\n`,\r\n        NewlineType.End,\r\n      )\r\n    }\r\n  }\r\n\r\n  if (ast.ssrHelpers && ast.ssrHelpers.length) {\r\n    push(\r\n      `import { ${ast.ssrHelpers\r\n        .map(s => `${helperNameMap[s]} as _${helperNameMap[s]}`)\r\n        .join(', ')} } from \"${ssrRuntimeModuleName}\"\\n`,\r\n      NewlineType.End,\r\n    )\r\n  }\r\n\r\n  if (ast.imports.length) {\r\n    genImports(ast.imports, context)\r\n    newline()\r\n  }\r\n\r\n  genHoists(ast.hoists, context)\r\n  newline()\r\n\r\n  if (!inline) {\r\n    push(`export `)\r\n  }\r\n}\r\n\r\nfunction genAssets(\r\n  assets: string[],\r\n  type: 'component' | 'directive' | 'filter',\r\n  { helper, push, newline, isTS }: CodegenContext,\r\n) {\r\n  const resolver = helper(\r\n    __COMPAT__ && type === 'filter'\r\n      ? RESOLVE_FILTER\r\n      : type === 'component'\r\n        ? RESOLVE_COMPONENT\r\n        : RESOLVE_DIRECTIVE,\r\n  )\r\n  for (let i = 0; i < assets.length; i++) {\r\n    let id = assets[i]\r\n    // potential component implicit self-reference inferred from SFC filename\r\n    const maybeSelfReference = id.endsWith('__self')\r\n    if (maybeSelfReference) {\r\n      id = id.slice(0, -6)\r\n    }\r\n    push(\r\n      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${\r\n        maybeSelfReference ? `, true` : ``\r\n      })${isTS ? `!` : ``}`,\r\n    )\r\n    if (i < assets.length - 1) {\r\n      newline()\r\n    }\r\n  }\r\n}\r\n\r\nfunction genHoists(hoists: (JSChildNode | null)[], context: CodegenContext) {\r\n  if (!hoists.length) {\r\n    return\r\n  }\r\n  context.pure = true\r\n  const { push, newline, helper, scopeId, mode } = context\r\n  const genScopeId = !__BROWSER__ && scopeId != null && mode !== 'function'\r\n  newline()\r\n\r\n  // generate inlined withScopeId helper\r\n  if (genScopeId) {\r\n    push(\r\n      `const _withScopeId = n => (${helper(\r\n        PUSH_SCOPE_ID,\r\n      )}(\"${scopeId}\"),n=n(),${helper(POP_SCOPE_ID)}(),n)`,\r\n    )\r\n    newline()\r\n  }\r\n\r\n  for (let i = 0; i < hoists.length; i++) {\r\n    const exp = hoists[i]\r\n    if (exp) {\r\n      const needScopeIdWrapper = genScopeId && exp.type === NodeTypes.VNODE_CALL\r\n      push(\r\n        `const _hoisted_${i + 1} = ${\r\n          needScopeIdWrapper ? `${PURE_ANNOTATION} _withScopeId(() => ` : ``\r\n        }`,\r\n      )\r\n      genNode(exp, context)\r\n      if (needScopeIdWrapper) {\r\n        push(`)`)\r\n      }\r\n      newline()\r\n    }\r\n  }\r\n\r\n  context.pure = false\r\n}\r\n\r\nfunction genImports(importsOptions: ImportItem[], context: CodegenContext) {\r\n  if (!importsOptions.length) {\r\n    return\r\n  }\r\n  importsOptions.forEach(imports => {\r\n    context.push(`import `)\r\n    genNode(imports.exp, context)\r\n    context.push(` from '${imports.path}'`)\r\n    context.newline()\r\n  })\r\n}\r\n\r\nfunction isText(n: string | CodegenNode) {\r\n  return (\r\n    isString(n) ||\r\n    n.type === NodeTypes.SIMPLE_EXPRESSION ||\r\n    n.type === NodeTypes.TEXT ||\r\n    n.type === NodeTypes.INTERPOLATION ||\r\n    n.type === NodeTypes.COMPOUND_EXPRESSION\r\n  )\r\n}\r\n\r\nfunction genNodeListAsArray(\r\n  nodes: (string | CodegenNode | TemplateChildNode[])[],\r\n  context: CodegenContext,\r\n) {\r\n  const multilines =\r\n    nodes.length > 3 ||\r\n    ((!__BROWSER__ || __DEV__) && nodes.some(n => isArray(n) || !isText(n)))\r\n  context.push(`[`)\r\n  multilines && context.indent()\r\n  genNodeList(nodes, context, multilines)\r\n  multilines && context.deindent()\r\n  context.push(`]`)\r\n}\r\n\r\nfunction genNodeList(\r\n  nodes: (string | symbol | CodegenNode | TemplateChildNode[])[],\r\n  context: CodegenContext,\r\n  multilines: boolean = false,\r\n  comma: boolean = true,\r\n) {\r\n  const { push, newline } = context\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    const node = nodes[i]\r\n    if (isString(node)) {\r\n      push(node, NewlineType.Unknown)\r\n    } else if (isArray(node)) {\r\n      genNodeListAsArray(node, context)\r\n    } else {\r\n      genNode(node, context)\r\n    }\r\n    if (i < nodes.length - 1) {\r\n      if (multilines) {\r\n        comma && push(',')\r\n        newline()\r\n      } else {\r\n        comma && push(', ')\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction genNode(node: CodegenNode | symbol | string, context: CodegenContext) {\r\n  if (isString(node)) {\r\n    context.push(node, NewlineType.Unknown)\r\n    return\r\n  }\r\n  if (isSymbol(node)) {\r\n    context.push(context.helper(node))\r\n    return\r\n  }\r\n  switch (node.type) {\r\n    case NodeTypes.ELEMENT:\r\n    case NodeTypes.IF:\r\n    case NodeTypes.FOR:\r\n      __DEV__ &&\r\n        assert(\r\n          node.codegenNode != null,\r\n          `Codegen node is missing for element/if/for node. ` +\r\n            `Apply appropriate transforms first.`,\r\n        )\r\n      genNode(node.codegenNode!, context)\r\n      break\r\n    case NodeTypes.TEXT:\r\n      genText(node, context)\r\n      break\r\n    case NodeTypes.SIMPLE_EXPRESSION:\r\n      genExpression(node, context)\r\n      break\r\n    case NodeTypes.INTERPOLATION:\r\n      genInterpolation(node, context)\r\n      break\r\n    case NodeTypes.TEXT_CALL:\r\n      genNode(node.codegenNode, context)\r\n      break\r\n    case NodeTypes.COMPOUND_EXPRESSION:\r\n      genCompoundExpression(node, context)\r\n      break\r\n    case NodeTypes.COMMENT:\r\n      genComment(node, context)\r\n      break\r\n    case NodeTypes.VNODE_CALL:\r\n      genVNodeCall(node, context)\r\n      break\r\n\r\n    case NodeTypes.JS_CALL_EXPRESSION:\r\n      genCallExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_OBJECT_EXPRESSION:\r\n      genObjectExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_ARRAY_EXPRESSION:\r\n      genArrayExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_FUNCTION_EXPRESSION:\r\n      genFunctionExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_CONDITIONAL_EXPRESSION:\r\n      genConditionalExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_CACHE_EXPRESSION:\r\n      genCacheExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_BLOCK_STATEMENT:\r\n      genNodeList(node.body, context, true, false)\r\n      break\r\n\r\n    // SSR only types\r\n    case NodeTypes.JS_TEMPLATE_LITERAL:\r\n      !__BROWSER__ && genTemplateLiteral(node, context)\r\n      break\r\n    case NodeTypes.JS_IF_STATEMENT:\r\n      !__BROWSER__ && genIfStatement(node, context)\r\n      break\r\n    case NodeTypes.JS_ASSIGNMENT_EXPRESSION:\r\n      !__BROWSER__ && genAssignmentExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_SEQUENCE_EXPRESSION:\r\n      !__BROWSER__ && genSequenceExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_RETURN_STATEMENT:\r\n      !__BROWSER__ && genReturnStatement(node, context)\r\n      break\r\n\r\n    /* istanbul ignore next */\r\n    case NodeTypes.IF_BRANCH:\r\n      // noop\r\n      break\r\n    default:\r\n      if (__DEV__) {\r\n        assert(false, `unhandled codegen node type: ${(node as any).type}`)\r\n        // make sure we exhaust all possible types\r\n        const exhaustiveCheck: never = node\r\n        return exhaustiveCheck\r\n      }\r\n  }\r\n}\r\n\r\nfunction genText(\r\n  node: TextNode | SimpleExpressionNode,\r\n  context: CodegenContext,\r\n) {\r\n  context.push(JSON.stringify(node.content), NewlineType.Unknown, node)\r\n}\r\n\r\nfunction genExpression(node: SimpleExpressionNode, context: CodegenContext) {\r\n  const { content, isStatic } = node\r\n  context.push(\r\n    isStatic ? JSON.stringify(content) : content,\r\n    NewlineType.Unknown,\r\n    node,\r\n  )\r\n}\r\n\r\nfunction genInterpolation(node: InterpolationNode, context: CodegenContext) {\r\n  const { push, helper, pure } = context\r\n  if (pure) push(PURE_ANNOTATION)\r\n  push(`${helper(TO_DISPLAY_STRING)}(`)\r\n  genNode(node.content, context)\r\n  push(`)`)\r\n}\r\n\r\nfunction genCompoundExpression(\r\n  node: CompoundExpressionNode,\r\n  context: CodegenContext,\r\n) {\r\n  for (let i = 0; i < node.children!.length; i++) {\r\n    const child = node.children![i]\r\n    if (isString(child)) {\r\n      context.push(child, NewlineType.Unknown)\r\n    } else {\r\n      genNode(child, context)\r\n    }\r\n  }\r\n}\r\n\r\nfunction genExpressionAsPropertyKey(\r\n  node: ExpressionNode,\r\n  context: CodegenContext,\r\n) {\r\n  const { push } = context\r\n  if (node.type === NodeTypes.COMPOUND_EXPRESSION) {\r\n    push(`[`)\r\n    genCompoundExpression(node, context)\r\n    push(`]`)\r\n  } else if (node.isStatic) {\r\n    // only quote keys if necessary\r\n    const text = isSimpleIdentifier(node.content)\r\n      ? node.content\r\n      : JSON.stringify(node.content)\r\n    push(text, NewlineType.None, node)\r\n  } else {\r\n    push(`[${node.content}]`, NewlineType.Unknown, node)\r\n  }\r\n}\r\n\r\nfunction genComment(node: CommentNode, context: CodegenContext) {\r\n  const { push, helper, pure } = context\r\n  if (pure) {\r\n    push(PURE_ANNOTATION)\r\n  }\r\n  push(\r\n    `${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,\r\n    NewlineType.Unknown,\r\n    node,\r\n  )\r\n}\r\n\r\nfunction genVNodeCall(node: VNodeCall, context: CodegenContext) {\r\n  const { push, helper, pure } = context\r\n  const {\r\n    tag,\r\n    props,\r\n    children,\r\n    patchFlag,\r\n    dynamicProps,\r\n    directives,\r\n    isBlock,\r\n    disableTracking,\r\n    isComponent,\r\n  } = node\r\n  if (directives) {\r\n    push(helper(WITH_DIRECTIVES) + `(`)\r\n  }\r\n  if (isBlock) {\r\n    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `)\r\n  }\r\n  if (pure) {\r\n    push(PURE_ANNOTATION)\r\n  }\r\n  const callHelper: symbol = isBlock\r\n    ? getVNodeBlockHelper(context.inSSR, isComponent)\r\n    : getVNodeHelper(context.inSSR, isComponent)\r\n  push(helper(callHelper) + `(`, NewlineType.None, node)\r\n  genNodeList(\r\n    genNullableArgs([tag, props, children, patchFlag, dynamicProps]),\r\n    context,\r\n  )\r\n  push(`)`)\r\n  if (isBlock) {\r\n    push(`)`)\r\n  }\r\n  if (directives) {\r\n    push(`, `)\r\n    genNode(directives, context)\r\n    push(`)`)\r\n  }\r\n}\r\n\r\nfunction genNullableArgs(args: any[]): CallExpression['arguments'] {\r\n  let i = args.length\r\n  while (i--) {\r\n    if (args[i] != null) break\r\n  }\r\n  return args.slice(0, i + 1).map(arg => arg || `null`)\r\n}\r\n\r\n// JavaScript\r\nfunction genCallExpression(node: CallExpression, context: CodegenContext) {\r\n  const { push, helper, pure } = context\r\n  const callee = isString(node.callee) ? node.callee : helper(node.callee)\r\n  if (pure) {\r\n    push(PURE_ANNOTATION)\r\n  }\r\n  push(callee + `(`, NewlineType.None, node)\r\n  genNodeList(node.arguments, context)\r\n  push(`)`)\r\n}\r\n\r\nfunction genObjectExpression(node: ObjectExpression, context: CodegenContext) {\r\n  const { push, indent, deindent, newline } = context\r\n  const { properties } = node\r\n  if (!properties.length) {\r\n    push(`{}`, NewlineType.None, node)\r\n    return\r\n  }\r\n  const multilines =\r\n    properties.length > 1 ||\r\n    ((!__BROWSER__ || __DEV__) &&\r\n      properties.some(p => p.value.type !== NodeTypes.SIMPLE_EXPRESSION))\r\n  push(multilines ? `{` : `{ `)\r\n  multilines && indent()\r\n  for (let i = 0; i < properties.length; i++) {\r\n    const { key, value } = properties[i]\r\n    // key\r\n    genExpressionAsPropertyKey(key, context)\r\n    push(`: `)\r\n    // value\r\n    genNode(value, context)\r\n    if (i < properties.length - 1) {\r\n      // will only reach this if it's multilines\r\n      push(`,`)\r\n      newline()\r\n    }\r\n  }\r\n  multilines && deindent()\r\n  push(multilines ? `}` : ` }`)\r\n}\r\n\r\nfunction genArrayExpression(node: ArrayExpression, context: CodegenContext) {\r\n  genNodeListAsArray(node.elements as CodegenNode[], context)\r\n}\r\n\r\nfunction genFunctionExpression(\r\n  node: FunctionExpression,\r\n  context: CodegenContext,\r\n) {\r\n  const { push, indent, deindent } = context\r\n  const { params, returns, body, newline, isSlot } = node\r\n  if (isSlot) {\r\n    // wrap slot functions with owner context\r\n    push(`_${helperNameMap[WITH_CTX]}(`)\r\n  }\r\n  push(`(`, NewlineType.None, node)\r\n  if (isArray(params)) {\r\n    genNodeList(params, context)\r\n  } else if (params) {\r\n    genNode(params, context)\r\n  }\r\n  push(`) => `)\r\n  if (newline || body) {\r\n    push(`{`)\r\n    indent()\r\n  }\r\n  if (returns) {\r\n    if (newline) {\r\n      push(`return `)\r\n    }\r\n    if (isArray(returns)) {\r\n      genNodeListAsArray(returns, context)\r\n    } else {\r\n      genNode(returns, context)\r\n    }\r\n  } else if (body) {\r\n    genNode(body, context)\r\n  }\r\n  if (newline || body) {\r\n    deindent()\r\n    push(`}`)\r\n  }\r\n  if (isSlot) {\r\n    if (__COMPAT__ && node.isNonScopedSlot) {\r\n      push(`, undefined, true`)\r\n    }\r\n    push(`)`)\r\n  }\r\n}\r\n\r\nfunction genConditionalExpression(\r\n  node: ConditionalExpression,\r\n  context: CodegenContext,\r\n) {\r\n  const { test, consequent, alternate, newline: needNewline } = node\r\n  const { push, indent, deindent, newline } = context\r\n  if (test.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n    const needsParens = !isSimpleIdentifier(test.content)\r\n    needsParens && push(`(`)\r\n    genExpression(test, context)\r\n    needsParens && push(`)`)\r\n  } else {\r\n    push(`(`)\r\n    genNode(test, context)\r\n    push(`)`)\r\n  }\r\n  needNewline && indent()\r\n  context.indentLevel++\r\n  needNewline || push(` `)\r\n  push(`? `)\r\n  genNode(consequent, context)\r\n  context.indentLevel--\r\n  needNewline && newline()\r\n  needNewline || push(` `)\r\n  push(`: `)\r\n  const isNested = alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION\r\n  if (!isNested) {\r\n    context.indentLevel++\r\n  }\r\n  genNode(alternate, context)\r\n  if (!isNested) {\r\n    context.indentLevel--\r\n  }\r\n  needNewline && deindent(true /* without newline */)\r\n}\r\n\r\nfunction genCacheExpression(node: CacheExpression, context: CodegenContext) {\r\n  const { push, helper, indent, deindent, newline } = context\r\n  push(`_cache[${node.index}] || (`)\r\n  if (node.isVNode) {\r\n    indent()\r\n    push(`${helper(SET_BLOCK_TRACKING)}(-1),`)\r\n    newline()\r\n  }\r\n  push(`_cache[${node.index}] = `)\r\n  genNode(node.value, context)\r\n  if (node.isVNode) {\r\n    push(`,`)\r\n    newline()\r\n    push(`${helper(SET_BLOCK_TRACKING)}(1),`)\r\n    newline()\r\n    push(`_cache[${node.index}]`)\r\n    deindent()\r\n  }\r\n  push(`)`)\r\n}\r\n\r\nfunction genTemplateLiteral(node: TemplateLiteral, context: CodegenContext) {\r\n  const { push, indent, deindent } = context\r\n  push('`')\r\n  const l = node.elements.length\r\n  const multilines = l > 3\r\n  for (let i = 0; i < l; i++) {\r\n    const e = node.elements[i]\r\n    if (isString(e)) {\r\n      push(e.replace(/(`|\\$|\\\\)/g, '\\\\$1'), NewlineType.Unknown)\r\n    } else {\r\n      push('${')\r\n      if (multilines) indent()\r\n      genNode(e, context)\r\n      if (multilines) deindent()\r\n      push('}')\r\n    }\r\n  }\r\n  push('`')\r\n}\r\n\r\nfunction genIfStatement(node: IfStatement, context: CodegenContext) {\r\n  const { push, indent, deindent } = context\r\n  const { test, consequent, alternate } = node\r\n  push(`if (`)\r\n  genNode(test, context)\r\n  push(`) {`)\r\n  indent()\r\n  genNode(consequent, context)\r\n  deindent()\r\n  push(`}`)\r\n  if (alternate) {\r\n    push(` else `)\r\n    if (alternate.type === NodeTypes.JS_IF_STATEMENT) {\r\n      genIfStatement(alternate, context)\r\n    } else {\r\n      push(`{`)\r\n      indent()\r\n      genNode(alternate, context)\r\n      deindent()\r\n      push(`}`)\r\n    }\r\n  }\r\n}\r\n\r\nfunction genAssignmentExpression(\r\n  node: AssignmentExpression,\r\n  context: CodegenContext,\r\n) {\r\n  genNode(node.left, context)\r\n  context.push(` = `)\r\n  genNode(node.right, context)\r\n}\r\n\r\nfunction genSequenceExpression(\r\n  node: SequenceExpression,\r\n  context: CodegenContext,\r\n) {\r\n  context.push(`(`)\r\n  genNodeList(node.expressions, context)\r\n  context.push(`)`)\r\n}\r\n\r\nfunction genReturnStatement(\r\n  { returns }: ReturnStatement,\r\n  context: CodegenContext,\r\n) {\r\n  context.push(`return `)\r\n  if (isArray(returns)) {\r\n    genNodeListAsArray(returns, context)\r\n  } else {\r\n    genNode(returns, context)\r\n  }\r\n}\r\n","// - Parse expressions in templates into compound expressions so that each\r\n//   identifier gets more accurate source-map locations.\r\n//\r\n// - Prefix identifiers with `_ctx.` or `$xxx` (for known binding types) so that\r\n//   they are accessed from the right source\r\n//\r\n// - This transform is only applied in non-browser builds because it relies on\r\n//   an additional JavaScript parser. In the browser, there is no source-map\r\n//   support and the code is wrapped in `with (this) { ... }`.\r\nimport type { NodeTransform, TransformContext } from '../transform'\r\nimport {\r\n  type CompoundExpressionNode,\r\n  ConstantTypes,\r\n  type ExpressionNode,\r\n  NodeTypes,\r\n  type SimpleExpressionNode,\r\n  createCompoundExpression,\r\n  createSimpleExpression,\r\n} from '../ast'\r\nimport {\r\n  isInDestructureAssignment,\r\n  isInNewExpression,\r\n  isStaticProperty,\r\n  isStaticPropertyKey,\r\n  walkIdentifiers,\r\n} from '../babelUtils'\r\nimport { advancePositionWithClone, isSimpleIdentifier } from '../utils'\r\nimport {\r\n  genPropsAccessExp,\r\n  hasOwn,\r\n  isGloballyAllowed,\r\n  isString,\r\n  makeMap,\r\n} from '@vue/shared'\r\nimport { ErrorCodes, createCompilerError } from '../errors'\r\nimport type {\r\n  AssignmentExpression,\r\n  Identifier,\r\n  Node,\r\n  UpdateExpression,\r\n} from '@babel/types'\r\nimport { validateBrowserExpression } from '../validateExpression'\r\nimport { parse } from '@babel/parser'\r\nimport { IS_REF, UNREF } from '../runtimeHelpers'\r\nimport { BindingTypes } from '../options'\r\n\r\nconst isLiteralWhitelisted = /*#__PURE__*/ makeMap('true,false,null,this')\r\n\r\n// a heuristic safeguard to bail constant expressions on presence of\r\n// likely function invocation and member access\r\nconst constantBailRE = /\\w\\s*\\(|\\.[^\\d]/\r\n\r\nexport const transformExpression: NodeTransform = (node, context) => {\r\n  if (node.type === NodeTypes.INTERPOLATION) {\r\n    node.content = processExpression(\r\n      node.content as SimpleExpressionNode,\r\n      context,\r\n    )\r\n  } else if (node.type === NodeTypes.ELEMENT) {\r\n    // handle directives on element\r\n    for (let i = 0; i < node.props.length; i++) {\r\n      const dir = node.props[i]\r\n      // do not process for v-on & v-for since they are special handled\r\n      if (dir.type === NodeTypes.DIRECTIVE && dir.name !== 'for') {\r\n        const exp = dir.exp\r\n        const arg = dir.arg\r\n        // do not process exp if this is v-on:arg - we need special handling\r\n        // for wrapping inline statements.\r\n        if (\r\n          exp &&\r\n          exp.type === NodeTypes.SIMPLE_EXPRESSION &&\r\n          !(dir.name === 'on' && arg)\r\n        ) {\r\n          dir.exp = processExpression(\r\n            exp,\r\n            context,\r\n            // slot args must be processed as function params\r\n            dir.name === 'slot',\r\n          )\r\n        }\r\n        if (arg && arg.type === NodeTypes.SIMPLE_EXPRESSION && !arg.isStatic) {\r\n          dir.arg = processExpression(arg, context)\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\ninterface PrefixMeta {\r\n  prefix?: string\r\n  isConstant: boolean\r\n  start: number\r\n  end: number\r\n  scopeIds?: Set<string>\r\n}\r\n\r\n// Important: since this function uses Node.js only dependencies, it should\r\n// always be used with a leading !__BROWSER__ check so that it can be\r\n// tree-shaken from the browser build.\r\nexport function processExpression(\r\n  node: SimpleExpressionNode,\r\n  context: TransformContext,\r\n  // some expressions like v-slot props & v-for aliases should be parsed as\r\n  // function params\r\n  asParams = false,\r\n  // v-on handler values may contain multiple statements\r\n  asRawStatements = false,\r\n  localVars: Record<string, number> = Object.create(context.identifiers),\r\n): ExpressionNode {\r\n  if (__BROWSER__) {\r\n    if (__DEV__) {\r\n      // simple in-browser validation (same logic in 2.x)\r\n      validateBrowserExpression(node, context, asParams, asRawStatements)\r\n    }\r\n    return node\r\n  }\r\n\r\n  if (!context.prefixIdentifiers || !node.content.trim()) {\r\n    return node\r\n  }\r\n\r\n  const { inline, bindingMetadata } = context\r\n  const rewriteIdentifier = (raw: string, parent?: Node, id?: Identifier) => {\r\n    const type = hasOwn(bindingMetadata, raw) && bindingMetadata[raw]\r\n    if (inline) {\r\n      // x = y\r\n      const isAssignmentLVal =\r\n        parent && parent.type === 'AssignmentExpression' && parent.left === id\r\n      // x++\r\n      const isUpdateArg =\r\n        parent && parent.type === 'UpdateExpression' && parent.argument === id\r\n      // ({ x } = y)\r\n      const isDestructureAssignment =\r\n        parent && isInDestructureAssignment(parent, parentStack)\r\n      const isNewExpression = parent && isInNewExpression(parentStack)\r\n      const wrapWithUnref = (raw: string) => {\r\n        const wrapped = `${context.helperString(UNREF)}(${raw})`\r\n        return isNewExpression ? `(${wrapped})` : wrapped\r\n      }\r\n\r\n      if (\r\n        isConst(type) ||\r\n        type === BindingTypes.SETUP_REACTIVE_CONST ||\r\n        localVars[raw]\r\n      ) {\r\n        return raw\r\n      } else if (type === BindingTypes.SETUP_REF) {\r\n        return `${raw}.value`\r\n      } else if (type === BindingTypes.SETUP_MAYBE_REF) {\r\n        // const binding that may or may not be ref\r\n        // if it's not a ref, then assignments don't make sense -\r\n        // so we ignore the non-ref assignment case and generate code\r\n        // that assumes the value to be a ref for more efficiency\r\n        return isAssignmentLVal || isUpdateArg || isDestructureAssignment\r\n          ? `${raw}.value`\r\n          : wrapWithUnref(raw)\r\n      } else if (type === BindingTypes.SETUP_LET) {\r\n        if (isAssignmentLVal) {\r\n          // let binding.\r\n          // this is a bit more tricky as we need to cover the case where\r\n          // let is a local non-ref value, and we need to replicate the\r\n          // right hand side value.\r\n          // x = y --> isRef(x) ? x.value = y : x = y\r\n          const { right: rVal, operator } = parent as AssignmentExpression\r\n          const rExp = rawExp.slice(rVal.start! - 1, rVal.end! - 1)\r\n          const rExpString = stringifyExpression(\r\n            processExpression(\r\n              createSimpleExpression(rExp, false),\r\n              context,\r\n              false,\r\n              false,\r\n              knownIds,\r\n            ),\r\n          )\r\n          return `${context.helperString(IS_REF)}(${raw})${\r\n            context.isTS ? ` //@ts-ignore\\n` : ``\r\n          } ? ${raw}.value ${operator} ${rExpString} : ${raw}`\r\n        } else if (isUpdateArg) {\r\n          // make id replace parent in the code range so the raw update operator\r\n          // is removed\r\n          id!.start = parent!.start\r\n          id!.end = parent!.end\r\n          const { prefix: isPrefix, operator } = parent as UpdateExpression\r\n          const prefix = isPrefix ? operator : ``\r\n          const postfix = isPrefix ? `` : operator\r\n          // let binding.\r\n          // x++ --> isRef(a) ? a.value++ : a++\r\n          return `${context.helperString(IS_REF)}(${raw})${\r\n            context.isTS ? ` //@ts-ignore\\n` : ``\r\n          } ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`\r\n        } else if (isDestructureAssignment) {\r\n          // TODO\r\n          // let binding in a destructure assignment - it's very tricky to\r\n          // handle both possible cases here without altering the original\r\n          // structure of the code, so we just assume it's not a ref here\r\n          // for now\r\n          return raw\r\n        } else {\r\n          return wrapWithUnref(raw)\r\n        }\r\n      } else if (type === BindingTypes.PROPS) {\r\n        // use __props which is generated by compileScript so in ts mode\r\n        // it gets correct type\r\n        return genPropsAccessExp(raw)\r\n      } else if (type === BindingTypes.PROPS_ALIASED) {\r\n        // prop with a different local alias (from defineProps() destructure)\r\n        return genPropsAccessExp(bindingMetadata.__propsAliases![raw])\r\n      }\r\n    } else {\r\n      if (\r\n        (type && type.startsWith('setup')) ||\r\n        type === BindingTypes.LITERAL_CONST\r\n      ) {\r\n        // setup bindings in non-inline mode\r\n        return `$setup.${raw}`\r\n      } else if (type === BindingTypes.PROPS_ALIASED) {\r\n        return `$props['${bindingMetadata.__propsAliases![raw]}']`\r\n      } else if (type) {\r\n        return `$${type}.${raw}`\r\n      }\r\n    }\r\n\r\n    // fallback to ctx\r\n    return `_ctx.${raw}`\r\n  }\r\n\r\n  // fast path if expression is a simple identifier.\r\n  const rawExp = node.content\r\n  // bail constant on parens (function invocation) and dot (member access)\r\n  const bailConstant = constantBailRE.test(rawExp)\r\n\r\n  let ast = node.ast\r\n\r\n  if (ast === false) {\r\n    // ast being false means it has caused an error already during parse phase\r\n    return node\r\n  }\r\n\r\n  if (ast === null || (!ast && isSimpleIdentifier(rawExp))) {\r\n    const isScopeVarReference = context.identifiers[rawExp]\r\n    const isAllowedGlobal = isGloballyAllowed(rawExp)\r\n    const isLiteral = isLiteralWhitelisted(rawExp)\r\n    if (\r\n      !asParams &&\r\n      !isScopeVarReference &&\r\n      !isLiteral &&\r\n      (!isAllowedGlobal || bindingMetadata[rawExp])\r\n    ) {\r\n      // const bindings exposed from setup can be skipped for patching but\r\n      // cannot be hoisted to module scope\r\n      if (isConst(bindingMetadata[rawExp])) {\r\n        node.constType = ConstantTypes.CAN_SKIP_PATCH\r\n      }\r\n      node.content = rewriteIdentifier(rawExp)\r\n    } else if (!isScopeVarReference) {\r\n      if (isLiteral) {\r\n        node.constType = ConstantTypes.CAN_STRINGIFY\r\n      } else {\r\n        node.constType = ConstantTypes.CAN_HOIST\r\n      }\r\n    }\r\n    return node\r\n  }\r\n\r\n  if (!ast) {\r\n    // exp needs to be parsed differently:\r\n    // 1. Multiple inline statements (v-on, with presence of `;`): parse as raw\r\n    //    exp, but make sure to pad with spaces for consistent ranges\r\n    // 2. Expressions: wrap with parens (for e.g. object expressions)\r\n    // 3. Function arguments (v-for, v-slot): place in a function argument position\r\n    const source = asRawStatements\r\n      ? ` ${rawExp} `\r\n      : `(${rawExp})${asParams ? `=>{}` : ``}`\r\n    try {\r\n      ast = parse(source, {\r\n        plugins: context.expressionPlugins,\r\n      }).program\r\n    } catch (e: any) {\r\n      context.onError(\r\n        createCompilerError(\r\n          ErrorCodes.X_INVALID_EXPRESSION,\r\n          node.loc,\r\n          undefined,\r\n          e.message,\r\n        ),\r\n      )\r\n      return node\r\n    }\r\n  }\r\n\r\n  type QualifiedId = Identifier & PrefixMeta\r\n  const ids: QualifiedId[] = []\r\n  const parentStack: Node[] = []\r\n  const knownIds: Record<string, number> = Object.create(context.identifiers)\r\n\r\n  walkIdentifiers(\r\n    ast,\r\n    (node, parent, _, isReferenced, isLocal) => {\r\n      if (isStaticPropertyKey(node, parent!)) {\r\n        return\r\n      }\r\n      // v2 wrapped filter call\r\n      if (__COMPAT__ && node.name.startsWith('_filter_')) {\r\n        return\r\n      }\r\n\r\n      const needPrefix = isReferenced && canPrefix(node)\r\n      if (needPrefix && !isLocal) {\r\n        if (isStaticProperty(parent!) && parent.shorthand) {\r\n          // property shorthand like { foo }, we need to add the key since\r\n          // we rewrite the value\r\n          ;(node as QualifiedId).prefix = `${node.name}: `\r\n        }\r\n        node.name = rewriteIdentifier(node.name, parent, node)\r\n        ids.push(node as QualifiedId)\r\n      } else {\r\n        // The identifier is considered constant unless it's pointing to a\r\n        // local scope variable (a v-for alias, or a v-slot prop)\r\n        if (!(needPrefix && isLocal) && !bailConstant) {\r\n          ;(node as QualifiedId).isConstant = true\r\n        }\r\n        // also generate sub-expressions for other identifiers for better\r\n        // source map support. (except for property keys which are static)\r\n        ids.push(node as QualifiedId)\r\n      }\r\n    },\r\n    true, // invoke on ALL identifiers\r\n    parentStack,\r\n    knownIds,\r\n  )\r\n\r\n  // We break up the compound expression into an array of strings and sub\r\n  // expressions (for identifiers that have been prefixed). In codegen, if\r\n  // an ExpressionNode has the `.children` property, it will be used instead of\r\n  // `.content`.\r\n  const children: CompoundExpressionNode['children'] = []\r\n  ids.sort((a, b) => a.start - b.start)\r\n  ids.forEach((id, i) => {\r\n    // range is offset by -1 due to the wrapping parens when parsed\r\n    const start = id.start - 1\r\n    const end = id.end - 1\r\n    const last = ids[i - 1]\r\n    const leadingText = rawExp.slice(last ? last.end - 1 : 0, start)\r\n    if (leadingText.length || id.prefix) {\r\n      children.push(leadingText + (id.prefix || ``))\r\n    }\r\n    const source = rawExp.slice(start, end)\r\n    children.push(\r\n      createSimpleExpression(\r\n        id.name,\r\n        false,\r\n        {\r\n          start: advancePositionWithClone(node.loc.start, source, start),\r\n          end: advancePositionWithClone(node.loc.start, source, end),\r\n          source,\r\n        },\r\n        id.isConstant\r\n          ? ConstantTypes.CAN_STRINGIFY\r\n          : ConstantTypes.NOT_CONSTANT,\r\n      ),\r\n    )\r\n    if (i === ids.length - 1 && end < rawExp.length) {\r\n      children.push(rawExp.slice(end))\r\n    }\r\n  })\r\n\r\n  let ret\r\n  if (children.length) {\r\n    ret = createCompoundExpression(children, node.loc)\r\n    ret.ast = ast\r\n  } else {\r\n    ret = node\r\n    ret.constType = bailConstant\r\n      ? ConstantTypes.NOT_CONSTANT\r\n      : ConstantTypes.CAN_STRINGIFY\r\n  }\r\n  ret.identifiers = Object.keys(knownIds)\r\n  return ret\r\n}\r\n\r\nfunction canPrefix(id: Identifier) {\r\n  // skip whitelisted globals\r\n  if (isGloballyAllowed(id.name)) {\r\n    return false\r\n  }\r\n  // special case for webpack compilation\r\n  if (id.name === 'require') {\r\n    return false\r\n  }\r\n  return true\r\n}\r\n\r\nexport function stringifyExpression(exp: ExpressionNode | string): string {\r\n  if (isString(exp)) {\r\n    return exp\r\n  } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n    return exp.content\r\n  } else {\r\n    return (exp.children as (ExpressionNode | string)[])\r\n      .map(stringifyExpression)\r\n      .join('')\r\n  }\r\n}\r\n\r\nfunction isConst(type: unknown) {\r\n  return (\r\n    type === BindingTypes.SETUP_CONST || type === BindingTypes.LITERAL_CONST\r\n  )\r\n}\r\n","import {\r\n  type TransformContext,\r\n  createStructuralDirectiveTransform,\r\n  traverseNode,\r\n} from '../transform'\r\nimport {\r\n  type AttributeNode,\r\n  type BlockCodegenNode,\r\n  type CacheExpression,\r\n  ConstantTypes,\r\n  type DirectiveNode,\r\n  type ElementNode,\r\n  ElementTypes,\r\n  type IfBranchNode,\r\n  type IfConditionalExpression,\r\n  type IfNode,\r\n  type MemoExpression,\r\n  NodeTypes,\r\n  type SimpleExpressionNode,\r\n  convertToBlock,\r\n  createCallExpression,\r\n  createConditionalExpression,\r\n  createObjectExpression,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  createVNodeCall,\r\n  locStub,\r\n} from '../ast'\r\nimport { ErrorCodes, createCompilerError } from '../errors'\r\nimport { processExpression } from './transformExpression'\r\nimport { validateBrowserExpression } from '../validateExpression'\r\nimport { CREATE_COMMENT, FRAGMENT } from '../runtimeHelpers'\r\nimport { findDir, findProp, getMemoedVNodeCall, injectProp } from '../utils'\r\nimport { PatchFlagNames, PatchFlags } from '@vue/shared'\r\n\r\nexport const transformIf = createStructuralDirectiveTransform(\r\n  /^(if|else|else-if)$/,\r\n  (node, dir, context) => {\r\n    return processIf(node, dir, context, (ifNode, branch, isRoot) => {\r\n      // #1587: We need to dynamically increment the key based on the current\r\n      // node's sibling nodes, since chained v-if/else branches are\r\n      // rendered at the same depth\r\n      const siblings = context.parent!.children\r\n      let i = siblings.indexOf(ifNode)\r\n      let key = 0\r\n      while (i-- >= 0) {\r\n        const sibling = siblings[i]\r\n        if (sibling && sibling.type === NodeTypes.IF) {\r\n          key += sibling.branches.length\r\n        }\r\n      }\r\n\r\n      // Exit callback. Complete the codegenNode when all children have been\r\n      // transformed.\r\n      return () => {\r\n        if (isRoot) {\r\n          ifNode.codegenNode = createCodegenNodeForBranch(\r\n            branch,\r\n            key,\r\n            context,\r\n          ) as IfConditionalExpression\r\n        } else {\r\n          // attach this branch's codegen node to the v-if root.\r\n          const parentCondition = getParentCondition(ifNode.codegenNode!)\r\n          parentCondition.alternate = createCodegenNodeForBranch(\r\n            branch,\r\n            key + ifNode.branches.length - 1,\r\n            context,\r\n          )\r\n        }\r\n      }\r\n    })\r\n  },\r\n)\r\n\r\n// target-agnostic transform used for both Client and SSR\r\nexport function processIf(\r\n  node: ElementNode,\r\n  dir: DirectiveNode,\r\n  context: TransformContext,\r\n  processCodegen?: (\r\n    node: IfNode,\r\n    branch: IfBranchNode,\r\n    isRoot: boolean,\r\n  ) => (() => void) | undefined,\r\n) {\r\n  if (\r\n    dir.name !== 'else' &&\r\n    (!dir.exp || !(dir.exp as SimpleExpressionNode).content.trim())\r\n  ) {\r\n    const loc = dir.exp ? dir.exp.loc : node.loc\r\n    context.onError(\r\n      createCompilerError(ErrorCodes.X_V_IF_NO_EXPRESSION, dir.loc),\r\n    )\r\n    dir.exp = createSimpleExpression(`true`, false, loc)\r\n  }\r\n\r\n  if (!__BROWSER__ && context.prefixIdentifiers && dir.exp) {\r\n    // dir.exp can only be simple expression because vIf transform is applied\r\n    // before expression transform.\r\n    dir.exp = processExpression(dir.exp as SimpleExpressionNode, context)\r\n  }\r\n\r\n  if (__DEV__ && __BROWSER__ && dir.exp) {\r\n    validateBrowserExpression(dir.exp as SimpleExpressionNode, context)\r\n  }\r\n\r\n  if (dir.name === 'if') {\r\n    const branch = createIfBranch(node, dir)\r\n    const ifNode: IfNode = {\r\n      type: NodeTypes.IF,\r\n      loc: node.loc,\r\n      branches: [branch],\r\n    }\r\n    context.replaceNode(ifNode)\r\n    if (processCodegen) {\r\n      return processCodegen(ifNode, branch, true)\r\n    }\r\n  } else {\r\n    // locate the adjacent v-if\r\n    const siblings = context.parent!.children\r\n    const comments = []\r\n    let i = siblings.indexOf(node)\r\n    while (i-- >= -1) {\r\n      const sibling = siblings[i]\r\n      if (sibling && sibling.type === NodeTypes.COMMENT) {\r\n        context.removeNode(sibling)\r\n        __DEV__ && comments.unshift(sibling)\r\n        continue\r\n      }\r\n\r\n      if (\r\n        sibling &&\r\n        sibling.type === NodeTypes.TEXT &&\r\n        !sibling.content.trim().length\r\n      ) {\r\n        context.removeNode(sibling)\r\n        continue\r\n      }\r\n\r\n      if (sibling && sibling.type === NodeTypes.IF) {\r\n        // Check if v-else was followed by v-else-if\r\n        if (\r\n          dir.name === 'else-if' &&\r\n          sibling.branches[sibling.branches.length - 1].condition === undefined\r\n        ) {\r\n          context.onError(\r\n            createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, node.loc),\r\n          )\r\n        }\r\n\r\n        // move the node to the if node's branches\r\n        context.removeNode()\r\n        const branch = createIfBranch(node, dir)\r\n        if (\r\n          __DEV__ &&\r\n          comments.length &&\r\n          // #3619 ignore comments if the v-if is direct child of <transition>\r\n          !(\r\n            context.parent &&\r\n            context.parent.type === NodeTypes.ELEMENT &&\r\n            (context.parent.tag === 'transition' ||\r\n              context.parent.tag === 'Transition')\r\n          )\r\n        ) {\r\n          branch.children = [...comments, ...branch.children]\r\n        }\r\n\r\n        // check if user is forcing same key on different branches\r\n        if (__DEV__ || !__BROWSER__) {\r\n          const key = branch.userKey\r\n          if (key) {\r\n            sibling.branches.forEach(({ userKey }) => {\r\n              if (isSameKey(userKey, key)) {\r\n                context.onError(\r\n                  createCompilerError(\r\n                    ErrorCodes.X_V_IF_SAME_KEY,\r\n                    branch.userKey!.loc,\r\n                  ),\r\n                )\r\n              }\r\n            })\r\n          }\r\n        }\r\n\r\n        sibling.branches.push(branch)\r\n        const onExit = processCodegen && processCodegen(sibling, branch, false)\r\n        // since the branch was removed, it will not be traversed.\r\n        // make sure to traverse here.\r\n        traverseNode(branch, context)\r\n        // call on exit\r\n        if (onExit) onExit()\r\n        // make sure to reset currentNode after traversal to indicate this\r\n        // node has been removed.\r\n        context.currentNode = null\r\n      } else {\r\n        context.onError(\r\n          createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, node.loc),\r\n        )\r\n      }\r\n      break\r\n    }\r\n  }\r\n}\r\n\r\nfunction createIfBranch(node: ElementNode, dir: DirectiveNode): IfBranchNode {\r\n  const isTemplateIf = node.tagType === ElementTypes.TEMPLATE\r\n  return {\r\n    type: NodeTypes.IF_BRANCH,\r\n    loc: node.loc,\r\n    condition: dir.name === 'else' ? undefined : dir.exp,\r\n    children: isTemplateIf && !findDir(node, 'for') ? node.children : [node],\r\n    userKey: findProp(node, `key`),\r\n    isTemplateIf,\r\n  }\r\n}\r\n\r\nfunction createCodegenNodeForBranch(\r\n  branch: IfBranchNode,\r\n  keyIndex: number,\r\n  context: TransformContext,\r\n): IfConditionalExpression | BlockCodegenNode | MemoExpression {\r\n  if (branch.condition) {\r\n    return createConditionalExpression(\r\n      branch.condition,\r\n      createChildrenCodegenNode(branch, keyIndex, context),\r\n      // make sure to pass in asBlock: true so that the comment node call\r\n      // closes the current block.\r\n      createCallExpression(context.helper(CREATE_COMMENT), [\r\n        __DEV__ ? '\"v-if\"' : '\"\"',\r\n        'true',\r\n      ]),\r\n    ) as IfConditionalExpression\r\n  } else {\r\n    return createChildrenCodegenNode(branch, keyIndex, context)\r\n  }\r\n}\r\n\r\nfunction createChildrenCodegenNode(\r\n  branch: IfBranchNode,\r\n  keyIndex: number,\r\n  context: TransformContext,\r\n): BlockCodegenNode | MemoExpression {\r\n  const { helper } = context\r\n  const keyProperty = createObjectProperty(\r\n    `key`,\r\n    createSimpleExpression(\r\n      `${keyIndex}`,\r\n      false,\r\n      locStub,\r\n      ConstantTypes.CAN_HOIST,\r\n    ),\r\n  )\r\n  const { children } = branch\r\n  const firstChild = children[0]\r\n  const needFragmentWrapper =\r\n    children.length !== 1 || firstChild.type !== NodeTypes.ELEMENT\r\n  if (needFragmentWrapper) {\r\n    if (children.length === 1 && firstChild.type === NodeTypes.FOR) {\r\n      // optimize away nested fragments when child is a ForNode\r\n      const vnodeCall = firstChild.codegenNode!\r\n      injectProp(vnodeCall, keyProperty, context)\r\n      return vnodeCall\r\n    } else {\r\n      let patchFlag = PatchFlags.STABLE_FRAGMENT\r\n      let patchFlagText = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]\r\n      // check if the fragment actually contains a single valid child with\r\n      // the rest being comments\r\n      if (\r\n        __DEV__ &&\r\n        !branch.isTemplateIf &&\r\n        children.filter(c => c.type !== NodeTypes.COMMENT).length === 1\r\n      ) {\r\n        patchFlag |= PatchFlags.DEV_ROOT_FRAGMENT\r\n        patchFlagText += `, ${PatchFlagNames[PatchFlags.DEV_ROOT_FRAGMENT]}`\r\n      }\r\n\r\n      return createVNodeCall(\r\n        context,\r\n        helper(FRAGMENT),\r\n        createObjectExpression([keyProperty]),\r\n        children,\r\n        patchFlag + (__DEV__ ? ` /* ${patchFlagText} */` : ``),\r\n        undefined,\r\n        undefined,\r\n        true,\r\n        false,\r\n        false /* isComponent */,\r\n        branch.loc,\r\n      )\r\n    }\r\n  } else {\r\n    const ret = (firstChild as ElementNode).codegenNode as\r\n      | BlockCodegenNode\r\n      | MemoExpression\r\n    const vnodeCall = getMemoedVNodeCall(ret)\r\n    // Change createVNode to createBlock.\r\n    if (vnodeCall.type === NodeTypes.VNODE_CALL) {\r\n      convertToBlock(vnodeCall, context)\r\n    }\r\n    // inject branch key\r\n    injectProp(vnodeCall, keyProperty, context)\r\n    return ret\r\n  }\r\n}\r\n\r\nfunction isSameKey(\r\n  a: AttributeNode | DirectiveNode | undefined,\r\n  b: AttributeNode | DirectiveNode,\r\n): boolean {\r\n  if (!a || a.type !== b.type) {\r\n    return false\r\n  }\r\n  if (a.type === NodeTypes.ATTRIBUTE) {\r\n    if (a.value!.content !== (b as AttributeNode).value!.content) {\r\n      return false\r\n    }\r\n  } else {\r\n    // directive\r\n    const exp = a.exp!\r\n    const branchExp = (b as DirectiveNode).exp!\r\n    if (exp.type !== branchExp.type) {\r\n      return false\r\n    }\r\n    if (\r\n      exp.type !== NodeTypes.SIMPLE_EXPRESSION ||\r\n      exp.isStatic !== (branchExp as SimpleExpressionNode).isStatic ||\r\n      exp.content !== (branchExp as SimpleExpressionNode).content\r\n    ) {\r\n      return false\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\nfunction getParentCondition(\r\n  node: IfConditionalExpression | CacheExpression,\r\n): IfConditionalExpression {\r\n  while (true) {\r\n    if (node.type === NodeTypes.JS_CONDITIONAL_EXPRESSION) {\r\n      if (node.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION) {\r\n        node = node.alternate\r\n      } else {\r\n        return node\r\n      }\r\n    } else if (node.type === NodeTypes.JS_CACHE_EXPRESSION) {\r\n      node = node.value as IfConditionalExpression\r\n    }\r\n  }\r\n}\r\n","import {\r\n  type TransformContext,\r\n  createStructuralDirectiveTransform,\r\n} from '../transform'\r\nimport {\r\n  type BlockCodegenNode,\r\n  ConstantTypes,\r\n  type DirectiveNode,\r\n  type ElementNode,\r\n  type ExpressionNode,\r\n  type ForCodegenNode,\r\n  type ForIteratorExpression,\r\n  type ForNode,\r\n  type ForParseResult,\r\n  type ForRenderListExpression,\r\n  NodeTypes,\r\n  type PlainElementNode,\r\n  type RenderSlotCall,\r\n  type SimpleExpressionNode,\r\n  type SlotOutletNode,\r\n  type VNodeCall,\r\n  createBlockStatement,\r\n  createCallExpression,\r\n  createCompoundExpression,\r\n  createFunctionExpression,\r\n  createObjectExpression,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  createVNodeCall,\r\n  getVNodeBlockHelper,\r\n  getVNodeHelper,\r\n} from '../ast'\r\nimport { ErrorCodes, createCompilerError } from '../errors'\r\nimport {\r\n  findDir,\r\n  findProp,\r\n  injectProp,\r\n  isSlotOutlet,\r\n  isTemplateNode,\r\n} from '../utils'\r\nimport {\r\n  FRAGMENT,\r\n  IS_MEMO_SAME,\r\n  OPEN_BLOCK,\r\n  RENDER_LIST,\r\n} from '../runtimeHelpers'\r\nimport { processExpression } from './transformExpression'\r\nimport { validateBrowserExpression } from '../validateExpression'\r\nimport { PatchFlagNames, PatchFlags } from '@vue/shared'\r\n\r\nexport const transformFor = createStructuralDirectiveTransform(\r\n  'for',\r\n  (node, dir, context) => {\r\n    const { helper, removeHelper } = context\r\n    return processFor(node, dir, context, forNode => {\r\n      // create the loop render function expression now, and add the\r\n      // iterator on exit after all children have been traversed\r\n      const renderExp = createCallExpression(helper(RENDER_LIST), [\r\n        forNode.source,\r\n      ]) as ForRenderListExpression\r\n      const isTemplate = isTemplateNode(node)\r\n      const memo = findDir(node, 'memo')\r\n      const keyProp = findProp(node, `key`)\r\n      const keyExp =\r\n        keyProp &&\r\n        (keyProp.type === NodeTypes.ATTRIBUTE\r\n          ? createSimpleExpression(keyProp.value!.content, true)\r\n          : keyProp.exp!)\r\n      const keyProperty = keyProp ? createObjectProperty(`key`, keyExp!) : null\r\n\r\n      if (!__BROWSER__ && isTemplate) {\r\n        // #2085 / #5288 process :key and v-memo expressions need to be\r\n        // processed on `<template v-for>`. In this case the node is discarded\r\n        // and never traversed so its binding expressions won't be processed\r\n        // by the normal transforms.\r\n        if (memo) {\r\n          memo.exp = processExpression(\r\n            memo.exp! as SimpleExpressionNode,\r\n            context,\r\n          )\r\n        }\r\n        if (keyProperty && keyProp!.type !== NodeTypes.ATTRIBUTE) {\r\n          keyProperty.value = processExpression(\r\n            keyProperty.value as SimpleExpressionNode,\r\n            context,\r\n          )\r\n        }\r\n      }\r\n\r\n      const isStableFragment =\r\n        forNode.source.type === NodeTypes.SIMPLE_EXPRESSION &&\r\n        forNode.source.constType > ConstantTypes.NOT_CONSTANT\r\n      const fragmentFlag = isStableFragment\r\n        ? PatchFlags.STABLE_FRAGMENT\r\n        : keyProp\r\n          ? PatchFlags.KEYED_FRAGMENT\r\n          : PatchFlags.UNKEYED_FRAGMENT\r\n\r\n      forNode.codegenNode = createVNodeCall(\r\n        context,\r\n        helper(FRAGMENT),\r\n        undefined,\r\n        renderExp,\r\n        fragmentFlag +\r\n          (__DEV__ ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``),\r\n        undefined,\r\n        undefined,\r\n        true /* isBlock */,\r\n        !isStableFragment /* disableTracking */,\r\n        false /* isComponent */,\r\n        node.loc,\r\n      ) as ForCodegenNode\r\n\r\n      return () => {\r\n        // finish the codegen now that all children have been traversed\r\n        let childBlock: BlockCodegenNode\r\n        const { children } = forNode\r\n\r\n        // check <template v-for> key placement\r\n        if ((__DEV__ || !__BROWSER__) && isTemplate) {\r\n          node.children.some(c => {\r\n            if (c.type === NodeTypes.ELEMENT) {\r\n              const key = findProp(c, 'key')\r\n              if (key) {\r\n                context.onError(\r\n                  createCompilerError(\r\n                    ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT,\r\n                    key.loc,\r\n                  ),\r\n                )\r\n                return true\r\n              }\r\n            }\r\n          })\r\n        }\r\n\r\n        const needFragmentWrapper =\r\n          children.length !== 1 || children[0].type !== NodeTypes.ELEMENT\r\n        const slotOutlet = isSlotOutlet(node)\r\n          ? node\r\n          : isTemplate &&\r\n              node.children.length === 1 &&\r\n              isSlotOutlet(node.children[0])\r\n            ? (node.children[0] as SlotOutletNode) // api-extractor somehow fails to infer this\r\n            : null\r\n\r\n        if (slotOutlet) {\r\n          // <slot v-for=\"...\"> or <template v-for=\"...\"><slot/></template>\r\n          childBlock = slotOutlet.codegenNode as RenderSlotCall\r\n          if (isTemplate && keyProperty) {\r\n            // <template v-for=\"...\" :key=\"...\"><slot/></template>\r\n            // we need to inject the key to the renderSlot() call.\r\n            // the props for renderSlot is passed as the 3rd argument.\r\n            injectProp(childBlock, keyProperty, context)\r\n          }\r\n        } else if (needFragmentWrapper) {\r\n          // <template v-for=\"...\"> with text or multi-elements\r\n          // should generate a fragment block for each loop\r\n          childBlock = createVNodeCall(\r\n            context,\r\n            helper(FRAGMENT),\r\n            keyProperty ? createObjectExpression([keyProperty]) : undefined,\r\n            node.children,\r\n            PatchFlags.STABLE_FRAGMENT +\r\n              (__DEV__\r\n                ? ` /* ${PatchFlagNames[PatchFlags.STABLE_FRAGMENT]} */`\r\n                : ``),\r\n            undefined,\r\n            undefined,\r\n            true,\r\n            undefined,\r\n            false /* isComponent */,\r\n          )\r\n        } else {\r\n          // Normal element v-for. Directly use the child's codegenNode\r\n          // but mark it as a block.\r\n          childBlock = (children[0] as PlainElementNode)\r\n            .codegenNode as VNodeCall\r\n          if (isTemplate && keyProperty) {\r\n            injectProp(childBlock, keyProperty, context)\r\n          }\r\n          if (childBlock.isBlock !== !isStableFragment) {\r\n            if (childBlock.isBlock) {\r\n              // switch from block to vnode\r\n              removeHelper(OPEN_BLOCK)\r\n              removeHelper(\r\n                getVNodeBlockHelper(context.inSSR, childBlock.isComponent),\r\n              )\r\n            } else {\r\n              // switch from vnode to block\r\n              removeHelper(\r\n                getVNodeHelper(context.inSSR, childBlock.isComponent),\r\n              )\r\n            }\r\n          }\r\n          childBlock.isBlock = !isStableFragment\r\n          if (childBlock.isBlock) {\r\n            helper(OPEN_BLOCK)\r\n            helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent))\r\n          } else {\r\n            helper(getVNodeHelper(context.inSSR, childBlock.isComponent))\r\n          }\r\n        }\r\n\r\n        if (memo) {\r\n          const loop = createFunctionExpression(\r\n            createForLoopParams(forNode.parseResult, [\r\n              createSimpleExpression(`_cached`),\r\n            ]),\r\n          )\r\n          loop.body = createBlockStatement([\r\n            createCompoundExpression([`const _memo = (`, memo.exp!, `)`]),\r\n            createCompoundExpression([\r\n              `if (_cached`,\r\n              ...(keyExp ? [` && _cached.key === `, keyExp] : []),\r\n              ` && ${context.helperString(\r\n                IS_MEMO_SAME,\r\n              )}(_cached, _memo)) return _cached`,\r\n            ]),\r\n            createCompoundExpression([`const _item = `, childBlock as any]),\r\n            createSimpleExpression(`_item.memo = _memo`),\r\n            createSimpleExpression(`return _item`),\r\n          ])\r\n          renderExp.arguments.push(\r\n            loop as ForIteratorExpression,\r\n            createSimpleExpression(`_cache`),\r\n            createSimpleExpression(String(context.cached++)),\r\n          )\r\n        } else {\r\n          renderExp.arguments.push(\r\n            createFunctionExpression(\r\n              createForLoopParams(forNode.parseResult),\r\n              childBlock,\r\n              true /* force newline */,\r\n            ) as ForIteratorExpression,\r\n          )\r\n        }\r\n      }\r\n    })\r\n  },\r\n)\r\n\r\n// target-agnostic transform used for both Client and SSR\r\nexport function processFor(\r\n  node: ElementNode,\r\n  dir: DirectiveNode,\r\n  context: TransformContext,\r\n  processCodegen?: (forNode: ForNode) => (() => void) | undefined,\r\n) {\r\n  if (!dir.exp) {\r\n    context.onError(\r\n      createCompilerError(ErrorCodes.X_V_FOR_NO_EXPRESSION, dir.loc),\r\n    )\r\n    return\r\n  }\r\n\r\n  const parseResult = dir.forParseResult\r\n\r\n  if (!parseResult) {\r\n    context.onError(\r\n      createCompilerError(ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION, dir.loc),\r\n    )\r\n    return\r\n  }\r\n\r\n  finalizeForParseResult(parseResult, context)\r\n\r\n  const { addIdentifiers, removeIdentifiers, scopes } = context\r\n  const { source, value, key, index } = parseResult\r\n\r\n  const forNode: ForNode = {\r\n    type: NodeTypes.FOR,\r\n    loc: dir.loc,\r\n    source,\r\n    valueAlias: value,\r\n    keyAlias: key,\r\n    objectIndexAlias: index,\r\n    parseResult,\r\n    children: isTemplateNode(node) ? node.children : [node],\r\n  }\r\n\r\n  context.replaceNode(forNode)\r\n\r\n  // bookkeeping\r\n  scopes.vFor++\r\n  if (!__BROWSER__ && context.prefixIdentifiers) {\r\n    // scope management\r\n    // inject identifiers to context\r\n    value && addIdentifiers(value)\r\n    key && addIdentifiers(key)\r\n    index && addIdentifiers(index)\r\n  }\r\n\r\n  const onExit = processCodegen && processCodegen(forNode)\r\n\r\n  return () => {\r\n    scopes.vFor--\r\n    if (!__BROWSER__ && context.prefixIdentifiers) {\r\n      value && removeIdentifiers(value)\r\n      key && removeIdentifiers(key)\r\n      index && removeIdentifiers(index)\r\n    }\r\n    if (onExit) onExit()\r\n  }\r\n}\r\n\r\nexport function finalizeForParseResult(\r\n  result: ForParseResult,\r\n  context: TransformContext,\r\n) {\r\n  if (result.finalized) return\r\n\r\n  if (!__BROWSER__ && context.prefixIdentifiers) {\r\n    result.source = processExpression(\r\n      result.source as SimpleExpressionNode,\r\n      context,\r\n    )\r\n    if (result.key) {\r\n      result.key = processExpression(\r\n        result.key as SimpleExpressionNode,\r\n        context,\r\n        true,\r\n      )\r\n    }\r\n    if (result.index) {\r\n      result.index = processExpression(\r\n        result.index as SimpleExpressionNode,\r\n        context,\r\n        true,\r\n      )\r\n    }\r\n    if (result.value) {\r\n      result.value = processExpression(\r\n        result.value as SimpleExpressionNode,\r\n        context,\r\n        true,\r\n      )\r\n    }\r\n  }\r\n  if (__DEV__ && __BROWSER__) {\r\n    validateBrowserExpression(result.source as SimpleExpressionNode, context)\r\n    if (result.key) {\r\n      validateBrowserExpression(\r\n        result.key as SimpleExpressionNode,\r\n        context,\r\n        true,\r\n      )\r\n    }\r\n    if (result.index) {\r\n      validateBrowserExpression(\r\n        result.index as SimpleExpressionNode,\r\n        context,\r\n        true,\r\n      )\r\n    }\r\n    if (result.value) {\r\n      validateBrowserExpression(\r\n        result.value as SimpleExpressionNode,\r\n        context,\r\n        true,\r\n      )\r\n    }\r\n  }\r\n  result.finalized = true\r\n}\r\n\r\nexport function createForLoopParams(\r\n  { value, key, index }: ForParseResult,\r\n  memoArgs: ExpressionNode[] = [],\r\n): ExpressionNode[] {\r\n  return createParamsList([value, key, index, ...memoArgs])\r\n}\r\n\r\nfunction createParamsList(\r\n  args: (ExpressionNode | undefined)[],\r\n): ExpressionNode[] {\r\n  let i = args.length\r\n  while (i--) {\r\n    if (args[i]) break\r\n  }\r\n  return args\r\n    .slice(0, i + 1)\r\n    .map((arg, i) => arg || createSimpleExpression(`_`.repeat(i + 1), false))\r\n}\r\n","import {\r\n  type CallExpression,\r\n  type ConditionalExpression,\r\n  type DirectiveNode,\r\n  type ElementNode,\r\n  ElementTypes,\r\n  type ExpressionNode,\r\n  type FunctionExpression,\r\n  NodeTypes,\r\n  type ObjectExpression,\r\n  type Property,\r\n  type SlotsExpression,\r\n  type SourceLocation,\r\n  type TemplateChildNode,\r\n  createArrayExpression,\r\n  createCallExpression,\r\n  createConditionalExpression,\r\n  createFunctionExpression,\r\n  createObjectExpression,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n} from '../ast'\r\nimport type { NodeTransform, TransformContext } from '../transform'\r\nimport { ErrorCodes, createCompilerError } from '../errors'\r\nimport {\r\n  assert,\r\n  findDir,\r\n  hasScopeRef,\r\n  isStaticExp,\r\n  isTemplateNode,\r\n  isVSlot,\r\n} from '../utils'\r\nimport { CREATE_SLOTS, RENDER_LIST, WITH_CTX } from '../runtimeHelpers'\r\nimport { createForLoopParams, finalizeForParseResult } from './vFor'\r\nimport { SlotFlags, slotFlagsText } from '@vue/shared'\r\n\r\nconst defaultFallback = createSimpleExpression(`undefined`, false)\r\n\r\n// A NodeTransform that:\r\n// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed\r\n//    by transformExpression. This is only applied in non-browser builds with\r\n//    { prefixIdentifiers: true }.\r\n// 2. Track v-slot depths so that we know a slot is inside another slot.\r\n//    Note the exit callback is executed before buildSlots() on the same node,\r\n//    so only nested slots see positive numbers.\r\nexport const trackSlotScopes: NodeTransform = (node, context) => {\r\n  if (\r\n    node.type === NodeTypes.ELEMENT &&\r\n    (node.tagType === ElementTypes.COMPONENT ||\r\n      node.tagType === ElementTypes.TEMPLATE)\r\n  ) {\r\n    // We are only checking non-empty v-slot here\r\n    // since we only care about slots that introduce scope variables.\r\n    const vSlot = findDir(node, 'slot')\r\n    if (vSlot) {\r\n      const slotProps = vSlot.exp\r\n      if (!__BROWSER__ && context.prefixIdentifiers) {\r\n        slotProps && context.addIdentifiers(slotProps)\r\n      }\r\n      context.scopes.vSlot++\r\n      return () => {\r\n        if (!__BROWSER__ && context.prefixIdentifiers) {\r\n          slotProps && context.removeIdentifiers(slotProps)\r\n        }\r\n        context.scopes.vSlot--\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// A NodeTransform that tracks scope identifiers for scoped slots with v-for.\r\n// This transform is only applied in non-browser builds with { prefixIdentifiers: true }\r\nexport const trackVForSlotScopes: NodeTransform = (node, context) => {\r\n  let vFor\r\n  if (\r\n    isTemplateNode(node) &&\r\n    node.props.some(isVSlot) &&\r\n    (vFor = findDir(node, 'for'))\r\n  ) {\r\n    const result = vFor.forParseResult\r\n    if (result) {\r\n      finalizeForParseResult(result, context)\r\n      const { value, key, index } = result\r\n      const { addIdentifiers, removeIdentifiers } = context\r\n      value && addIdentifiers(value)\r\n      key && addIdentifiers(key)\r\n      index && addIdentifiers(index)\r\n\r\n      return () => {\r\n        value && removeIdentifiers(value)\r\n        key && removeIdentifiers(key)\r\n        index && removeIdentifiers(index)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport type SlotFnBuilder = (\r\n  slotProps: ExpressionNode | undefined,\r\n  vFor: DirectiveNode | undefined,\r\n  slotChildren: TemplateChildNode[],\r\n  loc: SourceLocation,\r\n) => FunctionExpression\r\n\r\nconst buildClientSlotFn: SlotFnBuilder = (props, _vForExp, children, loc) =>\r\n  createFunctionExpression(\r\n    props,\r\n    children,\r\n    false /* newline */,\r\n    true /* isSlot */,\r\n    children.length ? children[0].loc : loc,\r\n  )\r\n\r\n// Instead of being a DirectiveTransform, v-slot processing is called during\r\n// transformElement to build the slots object for a component.\r\nexport function buildSlots(\r\n  node: ElementNode,\r\n  context: TransformContext,\r\n  buildSlotFn: SlotFnBuilder = buildClientSlotFn,\r\n): {\r\n  slots: SlotsExpression\r\n  hasDynamicSlots: boolean\r\n} {\r\n  context.helper(WITH_CTX)\r\n\r\n  const { children, loc } = node\r\n  const slotsProperties: Property[] = []\r\n  const dynamicSlots: (ConditionalExpression | CallExpression)[] = []\r\n\r\n  // If the slot is inside a v-for or another v-slot, force it to be dynamic\r\n  // since it likely uses a scope variable.\r\n  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0\r\n  // with `prefixIdentifiers: true`, this can be further optimized to make\r\n  // it dynamic only when the slot actually uses the scope variables.\r\n  if (!__BROWSER__ && !context.ssr && context.prefixIdentifiers) {\r\n    hasDynamicSlots = hasScopeRef(node, context.identifiers)\r\n  }\r\n\r\n  // 1. Check for slot with slotProps on component itself.\r\n  //    <Comp v-slot=\"{ prop }\"/>\r\n  const onComponentSlot = findDir(node, 'slot', true)\r\n  if (onComponentSlot) {\r\n    const { arg, exp } = onComponentSlot\r\n    if (arg && !isStaticExp(arg)) {\r\n      hasDynamicSlots = true\r\n    }\r\n    slotsProperties.push(\r\n      createObjectProperty(\r\n        arg || createSimpleExpression('default', true),\r\n        buildSlotFn(exp, undefined, children, loc),\r\n      ),\r\n    )\r\n  }\r\n\r\n  // 2. Iterate through children and check for template slots\r\n  //    <template v-slot:foo=\"{ prop }\">\r\n  let hasTemplateSlots = false\r\n  let hasNamedDefaultSlot = false\r\n  const implicitDefaultChildren: TemplateChildNode[] = []\r\n  const seenSlotNames = new Set<string>()\r\n  let conditionalBranchIndex = 0\r\n\r\n  for (let i = 0; i < children.length; i++) {\r\n    const slotElement = children[i]\r\n    let slotDir\r\n\r\n    if (\r\n      !isTemplateNode(slotElement) ||\r\n      !(slotDir = findDir(slotElement, 'slot', true))\r\n    ) {\r\n      // not a <template v-slot>, skip.\r\n      if (slotElement.type !== NodeTypes.COMMENT) {\r\n        implicitDefaultChildren.push(slotElement)\r\n      }\r\n      continue\r\n    }\r\n\r\n    if (onComponentSlot) {\r\n      // already has on-component slot - this is incorrect usage.\r\n      context.onError(\r\n        createCompilerError(ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE, slotDir.loc),\r\n      )\r\n      break\r\n    }\r\n\r\n    hasTemplateSlots = true\r\n    const { children: slotChildren, loc: slotLoc } = slotElement\r\n    const {\r\n      arg: slotName = createSimpleExpression(`default`, true),\r\n      exp: slotProps,\r\n      loc: dirLoc,\r\n    } = slotDir\r\n\r\n    // check if name is dynamic.\r\n    let staticSlotName: string | undefined\r\n    if (isStaticExp(slotName)) {\r\n      staticSlotName = slotName ? slotName.content : `default`\r\n    } else {\r\n      hasDynamicSlots = true\r\n    }\r\n\r\n    const vFor = findDir(slotElement, 'for')\r\n    const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc)\r\n\r\n    // check if this slot is conditional (v-if/v-for)\r\n    let vIf: DirectiveNode | undefined\r\n    let vElse: DirectiveNode | undefined\r\n    if ((vIf = findDir(slotElement, 'if'))) {\r\n      hasDynamicSlots = true\r\n      dynamicSlots.push(\r\n        createConditionalExpression(\r\n          vIf.exp!,\r\n          buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),\r\n          defaultFallback,\r\n        ),\r\n      )\r\n    } else if (\r\n      (vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))\r\n    ) {\r\n      // find adjacent v-if\r\n      let j = i\r\n      let prev\r\n      while (j--) {\r\n        prev = children[j]\r\n        if (prev.type !== NodeTypes.COMMENT) {\r\n          break\r\n        }\r\n      }\r\n      if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {\r\n        // remove node\r\n        children.splice(i, 1)\r\n        i--\r\n        __TEST__ && assert(dynamicSlots.length > 0)\r\n        // attach this slot to previous conditional\r\n        let conditional = dynamicSlots[\r\n          dynamicSlots.length - 1\r\n        ] as ConditionalExpression\r\n        while (\r\n          conditional.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION\r\n        ) {\r\n          conditional = conditional.alternate\r\n        }\r\n        conditional.alternate = vElse.exp\r\n          ? createConditionalExpression(\r\n              vElse.exp,\r\n              buildDynamicSlot(\r\n                slotName,\r\n                slotFunction,\r\n                conditionalBranchIndex++,\r\n              ),\r\n              defaultFallback,\r\n            )\r\n          : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++)\r\n      } else {\r\n        context.onError(\r\n          createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, vElse.loc),\r\n        )\r\n      }\r\n    } else if (vFor) {\r\n      hasDynamicSlots = true\r\n      const parseResult = vFor.forParseResult\r\n      if (parseResult) {\r\n        finalizeForParseResult(parseResult, context)\r\n        // Render the dynamic slots as an array and add it to the createSlot()\r\n        // args. The runtime knows how to handle it appropriately.\r\n        dynamicSlots.push(\r\n          createCallExpression(context.helper(RENDER_LIST), [\r\n            parseResult.source,\r\n            createFunctionExpression(\r\n              createForLoopParams(parseResult),\r\n              buildDynamicSlot(slotName, slotFunction),\r\n              true /* force newline */,\r\n            ),\r\n          ]),\r\n        )\r\n      } else {\r\n        context.onError(\r\n          createCompilerError(\r\n            ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION,\r\n            vFor.loc,\r\n          ),\r\n        )\r\n      }\r\n    } else {\r\n      // check duplicate static names\r\n      if (staticSlotName) {\r\n        if (seenSlotNames.has(staticSlotName)) {\r\n          context.onError(\r\n            createCompilerError(\r\n              ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES,\r\n              dirLoc,\r\n            ),\r\n          )\r\n          continue\r\n        }\r\n        seenSlotNames.add(staticSlotName)\r\n        if (staticSlotName === 'default') {\r\n          hasNamedDefaultSlot = true\r\n        }\r\n      }\r\n      slotsProperties.push(createObjectProperty(slotName, slotFunction))\r\n    }\r\n  }\r\n\r\n  if (!onComponentSlot) {\r\n    const buildDefaultSlotProperty = (\r\n      props: ExpressionNode | undefined,\r\n      children: TemplateChildNode[],\r\n    ) => {\r\n      const fn = buildSlotFn(props, undefined, children, loc)\r\n      if (__COMPAT__ && context.compatConfig) {\r\n        fn.isNonScopedSlot = true\r\n      }\r\n      return createObjectProperty(`default`, fn)\r\n    }\r\n\r\n    if (!hasTemplateSlots) {\r\n      // implicit default slot (on component)\r\n      slotsProperties.push(buildDefaultSlotProperty(undefined, children))\r\n    } else if (\r\n      implicitDefaultChildren.length &&\r\n      // #3766\r\n      // with whitespace: 'preserve', whitespaces between slots will end up in\r\n      // implicitDefaultChildren. Ignore if all implicit children are whitespaces.\r\n      implicitDefaultChildren.some(node => isNonWhitespaceContent(node))\r\n    ) {\r\n      // implicit default slot (mixed with named slots)\r\n      if (hasNamedDefaultSlot) {\r\n        context.onError(\r\n          createCompilerError(\r\n            ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN,\r\n            implicitDefaultChildren[0].loc,\r\n          ),\r\n        )\r\n      } else {\r\n        slotsProperties.push(\r\n          buildDefaultSlotProperty(undefined, implicitDefaultChildren),\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  const slotFlag = hasDynamicSlots\r\n    ? SlotFlags.DYNAMIC\r\n    : hasForwardedSlots(node.children)\r\n      ? SlotFlags.FORWARDED\r\n      : SlotFlags.STABLE\r\n\r\n  let slots = createObjectExpression(\r\n    slotsProperties.concat(\r\n      createObjectProperty(\r\n        `_`,\r\n        // 2 = compiled but dynamic = can skip normalization, but must run diff\r\n        // 1 = compiled and static = can skip normalization AND diff as optimized\r\n        createSimpleExpression(\r\n          slotFlag + (__DEV__ ? ` /* ${slotFlagsText[slotFlag]} */` : ``),\r\n          false,\r\n        ),\r\n      ),\r\n    ),\r\n    loc,\r\n  ) as SlotsExpression\r\n  if (dynamicSlots.length) {\r\n    slots = createCallExpression(context.helper(CREATE_SLOTS), [\r\n      slots,\r\n      createArrayExpression(dynamicSlots),\r\n    ]) as SlotsExpression\r\n  }\r\n\r\n  return {\r\n    slots,\r\n    hasDynamicSlots,\r\n  }\r\n}\r\n\r\nfunction buildDynamicSlot(\r\n  name: ExpressionNode,\r\n  fn: FunctionExpression,\r\n  index?: number,\r\n): ObjectExpression {\r\n  const props = [\r\n    createObjectProperty(`name`, name),\r\n    createObjectProperty(`fn`, fn),\r\n  ]\r\n  if (index != null) {\r\n    props.push(\r\n      createObjectProperty(`key`, createSimpleExpression(String(index), true)),\r\n    )\r\n  }\r\n  return createObjectExpression(props)\r\n}\r\n\r\nfunction hasForwardedSlots(children: TemplateChildNode[]): boolean {\r\n  for (let i = 0; i < children.length; i++) {\r\n    const child = children[i]\r\n    switch (child.type) {\r\n      case NodeTypes.ELEMENT:\r\n        if (\r\n          child.tagType === ElementTypes.SLOT ||\r\n          hasForwardedSlots(child.children)\r\n        ) {\r\n          return true\r\n        }\r\n        break\r\n      case NodeTypes.IF:\r\n        if (hasForwardedSlots(child.branches)) return true\r\n        break\r\n      case NodeTypes.IF_BRANCH:\r\n      case NodeTypes.FOR:\r\n        if (hasForwardedSlots(child.children)) return true\r\n        break\r\n      default:\r\n        break\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nfunction isNonWhitespaceContent(node: TemplateChildNode): boolean {\r\n  if (node.type !== NodeTypes.TEXT && node.type !== NodeTypes.TEXT_CALL)\r\n    return true\r\n  return node.type === NodeTypes.TEXT\r\n    ? !!node.content.trim()\r\n    : isNonWhitespaceContent(node.content)\r\n}\r\n","import type { NodeTransform, TransformContext } from '../transform'\r\nimport {\r\n  type ArrayExpression,\r\n  type CallExpression,\r\n  type ComponentNode,\r\n  ConstantTypes,\r\n  type DirectiveArguments,\r\n  type DirectiveNode,\r\n  type ElementNode,\r\n  ElementTypes,\r\n  type ExpressionNode,\r\n  type JSChildNode,\r\n  NodeTypes,\r\n  type ObjectExpression,\r\n  type Property,\r\n  type TemplateTextChildNode,\r\n  type VNodeCall,\r\n  createArrayExpression,\r\n  createCallExpression,\r\n  createObjectExpression,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  createVNodeCall,\r\n} from '../ast'\r\nimport {\r\n  PatchFlagNames,\r\n  PatchFlags,\r\n  camelize,\r\n  capitalize,\r\n  isBuiltInDirective,\r\n  isObject,\r\n  isOn,\r\n  isReservedProp,\r\n  isSymbol,\r\n} from '@vue/shared'\r\nimport { ErrorCodes, createCompilerError } from '../errors'\r\nimport {\r\n  GUARD_REACTIVE_PROPS,\r\n  KEEP_ALIVE,\r\n  MERGE_PROPS,\r\n  NORMALIZE_CLASS,\r\n  NORMALIZE_PROPS,\r\n  NORMALIZE_STYLE,\r\n  RESOLVE_COMPONENT,\r\n  RESOLVE_DIRECTIVE,\r\n  RESOLVE_DYNAMIC_COMPONENT,\r\n  SUSPENSE,\r\n  TELEPORT,\r\n  TO_HANDLERS,\r\n  UNREF,\r\n} from '../runtimeHelpers'\r\nimport {\r\n  findProp,\r\n  isCoreComponent,\r\n  isStaticArgOf,\r\n  isStaticExp,\r\n  toValidAssetId,\r\n} from '../utils'\r\nimport { buildSlots } from './vSlot'\r\nimport { getConstantType } from './hoistStatic'\r\nimport { BindingTypes } from '../options'\r\nimport {\r\n  CompilerDeprecationTypes,\r\n  checkCompatEnabled,\r\n  isCompatEnabled,\r\n} from '../compat/compatConfig'\r\n\r\n// some directive transforms (e.g. v-model) may return a symbol for runtime\r\n// import, which should be used instead of a resolveDirective call.\r\nconst directiveImportMap = new WeakMap<DirectiveNode, symbol>()\r\n\r\n// generate a JavaScript AST for this element's codegen\r\nexport const transformElement: NodeTransform = (node, context) => {\r\n  // perform the work on exit, after all child expressions have been\r\n  // processed and merged.\r\n  return function postTransformElement() {\r\n    node = context.currentNode!\r\n\r\n    if (\r\n      !(\r\n        node.type === NodeTypes.ELEMENT &&\r\n        (node.tagType === ElementTypes.ELEMENT ||\r\n          node.tagType === ElementTypes.COMPONENT)\r\n      )\r\n    ) {\r\n      return\r\n    }\r\n\r\n    const { tag, props } = node\r\n    const isComponent = node.tagType === ElementTypes.COMPONENT\r\n\r\n    // The goal of the transform is to create a codegenNode implementing the\r\n    // VNodeCall interface.\r\n    let vnodeTag = isComponent\r\n      ? resolveComponentType(node as ComponentNode, context)\r\n      : `\"${tag}\"`\r\n\r\n    const isDynamicComponent =\r\n      isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT\r\n\r\n    let vnodeProps: VNodeCall['props']\r\n    let vnodeChildren: VNodeCall['children']\r\n    let vnodePatchFlag: VNodeCall['patchFlag']\r\n    let patchFlag: number = 0\r\n    let vnodeDynamicProps: VNodeCall['dynamicProps']\r\n    let dynamicPropNames: string[] | undefined\r\n    let vnodeDirectives: VNodeCall['directives']\r\n\r\n    let shouldUseBlock =\r\n      // dynamic component may resolve to plain elements\r\n      isDynamicComponent ||\r\n      vnodeTag === TELEPORT ||\r\n      vnodeTag === SUSPENSE ||\r\n      (!isComponent &&\r\n        // <svg> and <foreignObject> must be forced into blocks so that block\r\n        // updates inside get proper isSVG flag at runtime. (#639, #643)\r\n        // This is technically web-specific, but splitting the logic out of core\r\n        // leads to too much unnecessary complexity.\r\n        (tag === 'svg' || tag === 'foreignObject'))\r\n\r\n    // props\r\n    if (props.length > 0) {\r\n      const propsBuildResult = buildProps(\r\n        node,\r\n        context,\r\n        undefined,\r\n        isComponent,\r\n        isDynamicComponent,\r\n      )\r\n      vnodeProps = propsBuildResult.props\r\n      patchFlag = propsBuildResult.patchFlag\r\n      dynamicPropNames = propsBuildResult.dynamicPropNames\r\n      const directives = propsBuildResult.directives\r\n      vnodeDirectives =\r\n        directives && directives.length\r\n          ? (createArrayExpression(\r\n              directives.map(dir => buildDirectiveArgs(dir, context)),\r\n            ) as DirectiveArguments)\r\n          : undefined\r\n\r\n      if (propsBuildResult.shouldUseBlock) {\r\n        shouldUseBlock = true\r\n      }\r\n    }\r\n\r\n    // children\r\n    if (node.children.length > 0) {\r\n      if (vnodeTag === KEEP_ALIVE) {\r\n        // Although a built-in component, we compile KeepAlive with raw children\r\n        // instead of slot functions so that it can be used inside Transition\r\n        // or other Transition-wrapping HOCs.\r\n        // To ensure correct updates with block optimizations, we need to:\r\n        // 1. Force keep-alive into a block. This avoids its children being\r\n        //    collected by a parent block.\r\n        shouldUseBlock = true\r\n        // 2. Force keep-alive to always be updated, since it uses raw children.\r\n        patchFlag |= PatchFlags.DYNAMIC_SLOTS\r\n        if (__DEV__ && node.children.length > 1) {\r\n          context.onError(\r\n            createCompilerError(ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN, {\r\n              start: node.children[0].loc.start,\r\n              end: node.children[node.children.length - 1].loc.end,\r\n              source: '',\r\n            }),\r\n          )\r\n        }\r\n      }\r\n\r\n      const shouldBuildAsSlots =\r\n        isComponent &&\r\n        // Teleport is not a real component and has dedicated runtime handling\r\n        vnodeTag !== TELEPORT &&\r\n        // explained above.\r\n        vnodeTag !== KEEP_ALIVE\r\n\r\n      if (shouldBuildAsSlots) {\r\n        const { slots, hasDynamicSlots } = buildSlots(node, context)\r\n        vnodeChildren = slots\r\n        if (hasDynamicSlots) {\r\n          patchFlag |= PatchFlags.DYNAMIC_SLOTS\r\n        }\r\n      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {\r\n        const child = node.children[0]\r\n        const type = child.type\r\n        // check for dynamic text children\r\n        const hasDynamicTextChild =\r\n          type === NodeTypes.INTERPOLATION ||\r\n          type === NodeTypes.COMPOUND_EXPRESSION\r\n        if (\r\n          hasDynamicTextChild &&\r\n          getConstantType(child, context) === ConstantTypes.NOT_CONSTANT\r\n        ) {\r\n          patchFlag |= PatchFlags.TEXT\r\n        }\r\n        // pass directly if the only child is a text node\r\n        // (plain / interpolation / expression)\r\n        if (hasDynamicTextChild || type === NodeTypes.TEXT) {\r\n          vnodeChildren = child as TemplateTextChildNode\r\n        } else {\r\n          vnodeChildren = node.children\r\n        }\r\n      } else {\r\n        vnodeChildren = node.children\r\n      }\r\n    }\r\n\r\n    // patchFlag & dynamicPropNames\r\n    if (patchFlag !== 0) {\r\n      if (__DEV__) {\r\n        if (patchFlag < 0) {\r\n          // special flags (negative and mutually exclusive)\r\n          vnodePatchFlag =\r\n            patchFlag + ` /* ${PatchFlagNames[patchFlag as PatchFlags]} */`\r\n        } else {\r\n          // bitwise flags\r\n          const flagNames = Object.keys(PatchFlagNames)\r\n            .map(Number)\r\n            .filter(n => n > 0 && patchFlag & n)\r\n            .map(n => PatchFlagNames[n as PatchFlags])\r\n            .join(`, `)\r\n          vnodePatchFlag = patchFlag + ` /* ${flagNames} */`\r\n        }\r\n      } else {\r\n        vnodePatchFlag = String(patchFlag)\r\n      }\r\n      if (dynamicPropNames && dynamicPropNames.length) {\r\n        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames)\r\n      }\r\n    }\r\n\r\n    node.codegenNode = createVNodeCall(\r\n      context,\r\n      vnodeTag,\r\n      vnodeProps,\r\n      vnodeChildren,\r\n      vnodePatchFlag,\r\n      vnodeDynamicProps,\r\n      vnodeDirectives,\r\n      !!shouldUseBlock,\r\n      false /* disableTracking */,\r\n      isComponent,\r\n      node.loc,\r\n    )\r\n  }\r\n}\r\n\r\nexport function resolveComponentType(\r\n  node: ComponentNode,\r\n  context: TransformContext,\r\n  ssr = false,\r\n) {\r\n  let { tag } = node\r\n\r\n  // 1. dynamic component\r\n  const isExplicitDynamic = isComponentTag(tag)\r\n  const isProp = findProp(node, 'is')\r\n  if (isProp) {\r\n    if (\r\n      isExplicitDynamic ||\r\n      (__COMPAT__ &&\r\n        isCompatEnabled(\r\n          CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\r\n          context,\r\n        ))\r\n    ) {\r\n      const exp =\r\n        isProp.type === NodeTypes.ATTRIBUTE\r\n          ? isProp.value && createSimpleExpression(isProp.value.content, true)\r\n          : isProp.exp\r\n      if (exp) {\r\n        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\r\n          exp,\r\n        ])\r\n      }\r\n    } else if (\r\n      isProp.type === NodeTypes.ATTRIBUTE &&\r\n      isProp.value!.content.startsWith('vue:')\r\n    ) {\r\n      // <button is=\"vue:xxx\">\r\n      // if not <component>, only is value that starts with \"vue:\" will be\r\n      // treated as component by the parse phase and reach here, unless it's\r\n      // compat mode where all is values are considered components\r\n      tag = isProp.value!.content.slice(4)\r\n    }\r\n  }\r\n\r\n  // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)\r\n  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag)\r\n  if (builtIn) {\r\n    // built-ins are simply fallthroughs / have special handling during ssr\r\n    // so we don't need to import their runtime equivalents\r\n    if (!ssr) context.helper(builtIn)\r\n    return builtIn\r\n  }\r\n\r\n  // 3. user component (from setup bindings)\r\n  // this is skipped in browser build since browser builds do not perform\r\n  // binding analysis.\r\n  if (!__BROWSER__) {\r\n    const fromSetup = resolveSetupReference(tag, context)\r\n    if (fromSetup) {\r\n      return fromSetup\r\n    }\r\n    const dotIndex = tag.indexOf('.')\r\n    if (dotIndex > 0) {\r\n      const ns = resolveSetupReference(tag.slice(0, dotIndex), context)\r\n      if (ns) {\r\n        return ns + tag.slice(dotIndex)\r\n      }\r\n    }\r\n  }\r\n\r\n  // 4. Self referencing component (inferred from filename)\r\n  if (\r\n    !__BROWSER__ &&\r\n    context.selfName &&\r\n    capitalize(camelize(tag)) === context.selfName\r\n  ) {\r\n    context.helper(RESOLVE_COMPONENT)\r\n    // codegen.ts has special check for __self postfix when generating\r\n    // component imports, which will pass additional `maybeSelfReference` flag\r\n    // to `resolveComponent`.\r\n    context.components.add(tag + `__self`)\r\n    return toValidAssetId(tag, `component`)\r\n  }\r\n\r\n  // 5. user component (resolve)\r\n  context.helper(RESOLVE_COMPONENT)\r\n  context.components.add(tag)\r\n  return toValidAssetId(tag, `component`)\r\n}\r\n\r\nfunction resolveSetupReference(name: string, context: TransformContext) {\r\n  const bindings = context.bindingMetadata\r\n  if (!bindings || bindings.__isScriptSetup === false) {\r\n    return\r\n  }\r\n\r\n  const camelName = camelize(name)\r\n  const PascalName = capitalize(camelName)\r\n  const checkType = (type: BindingTypes) => {\r\n    if (bindings[name] === type) {\r\n      return name\r\n    }\r\n    if (bindings[camelName] === type) {\r\n      return camelName\r\n    }\r\n    if (bindings[PascalName] === type) {\r\n      return PascalName\r\n    }\r\n  }\r\n\r\n  const fromConst =\r\n    checkType(BindingTypes.SETUP_CONST) ||\r\n    checkType(BindingTypes.SETUP_REACTIVE_CONST) ||\r\n    checkType(BindingTypes.LITERAL_CONST)\r\n  if (fromConst) {\r\n    return context.inline\r\n      ? // in inline mode, const setup bindings (e.g. imports) can be used as-is\r\n        fromConst\r\n      : `$setup[${JSON.stringify(fromConst)}]`\r\n  }\r\n\r\n  const fromMaybeRef =\r\n    checkType(BindingTypes.SETUP_LET) ||\r\n    checkType(BindingTypes.SETUP_REF) ||\r\n    checkType(BindingTypes.SETUP_MAYBE_REF)\r\n  if (fromMaybeRef) {\r\n    return context.inline\r\n      ? // setup scope bindings that may be refs need to be unrefed\r\n        `${context.helperString(UNREF)}(${fromMaybeRef})`\r\n      : `$setup[${JSON.stringify(fromMaybeRef)}]`\r\n  }\r\n\r\n  const fromProps = checkType(BindingTypes.PROPS)\r\n  if (fromProps) {\r\n    return `${context.helperString(UNREF)}(${\r\n      context.inline ? '__props' : '$props'\r\n    }[${JSON.stringify(fromProps)}])`\r\n  }\r\n}\r\n\r\nexport type PropsExpression = ObjectExpression | CallExpression | ExpressionNode\r\n\r\nexport function buildProps(\r\n  node: ElementNode,\r\n  context: TransformContext,\r\n  props: ElementNode['props'] = node.props,\r\n  isComponent: boolean,\r\n  isDynamicComponent: boolean,\r\n  ssr = false,\r\n): {\r\n  props: PropsExpression | undefined\r\n  directives: DirectiveNode[]\r\n  patchFlag: number\r\n  dynamicPropNames: string[]\r\n  shouldUseBlock: boolean\r\n} {\r\n  const { tag, loc: elementLoc, children } = node\r\n  let properties: ObjectExpression['properties'] = []\r\n  const mergeArgs: PropsExpression[] = []\r\n  const runtimeDirectives: DirectiveNode[] = []\r\n  const hasChildren = children.length > 0\r\n  let shouldUseBlock = false\r\n\r\n  // patchFlag analysis\r\n  let patchFlag = 0\r\n  let hasRef = false\r\n  let hasClassBinding = false\r\n  let hasStyleBinding = false\r\n  let hasHydrationEventBinding = false\r\n  let hasDynamicKeys = false\r\n  let hasVnodeHook = false\r\n  const dynamicPropNames: string[] = []\r\n\r\n  const pushMergeArg = (arg?: PropsExpression) => {\r\n    if (properties.length) {\r\n      mergeArgs.push(\r\n        createObjectExpression(dedupeProperties(properties), elementLoc),\r\n      )\r\n      properties = []\r\n    }\r\n    if (arg) mergeArgs.push(arg)\r\n  }\r\n\r\n  const analyzePatchFlag = ({ key, value }: Property) => {\r\n    if (isStaticExp(key)) {\r\n      const name = key.content\r\n      const isEventHandler = isOn(name)\r\n      if (\r\n        isEventHandler &&\r\n        (!isComponent || isDynamicComponent) &&\r\n        // omit the flag for click handlers because hydration gives click\r\n        // dedicated fast path.\r\n        name.toLowerCase() !== 'onclick' &&\r\n        // omit v-model handlers\r\n        name !== 'onUpdate:modelValue' &&\r\n        // omit onVnodeXXX hooks\r\n        !isReservedProp(name)\r\n      ) {\r\n        hasHydrationEventBinding = true\r\n      }\r\n\r\n      if (isEventHandler && isReservedProp(name)) {\r\n        hasVnodeHook = true\r\n      }\r\n\r\n      if (isEventHandler && value.type === NodeTypes.JS_CALL_EXPRESSION) {\r\n        // handler wrapped with internal helper e.g. withModifiers(fn)\r\n        // extract the actual expression\r\n        value = value.arguments[0] as JSChildNode\r\n      }\r\n\r\n      if (\r\n        value.type === NodeTypes.JS_CACHE_EXPRESSION ||\r\n        ((value.type === NodeTypes.SIMPLE_EXPRESSION ||\r\n          value.type === NodeTypes.COMPOUND_EXPRESSION) &&\r\n          getConstantType(value, context) > 0)\r\n      ) {\r\n        // skip if the prop is a cached handler or has constant value\r\n        return\r\n      }\r\n\r\n      if (name === 'ref') {\r\n        hasRef = true\r\n      } else if (name === 'class') {\r\n        hasClassBinding = true\r\n      } else if (name === 'style') {\r\n        hasStyleBinding = true\r\n      } else if (name !== 'key' && !dynamicPropNames.includes(name)) {\r\n        dynamicPropNames.push(name)\r\n      }\r\n\r\n      // treat the dynamic class and style binding of the component as dynamic props\r\n      if (\r\n        isComponent &&\r\n        (name === 'class' || name === 'style') &&\r\n        !dynamicPropNames.includes(name)\r\n      ) {\r\n        dynamicPropNames.push(name)\r\n      }\r\n    } else {\r\n      hasDynamicKeys = true\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < props.length; i++) {\r\n    // static attribute\r\n    const prop = props[i]\r\n    if (prop.type === NodeTypes.ATTRIBUTE) {\r\n      const { loc, name, nameLoc, value } = prop\r\n      let isStatic = true\r\n      if (name === 'ref') {\r\n        hasRef = true\r\n        if (context.scopes.vFor > 0) {\r\n          properties.push(\r\n            createObjectProperty(\r\n              createSimpleExpression('ref_for', true),\r\n              createSimpleExpression('true'),\r\n            ),\r\n          )\r\n        }\r\n        // in inline mode there is no setupState object, so we can't use string\r\n        // keys to set the ref. Instead, we need to transform it to pass the\r\n        // actual ref instead.\r\n        if (!__BROWSER__ && value && context.inline) {\r\n          const binding = context.bindingMetadata[value.content]\r\n          if (\r\n            binding === BindingTypes.SETUP_LET ||\r\n            binding === BindingTypes.SETUP_REF ||\r\n            binding === BindingTypes.SETUP_MAYBE_REF\r\n          ) {\r\n            isStatic = false\r\n            properties.push(\r\n              createObjectProperty(\r\n                createSimpleExpression('ref_key', true),\r\n                createSimpleExpression(value.content, true, value.loc),\r\n              ),\r\n            )\r\n          }\r\n        }\r\n      }\r\n      // skip is on <component>, or is=\"vue:xxx\"\r\n      if (\r\n        name === 'is' &&\r\n        (isComponentTag(tag) ||\r\n          (value && value.content.startsWith('vue:')) ||\r\n          (__COMPAT__ &&\r\n            isCompatEnabled(\r\n              CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\r\n              context,\r\n            )))\r\n      ) {\r\n        continue\r\n      }\r\n      properties.push(\r\n        createObjectProperty(\r\n          createSimpleExpression(name, true, nameLoc),\r\n          createSimpleExpression(\r\n            value ? value.content : '',\r\n            isStatic,\r\n            value ? value.loc : loc,\r\n          ),\r\n        ),\r\n      )\r\n    } else {\r\n      // directives\r\n      const { name, arg, exp, loc, modifiers } = prop\r\n      const isVBind = name === 'bind'\r\n      const isVOn = name === 'on'\r\n\r\n      // skip v-slot - it is handled by its dedicated transform.\r\n      if (name === 'slot') {\r\n        if (!isComponent) {\r\n          context.onError(\r\n            createCompilerError(ErrorCodes.X_V_SLOT_MISPLACED, loc),\r\n          )\r\n        }\r\n        continue\r\n      }\r\n      // skip v-once/v-memo - they are handled by dedicated transforms.\r\n      if (name === 'once' || name === 'memo') {\r\n        continue\r\n      }\r\n      // skip v-is and :is on <component>\r\n      if (\r\n        name === 'is' ||\r\n        (isVBind &&\r\n          isStaticArgOf(arg, 'is') &&\r\n          (isComponentTag(tag) ||\r\n            (__COMPAT__ &&\r\n              isCompatEnabled(\r\n                CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\r\n                context,\r\n              ))))\r\n      ) {\r\n        continue\r\n      }\r\n      // skip v-on in SSR compilation\r\n      if (isVOn && ssr) {\r\n        continue\r\n      }\r\n\r\n      if (\r\n        // #938: elements with dynamic keys should be forced into blocks\r\n        (isVBind && isStaticArgOf(arg, 'key')) ||\r\n        // inline before-update hooks need to force block so that it is invoked\r\n        // before children\r\n        (isVOn && hasChildren && isStaticArgOf(arg, 'vue:before-update'))\r\n      ) {\r\n        shouldUseBlock = true\r\n      }\r\n\r\n      if (isVBind && isStaticArgOf(arg, 'ref') && context.scopes.vFor > 0) {\r\n        properties.push(\r\n          createObjectProperty(\r\n            createSimpleExpression('ref_for', true),\r\n            createSimpleExpression('true'),\r\n          ),\r\n        )\r\n      }\r\n\r\n      // special case for v-bind and v-on with no argument\r\n      if (!arg && (isVBind || isVOn)) {\r\n        hasDynamicKeys = true\r\n        if (exp) {\r\n          if (isVBind) {\r\n            // have to merge early for compat build check\r\n            pushMergeArg()\r\n            if (__COMPAT__) {\r\n              // 2.x v-bind object order compat\r\n              if (__DEV__) {\r\n                const hasOverridableKeys = mergeArgs.some(arg => {\r\n                  if (arg.type === NodeTypes.JS_OBJECT_EXPRESSION) {\r\n                    return arg.properties.some(({ key }) => {\r\n                      if (\r\n                        key.type !== NodeTypes.SIMPLE_EXPRESSION ||\r\n                        !key.isStatic\r\n                      ) {\r\n                        return true\r\n                      }\r\n                      return (\r\n                        key.content !== 'class' &&\r\n                        key.content !== 'style' &&\r\n                        !isOn(key.content)\r\n                      )\r\n                    })\r\n                  } else {\r\n                    // dynamic expression\r\n                    return true\r\n                  }\r\n                })\r\n                if (hasOverridableKeys) {\r\n                  checkCompatEnabled(\r\n                    CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER,\r\n                    context,\r\n                    loc,\r\n                  )\r\n                }\r\n              }\r\n\r\n              if (\r\n                isCompatEnabled(\r\n                  CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER,\r\n                  context,\r\n                )\r\n              ) {\r\n                mergeArgs.unshift(exp)\r\n                continue\r\n              }\r\n            }\r\n\r\n            mergeArgs.push(exp)\r\n          } else {\r\n            // v-on=\"obj\" -> toHandlers(obj)\r\n            pushMergeArg({\r\n              type: NodeTypes.JS_CALL_EXPRESSION,\r\n              loc,\r\n              callee: context.helper(TO_HANDLERS),\r\n              arguments: isComponent ? [exp] : [exp, `true`],\r\n            })\r\n          }\r\n        } else {\r\n          context.onError(\r\n            createCompilerError(\r\n              isVBind\r\n                ? ErrorCodes.X_V_BIND_NO_EXPRESSION\r\n                : ErrorCodes.X_V_ON_NO_EXPRESSION,\r\n              loc,\r\n            ),\r\n          )\r\n        }\r\n        continue\r\n      }\r\n\r\n      // force hydration for v-bind with .prop modifier\r\n      if (isVBind && modifiers.includes('prop')) {\r\n        patchFlag |= PatchFlags.NEED_HYDRATION\r\n      }\r\n\r\n      const directiveTransform = context.directiveTransforms[name]\r\n      if (directiveTransform) {\r\n        // has built-in directive transform.\r\n        const { props, needRuntime } = directiveTransform(prop, node, context)\r\n        !ssr && props.forEach(analyzePatchFlag)\r\n        if (isVOn && arg && !isStaticExp(arg)) {\r\n          pushMergeArg(createObjectExpression(props, elementLoc))\r\n        } else {\r\n          properties.push(...props)\r\n        }\r\n        if (needRuntime) {\r\n          runtimeDirectives.push(prop)\r\n          if (isSymbol(needRuntime)) {\r\n            directiveImportMap.set(prop, needRuntime)\r\n          }\r\n        }\r\n      } else if (!isBuiltInDirective(name)) {\r\n        // no built-in transform, this is a user custom directive.\r\n        runtimeDirectives.push(prop)\r\n        // custom dirs may use beforeUpdate so they need to force blocks\r\n        // to ensure before-update gets called before children update\r\n        if (hasChildren) {\r\n          shouldUseBlock = true\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  let propsExpression: PropsExpression | undefined = undefined\r\n\r\n  // has v-bind=\"object\" or v-on=\"object\", wrap with mergeProps\r\n  if (mergeArgs.length) {\r\n    // close up any not-yet-merged props\r\n    pushMergeArg()\r\n    if (mergeArgs.length > 1) {\r\n      propsExpression = createCallExpression(\r\n        context.helper(MERGE_PROPS),\r\n        mergeArgs,\r\n        elementLoc,\r\n      )\r\n    } else {\r\n      // single v-bind with nothing else - no need for a mergeProps call\r\n      propsExpression = mergeArgs[0]\r\n    }\r\n  } else if (properties.length) {\r\n    propsExpression = createObjectExpression(\r\n      dedupeProperties(properties),\r\n      elementLoc,\r\n    )\r\n  }\r\n\r\n  // patchFlag analysis\r\n  if (hasDynamicKeys) {\r\n    patchFlag |= PatchFlags.FULL_PROPS\r\n  } else {\r\n    if (hasClassBinding && !isComponent) {\r\n      patchFlag |= PatchFlags.CLASS\r\n    }\r\n    if (hasStyleBinding && !isComponent) {\r\n      patchFlag |= PatchFlags.STYLE\r\n    }\r\n    if (dynamicPropNames.length) {\r\n      patchFlag |= PatchFlags.PROPS\r\n    }\r\n    if (hasHydrationEventBinding) {\r\n      patchFlag |= PatchFlags.NEED_HYDRATION\r\n    }\r\n  }\r\n  if (\r\n    !shouldUseBlock &&\r\n    (patchFlag === 0 || patchFlag === PatchFlags.NEED_HYDRATION) &&\r\n    (hasRef || hasVnodeHook || runtimeDirectives.length > 0)\r\n  ) {\r\n    patchFlag |= PatchFlags.NEED_PATCH\r\n  }\r\n\r\n  // pre-normalize props, SSR is skipped for now\r\n  if (!context.inSSR && propsExpression) {\r\n    switch (propsExpression.type) {\r\n      case NodeTypes.JS_OBJECT_EXPRESSION:\r\n        // means that there is no v-bind,\r\n        // but still need to deal with dynamic key binding\r\n        let classKeyIndex = -1\r\n        let styleKeyIndex = -1\r\n        let hasDynamicKey = false\r\n\r\n        for (let i = 0; i < propsExpression.properties.length; i++) {\r\n          const key = propsExpression.properties[i].key\r\n          if (isStaticExp(key)) {\r\n            if (key.content === 'class') {\r\n              classKeyIndex = i\r\n            } else if (key.content === 'style') {\r\n              styleKeyIndex = i\r\n            }\r\n          } else if (!key.isHandlerKey) {\r\n            hasDynamicKey = true\r\n          }\r\n        }\r\n\r\n        const classProp = propsExpression.properties[classKeyIndex]\r\n        const styleProp = propsExpression.properties[styleKeyIndex]\r\n\r\n        // no dynamic key\r\n        if (!hasDynamicKey) {\r\n          if (classProp && !isStaticExp(classProp.value)) {\r\n            classProp.value = createCallExpression(\r\n              context.helper(NORMALIZE_CLASS),\r\n              [classProp.value],\r\n            )\r\n          }\r\n          if (\r\n            styleProp &&\r\n            // the static style is compiled into an object,\r\n            // so use `hasStyleBinding` to ensure that it is a dynamic style binding\r\n            (hasStyleBinding ||\r\n              (styleProp.value.type === NodeTypes.SIMPLE_EXPRESSION &&\r\n                styleProp.value.content.trim()[0] === `[`) ||\r\n              // v-bind:style and style both exist,\r\n              // v-bind:style with static literal object\r\n              styleProp.value.type === NodeTypes.JS_ARRAY_EXPRESSION)\r\n          ) {\r\n            styleProp.value = createCallExpression(\r\n              context.helper(NORMALIZE_STYLE),\r\n              [styleProp.value],\r\n            )\r\n          }\r\n        } else {\r\n          // dynamic key binding, wrap with `normalizeProps`\r\n          propsExpression = createCallExpression(\r\n            context.helper(NORMALIZE_PROPS),\r\n            [propsExpression],\r\n          )\r\n        }\r\n        break\r\n      case NodeTypes.JS_CALL_EXPRESSION:\r\n        // mergeProps call, do nothing\r\n        break\r\n      default:\r\n        // single v-bind\r\n        propsExpression = createCallExpression(\r\n          context.helper(NORMALIZE_PROPS),\r\n          [\r\n            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [\r\n              propsExpression,\r\n            ]),\r\n          ],\r\n        )\r\n        break\r\n    }\r\n  }\r\n\r\n  return {\r\n    props: propsExpression,\r\n    directives: runtimeDirectives,\r\n    patchFlag,\r\n    dynamicPropNames,\r\n    shouldUseBlock,\r\n  }\r\n}\r\n\r\n// Dedupe props in an object literal.\r\n// Literal duplicated attributes would have been warned during the parse phase,\r\n// however, it's possible to encounter duplicated `onXXX` handlers with different\r\n// modifiers. We also need to merge static and dynamic class / style attributes.\r\n// - onXXX handlers / style: merge into array\r\n// - class: merge into single expression with concatenation\r\nfunction dedupeProperties(properties: Property[]): Property[] {\r\n  const knownProps: Map<string, Property> = new Map()\r\n  const deduped: Property[] = []\r\n  for (let i = 0; i < properties.length; i++) {\r\n    const prop = properties[i]\r\n    // dynamic keys are always allowed\r\n    if (prop.key.type === NodeTypes.COMPOUND_EXPRESSION || !prop.key.isStatic) {\r\n      deduped.push(prop)\r\n      continue\r\n    }\r\n    const name = prop.key.content\r\n    const existing = knownProps.get(name)\r\n    if (existing) {\r\n      if (name === 'style' || name === 'class' || isOn(name)) {\r\n        mergeAsArray(existing, prop)\r\n      }\r\n      // unexpected duplicate, should have emitted error during parse\r\n    } else {\r\n      knownProps.set(name, prop)\r\n      deduped.push(prop)\r\n    }\r\n  }\r\n  return deduped\r\n}\r\n\r\nfunction mergeAsArray(existing: Property, incoming: Property) {\r\n  if (existing.value.type === NodeTypes.JS_ARRAY_EXPRESSION) {\r\n    existing.value.elements.push(incoming.value)\r\n  } else {\r\n    existing.value = createArrayExpression(\r\n      [existing.value, incoming.value],\r\n      existing.loc,\r\n    )\r\n  }\r\n}\r\n\r\nexport function buildDirectiveArgs(\r\n  dir: DirectiveNode,\r\n  context: TransformContext,\r\n): ArrayExpression {\r\n  const dirArgs: ArrayExpression['elements'] = []\r\n  const runtime = directiveImportMap.get(dir)\r\n  if (runtime) {\r\n    // built-in directive with runtime\r\n    dirArgs.push(context.helperString(runtime))\r\n  } else {\r\n    // user directive.\r\n    // see if we have directives exposed via <script setup>\r\n    const fromSetup =\r\n      !__BROWSER__ && resolveSetupReference('v-' + dir.name, context)\r\n    if (fromSetup) {\r\n      dirArgs.push(fromSetup)\r\n    } else {\r\n      // inject statement for resolving directive\r\n      context.helper(RESOLVE_DIRECTIVE)\r\n      context.directives.add(dir.name)\r\n      dirArgs.push(toValidAssetId(dir.name, `directive`))\r\n    }\r\n  }\r\n  const { loc } = dir\r\n  if (dir.exp) dirArgs.push(dir.exp)\r\n  if (dir.arg) {\r\n    if (!dir.exp) {\r\n      dirArgs.push(`void 0`)\r\n    }\r\n    dirArgs.push(dir.arg)\r\n  }\r\n  if (Object.keys(dir.modifiers).length) {\r\n    if (!dir.arg) {\r\n      if (!dir.exp) {\r\n        dirArgs.push(`void 0`)\r\n      }\r\n      dirArgs.push(`void 0`)\r\n    }\r\n    const trueExpression = createSimpleExpression(`true`, false, loc)\r\n    dirArgs.push(\r\n      createObjectExpression(\r\n        dir.modifiers.map(modifier =>\r\n          createObjectProperty(modifier, trueExpression),\r\n        ),\r\n        loc,\r\n      ),\r\n    )\r\n  }\r\n  return createArrayExpression(dirArgs, dir.loc)\r\n}\r\n\r\nfunction stringifyDynamicPropNames(props: string[]): string {\r\n  let propsNamesString = `[`\r\n  for (let i = 0, l = props.length; i < l; i++) {\r\n    propsNamesString += JSON.stringify(props[i])\r\n    if (i < l - 1) propsNamesString += ', '\r\n  }\r\n  return propsNamesString + `]`\r\n}\r\n\r\nfunction isComponentTag(tag: string) {\r\n  return tag === 'component' || tag === 'Component'\r\n}\r\n","import type { NodeTransform, TransformContext } from '../transform'\r\nimport {\r\n  type CallExpression,\r\n  type ExpressionNode,\r\n  NodeTypes,\r\n  type SlotOutletNode,\r\n  createCallExpression,\r\n  createFunctionExpression,\r\n} from '../ast'\r\nimport { isSlotOutlet, isStaticArgOf, isStaticExp } from '../utils'\r\nimport { type PropsExpression, buildProps } from './transformElement'\r\nimport { ErrorCodes, createCompilerError } from '../errors'\r\nimport { RENDER_SLOT } from '../runtimeHelpers'\r\nimport { camelize } from '@vue/shared'\r\n\r\nexport const transformSlotOutlet: NodeTransform = (node, context) => {\r\n  if (isSlotOutlet(node)) {\r\n    const { children, loc } = node\r\n    const { slotName, slotProps } = processSlotOutlet(node, context)\r\n\r\n    const slotArgs: CallExpression['arguments'] = [\r\n      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,\r\n      slotName,\r\n      '{}',\r\n      'undefined',\r\n      'true',\r\n    ]\r\n    let expectedLen = 2\r\n\r\n    if (slotProps) {\r\n      slotArgs[2] = slotProps\r\n      expectedLen = 3\r\n    }\r\n\r\n    if (children.length) {\r\n      slotArgs[3] = createFunctionExpression([], children, false, false, loc)\r\n      expectedLen = 4\r\n    }\r\n\r\n    if (context.scopeId && !context.slotted) {\r\n      expectedLen = 5\r\n    }\r\n    slotArgs.splice(expectedLen) // remove unused arguments\r\n\r\n    node.codegenNode = createCallExpression(\r\n      context.helper(RENDER_SLOT),\r\n      slotArgs,\r\n      loc,\r\n    )\r\n  }\r\n}\r\n\r\ninterface SlotOutletProcessResult {\r\n  slotName: string | ExpressionNode\r\n  slotProps: PropsExpression | undefined\r\n}\r\n\r\nexport function processSlotOutlet(\r\n  node: SlotOutletNode,\r\n  context: TransformContext,\r\n): SlotOutletProcessResult {\r\n  let slotName: string | ExpressionNode = `\"default\"`\r\n  let slotProps: PropsExpression | undefined = undefined\r\n\r\n  const nonNameProps = []\r\n  for (let i = 0; i < node.props.length; i++) {\r\n    const p = node.props[i]\r\n    if (p.type === NodeTypes.ATTRIBUTE) {\r\n      if (p.value) {\r\n        if (p.name === 'name') {\r\n          slotName = JSON.stringify(p.value.content)\r\n        } else {\r\n          p.name = camelize(p.name)\r\n          nonNameProps.push(p)\r\n        }\r\n      }\r\n    } else {\r\n      if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {\r\n        if (p.exp) slotName = p.exp\r\n      } else {\r\n        if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {\r\n          p.arg.content = camelize(p.arg.content)\r\n        }\r\n        nonNameProps.push(p)\r\n      }\r\n    }\r\n  }\r\n\r\n  if (nonNameProps.length > 0) {\r\n    const { props, directives } = buildProps(\r\n      node,\r\n      context,\r\n      nonNameProps,\r\n      false,\r\n      false,\r\n    )\r\n    slotProps = props\r\n\r\n    if (directives.length) {\r\n      context.onError(\r\n        createCompilerError(\r\n          ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET,\r\n          directives[0].loc,\r\n        ),\r\n      )\r\n    }\r\n  }\r\n\r\n  return {\r\n    slotName,\r\n    slotProps,\r\n  }\r\n}\r\n","import type { DirectiveTransform, DirectiveTransformResult } from '../transform'\r\nimport {\r\n  type DirectiveNode,\r\n  ElementTypes,\r\n  type ExpressionNode,\r\n  NodeTypes,\r\n  type SimpleExpressionNode,\r\n  createCompoundExpression,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n} from '../ast'\r\nimport { camelize, toHandlerKey } from '@vue/shared'\r\nimport { ErrorCodes, createCompilerError } from '../errors'\r\nimport { processExpression } from './transformExpression'\r\nimport { validateBrowserExpression } from '../validateExpression'\r\nimport { hasScopeRef, isMemberExpression } from '../utils'\r\nimport { TO_HANDLER_KEY } from '../runtimeHelpers'\r\n\r\nconst fnExpRE =\r\n  /^\\s*([\\w$_]+|(async\\s*)?\\([^)]*?\\))\\s*(:[^=]+)?=>|^\\s*(async\\s+)?function(?:\\s+[\\w$]+)?\\s*\\(/\r\n\r\nexport interface VOnDirectiveNode extends DirectiveNode {\r\n  // v-on without arg is handled directly in ./transformElements.ts due to it affecting\r\n  // codegen for the entire props object. This transform here is only for v-on\r\n  // *with* args.\r\n  arg: ExpressionNode\r\n  // exp is guaranteed to be a simple expression here because v-on w/ arg is\r\n  // skipped by transformExpression as a special case.\r\n  exp: SimpleExpressionNode | undefined\r\n}\r\n\r\nexport const transformOn: DirectiveTransform = (\r\n  dir,\r\n  node,\r\n  context,\r\n  augmentor,\r\n) => {\r\n  const { loc, modifiers, arg } = dir as VOnDirectiveNode\r\n  if (!dir.exp && !modifiers.length) {\r\n    context.onError(createCompilerError(ErrorCodes.X_V_ON_NO_EXPRESSION, loc))\r\n  }\r\n  let eventName: ExpressionNode\r\n  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n    if (arg.isStatic) {\r\n      let rawName = arg.content\r\n      if (__DEV__ && rawName.startsWith('vnode')) {\r\n        context.onError(createCompilerError(ErrorCodes.X_VNODE_HOOKS, arg.loc))\r\n      }\r\n      if (rawName.startsWith('vue:')) {\r\n        rawName = `vnode-${rawName.slice(4)}`\r\n      }\r\n      const eventString =\r\n        node.tagType !== ElementTypes.ELEMENT ||\r\n        rawName.startsWith('vnode') ||\r\n        !/[A-Z]/.test(rawName)\r\n          ? // for non-element and vnode lifecycle event listeners, auto convert\r\n            // it to camelCase. See issue #2249\r\n            toHandlerKey(camelize(rawName))\r\n          : // preserve case for plain element listeners that have uppercase\r\n            // letters, as these may be custom elements' custom events\r\n            `on:${rawName}`\r\n      eventName = createSimpleExpression(eventString, true, arg.loc)\r\n    } else {\r\n      // #2388\r\n      eventName = createCompoundExpression([\r\n        `${context.helperString(TO_HANDLER_KEY)}(`,\r\n        arg,\r\n        `)`,\r\n      ])\r\n    }\r\n  } else {\r\n    // already a compound expression.\r\n    eventName = arg\r\n    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`)\r\n    eventName.children.push(`)`)\r\n  }\r\n\r\n  // handler processing\r\n  let exp: ExpressionNode | undefined = dir.exp as\r\n    | SimpleExpressionNode\r\n    | undefined\r\n  if (exp && !exp.content.trim()) {\r\n    exp = undefined\r\n  }\r\n  let shouldCache: boolean = context.cacheHandlers && !exp && !context.inVOnce\r\n  if (exp) {\r\n    const isMemberExp = isMemberExpression(exp.content, context)\r\n    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content))\r\n    const hasMultipleStatements = exp.content.includes(`;`)\r\n\r\n    // process the expression since it's been skipped\r\n    if (!__BROWSER__ && context.prefixIdentifiers) {\r\n      isInlineStatement && context.addIdentifiers(`$event`)\r\n      exp = dir.exp = processExpression(\r\n        exp,\r\n        context,\r\n        false,\r\n        hasMultipleStatements,\r\n      )\r\n      isInlineStatement && context.removeIdentifiers(`$event`)\r\n      // with scope analysis, the function is hoistable if it has no reference\r\n      // to scope variables.\r\n      shouldCache =\r\n        context.cacheHandlers &&\r\n        // unnecessary to cache inside v-once\r\n        !context.inVOnce &&\r\n        // runtime constants don't need to be cached\r\n        // (this is analyzed by compileScript in SFC <script setup>)\r\n        !(exp.type === NodeTypes.SIMPLE_EXPRESSION && exp.constType > 0) &&\r\n        // #1541 bail if this is a member exp handler passed to a component -\r\n        // we need to use the original function to preserve arity,\r\n        // e.g. <transition> relies on checking cb.length to determine\r\n        // transition end handling. Inline function is ok since its arity\r\n        // is preserved even when cached.\r\n        !(isMemberExp && node.tagType === ElementTypes.COMPONENT) &&\r\n        // bail if the function references closure variables (v-for, v-slot)\r\n        // it must be passed fresh to avoid stale values.\r\n        !hasScopeRef(exp, context.identifiers)\r\n      // If the expression is optimizable and is a member expression pointing\r\n      // to a function, turn it into invocation (and wrap in an arrow function\r\n      // below) so that it always accesses the latest value when called - thus\r\n      // avoiding the need to be patched.\r\n      if (shouldCache && isMemberExp) {\r\n        if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n          exp.content = `${exp.content} && ${exp.content}(...args)`\r\n        } else {\r\n          exp.children = [...exp.children, ` && `, ...exp.children, `(...args)`]\r\n        }\r\n      }\r\n    }\r\n\r\n    if (__DEV__ && __BROWSER__) {\r\n      validateBrowserExpression(\r\n        exp as SimpleExpressionNode,\r\n        context,\r\n        false,\r\n        hasMultipleStatements,\r\n      )\r\n    }\r\n\r\n    if (isInlineStatement || (shouldCache && isMemberExp)) {\r\n      // wrap inline statement in a function expression\r\n      exp = createCompoundExpression([\r\n        `${\r\n          isInlineStatement\r\n            ? !__BROWSER__ && context.isTS\r\n              ? `($event: any)`\r\n              : `$event`\r\n            : `${\r\n                !__BROWSER__ && context.isTS ? `\\n//@ts-ignore\\n` : ``\r\n              }(...args)`\r\n        } => ${hasMultipleStatements ? `{` : `(`}`,\r\n        exp,\r\n        hasMultipleStatements ? `}` : `)`,\r\n      ])\r\n    }\r\n  }\r\n\r\n  let ret: DirectiveTransformResult = {\r\n    props: [\r\n      createObjectProperty(\r\n        eventName,\r\n        exp || createSimpleExpression(`() => {}`, false, loc),\r\n      ),\r\n    ],\r\n  }\r\n\r\n  // apply extended compiler augmentor\r\n  if (augmentor) {\r\n    ret = augmentor(ret)\r\n  }\r\n\r\n  if (shouldCache) {\r\n    // cache handlers so that it's always the same handler being passed down.\r\n    // this avoids unnecessary re-renders when users use inline handlers on\r\n    // components.\r\n    ret.props[0].value = context.cache(ret.props[0].value)\r\n  }\r\n\r\n  // mark the key as handler for props normalization check\r\n  ret.props.forEach(p => (p.key.isHandlerKey = true))\r\n  return ret\r\n}\r\n","import type { DirectiveTransform } from '../transform'\r\nimport {\r\n  type ExpressionNode,\r\n  NodeTypes,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n} from '../ast'\r\nimport { ErrorCodes, createCompilerError } from '../errors'\r\nimport { camelize } from '@vue/shared'\r\nimport { CAMELIZE } from '../runtimeHelpers'\r\nimport { processExpression } from './transformExpression'\r\n\r\n// v-bind without arg is handled directly in ./transformElements.ts due to it affecting\r\n// codegen for the entire props object. This transform here is only for v-bind\r\n// *with* args.\r\nexport const transformBind: DirectiveTransform = (dir, _node, context) => {\r\n  const { modifiers, loc } = dir\r\n  const arg = dir.arg!\r\n\r\n  // :arg is replaced by :arg=\"arg\"\r\n  let { exp } = dir\r\n  if (!exp && arg.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n    const propName = camelize(arg.content)\r\n    exp = dir.exp = createSimpleExpression(propName, false, arg.loc)\r\n    if (!__BROWSER__) {\r\n      exp = dir.exp = processExpression(exp, context)\r\n    }\r\n  }\r\n\r\n  if (arg.type !== NodeTypes.SIMPLE_EXPRESSION) {\r\n    arg.children.unshift(`(`)\r\n    arg.children.push(`) || \"\"`)\r\n  } else if (!arg.isStatic) {\r\n    arg.content = `${arg.content} || \"\"`\r\n  }\r\n\r\n  // .sync is replaced by v-model:arg\r\n  if (modifiers.includes('camel')) {\r\n    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n      if (arg.isStatic) {\r\n        arg.content = camelize(arg.content)\r\n      } else {\r\n        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`\r\n      }\r\n    } else {\r\n      arg.children.unshift(`${context.helperString(CAMELIZE)}(`)\r\n      arg.children.push(`)`)\r\n    }\r\n  }\r\n\r\n  if (!context.inSSR) {\r\n    if (modifiers.includes('prop')) {\r\n      injectPrefix(arg, '.')\r\n    }\r\n    if (modifiers.includes('attr')) {\r\n      injectPrefix(arg, '^')\r\n    }\r\n  }\r\n\r\n  if (\r\n    !exp ||\r\n    (exp.type === NodeTypes.SIMPLE_EXPRESSION && !exp.content.trim())\r\n  ) {\r\n    context.onError(createCompilerError(ErrorCodes.X_V_BIND_NO_EXPRESSION, loc))\r\n    return {\r\n      props: [createObjectProperty(arg, createSimpleExpression('', true, loc))],\r\n    }\r\n  }\r\n\r\n  return {\r\n    props: [createObjectProperty(arg, exp)],\r\n  }\r\n}\r\n\r\nconst injectPrefix = (arg: ExpressionNode, prefix: string) => {\r\n  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n    if (arg.isStatic) {\r\n      arg.content = prefix + arg.content\r\n    } else {\r\n      arg.content = `\\`${prefix}\\${${arg.content}}\\``\r\n    }\r\n  } else {\r\n    arg.children.unshift(`'${prefix}' + (`)\r\n    arg.children.push(`)`)\r\n  }\r\n}\r\n","import type { NodeTransform } from '../transform'\r\nimport {\r\n  type CallExpression,\r\n  type CompoundExpressionNode,\r\n  ConstantTypes,\r\n  ElementTypes,\r\n  NodeTypes,\r\n  createCallExpression,\r\n  createCompoundExpression,\r\n} from '../ast'\r\nimport { isText } from '../utils'\r\nimport { CREATE_TEXT } from '../runtimeHelpers'\r\nimport { PatchFlagNames, PatchFlags } from '@vue/shared'\r\nimport { getConstantType } from './hoistStatic'\r\n\r\n// Merge adjacent text nodes and expressions into a single expression\r\n// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.\r\nexport const transformText: NodeTransform = (node, context) => {\r\n  if (\r\n    node.type === NodeTypes.ROOT ||\r\n    node.type === NodeTypes.ELEMENT ||\r\n    node.type === NodeTypes.FOR ||\r\n    node.type === NodeTypes.IF_BRANCH\r\n  ) {\r\n    // perform the transform on node exit so that all expressions have already\r\n    // been processed.\r\n    return () => {\r\n      const children = node.children\r\n      let currentContainer: CompoundExpressionNode | undefined = undefined\r\n      let hasText = false\r\n\r\n      for (let i = 0; i < children.length; i++) {\r\n        const child = children[i]\r\n        if (isText(child)) {\r\n          hasText = true\r\n          for (let j = i + 1; j < children.length; j++) {\r\n            const next = children[j]\r\n            if (isText(next)) {\r\n              if (!currentContainer) {\r\n                currentContainer = children[i] = createCompoundExpression(\r\n                  [child],\r\n                  child.loc,\r\n                )\r\n              }\r\n              // merge adjacent text node into current\r\n              currentContainer.children.push(` + `, next)\r\n              children.splice(j, 1)\r\n              j--\r\n            } else {\r\n              currentContainer = undefined\r\n              break\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (\r\n        !hasText ||\r\n        // if this is a plain element with a single text child, leave it\r\n        // as-is since the runtime has dedicated fast path for this by directly\r\n        // setting textContent of the element.\r\n        // for component root it's always normalized anyway.\r\n        (children.length === 1 &&\r\n          (node.type === NodeTypes.ROOT ||\r\n            (node.type === NodeTypes.ELEMENT &&\r\n              node.tagType === ElementTypes.ELEMENT &&\r\n              // #3756\r\n              // custom directives can potentially add DOM elements arbitrarily,\r\n              // we need to avoid setting textContent of the element at runtime\r\n              // to avoid accidentally overwriting the DOM elements added\r\n              // by the user through custom directives.\r\n              !node.props.find(\r\n                p =>\r\n                  p.type === NodeTypes.DIRECTIVE &&\r\n                  !context.directiveTransforms[p.name],\r\n              ) &&\r\n              // in compat mode, <template> tags with no special directives\r\n              // will be rendered as a fragment so its children must be\r\n              // converted into vnodes.\r\n              !(__COMPAT__ && node.tag === 'template'))))\r\n      ) {\r\n        return\r\n      }\r\n\r\n      // pre-convert text nodes into createTextVNode(text) calls to avoid\r\n      // runtime normalization.\r\n      for (let i = 0; i < children.length; i++) {\r\n        const child = children[i]\r\n        if (isText(child) || child.type === NodeTypes.COMPOUND_EXPRESSION) {\r\n          const callArgs: CallExpression['arguments'] = []\r\n          // createTextVNode defaults to single whitespace, so if it is a\r\n          // single space the code could be an empty call to save bytes.\r\n          if (child.type !== NodeTypes.TEXT || child.content !== ' ') {\r\n            callArgs.push(child)\r\n          }\r\n          // mark dynamic text with flag so it gets patched inside a block\r\n          if (\r\n            !context.ssr &&\r\n            getConstantType(child, context) === ConstantTypes.NOT_CONSTANT\r\n          ) {\r\n            callArgs.push(\r\n              PatchFlags.TEXT +\r\n                (__DEV__ ? ` /* ${PatchFlagNames[PatchFlags.TEXT]} */` : ``),\r\n            )\r\n          }\r\n          children[i] = {\r\n            type: NodeTypes.TEXT_CALL,\r\n            content: child,\r\n            loc: child.loc,\r\n            codegenNode: createCallExpression(\r\n              context.helper(CREATE_TEXT),\r\n              callArgs,\r\n            ),\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import type { NodeTransform } from '../transform'\r\nimport { findDir } from '../utils'\r\nimport { type ElementNode, type ForNode, type IfNode, NodeTypes } from '../ast'\r\nimport { SET_BLOCK_TRACKING } from '../runtimeHelpers'\r\n\r\nconst seen = new WeakSet()\r\n\r\nexport const transformOnce: NodeTransform = (node, context) => {\r\n  if (node.type === NodeTypes.ELEMENT && findDir(node, 'once', true)) {\r\n    if (seen.has(node) || context.inVOnce || context.inSSR) {\r\n      return\r\n    }\r\n    seen.add(node)\r\n    context.inVOnce = true\r\n    context.helper(SET_BLOCK_TRACKING)\r\n    return () => {\r\n      context.inVOnce = false\r\n      const cur = context.currentNode as ElementNode | IfNode | ForNode\r\n      if (cur.codegenNode) {\r\n        cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */)\r\n      }\r\n    }\r\n  }\r\n}\r\n","import type { DirectiveTransform } from '../transform'\r\nimport {\r\n  ConstantTypes,\r\n  ElementTypes,\r\n  type ExpressionNode,\r\n  NodeTypes,\r\n  type Property,\r\n  createCompoundExpression,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n} from '../ast'\r\nimport { ErrorCodes, createCompilerError } from '../errors'\r\nimport {\r\n  hasScopeRef,\r\n  isMemberExpression,\r\n  isSimpleIdentifier,\r\n  isStaticExp,\r\n} from '../utils'\r\nimport { IS_REF } from '../runtimeHelpers'\r\nimport { BindingTypes } from '../options'\r\nimport { camelize } from '@vue/shared'\r\n\r\nexport const transformModel: DirectiveTransform = (dir, node, context) => {\r\n  const { exp, arg } = dir\r\n  if (!exp) {\r\n    context.onError(\r\n      createCompilerError(ErrorCodes.X_V_MODEL_NO_EXPRESSION, dir.loc),\r\n    )\r\n    return createTransformProps()\r\n  }\r\n\r\n  // we assume v-model directives are always parsed\r\n  // (not artificially created by a transform)\r\n  const rawExp = exp.loc.source\r\n  const expString =\r\n    exp.type === NodeTypes.SIMPLE_EXPRESSION ? exp.content : rawExp\r\n\r\n  // im SFC <script setup> inline mode, the exp may have been transformed into\r\n  // _unref(exp)\r\n  const bindingType = context.bindingMetadata[rawExp]\r\n\r\n  // check props\r\n  if (\r\n    bindingType === BindingTypes.PROPS ||\r\n    bindingType === BindingTypes.PROPS_ALIASED\r\n  ) {\r\n    context.onError(createCompilerError(ErrorCodes.X_V_MODEL_ON_PROPS, exp.loc))\r\n    return createTransformProps()\r\n  }\r\n\r\n  const maybeRef =\r\n    !__BROWSER__ &&\r\n    context.inline &&\r\n    (bindingType === BindingTypes.SETUP_LET ||\r\n      bindingType === BindingTypes.SETUP_REF ||\r\n      bindingType === BindingTypes.SETUP_MAYBE_REF)\r\n\r\n  if (\r\n    !expString.trim() ||\r\n    (!isMemberExpression(expString, context) && !maybeRef)\r\n  ) {\r\n    context.onError(\r\n      createCompilerError(ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION, exp.loc),\r\n    )\r\n    return createTransformProps()\r\n  }\r\n\r\n  if (\r\n    !__BROWSER__ &&\r\n    context.prefixIdentifiers &&\r\n    isSimpleIdentifier(expString) &&\r\n    context.identifiers[expString]\r\n  ) {\r\n    context.onError(\r\n      createCompilerError(ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE, exp.loc),\r\n    )\r\n    return createTransformProps()\r\n  }\r\n\r\n  const propName = arg ? arg : createSimpleExpression('modelValue', true)\r\n  const eventName = arg\r\n    ? isStaticExp(arg)\r\n      ? `onUpdate:${camelize(arg.content)}`\r\n      : createCompoundExpression(['\"onUpdate:\" + ', arg])\r\n    : `onUpdate:modelValue`\r\n\r\n  let assignmentExp: ExpressionNode\r\n  const eventArg = context.isTS ? `($event: any)` : `$event`\r\n  if (maybeRef) {\r\n    if (bindingType === BindingTypes.SETUP_REF) {\r\n      // v-model used on known ref.\r\n      assignmentExp = createCompoundExpression([\r\n        `${eventArg} => ((`,\r\n        createSimpleExpression(rawExp, false, exp.loc),\r\n        `).value = $event)`,\r\n      ])\r\n    } else {\r\n      // v-model used on a potentially ref binding in <script setup> inline mode.\r\n      // the assignment needs to check whether the binding is actually a ref.\r\n      const altAssignment =\r\n        bindingType === BindingTypes.SETUP_LET ? `${rawExp} = $event` : `null`\r\n      assignmentExp = createCompoundExpression([\r\n        `${eventArg} => (${context.helperString(IS_REF)}(${rawExp}) ? (`,\r\n        createSimpleExpression(rawExp, false, exp.loc),\r\n        `).value = $event : ${altAssignment})`,\r\n      ])\r\n    }\r\n  } else {\r\n    assignmentExp = createCompoundExpression([\r\n      `${eventArg} => ((`,\r\n      exp,\r\n      `) = $event)`,\r\n    ])\r\n  }\r\n\r\n  const props = [\r\n    // modelValue: foo\r\n    createObjectProperty(propName, dir.exp!),\r\n    // \"onUpdate:modelValue\": $event => (foo = $event)\r\n    createObjectProperty(eventName, assignmentExp),\r\n  ]\r\n\r\n  // cache v-model handler if applicable (when it doesn't refer any scope vars)\r\n  if (\r\n    !__BROWSER__ &&\r\n    context.prefixIdentifiers &&\r\n    !context.inVOnce &&\r\n    context.cacheHandlers &&\r\n    !hasScopeRef(exp, context.identifiers)\r\n  ) {\r\n    props[1].value = context.cache(props[1].value)\r\n  }\r\n\r\n  // modelModifiers: { foo: true, \"bar-baz\": true }\r\n  if (dir.modifiers.length && node.tagType === ElementTypes.COMPONENT) {\r\n    const modifiers = dir.modifiers\r\n      .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)\r\n      .join(`, `)\r\n    const modifiersKey = arg\r\n      ? isStaticExp(arg)\r\n        ? `${arg.content}Modifiers`\r\n        : createCompoundExpression([arg, ' + \"Modifiers\"'])\r\n      : `modelModifiers`\r\n    props.push(\r\n      createObjectProperty(\r\n        modifiersKey,\r\n        createSimpleExpression(\r\n          `{ ${modifiers} }`,\r\n          false,\r\n          dir.loc,\r\n          ConstantTypes.CAN_HOIST,\r\n        ),\r\n      ),\r\n    )\r\n  }\r\n\r\n  return createTransformProps(props)\r\n}\r\n\r\nfunction createTransformProps(props: Property[] = []) {\r\n  return { props }\r\n}\r\n","import { RESOLVE_FILTER } from '../runtimeHelpers'\r\nimport {\r\n  type AttributeNode,\r\n  type DirectiveNode,\r\n  type ExpressionNode,\r\n  NodeTypes,\r\n  type SimpleExpressionNode,\r\n} from '../ast'\r\nimport {\r\n  CompilerDeprecationTypes,\r\n  isCompatEnabled,\r\n  warnDeprecation,\r\n} from './compatConfig'\r\nimport type { NodeTransform, TransformContext } from '../transform'\r\nimport { toValidAssetId } from '../utils'\r\n\r\nconst validDivisionCharRE = /[\\w).+\\-_$\\]]/\r\n\r\nexport const transformFilter: NodeTransform = (node, context) => {\r\n  if (!isCompatEnabled(CompilerDeprecationTypes.COMPILER_FILTERS, context)) {\r\n    return\r\n  }\r\n\r\n  if (node.type === NodeTypes.INTERPOLATION) {\r\n    // filter rewrite is applied before expression transform so only\r\n    // simple expressions are possible at this stage\r\n    rewriteFilter(node.content, context)\r\n  }\r\n\r\n  if (node.type === NodeTypes.ELEMENT) {\r\n    node.props.forEach((prop: AttributeNode | DirectiveNode) => {\r\n      if (\r\n        prop.type === NodeTypes.DIRECTIVE &&\r\n        prop.name !== 'for' &&\r\n        prop.exp\r\n      ) {\r\n        rewriteFilter(prop.exp, context)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nfunction rewriteFilter(node: ExpressionNode, context: TransformContext) {\r\n  if (node.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n    parseFilter(node, context)\r\n  } else {\r\n    for (let i = 0; i < node.children.length; i++) {\r\n      const child = node.children[i]\r\n      if (typeof child !== 'object') continue\r\n      if (child.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n        parseFilter(child, context)\r\n      } else if (child.type === NodeTypes.COMPOUND_EXPRESSION) {\r\n        rewriteFilter(node, context)\r\n      } else if (child.type === NodeTypes.INTERPOLATION) {\r\n        rewriteFilter(child.content, context)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction parseFilter(node: SimpleExpressionNode, context: TransformContext) {\r\n  const exp = node.content\r\n  let inSingle = false\r\n  let inDouble = false\r\n  let inTemplateString = false\r\n  let inRegex = false\r\n  let curly = 0\r\n  let square = 0\r\n  let paren = 0\r\n  let lastFilterIndex = 0\r\n  let c,\r\n    prev,\r\n    i: number,\r\n    expression,\r\n    filters: string[] = []\r\n\r\n  for (i = 0; i < exp.length; i++) {\r\n    prev = c\r\n    c = exp.charCodeAt(i)\r\n    if (inSingle) {\r\n      if (c === 0x27 && prev !== 0x5c) inSingle = false\r\n    } else if (inDouble) {\r\n      if (c === 0x22 && prev !== 0x5c) inDouble = false\r\n    } else if (inTemplateString) {\r\n      if (c === 0x60 && prev !== 0x5c) inTemplateString = false\r\n    } else if (inRegex) {\r\n      if (c === 0x2f && prev !== 0x5c) inRegex = false\r\n    } else if (\r\n      c === 0x7c && // pipe\r\n      exp.charCodeAt(i + 1) !== 0x7c &&\r\n      exp.charCodeAt(i - 1) !== 0x7c &&\r\n      !curly &&\r\n      !square &&\r\n      !paren\r\n    ) {\r\n      if (expression === undefined) {\r\n        // first filter, end of expression\r\n        lastFilterIndex = i + 1\r\n        expression = exp.slice(0, i).trim()\r\n      } else {\r\n        pushFilter()\r\n      }\r\n    } else {\r\n      switch (c) {\r\n        case 0x22:\r\n          inDouble = true\r\n          break // \"\r\n        case 0x27:\r\n          inSingle = true\r\n          break // '\r\n        case 0x60:\r\n          inTemplateString = true\r\n          break // `\r\n        case 0x28:\r\n          paren++\r\n          break // (\r\n        case 0x29:\r\n          paren--\r\n          break // )\r\n        case 0x5b:\r\n          square++\r\n          break // [\r\n        case 0x5d:\r\n          square--\r\n          break // ]\r\n        case 0x7b:\r\n          curly++\r\n          break // {\r\n        case 0x7d:\r\n          curly--\r\n          break // }\r\n      }\r\n      if (c === 0x2f) {\r\n        // /\r\n        let j = i - 1\r\n        let p\r\n        // find first non-whitespace prev char\r\n        for (; j >= 0; j--) {\r\n          p = exp.charAt(j)\r\n          if (p !== ' ') break\r\n        }\r\n        if (!p || !validDivisionCharRE.test(p)) {\r\n          inRegex = true\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (expression === undefined) {\r\n    expression = exp.slice(0, i).trim()\r\n  } else if (lastFilterIndex !== 0) {\r\n    pushFilter()\r\n  }\r\n\r\n  function pushFilter() {\r\n    filters.push(exp.slice(lastFilterIndex, i).trim())\r\n    lastFilterIndex = i + 1\r\n  }\r\n\r\n  if (filters.length) {\r\n    __DEV__ &&\r\n      warnDeprecation(\r\n        CompilerDeprecationTypes.COMPILER_FILTERS,\r\n        context,\r\n        node.loc,\r\n      )\r\n    for (i = 0; i < filters.length; i++) {\r\n      expression = wrapFilter(expression, filters[i], context)\r\n    }\r\n    node.content = expression\r\n  }\r\n}\r\n\r\nfunction wrapFilter(\r\n  exp: string,\r\n  filter: string,\r\n  context: TransformContext,\r\n): string {\r\n  context.helper(RESOLVE_FILTER)\r\n  const i = filter.indexOf('(')\r\n  if (i < 0) {\r\n    context.filters!.add(filter)\r\n    return `${toValidAssetId(filter, 'filter')}(${exp})`\r\n  } else {\r\n    const name = filter.slice(0, i)\r\n    const args = filter.slice(i + 1)\r\n    context.filters!.add(name)\r\n    return `${toValidAssetId(name, 'filter')}(${exp}${\r\n      args !== ')' ? ',' + args : args\r\n    }`\r\n  }\r\n}\r\n","import type { NodeTransform } from '../transform'\r\nimport { findDir } from '../utils'\r\nimport {\r\n  ElementTypes,\r\n  type MemoExpression,\r\n  NodeTypes,\r\n  type PlainElementNode,\r\n  convertToBlock,\r\n  createCallExpression,\r\n  createFunctionExpression,\r\n} from '../ast'\r\nimport { WITH_MEMO } from '../runtimeHelpers'\r\n\r\nconst seen = new WeakSet()\r\n\r\nexport const transformMemo: NodeTransform = (node, context) => {\r\n  if (node.type === NodeTypes.ELEMENT) {\r\n    const dir = findDir(node, 'memo')\r\n    if (!dir || seen.has(node)) {\r\n      return\r\n    }\r\n    seen.add(node)\r\n    return () => {\r\n      const codegenNode =\r\n        node.codegenNode ||\r\n        (context.currentNode as PlainElementNode).codegenNode\r\n      if (codegenNode && codegenNode.type === NodeTypes.VNODE_CALL) {\r\n        // non-component sub tree should be turned into a block\r\n        if (node.tagType !== ElementTypes.COMPONENT) {\r\n          convertToBlock(codegenNode, context)\r\n        }\r\n        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [\r\n          dir.exp!,\r\n          createFunctionExpression(undefined, codegenNode),\r\n          `_cache`,\r\n          String(context.cached++),\r\n        ]) as MemoExpression\r\n      }\r\n    }\r\n  }\r\n}\r\n","import type { CompilerOptions } from './options'\r\nimport { baseParse } from './parser'\r\nimport {\r\n  type DirectiveTransform,\r\n  type NodeTransform,\r\n  transform,\r\n} from './transform'\r\nimport { type CodegenResult, generate } from './codegen'\r\nimport type { RootNode } from './ast'\r\nimport { extend, isString } from '@vue/shared'\r\nimport { transformIf } from './transforms/vIf'\r\nimport { transformFor } from './transforms/vFor'\r\nimport { transformExpression } from './transforms/transformExpression'\r\nimport { transformSlotOutlet } from './transforms/transformSlotOutlet'\r\nimport { transformElement } from './transforms/transformElement'\r\nimport { transformOn } from './transforms/vOn'\r\nimport { transformBind } from './transforms/vBind'\r\nimport { trackSlotScopes, trackVForSlotScopes } from './transforms/vSlot'\r\nimport { transformText } from './transforms/transformText'\r\nimport { transformOnce } from './transforms/vOnce'\r\nimport { transformModel } from './transforms/vModel'\r\nimport { transformFilter } from './compat/transformFilter'\r\nimport { ErrorCodes, createCompilerError, defaultOnError } from './errors'\r\nimport { transformMemo } from './transforms/vMemo'\r\n\r\nexport type TransformPreset = [\r\n  NodeTransform[],\r\n  Record<string, DirectiveTransform>,\r\n]\r\n\r\nexport function getBaseTransformPreset(\r\n  prefixIdentifiers?: boolean,\r\n): TransformPreset {\r\n  return [\r\n    [\r\n      transformOnce,\r\n      transformIf,\r\n      transformMemo,\r\n      transformFor,\r\n      ...(__COMPAT__ ? [transformFilter] : []),\r\n      ...(!__BROWSER__ && prefixIdentifiers\r\n        ? [\r\n            // order is important\r\n            trackVForSlotScopes,\r\n            transformExpression,\r\n          ]\r\n        : __BROWSER__ && __DEV__\r\n          ? [transformExpression]\r\n          : []),\r\n      transformSlotOutlet,\r\n      transformElement,\r\n      trackSlotScopes,\r\n      transformText,\r\n    ],\r\n    {\r\n      on: transformOn,\r\n      bind: transformBind,\r\n      model: transformModel,\r\n    },\r\n  ]\r\n}\r\n\r\n// we name it `baseCompile` so that higher order compilers like\r\n// @vue/compiler-dom can export `compile` while re-exporting everything else.\r\nexport function baseCompile(\r\n  source: string | RootNode,\r\n  options: CompilerOptions = {},\r\n): CodegenResult {\r\n  const onError = options.onError || defaultOnError\r\n  const isModuleMode = options.mode === 'module'\r\n  /* istanbul ignore if */\r\n  if (__BROWSER__) {\r\n    if (options.prefixIdentifiers === true) {\r\n      onError(createCompilerError(ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED))\r\n    } else if (isModuleMode) {\r\n      onError(createCompilerError(ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED))\r\n    }\r\n  }\r\n\r\n  const prefixIdentifiers =\r\n    !__BROWSER__ && (options.prefixIdentifiers === true || isModuleMode)\r\n  if (!prefixIdentifiers && options.cacheHandlers) {\r\n    onError(createCompilerError(ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED))\r\n  }\r\n  if (options.scopeId && !isModuleMode) {\r\n    onError(createCompilerError(ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED))\r\n  }\r\n\r\n  const resolvedOptions = extend({}, options, {\r\n    prefixIdentifiers,\r\n  })\r\n  // 解析html判断（词法语法分析），最后会生成一个树形结构\r\n  const ast = isString(source) ? baseParse(source, resolvedOptions) : source\r\n  const [nodeTransforms, directiveTransforms] =\r\n    getBaseTransformPreset(prefixIdentifiers)\r\n\r\n  if (!__BROWSER__ && options.isTS) {\r\n    const { expressionPlugins } = options\r\n    if (!expressionPlugins || !expressionPlugins.includes('typescript')) {\r\n      options.expressionPlugins = [...(expressionPlugins || []), 'typescript']\r\n    }\r\n  }\r\n\r\n  transform(\r\n    ast,\r\n    extend({}, resolvedOptions, {\r\n      nodeTransforms: [\r\n        ...nodeTransforms,\r\n        ...(options.nodeTransforms || []), // user transforms\r\n      ],\r\n      directiveTransforms: extend(\r\n        {},\r\n        directiveTransforms,\r\n        options.directiveTransforms || {}, // user transforms\r\n      ),\r\n    }),\r\n  )\r\n\r\n  return generate(ast, resolvedOptions)\r\n}\r\n","import type {\r\n  ElementNode,\r\n  Namespace,\r\n  Namespaces,\r\n  ParentNode,\r\n  TemplateChildNode,\r\n} from './ast'\r\nimport type { CompilerError } from './errors'\r\nimport type {\r\n  DirectiveTransform,\r\n  NodeTransform,\r\n  TransformContext,\r\n} from './transform'\r\nimport type { CompilerCompatOptions } from './compat/compatConfig'\r\nimport type { ParserPlugin } from '@babel/parser'\r\n\r\nexport interface ErrorHandlingOptions {\r\n  onWarn?: (warning: CompilerError) => void\r\n  onError?: (error: CompilerError) => void\r\n}\r\n\r\nexport interface ParserOptions\r\n  extends ErrorHandlingOptions,\r\n    CompilerCompatOptions {\r\n  /**\r\n   * Base mode is platform agnostic and only parses HTML-like template syntax,\r\n   * treating all tags the same way. Specific tag parsing behavior can be\r\n   * configured by higher-level compilers.\r\n   *\r\n   * HTML mode adds additional logic for handling special parsing behavior in\r\n   * `<script>`, `<style>`,`<title>` and `<textarea>`.\r\n   * The logic is handled inside compiler-core for efficiency.\r\n   *\r\n   * SFC mode treats content of all root-level tags except `<template>` as plain\r\n   * text.\r\n   */\r\n  parseMode?: 'base' | 'html' | 'sfc'\r\n  /**\r\n   * Specify the root namespace to use when parsing a template.\r\n   * Defaults to `Namespaces.HTML` (0).\r\n   */\r\n  ns?: Namespaces\r\n  /**\r\n   * e.g. platform native elements, e.g. `<div>` for browsers\r\n   */\r\n  isNativeTag?: (tag: string) => boolean\r\n  /**\r\n   * e.g. native elements that can self-close, e.g. `<img>`, `<br>`, `<hr>`\r\n   */\r\n  isVoidTag?: (tag: string) => boolean\r\n  /**\r\n   * e.g. elements that should preserve whitespace inside, e.g. `<pre>`\r\n   */\r\n  isPreTag?: (tag: string) => boolean\r\n  /**\r\n   * Platform-specific built-in components e.g. `<Transition>`\r\n   */\r\n  isBuiltInComponent?: (tag: string) => symbol | void\r\n  /**\r\n   * Separate option for end users to extend the native elements list\r\n   */\r\n  isCustomElement?: (tag: string) => boolean | void\r\n  /**\r\n   * Get tag namespace\r\n   */\r\n  getNamespace?: (\r\n    tag: string,\r\n    parent: ElementNode | undefined,\r\n    rootNamespace: Namespace,\r\n  ) => Namespace\r\n  /**\r\n   * @default ['{{', '}}']\r\n   */\r\n  delimiters?: [string, string]\r\n  /**\r\n   * Whitespace handling strategy\r\n   */\r\n  whitespace?: 'preserve' | 'condense'\r\n  /**\r\n   * Only used for DOM compilers that runs in the browser.\r\n   * In non-browser builds, this option is ignored.\r\n   */\r\n  decodeEntities?: (rawText: string, asAttr: boolean) => string\r\n  /**\r\n   * Whether to keep comments in the templates AST.\r\n   * This defaults to `true` in development and `false` in production builds.\r\n   */\r\n  comments?: boolean\r\n  /**\r\n   * Parse JavaScript expressions with Babel.\r\n   * @default false\r\n   */\r\n  prefixIdentifiers?: boolean\r\n  /**\r\n   * A list of parser plugins to enable for `@babel/parser`, which is used to\r\n   * parse expressions in bindings and interpolations.\r\n   * https://babeljs.io/docs/en/next/babel-parser#plugins\r\n   */\r\n  expressionPlugins?: ParserPlugin[]\r\n}\r\n\r\nexport type HoistTransform = (\r\n  children: TemplateChildNode[],\r\n  context: TransformContext,\r\n  parent: ParentNode,\r\n) => void\r\n\r\nexport enum BindingTypes {\r\n  /**\r\n   * returned from data()\r\n   */\r\n  DATA = 'data',\r\n  /**\r\n   * declared as a prop\r\n   */\r\n  PROPS = 'props',\r\n  /**\r\n   * a local alias of a `<script setup>` destructured prop.\r\n   * the original is stored in __propsAliases of the bindingMetadata object.\r\n   */\r\n  PROPS_ALIASED = 'props-aliased',\r\n  /**\r\n   * a let binding (may or may not be a ref)\r\n   */\r\n  SETUP_LET = 'setup-let',\r\n  /**\r\n   * a const binding that can never be a ref.\r\n   * these bindings don't need `unref()` calls when processed in inlined\r\n   * template expressions.\r\n   */\r\n  SETUP_CONST = 'setup-const',\r\n  /**\r\n   * a const binding that does not need `unref()`, but may be mutated.\r\n   */\r\n  SETUP_REACTIVE_CONST = 'setup-reactive-const',\r\n  /**\r\n   * a const binding that may be a ref.\r\n   */\r\n  SETUP_MAYBE_REF = 'setup-maybe-ref',\r\n  /**\r\n   * bindings that are guaranteed to be refs\r\n   */\r\n  SETUP_REF = 'setup-ref',\r\n  /**\r\n   * declared by other options, e.g. computed, inject\r\n   */\r\n  OPTIONS = 'options',\r\n  /**\r\n   * a literal constant, e.g. 'foo', 1, true\r\n   */\r\n  LITERAL_CONST = 'literal-const',\r\n}\r\n\r\nexport type BindingMetadata = {\r\n  [key: string]: BindingTypes | undefined\r\n} & {\r\n  __isScriptSetup?: boolean\r\n  __propsAliases?: Record<string, string>\r\n}\r\n\r\ninterface SharedTransformCodegenOptions {\r\n  /**\r\n   * Transform expressions like {{ foo }} to `_ctx.foo`.\r\n   * If this option is false, the generated code will be wrapped in a\r\n   * `with (this) { ... }` block.\r\n   * - This is force-enabled in module mode, since modules are by default strict\r\n   * and cannot use `with`\r\n   * @default mode === 'module'\r\n   */\r\n  prefixIdentifiers?: boolean\r\n  /**\r\n   * Control whether generate SSR-optimized render functions instead.\r\n   * The resulting function must be attached to the component via the\r\n   * `ssrRender` option instead of `render`.\r\n   *\r\n   * When compiler generates code for SSR's fallback branch, we need to set it to false:\r\n   *  - context.ssr = false\r\n   *\r\n   * see `subTransform` in `ssrTransformComponent.ts`\r\n   */\r\n  ssr?: boolean\r\n  /**\r\n   * Indicates whether the compiler generates code for SSR,\r\n   * it is always true when generating code for SSR,\r\n   * regardless of whether we are generating code for SSR's fallback branch,\r\n   * this means that when the compiler generates code for SSR's fallback branch:\r\n   *  - context.ssr = false\r\n   *  - context.inSSR = true\r\n   */\r\n  inSSR?: boolean\r\n  /**\r\n   * Optional binding metadata analyzed from script - used to optimize\r\n   * binding access when `prefixIdentifiers` is enabled.\r\n   */\r\n  bindingMetadata?: BindingMetadata\r\n  /**\r\n   * Compile the function for inlining inside setup().\r\n   * This allows the function to directly access setup() local bindings.\r\n   */\r\n  inline?: boolean\r\n  /**\r\n   * Indicates that transforms and codegen should try to output valid TS code\r\n   */\r\n  isTS?: boolean\r\n  /**\r\n   * Filename for source map generation.\r\n   * Also used for self-recursive reference in templates\r\n   * @default 'template.vue.html'\r\n   */\r\n  filename?: string\r\n}\r\n\r\nexport interface TransformOptions\r\n  extends SharedTransformCodegenOptions,\r\n    ErrorHandlingOptions,\r\n    CompilerCompatOptions {\r\n  /**\r\n   * An array of node transforms to be applied to every AST node.\r\n   */\r\n  nodeTransforms?: NodeTransform[]\r\n  /**\r\n   * An object of { name: transform } to be applied to every directive attribute\r\n   * node found on element nodes.\r\n   */\r\n  directiveTransforms?: Record<string, DirectiveTransform | undefined>\r\n  /**\r\n   * An optional hook to transform a node being hoisted.\r\n   * used by compiler-dom to turn hoisted nodes into stringified HTML vnodes.\r\n   * @default null\r\n   */\r\n  transformHoist?: HoistTransform | null\r\n  /**\r\n   * If the pairing runtime provides additional built-in elements, use this to\r\n   * mark them as built-in so the compiler will generate component vnodes\r\n   * for them.\r\n   */\r\n  isBuiltInComponent?: (tag: string) => symbol | void\r\n  /**\r\n   * Used by some transforms that expects only native elements\r\n   */\r\n  isCustomElement?: (tag: string) => boolean | void\r\n  /**\r\n   * Transform expressions like {{ foo }} to `_ctx.foo`.\r\n   * If this option is false, the generated code will be wrapped in a\r\n   * `with (this) { ... }` block.\r\n   * - This is force-enabled in module mode, since modules are by default strict\r\n   * and cannot use `with`\r\n   * @default mode === 'module'\r\n   */\r\n  prefixIdentifiers?: boolean\r\n  /**\r\n   * Hoist static VNodes and props objects to `_hoisted_x` constants\r\n   * @default false\r\n   */\r\n  hoistStatic?: boolean\r\n  /**\r\n   * Cache v-on handlers to avoid creating new inline functions on each render,\r\n   * also avoids the need for dynamically patching the handlers by wrapping it.\r\n   * e.g `@click=\"foo\"` by default is compiled to `{ onClick: foo }`. With this\r\n   * option it's compiled to:\r\n   * ```js\r\n   * { onClick: _cache[0] || (_cache[0] = e => _ctx.foo(e)) }\r\n   * ```\r\n   * - Requires \"prefixIdentifiers\" to be enabled because it relies on scope\r\n   * analysis to determine if a handler is safe to cache.\r\n   * @default false\r\n   */\r\n  cacheHandlers?: boolean\r\n  /**\r\n   * A list of parser plugins to enable for `@babel/parser`, which is used to\r\n   * parse expressions in bindings and interpolations.\r\n   * https://babeljs.io/docs/en/next/babel-parser#plugins\r\n   */\r\n  expressionPlugins?: ParserPlugin[]\r\n  /**\r\n   * SFC scoped styles ID\r\n   */\r\n  scopeId?: string | null\r\n  /**\r\n   * Indicates this SFC template has used :slotted in its styles\r\n   * Defaults to `true` for backwards compatibility - SFC tooling should set it\r\n   * to `false` if no `:slotted` usage is detected in `<style>`\r\n   */\r\n  slotted?: boolean\r\n  /**\r\n   * SFC `<style vars>` injection string\r\n   * Should already be an object expression, e.g. `{ 'xxxx-color': color }`\r\n   * needed to render inline CSS variables on component root\r\n   */\r\n  ssrCssVars?: string\r\n  /**\r\n   * Whether to compile the template assuming it needs to handle HMR.\r\n   * Some edge cases may need to generate different code for HMR to work\r\n   * correctly, e.g. #6938, #7138\r\n   */\r\n  hmr?: boolean\r\n}\r\n\r\nexport interface CodegenOptions extends SharedTransformCodegenOptions {\r\n  /**\r\n   * - `module` mode will generate ES module import statements for helpers\r\n   * and export the render function as the default export.\r\n   * - `function` mode will generate a single `const { helpers... } = Vue`\r\n   * statement and return the render function. It expects `Vue` to be globally\r\n   * available (or passed by wrapping the code with an IIFE). It is meant to be\r\n   * used with `new Function(code)()` to generate a render function at runtime.\r\n   * @default 'function'\r\n   */\r\n  mode?: 'module' | 'function'\r\n  /**\r\n   * Generate source map?\r\n   * @default false\r\n   */\r\n  sourceMap?: boolean\r\n  /**\r\n   * SFC scoped styles ID\r\n   */\r\n  scopeId?: string | null\r\n  /**\r\n   * Option to optimize helper import bindings via variable assignment\r\n   * (only used for webpack code-split)\r\n   * @default false\r\n   */\r\n  optimizeImports?: boolean\r\n  /**\r\n   * Customize where to import runtime helpers from.\r\n   * @default 'vue'\r\n   */\r\n  runtimeModuleName?: string\r\n  /**\r\n   * Customize where to import ssr runtime helpers from/**\r\n   * @default 'vue/server-renderer'\r\n   */\r\n  ssrRuntimeModuleName?: string\r\n  /**\r\n   * Customize the global variable name of `Vue` to get helpers from\r\n   * in function mode\r\n   * @default 'Vue'\r\n   */\r\n  runtimeGlobalName?: string\r\n}\r\n\r\nexport type CompilerOptions = ParserOptions & TransformOptions & CodegenOptions\r\n","import type { DirectiveTransform } from '../transform'\r\n\r\nexport const noopDirectiveTransform: DirectiveTransform = () => ({ props: [] })\r\n","import { registerRuntimeHelpers } from '@vue/compiler-core'\r\n\r\nexport const V_MODEL_RADIO = Symbol(__DEV__ ? `vModelRadio` : ``)\r\nexport const V_MODEL_CHECKBOX = Symbol(__DEV__ ? `vModelCheckbox` : ``)\r\nexport const V_MODEL_TEXT = Symbol(__DEV__ ? `vModelText` : ``)\r\nexport const V_MODEL_SELECT = Symbol(__DEV__ ? `vModelSelect` : ``)\r\nexport const V_MODEL_DYNAMIC = Symbol(__DEV__ ? `vModelDynamic` : ``)\r\n\r\nexport const V_ON_WITH_MODIFIERS = Symbol(__DEV__ ? `vOnModifiersGuard` : ``)\r\nexport const V_ON_WITH_KEYS = Symbol(__DEV__ ? `vOnKeysGuard` : ``)\r\n\r\nexport const V_SHOW = Symbol(__DEV__ ? `vShow` : ``)\r\n\r\nexport const TRANSITION = Symbol(__DEV__ ? `Transition` : ``)\r\nexport const TRANSITION_GROUP = Symbol(__DEV__ ? `TransitionGroup` : ``)\r\n\r\nregisterRuntimeHelpers({\r\n  [V_MODEL_RADIO]: `vModelRadio`,\r\n  [V_MODEL_CHECKBOX]: `vModelCheckbox`,\r\n  [V_MODEL_TEXT]: `vModelText`,\r\n  [V_MODEL_SELECT]: `vModelSelect`,\r\n  [V_MODEL_DYNAMIC]: `vModelDynamic`,\r\n  [V_ON_WITH_MODIFIERS]: `withModifiers`,\r\n  [V_ON_WITH_KEYS]: `withKeys`,\r\n  [V_SHOW]: `vShow`,\r\n  [TRANSITION]: `Transition`,\r\n  [TRANSITION_GROUP]: `TransitionGroup`,\r\n})\r\n","/* eslint-disable no-restricted-globals */\r\n\r\nlet decoder: HTMLDivElement\r\n\r\nexport function decodeHtmlBrowser(raw: string, asAttr = false): string {\r\n  if (!decoder) {\r\n    decoder = document.createElement('div')\r\n  }\r\n  if (asAttr) {\r\n    decoder.innerHTML = `<div foo=\"${raw.replace(/\"/g, '&quot;')}\">`\r\n    return decoder.children[0].getAttribute('foo')!\r\n  } else {\r\n    decoder.innerHTML = raw\r\n    return decoder.textContent!\r\n  }\r\n}\r\n","import { Namespaces, NodeTypes, type ParserOptions } from '@vue/compiler-core'\r\nimport { isHTMLTag, isMathMLTag, isSVGTag, isVoidTag } from '@vue/shared'\r\nimport { TRANSITION, TRANSITION_GROUP } from './runtimeHelpers'\r\nimport { decodeHtmlBrowser } from './decodeHtmlBrowser'\r\n\r\nexport const parserOptions: ParserOptions = {\r\n  parseMode: 'html',\r\n  isVoidTag,\r\n  isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),\r\n  isPreTag: tag => tag === 'pre',\r\n  decodeEntities: __BROWSER__ ? decodeHtmlBrowser : undefined,\r\n\r\n  isBuiltInComponent: tag => {\r\n    if (tag === 'Transition' || tag === 'transition') {\r\n      return TRANSITION\r\n    } else if (tag === 'TransitionGroup' || tag === 'transition-group') {\r\n      return TRANSITION_GROUP\r\n    }\r\n  },\r\n\r\n  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\r\n  getNamespace(tag, parent, rootNamespace) {\r\n    let ns = parent ? parent.ns : rootNamespace\r\n    if (parent && ns === Namespaces.MATH_ML) {\r\n      if (parent.tag === 'annotation-xml') {\r\n        if (tag === 'svg') {\r\n          return Namespaces.SVG\r\n        }\r\n        if (\r\n          parent.props.some(\r\n            a =>\r\n              a.type === NodeTypes.ATTRIBUTE &&\r\n              a.name === 'encoding' &&\r\n              a.value != null &&\r\n              (a.value.content === 'text/html' ||\r\n                a.value.content === 'application/xhtml+xml'),\r\n          )\r\n        ) {\r\n          ns = Namespaces.HTML\r\n        }\r\n      } else if (\r\n        /^m(?:[ions]|text)$/.test(parent.tag) &&\r\n        tag !== 'mglyph' &&\r\n        tag !== 'malignmark'\r\n      ) {\r\n        ns = Namespaces.HTML\r\n      }\r\n    } else if (parent && ns === Namespaces.SVG) {\r\n      if (\r\n        parent.tag === 'foreignObject' ||\r\n        parent.tag === 'desc' ||\r\n        parent.tag === 'title'\r\n      ) {\r\n        ns = Namespaces.HTML\r\n      }\r\n    }\r\n\r\n    if (ns === Namespaces.HTML) {\r\n      if (tag === 'svg') {\r\n        return Namespaces.SVG\r\n      }\r\n      if (tag === 'math') {\r\n        return Namespaces.MATH_ML\r\n      }\r\n    }\r\n    return ns\r\n  },\r\n}\r\n","import {\r\n  ConstantTypes,\r\n  type NodeTransform,\r\n  NodeTypes,\r\n  type SimpleExpressionNode,\r\n  type SourceLocation,\r\n  createSimpleExpression,\r\n} from '@vue/compiler-core'\r\nimport { parseStringStyle } from '@vue/shared'\r\n\r\n// Parse inline CSS strings for static style attributes into an object.\r\n// This is a NodeTransform since it works on the static `style` attribute and\r\n// converts it into a dynamic equivalent:\r\n// style=\"color: red\" -> :style='{ \"color\": \"red\" }'\r\n// It is then processed by `transformElement` and included in the generated\r\n// props.\r\nexport const transformStyle: NodeTransform = node => {\r\n  if (node.type === NodeTypes.ELEMENT) {\r\n    node.props.forEach((p, i) => {\r\n      if (p.type === NodeTypes.ATTRIBUTE && p.name === 'style' && p.value) {\r\n        // replace p with an expression node\r\n        node.props[i] = {\r\n          type: NodeTypes.DIRECTIVE,\r\n          name: `bind`,\r\n          arg: createSimpleExpression(`style`, true, p.loc),\r\n          exp: parseInlineCSS(p.value.content, p.loc),\r\n          modifiers: [],\r\n          loc: p.loc,\r\n        }\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nconst parseInlineCSS = (\r\n  cssText: string,\r\n  loc: SourceLocation,\r\n): SimpleExpressionNode => {\r\n  const normalized = parseStringStyle(cssText)\r\n  return createSimpleExpression(\r\n    JSON.stringify(normalized),\r\n    false,\r\n    loc,\r\n    ConstantTypes.CAN_STRINGIFY,\r\n  )\r\n}\r\n","import {\r\n  type CompilerError,\r\n  ErrorCodes,\r\n  type SourceLocation,\r\n  createCompilerError,\r\n} from '@vue/compiler-core'\r\n\r\nexport interface DOMCompilerError extends CompilerError {\r\n  code: DOMErrorCodes\r\n}\r\n\r\nexport function createDOMCompilerError(\r\n  code: DOMErrorCodes,\r\n  loc?: SourceLocation,\r\n) {\r\n  return createCompilerError(\r\n    code,\r\n    loc,\r\n    __DEV__ || !__BROWSER__ ? DOMErrorMessages : undefined,\r\n  ) as DOMCompilerError\r\n}\r\n\r\nexport enum DOMErrorCodes {\r\n  X_V_HTML_NO_EXPRESSION = 53 /* ErrorCodes.__EXTEND_POINT__ */,\r\n  X_V_HTML_WITH_CHILDREN,\r\n  X_V_TEXT_NO_EXPRESSION,\r\n  X_V_TEXT_WITH_CHILDREN,\r\n  X_V_MODEL_ON_INVALID_ELEMENT,\r\n  X_V_MODEL_ARG_ON_ELEMENT,\r\n  X_V_MODEL_ON_FILE_INPUT_ELEMENT,\r\n  X_V_MODEL_UNNECESSARY_VALUE,\r\n  X_V_SHOW_NO_EXPRESSION,\r\n  X_TRANSITION_INVALID_CHILDREN,\r\n  X_IGNORED_SIDE_EFFECT_TAG,\r\n  __EXTEND_POINT__,\r\n}\r\n\r\nif (__TEST__) {\r\n  // esbuild cannot infer enum increments if first value is from another\r\n  // file, so we have to manually keep them in sync. this check ensures it\r\n  // errors out if there are collisions.\r\n  if (DOMErrorCodes.X_V_HTML_NO_EXPRESSION < ErrorCodes.__EXTEND_POINT__) {\r\n    throw new Error(\r\n      `DOMErrorCodes need to be updated to ${\r\n        ErrorCodes.__EXTEND_POINT__ + 1\r\n      } to match extension point from core ErrorCodes.`,\r\n    )\r\n  }\r\n}\r\n\r\nexport const DOMErrorMessages: { [code: number]: string } = {\r\n  [DOMErrorCodes.X_V_HTML_NO_EXPRESSION]: `v-html is missing expression.`,\r\n  [DOMErrorCodes.X_V_HTML_WITH_CHILDREN]: `v-html will override element children.`,\r\n  [DOMErrorCodes.X_V_TEXT_NO_EXPRESSION]: `v-text is missing expression.`,\r\n  [DOMErrorCodes.X_V_TEXT_WITH_CHILDREN]: `v-text will override element children.`,\r\n  [DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT]: `v-model can only be used on <input>, <textarea> and <select> elements.`,\r\n  [DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT]: `v-model argument is not supported on plain elements.`,\r\n  [DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,\r\n  [DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,\r\n  [DOMErrorCodes.X_V_SHOW_NO_EXPRESSION]: `v-show is missing expression.`,\r\n  [DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN]: `<Transition> expects exactly one child element or component.`,\r\n  [DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`,\r\n}\r\n","import {\r\n  CompilerDeprecationTypes,\r\n  type DirectiveTransform,\r\n  type ExpressionNode,\r\n  NodeTypes,\r\n  type SimpleExpressionNode,\r\n  type SourceLocation,\r\n  type TransformContext,\r\n  transformOn as baseTransform,\r\n  checkCompatEnabled,\r\n  createCallExpression,\r\n  createCompoundExpression,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  isStaticExp,\r\n} from '@vue/compiler-core'\r\nimport { V_ON_WITH_KEYS, V_ON_WITH_MODIFIERS } from '../runtimeHelpers'\r\nimport { capitalize, makeMap } from '@vue/shared'\r\n\r\nconst isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`)\r\nconst isNonKeyModifier = /*#__PURE__*/ makeMap(\r\n  // event propagation management\r\n  `stop,prevent,self,` +\r\n    // system modifiers + exact\r\n    `ctrl,shift,alt,meta,exact,` +\r\n    // mouse\r\n    `middle`,\r\n)\r\n// left & right could be mouse or key modifiers based on event type\r\nconst maybeKeyModifier = /*#__PURE__*/ makeMap('left,right')\r\nconst isKeyboardEvent = /*#__PURE__*/ makeMap(\r\n  `onkeyup,onkeydown,onkeypress`,\r\n  true,\r\n)\r\n\r\nconst resolveModifiers = (\r\n  key: ExpressionNode,\r\n  modifiers: string[],\r\n  context: TransformContext,\r\n  loc: SourceLocation,\r\n) => {\r\n  const keyModifiers = []\r\n  const nonKeyModifiers = []\r\n  const eventOptionModifiers = []\r\n\r\n  for (let i = 0; i < modifiers.length; i++) {\r\n    const modifier = modifiers[i]\r\n\r\n    if (\r\n      __COMPAT__ &&\r\n      modifier === 'native' &&\r\n      checkCompatEnabled(\r\n        CompilerDeprecationTypes.COMPILER_V_ON_NATIVE,\r\n        context,\r\n        loc,\r\n      )\r\n    ) {\r\n      eventOptionModifiers.push(modifier)\r\n    } else if (isEventOptionModifier(modifier)) {\r\n      // eventOptionModifiers: modifiers for addEventListener() options,\r\n      // e.g. .passive & .capture\r\n      eventOptionModifiers.push(modifier)\r\n    } else {\r\n      // runtimeModifiers: modifiers that needs runtime guards\r\n      if (maybeKeyModifier(modifier)) {\r\n        if (isStaticExp(key)) {\r\n          if (isKeyboardEvent((key as SimpleExpressionNode).content)) {\r\n            keyModifiers.push(modifier)\r\n          } else {\r\n            nonKeyModifiers.push(modifier)\r\n          }\r\n        } else {\r\n          keyModifiers.push(modifier)\r\n          nonKeyModifiers.push(modifier)\r\n        }\r\n      } else {\r\n        if (isNonKeyModifier(modifier)) {\r\n          nonKeyModifiers.push(modifier)\r\n        } else {\r\n          keyModifiers.push(modifier)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    keyModifiers,\r\n    nonKeyModifiers,\r\n    eventOptionModifiers,\r\n  }\r\n}\r\n\r\nconst transformClick = (key: ExpressionNode, event: string) => {\r\n  const isStaticClick =\r\n    isStaticExp(key) && key.content.toLowerCase() === 'onclick'\r\n  return isStaticClick\r\n    ? createSimpleExpression(event, true)\r\n    : key.type !== NodeTypes.SIMPLE_EXPRESSION\r\n      ? createCompoundExpression([\r\n          `(`,\r\n          key,\r\n          `) === \"onClick\" ? \"${event}\" : (`,\r\n          key,\r\n          `)`,\r\n        ])\r\n      : key\r\n}\r\n\r\nexport const transformOn: DirectiveTransform = (dir, node, context) => {\r\n  return baseTransform(dir, node, context, baseResult => {\r\n    const { modifiers } = dir\r\n    if (!modifiers.length) return baseResult\r\n\r\n    let { key, value: handlerExp } = baseResult.props[0]\r\n    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } =\r\n      resolveModifiers(key, modifiers, context, dir.loc)\r\n\r\n    // normalize click.right and click.middle since they don't actually fire\r\n    if (nonKeyModifiers.includes('right')) {\r\n      key = transformClick(key, `onContextmenu`)\r\n    }\r\n    if (nonKeyModifiers.includes('middle')) {\r\n      key = transformClick(key, `onMouseup`)\r\n    }\r\n\r\n    if (nonKeyModifiers.length) {\r\n      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [\r\n        handlerExp,\r\n        JSON.stringify(nonKeyModifiers),\r\n      ])\r\n    }\r\n\r\n    if (\r\n      keyModifiers.length &&\r\n      // if event name is dynamic, always wrap with keys guard\r\n      (!isStaticExp(key) || isKeyboardEvent(key.content))\r\n    ) {\r\n      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [\r\n        handlerExp,\r\n        JSON.stringify(keyModifiers),\r\n      ])\r\n    }\r\n\r\n    if (eventOptionModifiers.length) {\r\n      const modifierPostfix = eventOptionModifiers.map(capitalize).join('')\r\n      key = isStaticExp(key)\r\n        ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)\r\n        : createCompoundExpression([`(`, key, `) + \"${modifierPostfix}\"`])\r\n    }\r\n\r\n    return {\r\n      props: [createObjectProperty(key, handlerExp)],\r\n    }\r\n  })\r\n}\r\n","import { ElementTypes, type NodeTransform, NodeTypes } from '@vue/compiler-core'\r\nimport { DOMErrorCodes, createDOMCompilerError } from '../errors'\r\n\r\nexport const ignoreSideEffectTags: NodeTransform = (node, context) => {\r\n  if (\r\n    node.type === NodeTypes.ELEMENT &&\r\n    node.tagType === ElementTypes.ELEMENT &&\r\n    (node.tag === 'script' || node.tag === 'style')\r\n  ) {\r\n    __DEV__ &&\r\n      context.onError(\r\n        createDOMCompilerError(\r\n          DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG,\r\n          node.loc,\r\n        ),\r\n      )\r\n    context.removeNode()\r\n  }\r\n}\r\n","import {\r\n  type CodegenResult,\r\n  type CompilerOptions,\r\n  type DirectiveTransform,\r\n  type NodeTransform,\r\n  type ParserOptions,\r\n  type RootNode,\r\n  baseCompile,\r\n  baseParse,\r\n  noopDirectiveTransform,\r\n} from '@vue/compiler-core'\r\nimport { parserOptions } from './parserOptions'\r\nimport { transformStyle } from './transforms/transformStyle'\r\nimport { transformVHtml } from './transforms/vHtml'\r\nimport { transformVText } from './transforms/vText'\r\nimport { transformModel } from './transforms/vModel'\r\nimport { transformOn } from './transforms/vOn'\r\nimport { transformShow } from './transforms/vShow'\r\nimport { transformTransition } from './transforms/Transition'\r\nimport { stringifyStatic } from './transforms/stringifyStatic'\r\nimport { ignoreSideEffectTags } from './transforms/ignoreSideEffectTags'\r\nimport { extend } from '@vue/shared'\r\n\r\nexport { parserOptions }\r\n\r\nexport const DOMNodeTransforms: NodeTransform[] = [\r\n  transformStyle,\r\n  ...(__DEV__ ? [transformTransition] : []),\r\n]\r\n\r\nexport const DOMDirectiveTransforms: Record<string, DirectiveTransform> = {\r\n  cloak: noopDirectiveTransform,\r\n  html: transformVHtml,\r\n  text: transformVText,\r\n  model: transformModel, // override compiler-core\r\n  on: transformOn, // override compiler-core\r\n  show: transformShow,\r\n}\r\n\r\nexport function compile(\r\n  src: string | RootNode,\r\n  options: CompilerOptions = {},\r\n): CodegenResult {\r\n  return baseCompile(\r\n    src,\r\n    extend({}, parserOptions, options, {\r\n      nodeTransforms: [\r\n        // ignore <script> and <tag>\r\n        // this is not put inside DOMNodeTransforms because that list is used\r\n        // by compiler-ssr to generate vnode fallback branches\r\n        ignoreSideEffectTags,\r\n        ...DOMNodeTransforms,\r\n        ...(options.nodeTransforms || []),\r\n      ],\r\n      directiveTransforms: extend(\r\n        {},\r\n        DOMDirectiveTransforms,\r\n        options.directiveTransforms || {},\r\n      ),\r\n      transformHoist: __BROWSER__ ? null : stringifyStatic,\r\n    }),\r\n  )\r\n}\r\n\r\nexport function parse(template: string, options: ParserOptions = {}): RootNode {\r\n  return baseParse(template, extend({}, parserOptions, options))\r\n}\r\n\r\nexport * from './runtimeHelpers'\r\nexport { transformStyle } from './transforms/transformStyle'\r\nexport {\r\n  createDOMCompilerError,\r\n  DOMErrorCodes,\r\n  DOMErrorMessages,\r\n} from './errors'\r\nexport * from '@vue/compiler-core'\r\n","import {\r\n  type DirectiveTransform,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n} from '@vue/compiler-core'\r\nimport { DOMErrorCodes, createDOMCompilerError } from '../errors'\r\n\r\nexport const transformVHtml: DirectiveTransform = (dir, node, context) => {\r\n  const { exp, loc } = dir\r\n  if (!exp) {\r\n    context.onError(\r\n      createDOMCompilerError(DOMErrorCodes.X_V_HTML_NO_EXPRESSION, loc),\r\n    )\r\n  }\r\n  if (node.children.length) {\r\n    context.onError(\r\n      createDOMCompilerError(DOMErrorCodes.X_V_HTML_WITH_CHILDREN, loc),\r\n    )\r\n    node.children.length = 0\r\n  }\r\n  return {\r\n    props: [\r\n      createObjectProperty(\r\n        createSimpleExpression(`innerHTML`, true, loc),\r\n        exp || createSimpleExpression('', true),\r\n      ),\r\n    ],\r\n  }\r\n}\r\n","import {\r\n  type DirectiveTransform,\r\n  TO_DISPLAY_STRING,\r\n  createCallExpression,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  getConstantType,\r\n} from '@vue/compiler-core'\r\nimport { DOMErrorCodes, createDOMCompilerError } from '../errors'\r\n\r\nexport const transformVText: DirectiveTransform = (dir, node, context) => {\r\n  const { exp, loc } = dir\r\n  if (!exp) {\r\n    context.onError(\r\n      createDOMCompilerError(DOMErrorCodes.X_V_TEXT_NO_EXPRESSION, loc),\r\n    )\r\n  }\r\n  if (node.children.length) {\r\n    context.onError(\r\n      createDOMCompilerError(DOMErrorCodes.X_V_TEXT_WITH_CHILDREN, loc),\r\n    )\r\n    node.children.length = 0\r\n  }\r\n  return {\r\n    props: [\r\n      createObjectProperty(\r\n        createSimpleExpression(`textContent`, true),\r\n        exp\r\n          ? getConstantType(exp, context) > 0\r\n            ? exp\r\n            : createCallExpression(\r\n                context.helperString(TO_DISPLAY_STRING),\r\n                [exp],\r\n                loc,\r\n              )\r\n          : createSimpleExpression('', true),\r\n      ),\r\n    ],\r\n  }\r\n}\r\n","import {\r\n  type DirectiveTransform,\r\n  ElementTypes,\r\n  NodeTypes,\r\n  transformModel as baseTransform,\r\n  findDir,\r\n  findProp,\r\n  hasDynamicKeyVBind,\r\n  isStaticArgOf,\r\n} from '@vue/compiler-core'\r\nimport { DOMErrorCodes, createDOMCompilerError } from '../errors'\r\nimport {\r\n  V_MODEL_CHECKBOX,\r\n  V_MODEL_DYNAMIC,\r\n  V_MODEL_RADIO,\r\n  V_MODEL_SELECT,\r\n  V_MODEL_TEXT,\r\n} from '../runtimeHelpers'\r\n\r\nexport const transformModel: DirectiveTransform = (dir, node, context) => {\r\n  const baseResult = baseTransform(dir, node, context)\r\n  // base transform has errors OR component v-model (only need props)\r\n  if (!baseResult.props.length || node.tagType === ElementTypes.COMPONENT) {\r\n    return baseResult\r\n  }\r\n\r\n  if (dir.arg) {\r\n    context.onError(\r\n      createDOMCompilerError(\r\n        DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT,\r\n        dir.arg.loc,\r\n      ),\r\n    )\r\n  }\r\n\r\n  function checkDuplicatedValue() {\r\n    const value = findDir(node, 'bind')\r\n    if (value && isStaticArgOf(value.arg, 'value')) {\r\n      context.onError(\r\n        createDOMCompilerError(\r\n          DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE,\r\n          value.loc,\r\n        ),\r\n      )\r\n    }\r\n  }\r\n\r\n  const { tag } = node\r\n  const isCustomElement = context.isCustomElement(tag)\r\n  if (\r\n    tag === 'input' ||\r\n    tag === 'textarea' ||\r\n    tag === 'select' ||\r\n    isCustomElement\r\n  ) {\r\n    let directiveToUse = V_MODEL_TEXT\r\n    let isInvalidType = false\r\n    if (tag === 'input' || isCustomElement) {\r\n      const type = findProp(node, `type`)\r\n      if (type) {\r\n        if (type.type === NodeTypes.DIRECTIVE) {\r\n          // :type=\"foo\"\r\n          directiveToUse = V_MODEL_DYNAMIC\r\n        } else if (type.value) {\r\n          switch (type.value.content) {\r\n            case 'radio':\r\n              directiveToUse = V_MODEL_RADIO\r\n              break\r\n            case 'checkbox':\r\n              directiveToUse = V_MODEL_CHECKBOX\r\n              break\r\n            case 'file':\r\n              isInvalidType = true\r\n              context.onError(\r\n                createDOMCompilerError(\r\n                  DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT,\r\n                  dir.loc,\r\n                ),\r\n              )\r\n              break\r\n            default:\r\n              // text type\r\n              __DEV__ && checkDuplicatedValue()\r\n              break\r\n          }\r\n        }\r\n      } else if (hasDynamicKeyVBind(node)) {\r\n        // element has bindings with dynamic keys, which can possibly contain\r\n        // \"type\".\r\n        directiveToUse = V_MODEL_DYNAMIC\r\n      } else {\r\n        // text type\r\n        __DEV__ && checkDuplicatedValue()\r\n      }\r\n    } else if (tag === 'select') {\r\n      directiveToUse = V_MODEL_SELECT\r\n    } else {\r\n      // textarea\r\n      __DEV__ && checkDuplicatedValue()\r\n    }\r\n    // inject runtime directive\r\n    // by returning the helper symbol via needRuntime\r\n    // the import will replaced a resolveDirective call.\r\n    if (!isInvalidType) {\r\n      baseResult.needRuntime = context.helper(directiveToUse)\r\n    }\r\n  } else {\r\n    context.onError(\r\n      createDOMCompilerError(\r\n        DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT,\r\n        dir.loc,\r\n      ),\r\n    )\r\n  }\r\n\r\n  // native vmodel doesn't need the `modelValue` props since they are also\r\n  // passed to the runtime as `binding.value`. removing it reduces code size.\r\n  baseResult.props = baseResult.props.filter(\r\n    p =>\r\n      !(\r\n        p.key.type === NodeTypes.SIMPLE_EXPRESSION &&\r\n        p.key.content === 'modelValue'\r\n      ),\r\n  )\r\n\r\n  return baseResult\r\n}\r\n","import type { DirectiveTransform } from '@vue/compiler-core'\r\nimport { DOMErrorCodes, createDOMCompilerError } from '../errors'\r\nimport { V_SHOW } from '../runtimeHelpers'\r\n\r\nexport const transformShow: DirectiveTransform = (dir, node, context) => {\r\n  const { exp, loc } = dir\r\n  if (!exp) {\r\n    context.onError(\r\n      createDOMCompilerError(DOMErrorCodes.X_V_SHOW_NO_EXPRESSION, loc),\r\n    )\r\n  }\r\n\r\n  return {\r\n    props: [],\r\n    needRuntime: context.helper(V_SHOW),\r\n  }\r\n}\r\n","const range: number = 2\r\n\r\nexport function generateCodeFrame(\r\n  source: string,\r\n  start = 0,\r\n  end = source.length,\r\n): string {\r\n  // Split the content into individual lines but capture the newline sequence\r\n  // that separated each line. This is important because the actual sequence is\r\n  // needed to properly take into account the full line length for offset\r\n  // comparison\r\n  let lines = source.split(/(\\r?\\n)/)\r\n\r\n  // Separate the lines and newline sequences into separate arrays for easier referencing\r\n  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1)\r\n  lines = lines.filter((_, idx) => idx % 2 === 0)\r\n\r\n  let count = 0\r\n  const res: string[] = []\r\n  for (let i = 0; i < lines.length; i++) {\r\n    count +=\r\n      lines[i].length +\r\n      ((newlineSequences[i] && newlineSequences[i].length) || 0)\r\n    if (count >= start) {\r\n      for (let j = i - range; j <= i + range || end > count; j++) {\r\n        if (j < 0 || j >= lines.length) continue\r\n        const line = j + 1\r\n        res.push(\r\n          `${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${\r\n            lines[j]\r\n          }`,\r\n        )\r\n        const lineLength = lines[j].length\r\n        const newLineSeqLength =\r\n          (newlineSequences[j] && newlineSequences[j].length) || 0\r\n\r\n        if (j === i) {\r\n          // push underline\r\n          const pad = start - (count - (lineLength + newLineSeqLength))\r\n          const length = Math.max(\r\n            1,\r\n            end > count ? lineLength - pad : end - start,\r\n          )\r\n          res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length))\r\n        } else if (j > i) {\r\n          if (end > count) {\r\n            const length = Math.max(Math.min(end - count, lineLength), 1)\r\n            res.push(`   |  ` + '^'.repeat(length))\r\n          }\r\n\r\n          count += lineLength + newLineSeqLength\r\n        }\r\n      }\r\n      break\r\n    }\r\n  }\r\n  return res.join('\\n')\r\n}\r\n"],"names":["makeMap","str","expectsLowerCase","set","Set","split","val","has","toLowerCase","EMPTY_OBJ","NOOP","NO","isOn","key","charCodeAt","extend","Object","assign","isArray","Array","isString","isSymbol","isObject","isReservedProp","isBuiltInDirective","cacheStringFunction","fn","cache","create","camelizeRE","camelize","replace","_","c","toUpperCase","capitalize","charAt","slice","toHandlerKey","listDelimiterRE","propertyDelimiterRE","styleCommentRE","isHTMLTag","isSVGTag","isMathMLTag","isVoidTag","FRAGMENT","Symbol","TELEPORT","SUSPENSE","KEEP_ALIVE","BASE_TRANSITION","OPEN_BLOCK","CREATE_BLOCK","CREATE_ELEMENT_BLOCK","CREATE_VNODE","CREATE_ELEMENT_VNODE","CREATE_COMMENT","CREATE_TEXT","CREATE_STATIC","RESOLVE_COMPONENT","RESOLVE_DYNAMIC_COMPONENT","RESOLVE_DIRECTIVE","RESOLVE_FILTER","WITH_DIRECTIVES","RENDER_LIST","RENDER_SLOT","CREATE_SLOTS","TO_DISPLAY_STRING","MERGE_PROPS","NORMALIZE_CLASS","NORMALIZE_STYLE","NORMALIZE_PROPS","GUARD_REACTIVE_PROPS","TO_HANDLERS","CAMELIZE","CAPITALIZE","TO_HANDLER_KEY","SET_BLOCK_TRACKING","PUSH_SCOPE_ID","POP_SCOPE_ID","WITH_CTX","UNREF","IS_REF","WITH_MEMO","IS_MEMO_SAME","helperNameMap","registerRuntimeHelpers","helpers","getOwnPropertySymbols","forEach","s","locStub","start","line","column","offset","end","source","createRoot","children","type","components","directives","hoists","imports","cached","temps","codegenNode","loc","createVNodeCall","context","tag","props","patchFlag","dynamicProps","isBlock","disableTracking","isComponent","helper","getVNodeBlockHelper","inSSR","getVNodeHelper","createArrayExpression","elements","createObjectExpression","properties","createObjectProperty","value","createSimpleExpression","content","isStatic","constType","createCompoundExpression","createCallExpression","callee","args","arguments","createFunctionExpression","params","returns","newline","isSlot","createConditionalExpression","test","consequent","alternate","createCacheExpression","index","isVNode","createBlockStatement","body","ssr","convertToBlock","node","removeHelper","defaultDelimitersOpen","Uint8Array","defaultDelimitersClose","isTagStartChar","isWhitespace","isEndOfTagSection","toCharCodes","ret","length","i","Sequences","Cdata","CdataEnd","CommentEnd","ScriptEnd","StyleEnd","TitleEnd","TextareaEnd","deprecationData","COMPILER_IS_ON_ELEMENT","message","link","COMPILER_V_BIND_SYNC","COMPILER_V_BIND_OBJECT_ORDER","COMPILER_V_ON_NATIVE","COMPILER_V_IF_V_FOR_PRECEDENCE","COMPILER_NATIVE_TEMPLATE","COMPILER_INLINE_TEMPLATE","COMPILER_FILTERS","getCompatValue","compatConfig","isCompatEnabled","mode","checkCompatEnabled","defaultOnError","error","defaultOnWarn","msg","createCompilerError","code","messages","additionalMessage","SyntaxError","String","errorMessages","extractIdentifiers","param","nodes","push","object","prop","argument","element","left","isStaticProperty","computed","TS_NODE_TYPES","isStaticExp","p","isCoreComponent","nonIdentifierRE","isSimpleIdentifier","name","validFirstIdentCharRE","validIdentCharRE","whitespaceRE","isMemberExpressionBrowser","path","trim","state","stateStack","currentOpenBracketCount","currentOpenParensCount","currentStringType","char","pop","isMemberExpressionNode","isMemberExpression","advancePositionWithMutation","pos","numberOfCharacters","linesCount","lastNewLinePos","findDir","allowEmpty","exp","findProp","dynamicOnly","isStaticArgOf","arg","hasDynamicKeyVBind","some","isText","isVSlot","isTemplateNode","tagType","isSlotOutlet","propsHelperSet","getUnnormalizedProps","callPath","concat","injectProp","propsWithInjection","parentCall","first","unshift","hasProp","result","propKeyName","toValidAssetId","searchValue","replaceValue","toString","getMemoedVNodeCall","forAliasRE","defaultParserOptions","parseMode","ns","delimiters","getNamespace","isPreTag","isCustomElement","onError","onWarn","comments","prefixIdentifiers","currentOptions","currentRoot","currentInput","currentOpenTag","currentProp","currentAttrValue","currentAttrStartIndex","currentAttrEndIndex","inPre","inVPre","currentVPreBoundary","stack","tokenizer","constructor","cbs","this","__publicField","inSFCRoot","reset","buffer","sectionStart","baseState","inRCDATA","currentSequence","newlines","delimiterOpen","delimiterClose","getPos","newlineIndex","peek","stateText","ontext","delimiterIndex","stateInterpolationOpen","stateInRCDATA","stateInterpolation","stateInterpolationClose","oninterpolation","stateSpecialStartSequence","isEnd","sequenceIndex","stateInTagName","endOfText","actualIndex","stateInClosingTagName","fastForwardTo","Number","stateCDATASequence","stateInDeclaration","cc","stateInCommentLike","oncdata","oncomment","startSpecial","sequence","enterRCDATA","stateBeforeTagName","inXML","lower","handleTagName","stateInSFCRootTagName","onopentagname","stateBeforeAttrName","stateBeforeClosingTagName","onclosetag","stateAfterClosingTagName","onopentagend","handleAttrStart","ondirname","stateInSelfClosingTag","onselfclosingtag","stateInAttrName","onattribname","handleAttrNameEnd","stateInDirName","stateInDirArg","ondirarg","stateInDynamicDirArg","stateInDirModifier","ondirmodifier","onattribnameend","stateAfterAttrName","onattribend","stateBeforeAttrValue","stateInAttrValueNoQuotes","handleInAttrValue","quote","onattribdata","stateInAttrValueDoubleQuotes","stateInAttrValueSingleQuotes","onerr","stateBeforeDeclaration","stateInProcessingInstruction","onprocessinginstruction","stateBeforeComment","stateInSpecialComment","stateBeforeSpecialS","stateBeforeSpecialT","startEntity","stateInEntity","parse","input","cleanup","finish","handleTrailingData","onend","endIndex","emitCodePoint","cp","consumed","emitError","onText","getSlice","ontextentity","innerStart","innerEnd","includes","decodeEntities","addNode","createExp","getLoc","endOpenTag","found","j","onCloseTag","shift","backTrack","_a","isSelfClosing","nameLoc","raw","rawName","modifiers","dirToAttr","setLocEnd","mod","onattribentity","condense","expParseMode","forParseResult","inMatch","match","LHS","RHS","createAliasExpression","asParam","indexOf","finalized","valueContent","stripParensRE","trimmedOffset","iteratorMatch","forIteratorRE","keyContent","keyOffset","indexContent","parseForExpression","syncIndex","splice","innerLoc","parent","lastNode","el","isImplied","isFragmentTemplate","isBuiltInComponent","isNativeTag","startsWith","condenseWhitespace","inlineTemplateProp","find","specialTemplateDir","windowsNewlineRE","_b","shouldCondense","whitespace","removedWhitespace","isAllWhitespace","prev","next","hasNewlineChar","filter","Boolean","prevCharIsWhitespace","dir","attr","baseParse","options","root","hoistStatic","walk","isSingleElementRoot","child","doNotHoistNode","originalCount","hoistedCount","constantType","getConstantType","hoist","flag","getPatchFlag","getGeneratedPropsConstantType","getNodeProps","scopes","vSlot","branches","transformHoist","hoisted","hmr","constantCache","get","returnType","generatedPropsType","childType","expType","allowHoistedHelperSet","getConstantTypeOfHelperCall","keyType","valueType","parseInt","createTransformContext","filename","cacheHandlers","nodeTransforms","directiveTransforms","expressionPlugins","scopeId","slotted","ssrCssVars","bindingMetadata","inline","isTS","nameMatch","selfName","Map","WeakMap","identifiers","vFor","vPre","vOnce","currentNode","childIndex","inVOnce","count","currentCount","delete","helperString","replaceNode","removeNode","removalIndex","onNodeRemoved","addIdentifiers","removeIdentifiers","identifier","filters","transform","traverseNode","createRootCodegen","keys","transformed","exitFns","onExit","nodeRemoved","traverseChildren","createStructuralDirectiveTransform","matches","n","PURE_ANNOTATION","aliasHelper","createCodegenContext","ast","sourceMap","optimizeImports","runtimeGlobalName","runtimeModuleName","ssrRuntimeModuleName","indentLevel","pure","map","indent","deindent","withoutNewLine","repeat","generate","onContextCreated","from","hasHelpers","useWithBlock","preambleContext","VueBinding","join","genNode","genHoists","genFunctionPreamble","genAssets","preamble","toJSON","assets","resolver","id","maybeSelfReference","endsWith","JSON","stringify","genNodeListAsArray","multilines","genNodeList","comma","genText","genExpression","genInterpolation","genCompoundExpression","genComment","callHelper","genNullableArgs","genVNodeCall","genCallExpression","genExpressionAsPropertyKey","genObjectExpression","genArrayExpression","isNonScopedSlot","genFunctionExpression","needNewline","needsParens","isNested","genConditionalExpression","genCacheExpression","processExpression","asParams","asRawStatements","localVars","transformIf","processIf","ifNode","branch","isRoot","siblings","sibling","createCodegenNodeForBranch","parentCondition","getParentCondition","processCodegen","createIfBranch","condition","isTemplateIf","userKey","keyIndex","createChildrenCodegenNode","keyProperty","firstChild","vnodeCall","transformFor","processFor","forNode","renderExp","isTemplate","memo","keyProp","keyExp","isStableFragment","fragmentFlag","childBlock","needFragmentWrapper","slotOutlet","loop","createForLoopParams","parseResult","finalizeForParseResult","valueAlias","keyAlias","objectIndexAlias","memoArgs","createParamsList","defaultFallback","trackSlotScopes","buildClientSlotFn","_vForExp","buildSlots","buildSlotFn","slotsProperties","dynamicSlots","hasDynamicSlots","onComponentSlot","hasTemplateSlots","hasNamedDefaultSlot","implicitDefaultChildren","seenSlotNames","conditionalBranchIndex","slotElement","slotDir","slotChildren","slotLoc","slotName","slotProps","dirLoc","staticSlotName","slotFunction","vIf","vElse","buildDynamicSlot","conditional","add","buildDefaultSlotProperty","isNonWhitespaceContent","slotFlag","hasForwardedSlots","slots","directiveImportMap","transformElement","vnodeTag","resolveComponentType","isDynamicComponent","vnodeProps","vnodeChildren","vnodePatchFlag","vnodeDynamicProps","dynamicPropNames","vnodeDirectives","shouldUseBlock","propsBuildResult","buildProps","buildDirectiveArgs","hasDynamicTextChild","propsNamesString","l","stringifyDynamicPropNames","isExplicitDynamic","isComponentTag","isProp","builtIn","elementLoc","mergeArgs","runtimeDirectives","hasChildren","hasRef","hasClassBinding","hasStyleBinding","hasHydrationEventBinding","hasDynamicKeys","hasVnodeHook","pushMergeArg","dedupeProperties","analyzePatchFlag","isEventHandler","isVBind","isVOn","directiveTransform","needRuntime","propsExpression","classKeyIndex","styleKeyIndex","hasDynamicKey","isHandlerKey","classProp","styleProp","knownProps","deduped","existing","mergeAsArray","incoming","dirArgs","runtime","trueExpression","modifier","transformSlotOutlet","processSlotOutlet","slotArgs","expectedLen","nonNameProps","fnExpRE","transformOn","augmentor","eventName","shouldCache","isMemberExp","isInlineStatement","hasMultipleStatements","transformBind","_node","propName","injectPrefix","prefix","transformText","currentContainer","hasText","callArgs","seen","WeakSet","transformOnce","cur","transformModel","createTransformProps","rawExp","expString","bindingType","assignmentExp","m","modifiersKey","validDivisionCharRE","transformFilter","rewriteFilter","parseFilter","expression","inSingle","inDouble","inTemplateString","inRegex","curly","square","paren","lastFilterIndex","pushFilter","wrapFilter","transformMemo","getBaseTransformPreset","on","bind","model","baseCompile","isModuleMode","resolvedOptions","noopDirectiveTransform","V_MODEL_RADIO","V_MODEL_CHECKBOX","V_MODEL_TEXT","V_MODEL_SELECT","V_MODEL_DYNAMIC","V_ON_WITH_MODIFIERS","V_ON_WITH_KEYS","V_SHOW","TRANSITION","TRANSITION_GROUP","decoder","parserOptions","asAttr","document","createElement","innerHTML","getAttribute","textContent","rootNamespace","a","transformStyle","parseInlineCSS","cssText","normalized","item","tmp","parseStringStyle","createDOMCompilerError","DOMErrorMessages","isEventOptionModifier","isNonKeyModifier","maybeKeyModifier","isKeyboardEvent","transformClick","event","ignoreSideEffectTags","DOMNodeTransforms","DOMDirectiveTransforms","cloak","html","text","baseResult","baseTransform","directiveToUse","isInvalidType","handlerExp","keyModifiers","nonKeyModifiers","eventOptionModifiers","resolveModifiers","modifierPostfix","show","DATA","PROPS","PROPS_ALIASED","SETUP_LET","SETUP_CONST","SETUP_REACTIVE_CONST","SETUP_MAYBE_REF","SETUP_REF","OPTIONS","LITERAL_CONST","NOT_CONSTANT","CAN_SKIP_PATCH","CAN_HOIST","CAN_STRINGIFY","X_V_HTML_NO_EXPRESSION","X_V_HTML_WITH_CHILDREN","X_V_TEXT_NO_EXPRESSION","X_V_TEXT_WITH_CHILDREN","X_V_MODEL_ON_INVALID_ELEMENT","X_V_MODEL_ARG_ON_ELEMENT","X_V_MODEL_ON_FILE_INPUT_ELEMENT","X_V_MODEL_UNNECESSARY_VALUE","X_V_SHOW_NO_EXPRESSION","X_TRANSITION_INVALID_CHILDREN","X_IGNORED_SIDE_EFFECT_TAG","__EXTEND_POINT__","ELEMENT","COMPONENT","SLOT","TEMPLATE","ABRUPT_CLOSING_OF_EMPTY_COMMENT","CDATA_IN_HTML_CONTENT","DUPLICATE_ATTRIBUTE","END_TAG_WITH_ATTRIBUTES","END_TAG_WITH_TRAILING_SOLIDUS","EOF_BEFORE_TAG_NAME","EOF_IN_CDATA","EOF_IN_COMMENT","EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT","EOF_IN_TAG","INCORRECTLY_CLOSED_COMMENT","INCORRECTLY_OPENED_COMMENT","INVALID_FIRST_CHARACTER_OF_TAG_NAME","MISSING_ATTRIBUTE_VALUE","MISSING_END_TAG_NAME","MISSING_WHITESPACE_BETWEEN_ATTRIBUTES","NESTED_COMMENT","UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME","UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE","UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME","UNEXPECTED_NULL_CHARACTER","UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME","UNEXPECTED_SOLIDUS_IN_TAG","X_INVALID_END_TAG","X_MISSING_END_TAG","X_MISSING_INTERPOLATION_END","X_MISSING_DIRECTIVE_NAME","X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END","X_V_IF_NO_EXPRESSION","X_V_IF_SAME_KEY","X_V_ELSE_NO_ADJACENT_IF","X_V_FOR_NO_EXPRESSION","X_V_FOR_MALFORMED_EXPRESSION","X_V_FOR_TEMPLATE_KEY_PLACEMENT","X_V_BIND_NO_EXPRESSION","X_V_ON_NO_EXPRESSION","X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET","X_V_SLOT_MIXED_SLOT_USAGE","X_V_SLOT_DUPLICATE_SLOT_NAMES","X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN","X_V_SLOT_MISPLACED","X_V_MODEL_NO_EXPRESSION","X_V_MODEL_MALFORMED_EXPRESSION","X_V_MODEL_ON_SCOPE_VARIABLE","X_V_MODEL_ON_PROPS","X_INVALID_EXPRESSION","X_KEEP_ALIVE_INVALID_CHILDREN","X_PREFIX_ID_NOT_SUPPORTED","X_MODULE_MODE_NOT_SUPPORTED","X_CACHE_HANDLER_NOT_SUPPORTED","X_SCOPE_ID_NOT_SUPPORTED","X_VNODE_HOOKS","HTML","SVG","MATH_ML","ROOT","TEXT","COMMENT","SIMPLE_EXPRESSION","INTERPOLATION","ATTRIBUTE","DIRECTIVE","COMPOUND_EXPRESSION","IF","IF_BRANCH","FOR","TEXT_CALL","VNODE_CALL","JS_CALL_EXPRESSION","JS_OBJECT_EXPRESSION","JS_PROPERTY","JS_ARRAY_EXPRESSION","JS_FUNCTION_EXPRESSION","JS_CONDITIONAL_EXPRESSION","JS_CACHE_EXPRESSION","JS_BLOCK_STATEMENT","JS_TEMPLATE_LITERAL","JS_IF_STATEMENT","JS_ASSIGNMENT_EXPRESSION","JS_SEQUENCE_EXPRESSION","JS_RETURN_STATEMENT","Error","src","right","expressions","lines","newlineSequences","idx","res","Math","max","lineLength","newLineSeqLength","pad","min","hasScopeRef","ids","b","parentStack","template","stringifyExpression","unwrapTSNode","block","onIdent","stmt","declare","decl","declarations","variable","init","onIdentifier","includeAll","knownIds","err"],"mappings":"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"}