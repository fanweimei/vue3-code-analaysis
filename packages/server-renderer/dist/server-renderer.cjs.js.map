{"version":3,"file":"server-renderer.cjs.js","sources":["../src/helpers/ssrRenderAttrs.ts","../src/helpers/ssrRenderComponent.ts","../src/helpers/ssrRenderSlot.ts","../src/helpers/ssrRenderTeleport.ts","../src/helpers/ssrInterpolate.ts","../../reactivity/src/effect.ts","../../reactivity/src/reactive.ts","../../reactivity/src/ref.ts","../../runtime-core/src/warning.ts","../../runtime-core/src/errorHandling.ts","../../runtime-core/src/component.ts","../../runtime-core/src/index.ts","../src/helpers/ssrRenderList.ts","../src/helpers/ssrRenderSuspense.ts","../src/helpers/ssrGetDirectiveProps.ts","../src/helpers/ssrVModelHelpers.ts","../src/helpers/ssrCompile.ts","../src/render.ts","../src/renderToString.ts","../src/renderToStream.ts","../src/index.ts"],"sourcesContent":["import {\r\n  escapeHtml,\r\n  isRenderableAttrValue,\r\n  isSVGTag,\r\n  stringifyStyle,\r\n} from '@vue/shared'\r\nimport {\r\n  includeBooleanAttr,\r\n  isBooleanAttr,\r\n  isOn,\r\n  isSSRSafeAttrName,\r\n  isString,\r\n  makeMap,\r\n  normalizeClass,\r\n  normalizeStyle,\r\n  propsToAttrMap,\r\n} from '@vue/shared'\r\n\r\n// leading comma for empty string \"\"\r\nconst shouldIgnoreProp = makeMap(\r\n  `,key,ref,innerHTML,textContent,ref_key,ref_for`,\r\n)\r\n\r\nexport function ssrRenderAttrs(\r\n  props: Record<string, unknown>,\r\n  tag?: string,\r\n): string {\r\n  let ret = ''\r\n  for (const key in props) {\r\n    if (\r\n      shouldIgnoreProp(key) ||\r\n      isOn(key) ||\r\n      (tag === 'textarea' && key === 'value')\r\n    ) {\r\n      continue\r\n    }\r\n    const value = props[key]\r\n    if (key === 'class') {\r\n      ret += ` class=\"${ssrRenderClass(value)}\"`\r\n    } else if (key === 'style') {\r\n      ret += ` style=\"${ssrRenderStyle(value)}\"`\r\n    } else {\r\n      ret += ssrRenderDynamicAttr(key, value, tag)\r\n    }\r\n  }\r\n  return ret\r\n}\r\n\r\n// render an attr with dynamic (unknown) key.\r\nexport function ssrRenderDynamicAttr(\r\n  key: string,\r\n  value: unknown,\r\n  tag?: string,\r\n): string {\r\n  if (!isRenderableAttrValue(value)) {\r\n    return ``\r\n  }\r\n  const attrKey =\r\n    tag && (tag.indexOf('-') > 0 || isSVGTag(tag))\r\n      ? key // preserve raw name on custom elements and svg\r\n      : propsToAttrMap[key] || key.toLowerCase()\r\n  if (isBooleanAttr(attrKey)) {\r\n    return includeBooleanAttr(value) ? ` ${attrKey}` : ``\r\n  } else if (isSSRSafeAttrName(attrKey)) {\r\n    return value === '' ? ` ${attrKey}` : ` ${attrKey}=\"${escapeHtml(value)}\"`\r\n  } else {\r\n    console.warn(\r\n      `[@vue/server-renderer] Skipped rendering unsafe attribute name: ${attrKey}`,\r\n    )\r\n    return ``\r\n  }\r\n}\r\n\r\n// Render a v-bind attr with static key. The key is pre-processed at compile\r\n// time and we only need to check and escape value.\r\nexport function ssrRenderAttr(key: string, value: unknown): string {\r\n  if (!isRenderableAttrValue(value)) {\r\n    return ``\r\n  }\r\n  return ` ${key}=\"${escapeHtml(value)}\"`\r\n}\r\n\r\nexport function ssrRenderClass(raw: unknown): string {\r\n  return escapeHtml(normalizeClass(raw))\r\n}\r\n\r\nexport function ssrRenderStyle(raw: unknown): string {\r\n  if (!raw) {\r\n    return ''\r\n  }\r\n  if (isString(raw)) {\r\n    return escapeHtml(raw)\r\n  }\r\n  const styles = normalizeStyle(raw)\r\n  return escapeHtml(stringifyStyle(styles))\r\n}\r\n","import {\r\n  type Component,\r\n  type ComponentInternalInstance,\r\n  type Slots,\r\n  createVNode,\r\n} from 'vue'\r\nimport { type Props, type SSRBuffer, renderComponentVNode } from '../render'\r\nimport type { SSRSlots } from './ssrRenderSlot'\r\n\r\nexport function ssrRenderComponent(\r\n  comp: Component,\r\n  props: Props | null = null,\r\n  children: Slots | SSRSlots | null = null,\r\n  parentComponent: ComponentInternalInstance | null = null,\r\n  slotScopeId?: string,\r\n): SSRBuffer | Promise<SSRBuffer> {\r\n  return renderComponentVNode(\r\n    createVNode(comp, props, children),\r\n    parentComponent,\r\n    slotScopeId,\r\n  )\r\n}\r\n","import type { ComponentInternalInstance, Slots } from 'vue'\r\nimport {\r\n  type Props,\r\n  type PushFn,\r\n  type SSRBufferItem,\r\n  renderVNodeChildren,\r\n} from '../render'\r\nimport { isArray } from '@vue/shared'\r\n\r\nexport type SSRSlots = Record<string, SSRSlot>\r\nexport type SSRSlot = (\r\n  props: Props,\r\n  push: PushFn,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  scopeId: string | null,\r\n) => void\r\n\r\nexport function ssrRenderSlot(\r\n  slots: Slots | SSRSlots,\r\n  slotName: string,\r\n  slotProps: Props,\r\n  fallbackRenderFn: (() => void) | null,\r\n  push: PushFn,\r\n  parentComponent: ComponentInternalInstance,\r\n  slotScopeId?: string,\r\n) {\r\n  // template-compiled slots are always rendered as fragments\r\n  push(`<!--[-->`)\r\n  ssrRenderSlotInner(\r\n    slots,\r\n    slotName,\r\n    slotProps,\r\n    fallbackRenderFn,\r\n    push,\r\n    parentComponent,\r\n    slotScopeId,\r\n  )\r\n  push(`<!--]-->`)\r\n}\r\n\r\nexport function ssrRenderSlotInner(\r\n  slots: Slots | SSRSlots,\r\n  slotName: string,\r\n  slotProps: Props,\r\n  fallbackRenderFn: (() => void) | null,\r\n  push: PushFn,\r\n  parentComponent: ComponentInternalInstance,\r\n  slotScopeId?: string,\r\n  transition?: boolean,\r\n) {\r\n  const slotFn = slots[slotName]\r\n  if (slotFn) {\r\n    const slotBuffer: SSRBufferItem[] = []\r\n    const bufferedPush = (item: SSRBufferItem) => {\r\n      slotBuffer.push(item)\r\n    }\r\n    const ret = slotFn(\r\n      slotProps,\r\n      bufferedPush,\r\n      parentComponent,\r\n      slotScopeId ? ' ' + slotScopeId : '',\r\n    )\r\n    if (isArray(ret)) {\r\n      // normal slot\r\n      renderVNodeChildren(push, ret, parentComponent, slotScopeId)\r\n    } else {\r\n      // ssr slot.\r\n      // check if the slot renders all comments, in which case use the fallback\r\n      let isEmptySlot = true\r\n      if (transition) {\r\n        isEmptySlot = false\r\n      } else {\r\n        for (let i = 0; i < slotBuffer.length; i++) {\r\n          if (!isComment(slotBuffer[i])) {\r\n            isEmptySlot = false\r\n            break\r\n          }\r\n        }\r\n      }\r\n      if (isEmptySlot) {\r\n        if (fallbackRenderFn) {\r\n          fallbackRenderFn()\r\n        }\r\n      } else {\r\n        // #9933\r\n        // Although we handle Transition/TransitionGroup in the transform stage\r\n        // without rendering it as a fragment, the content passed into the slot\r\n        // may still be a fragment.\r\n        // Therefore, here we need to avoid rendering it as a fragment again.\r\n        let start = 0\r\n        let end = slotBuffer.length\r\n        if (\r\n          transition &&\r\n          slotBuffer[0] === '<!--[-->' &&\r\n          slotBuffer[end - 1] === '<!--]-->'\r\n        ) {\r\n          start++\r\n          end--\r\n        }\r\n\r\n        for (let i = start; i < end; i++) {\r\n          push(slotBuffer[i])\r\n        }\r\n      }\r\n    }\r\n  } else if (fallbackRenderFn) {\r\n    fallbackRenderFn()\r\n  }\r\n}\r\n\r\nconst commentTestRE = /^<!--.*-->$/s\r\nconst commentRE = /<!--[^]*?-->/gm\r\nfunction isComment(item: SSRBufferItem) {\r\n  if (typeof item !== 'string' || !commentTestRE.test(item)) return false\r\n  // if item is '<!---->' or '<!--[-->' or '<!--]-->', return true directly\r\n  if (item.length <= 8) return true\r\n  return !item.replace(commentRE, '').trim()\r\n}\r\n","import { type ComponentInternalInstance, ssrContextKey } from 'vue'\r\nimport {\r\n  type PushFn,\r\n  type SSRBufferItem,\r\n  type SSRContext,\r\n  createBuffer,\r\n} from '../render'\r\n\r\nexport function ssrRenderTeleport(\r\n  parentPush: PushFn,\r\n  contentRenderFn: (push: PushFn) => void,\r\n  target: string,\r\n  disabled: boolean,\r\n  parentComponent: ComponentInternalInstance,\r\n) {\r\n  parentPush('<!--teleport start-->')\r\n\r\n  const context = parentComponent.appContext.provides[\r\n    ssrContextKey as any\r\n  ] as SSRContext\r\n  const teleportBuffers =\r\n    context.__teleportBuffers || (context.__teleportBuffers = {})\r\n  const targetBuffer = teleportBuffers[target] || (teleportBuffers[target] = [])\r\n  // record current index of the target buffer to handle nested teleports\r\n  // since the parent needs to be rendered before the child\r\n  const bufferIndex = targetBuffer.length\r\n\r\n  let teleportContent: SSRBufferItem\r\n\r\n  if (disabled) {\r\n    contentRenderFn(parentPush)\r\n    teleportContent = `<!--teleport anchor-->`\r\n  } else {\r\n    const { getBuffer, push } = createBuffer()\r\n    contentRenderFn(push)\r\n    push(`<!--teleport anchor-->`)\r\n    teleportContent = getBuffer()\r\n  }\r\n\r\n  targetBuffer.splice(bufferIndex, 0, teleportContent)\r\n  parentPush('<!--teleport end-->')\r\n}\r\n","import { escapeHtml, toDisplayString } from '@vue/shared'\r\n\r\nexport function ssrInterpolate(value: unknown): string {\r\n  return escapeHtml(toDisplayString(value))\r\n}\r\n","import { NOOP, extend } from '@vue/shared'\r\nimport type { ComputedRefImpl } from './computed'\r\nimport {\r\n  DirtyLevels,\r\n  type TrackOpTypes,\r\n  type TriggerOpTypes,\r\n} from './constants'\r\nimport type { Dep } from './dep'\r\nimport { type EffectScope, recordEffectScope } from './effectScope'\r\n\r\nexport type EffectScheduler = (...args: any[]) => any\r\n\r\nexport type DebuggerEvent = {\r\n  effect: ReactiveEffect\r\n} & DebuggerEventExtraInfo\r\n\r\nexport type DebuggerEventExtraInfo = {\r\n  target: object\r\n  type: TrackOpTypes | TriggerOpTypes\r\n  key: any\r\n  newValue?: any\r\n  oldValue?: any\r\n  oldTarget?: Map<any, any> | Set<any>\r\n}\r\n\r\nexport let activeEffect: ReactiveEffect | undefined\r\n\r\n// 副作用函数\r\nexport class ReactiveEffect<T = any> {\r\n  active = true\r\n  /**\r\n   * 多对多的关系，一个副作用函数可以包含多个依赖的响应对象，一个响应对象可以存在多个副作用函数中\r\n   */\r\n  deps: Dep[] = []\r\n\r\n  /**\r\n   * Can be attached after creation\r\n   * @internal\r\n   */\r\n  computed?: ComputedRefImpl<T>\r\n  /**\r\n   * @internal\r\n   */\r\n  allowRecurse?: boolean\r\n\r\n  onStop?: () => void\r\n  // dev only\r\n  onTrack?: (event: DebuggerEvent) => void\r\n  // dev only\r\n  onTrigger?: (event: DebuggerEvent) => void\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  _dirtyLevel = DirtyLevels.Dirty\r\n  /**\r\n   * @internal\r\n   */\r\n  _trackId = 0\r\n  /**\r\n   * @internal\r\n   */\r\n  _runnings = 0\r\n  /**\r\n   * @internal\r\n   */\r\n  _shouldSchedule = false\r\n  /**\r\n   * @internal\r\n   */\r\n  _depsLength = 0\r\n\r\n  constructor(\r\n    public fn: () => T,\r\n    public trigger: () => void,\r\n    public scheduler?: EffectScheduler,\r\n    scope?: EffectScope,\r\n  ) {\r\n    recordEffectScope(this, scope)\r\n  }\r\n\r\n  public get dirty() {\r\n    if (this._dirtyLevel === DirtyLevels.MaybeDirty) {\r\n      pauseTracking()\r\n      for (let i = 0; i < this._depsLength; i++) {\r\n        const dep = this.deps[i]\r\n        if (dep.computed) {\r\n          triggerComputed(dep.computed)\r\n          if (this._dirtyLevel >= DirtyLevels.Dirty) {\r\n            break\r\n          }\r\n        }\r\n      }\r\n      if (this._dirtyLevel < DirtyLevels.Dirty) {\r\n        this._dirtyLevel = DirtyLevels.NotDirty\r\n      }\r\n      resetTracking()\r\n    }\r\n    return this._dirtyLevel >= DirtyLevels.Dirty\r\n  }\r\n\r\n  public set dirty(v) {\r\n    this._dirtyLevel = v ? DirtyLevels.Dirty : DirtyLevels.NotDirty\r\n  }\r\n\r\n  // 1 last null active p1\r\n  // 2 last p1 active p2\r\n  // 3 last p2 active p3\r\n  // p3执行完 active p2\r\n  // p2环境 执行完 active p1\r\n  // p3环境执行完\r\n  /**\r\n   * 总而言之：\r\n   * 1. lastEffect和activeEffect是为了防止堆栈递归调用effect函数的情况；\r\n   * 2. preCleanupEffect和postCleanupEffect结合_trackId目的就是为了每次执行前先斩断依赖对象和副作用函数之间的关系，\r\n   * 执行之后再重新收集依赖关系，但是呢从性能上考虑清空的时候不是直接把deps数组长度清空，\r\n   * 而是先通过_depsLength设置为0，重新建立正确的依赖关系，把多余的元素再剪短依赖关系\r\n   * 3. _trackId是副作用对象的执行次数追踪id\r\n   */\r\n  run() {\r\n    this._dirtyLevel = DirtyLevels.NotDirty // 只要即将执行，就是标志为NotDirty，比如一些异步函数，如果等执行完，\r\n    if (!this.active) {\r\n      return this.fn()\r\n    }\r\n    let lastShouldTrack = shouldTrack\r\n    let lastEffect = activeEffect\r\n    try {\r\n      shouldTrack = true\r\n      activeEffect = this\r\n      this._runnings++\r\n      /**\r\n       * 通过preCleaupEffect方法\r\n       * 标识执行状态_trackId加1了，然后把_depsLength设置为零\r\n       */\r\n      preCleanupEffect(this);\r\n      /**\r\n       * 执行fn副作用函数的时候，会重新手机依赖对象\r\n       * 收集的过程有多种情况：\r\n       * （1）只是把Dep中的key对应的value（_trackId）更新，它们的依赖关系依赖没变\r\n       * （2）存在有一些依赖对象没有执行到的，那这个时候deps里面的元素是比_depsLength要多\r\n       */\r\n      return this.fn()\r\n    } finally {\r\n      /**\r\n       * 收集过程中，走到清空2，\r\n       * 通过postCleanupEffect，把deps中多余的元素清空，并且见到多余的依赖对象和副作用函数之间的关系\r\n       */\r\n      postCleanupEffect(this)\r\n      /**\r\n       * _running的作用：\r\n       * （1）如果一个副作用函数对一个key先有get,然后set操作，因为_running不为0，所以后面的set操作不会再次触发副作用函数的执行\r\n       * （2）如果副作用函数是一个异步函数，在副作用函数还没执行结束之前，就发生了依赖对象key的改变，因为_running也不会再次触发副作用函数\r\n       */\r\n      this._runnings--\r\n      activeEffect = lastEffect\r\n      shouldTrack = lastShouldTrack\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    if (this.active) {\r\n      preCleanupEffect(this)\r\n      postCleanupEffect(this)\r\n      this.onStop?.()\r\n      this.active = false\r\n    }\r\n  }\r\n}\r\n\r\nfunction triggerComputed(computed: ComputedRefImpl<any>) {\r\n  return computed.value\r\n}\r\n\r\nfunction preCleanupEffect(effect: ReactiveEffect) {\r\n  effect._trackId++\r\n  effect._depsLength = 0\r\n}\r\n\r\nfunction postCleanupEffect(effect: ReactiveEffect) {\r\n  if (effect.deps && effect.deps.length > effect._depsLength) {\r\n    for (let i = effect._depsLength; i < effect.deps.length; i++) {\r\n      cleanupDepEffect(effect.deps[i], effect)\r\n    }\r\n    effect.deps.length = effect._depsLength\r\n  }\r\n}\r\n\r\nfunction cleanupDepEffect(dep: Dep, effect: ReactiveEffect) {\r\n  const trackId = dep.get(effect)\r\n   //这里判断原因\r\n  /**\r\n   * 比如说ok text name三个属性，\r\n   * 第二次ok为true了，\r\n   * text对应的代码不会再执行到了，name就占据到deps中的第二个位置，再执行postCleanupEffect方法时候\r\n   * 第三个元素其实就是第二个元素，trackId是等于effect._trackId的\r\n   */\r\n  if (trackId !== undefined && effect._trackId !== trackId) {\r\n    dep.delete(effect)\r\n    if (dep.size === 0) {\r\n      dep.cleanup()\r\n    }\r\n  }\r\n}\r\n\r\nexport interface DebuggerOptions {\r\n  onTrack?: (event: DebuggerEvent) => void\r\n  onTrigger?: (event: DebuggerEvent) => void\r\n}\r\n\r\nexport interface ReactiveEffectOptions extends DebuggerOptions {\r\n  lazy?: boolean\r\n  scheduler?: EffectScheduler\r\n  scope?: EffectScope\r\n  allowRecurse?: boolean\r\n  onStop?: () => void\r\n}\r\n\r\nexport interface ReactiveEffectRunner<T = any> {\r\n  (): T\r\n  effect: ReactiveEffect\r\n}\r\n\r\n/**\r\n * Registers the given function to track reactive updates.\r\n *\r\n * The given function will be run once immediately. Every time any reactive\r\n * property that's accessed within it gets updated, the function will run again.\r\n *\r\n * @param fn - The function that will track reactive updates.\r\n * @param options - Allows to control the effect's behaviour.\r\n * @returns A runner that can be used to control the effect after creation.\r\n */\r\nexport function effect<T = any>(\r\n  fn: () => T,\r\n  options?: ReactiveEffectOptions,\r\n): ReactiveEffectRunner {\r\n  if ((fn as ReactiveEffectRunner).effect instanceof ReactiveEffect) {\r\n    fn = (fn as ReactiveEffectRunner).effect.fn\r\n  }\r\n\r\n  const _effect = new ReactiveEffect(fn, NOOP, () => {\r\n    if (_effect.dirty) {\r\n      _effect.run()\r\n    }\r\n  })\r\n  if (options) {\r\n    extend(_effect, options)\r\n    if (options.scope) recordEffectScope(_effect, options.scope)\r\n  }\r\n  if (!options || !options.lazy) {\r\n    _effect.run()\r\n  }\r\n  const runner = _effect.run.bind(_effect) as ReactiveEffectRunner\r\n  runner.effect = _effect\r\n  return runner\r\n}\r\n\r\n/**\r\n * Stops the effect associated with the given runner.\r\n *\r\n * @param runner - Association with the effect to stop tracking.\r\n */\r\nexport function stop(runner: ReactiveEffectRunner) {\r\n  runner.effect.stop()\r\n}\r\n\r\nexport let shouldTrack = true\r\nexport let pauseScheduleStack = 0\r\n\r\nconst trackStack: boolean[] = []\r\n\r\n/**\r\n * Temporarily pauses tracking.\r\n */\r\nexport function pauseTracking() {\r\n  trackStack.push(shouldTrack)\r\n  shouldTrack = false\r\n}\r\n\r\n/**\r\n * Re-enables effect tracking (if it was paused).\r\n */\r\nexport function enableTracking() {\r\n  trackStack.push(shouldTrack)\r\n  shouldTrack = true\r\n}\r\n\r\n/**\r\n * Resets the previous global effect tracking state.\r\n */\r\nexport function resetTracking() {\r\n  const last = trackStack.pop()\r\n  shouldTrack = last === undefined ? true : last\r\n}\r\n\r\nexport function pauseScheduling() {\r\n  pauseScheduleStack++\r\n}\r\n\r\nexport function resetScheduling() {\r\n  pauseScheduleStack--\r\n  while (!pauseScheduleStack && queueEffectSchedulers.length) {\r\n    queueEffectSchedulers.shift()!()\r\n  }\r\n}\r\n\r\nexport function trackEffect(\r\n  effect: ReactiveEffect,\r\n  dep: Dep,\r\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo,\r\n) {\r\n  /**\r\n   * 比如在一个副作用函数中两次及以上使用了同一个代理对象的key的值，那第二次进入的时候，因为已经存在了且_trackId是相同的，就不会重复添加\r\n   * effect的_trackId的作用就是一个状态id，每执行一次，_trackId就加1，这样做目的：\r\n   * 第一次执行副作用函数的时候，会记录所有依赖对象的deps，但是后面执行条件发生改变了，可能某些依赖对象根本不会执行到，所以每次执行副作用函数\r\n   * 之前需要清空副作用函数对应的依赖对象，执行后又重新创建依赖对象，通过_depsLength和deps这样每次清空的时候，不会直接先把数组给清空了\r\n   * 所以第二次执行的时候_trackId是已经改变了\r\n   */\r\n  if (dep.get(effect) !== effect._trackId) {\r\n    dep.set(effect, effect._trackId)\r\n    const oldDep = effect.deps[effect._depsLength]\r\n    if (oldDep !== dep) {\r\n      if (oldDep) {\r\n        cleanupDepEffect(oldDep, effect)\r\n      }\r\n      effect.deps[effect._depsLength++] = dep\r\n    } else {\r\n      effect._depsLength++\r\n    }\r\n    if (__DEV__) {\r\n      effect.onTrack?.(extend({ effect }, debuggerEventExtraInfo!))\r\n    }\r\n  }\r\n}\r\n\r\nconst queueEffectSchedulers: EffectScheduler[] = []\r\n\r\n/**\r\n * 比如一个副作用函数即引用了代理A对象p属性的值，又循环遍历代理对象A\r\n * 那么A对象p属性的值更改时，即会触发p属性对应的副作用，也会触发迭代器对应的副作用\r\n * 第一次_dirtyLevel是NotDirty，改为Dirty，然后把该副作用函数先计入副作用调度器队列里面\r\n * 第二次通过迭代器进入triggerEffects的时候，因为都是同一个副作用对象，因为lastDirtyLevel已经是Dirty，所以不会再进入if里面，\r\n * 避免重复执行，比如以下场景：\r\n * const observed = reactive([1,2,3]);\r\n     effect(() => {\r\n        console.log(observed[3]);\r\n        for(let item of observed) {\r\n            console.log(item);\r\n        }\r\n    });\r\n    setTimeout(() => {\r\n        observed[3] = 5;\r\n    }, 500)\r\n    属性值length和key为3都会对effect建立依赖关系，observed[3]改变的时候，length和3对应的effect都会执行，因为通过_dirtyLevel和队列的形式，副作用只会加入到队列中一次并只执行一次（队列的作用不仅仅只有这一个）。\r\n */\r\nexport function triggerEffects(\r\n  dep: Dep,\r\n  dirtyLevel: DirtyLevels,\r\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo,\r\n) {\r\n  pauseScheduling()\r\n  for (const effect of dep.keys()) {\r\n    if (\r\n      effect._dirtyLevel < dirtyLevel && // 上一次没有dirty，这一次dirty，如果上一次正在dirty中，说明上一次副作用函数还没执行完，每次执行副作用函数之前都会把dirty设置为notdirty\r\n      dep.get(effect) === effect._trackId \r\n    ) {\r\n      const lastDirtyLevel = effect._dirtyLevel\r\n      effect._dirtyLevel = dirtyLevel\r\n      if (lastDirtyLevel === DirtyLevels.NotDirty) {\r\n        effect._shouldSchedule = true\r\n        if (__DEV__) {\r\n          effect.onTrigger?.(extend({ effect }, debuggerEventExtraInfo))\r\n        }\r\n        effect.trigger()\r\n      }\r\n    }\r\n  }\r\n  scheduleEffects(dep)\r\n  resetScheduling()\r\n}\r\n\r\n/**\r\n * 如果一个副作用函数对某个key先get，再set，那么set触发trigger，进入这个函数，_runnings不为0，allowRecurse默认是false\r\n * 所以不会重新调用副作用函数，不然就有可能进入死循环\r\n */\r\nexport function scheduleEffects(dep: Dep) {\r\n  for (const effect of dep.keys()) {\r\n    if (\r\n      effect.scheduler &&\r\n      effect._shouldSchedule &&\r\n      (!effect._runnings || effect.allowRecurse) &&\r\n      dep.get(effect) === effect._trackId\r\n    ) {\r\n      effect._shouldSchedule = false\r\n      queueEffectSchedulers.push(effect.scheduler)\r\n    }\r\n  }\r\n}\r\n","import { def, isObject, toRawType } from '@vue/shared'\r\nimport {\r\n  mutableHandlers,\r\n  readonlyHandlers,\r\n  shallowReactiveHandlers,\r\n  shallowReadonlyHandlers,\r\n} from './baseHandlers'\r\nimport {\r\n  mutableCollectionHandlers,\r\n  readonlyCollectionHandlers,\r\n  shallowCollectionHandlers,\r\n  shallowReadonlyCollectionHandlers,\r\n} from './collectionHandlers'\r\nimport type { RawSymbol, Ref, UnwrapRefSimple } from './ref'\r\nimport { ReactiveFlags } from './constants'\r\n\r\nexport interface Target {\r\n  [ReactiveFlags.SKIP]?: boolean\r\n  [ReactiveFlags.IS_REACTIVE]?: boolean\r\n  [ReactiveFlags.IS_READONLY]?: boolean\r\n  [ReactiveFlags.IS_SHALLOW]?: boolean\r\n  [ReactiveFlags.RAW]?: any\r\n}\r\n\r\nexport const reactiveMap = new WeakMap<Target, any>()\r\nexport const shallowReactiveMap = new WeakMap<Target, any>()\r\nexport const readonlyMap = new WeakMap<Target, any>()\r\nexport const shallowReadonlyMap = new WeakMap<Target, any>()\r\n\r\nenum TargetType {\r\n  INVALID = 0,\r\n  COMMON = 1,\r\n  COLLECTION = 2,\r\n}\r\n\r\nfunction targetTypeMap(rawType: string) {\r\n  switch (rawType) {\r\n    case 'Object':\r\n    case 'Array':\r\n      return TargetType.COMMON // 通用的类型\r\n    case 'Map':\r\n    case 'Set':\r\n    case 'WeakMap':\r\n    case 'WeakSet':\r\n      return TargetType.COLLECTION // set/map类型\r\n    default:\r\n      return TargetType.INVALID\r\n  }\r\n}\r\n\r\nfunction getTargetType(value: Target) {\r\n  // 有skip标志或者不能被扩展的就是无效的类型\r\n  return value[ReactiveFlags.SKIP] || !Object.isExtensible(value)\r\n    ? TargetType.INVALID\r\n    : targetTypeMap(toRawType(value))\r\n}\r\n\r\n// only unwrap nested ref\r\nexport type UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRefSimple<T>\r\n\r\n/**\r\n * Returns a reactive proxy of the object.\r\n *\r\n * The reactive conversion is \"deep\": it affects all nested properties. A\r\n * reactive object also deeply unwraps any properties that are refs while\r\n * maintaining reactivity.\r\n *\r\n * @example\r\n * ```js\r\n * const obj = reactive({ count: 0 })\r\n * ```\r\n *\r\n * @param target - The source object.\r\n * @see {@link https://vuejs.org/api/reactivity-core.html#reactive}\r\n */\r\nexport function reactive<T extends object>(target: T): UnwrapNestedRefs<T>\r\nexport function reactive(target: object) {\r\n  // if trying to observe a readonly proxy, return the readonly version.\r\n  // 如果创建的target本身就是reactive就直接返回\r\n  if (isReadonly(target)) {\r\n    return target\r\n  }\r\n  return createReactiveObject(\r\n    target,\r\n    false,\r\n    mutableHandlers,\r\n    mutableCollectionHandlers,\r\n    reactiveMap,\r\n  )\r\n}\r\n\r\nexport declare const ShallowReactiveMarker: unique symbol\r\n\r\nexport type ShallowReactive<T> = T & { [ShallowReactiveMarker]?: true }\r\n\r\n/**\r\n * Shallow version of {@link reactive()}.\r\n *\r\n * Unlike {@link reactive()}, there is no deep conversion: only root-level\r\n * properties are reactive for a shallow reactive object. Property values are\r\n * stored and exposed as-is - this also means properties with ref values will\r\n * not be automatically unwrapped.\r\n *\r\n * @example\r\n * ```js\r\n * const state = shallowReactive({\r\n *   foo: 1,\r\n *   nested: {\r\n *     bar: 2\r\n *   }\r\n * })\r\n *\r\n * // mutating state's own properties is reactive\r\n * state.foo++\r\n *\r\n * // ...but does not convert nested objects\r\n * isReactive(state.nested) // false\r\n *\r\n * // NOT reactive\r\n * state.nested.bar++\r\n * ```\r\n *\r\n * @param target - The source object.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#shallowreactive}\r\n */\r\nexport function shallowReactive<T extends object>(\r\n  target: T,\r\n): ShallowReactive<T> {\r\n  return createReactiveObject(\r\n    target,\r\n    false,\r\n    shallowReactiveHandlers,\r\n    shallowCollectionHandlers,\r\n    shallowReactiveMap,\r\n  )\r\n}\r\n\r\ntype Primitive = string | number | boolean | bigint | symbol | undefined | null\r\ntype Builtin = Primitive | Function | Date | Error | RegExp\r\nexport type DeepReadonly<T> = T extends Builtin\r\n  ? T\r\n  : T extends Map<infer K, infer V>\r\n    ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\r\n    : T extends ReadonlyMap<infer K, infer V>\r\n      ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\r\n      : T extends WeakMap<infer K, infer V>\r\n        ? WeakMap<DeepReadonly<K>, DeepReadonly<V>>\r\n        : T extends Set<infer U>\r\n          ? ReadonlySet<DeepReadonly<U>>\r\n          : T extends ReadonlySet<infer U>\r\n            ? ReadonlySet<DeepReadonly<U>>\r\n            : T extends WeakSet<infer U>\r\n              ? WeakSet<DeepReadonly<U>>\r\n              : T extends Promise<infer U>\r\n                ? Promise<DeepReadonly<U>>\r\n                : T extends Ref<infer U>\r\n                  ? Readonly<Ref<DeepReadonly<U>>>\r\n                  : T extends {}\r\n                    ? { readonly [K in keyof T]: DeepReadonly<T[K]> }\r\n                    : Readonly<T>\r\n\r\n/**\r\n * Takes an object (reactive or plain) or a ref and returns a readonly proxy to\r\n * the original.\r\n *\r\n * A readonly proxy is deep: any nested property accessed will be readonly as\r\n * well. It also has the same ref-unwrapping behavior as {@link reactive()},\r\n * except the unwrapped values will also be made readonly.\r\n *\r\n * @example\r\n * ```js\r\n * const original = reactive({ count: 0 })\r\n *\r\n * const copy = readonly(original)\r\n *\r\n * watchEffect(() => {\r\n *   // works for reactivity tracking\r\n *   console.log(copy.count)\r\n * })\r\n *\r\n * // mutating original will trigger watchers relying on the copy\r\n * original.count++\r\n *\r\n * // mutating the copy will fail and result in a warning\r\n * copy.count++ // warning!\r\n * ```\r\n *\r\n * @param target - The source object.\r\n * @see {@link https://vuejs.org/api/reactivity-core.html#readonly}\r\n */\r\nexport function readonly<T extends object>(\r\n  target: T,\r\n): DeepReadonly<UnwrapNestedRefs<T>> {\r\n  return createReactiveObject(\r\n    target,\r\n    true,\r\n    readonlyHandlers,\r\n    readonlyCollectionHandlers,\r\n    readonlyMap,\r\n  )\r\n}\r\n\r\n/**\r\n * Shallow version of {@link readonly()}.\r\n *\r\n * Unlike {@link readonly()}, there is no deep conversion: only root-level\r\n * properties are made readonly. Property values are stored and exposed as-is -\r\n * this also means properties with ref values will not be automatically\r\n * unwrapped.\r\n *\r\n * @example\r\n * ```js\r\n * const state = shallowReadonly({\r\n *   foo: 1,\r\n *   nested: {\r\n *     bar: 2\r\n *   }\r\n * })\r\n *\r\n * // mutating state's own properties will fail\r\n * state.foo++\r\n *\r\n * // ...but works on nested objects\r\n * isReadonly(state.nested) // false\r\n *\r\n * // works\r\n * state.nested.bar++\r\n * ```\r\n *\r\n * @param target - The source object.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#shallowreadonly}\r\n */\r\nexport function shallowReadonly<T extends object>(target: T): Readonly<T> {\r\n  return createReactiveObject(\r\n    target,\r\n    true,\r\n    shallowReadonlyHandlers,\r\n    shallowReadonlyCollectionHandlers,\r\n    shallowReadonlyMap,\r\n  )\r\n}\r\n\r\nfunction createReactiveObject(\r\n  target: Target,\r\n  isReadonly: boolean,\r\n  baseHandlers: ProxyHandler<any>,\r\n  collectionHandlers: ProxyHandler<any>,\r\n  proxyMap: WeakMap<Target, any>,\r\n) {\r\n  // 不是对象就直接返回\r\n  if (!isObject(target)) {\r\n    if (__DEV__) {\r\n      console.warn(`value cannot be made reactive: ${String(target)}`)\r\n    }\r\n    return target\r\n  }\r\n  // target is already a Proxy, return it.\r\n  // exception: calling readonly() on a reactive object\r\n  // 如果已经是一个代理对象，并且不是只读的响应式对象，直接返回\r\n  if (\r\n    target[ReactiveFlags.RAW] &&\r\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\r\n  ) {\r\n    return target\r\n  }\r\n  // target already has corresponding Proxy\r\n  const existingProxy = proxyMap.get(target)\r\n  if (existingProxy) {\r\n    return existingProxy\r\n  }\r\n  // only specific value types can be observed.\r\n  const targetType = getTargetType(target)\r\n  if (targetType === TargetType.INVALID) {\r\n    return target\r\n  }\r\n  // 创建代理\r\n  // collectionHandlers重写的是set/map对象，数组和普通对象就是走baseHandlers\r\n  const proxy = new Proxy(\r\n    target,\r\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers,\r\n  )\r\n  // 创建的代理对象都放到proxyMap中记录\r\n  proxyMap.set(target, proxy)\r\n  return proxy\r\n}\r\n\r\n/**\r\n * Checks if an object is a proxy created by {@link reactive()} or\r\n * {@link shallowReactive()} (or {@link ref()} in some cases).\r\n *\r\n * @example\r\n * ```js\r\n * isReactive(reactive({}))            // => true\r\n * isReactive(readonly(reactive({})))  // => true\r\n * isReactive(ref({}).value)           // => true\r\n * isReactive(readonly(ref({})).value) // => true\r\n * isReactive(ref(true))               // => false\r\n * isReactive(shallowRef({}).value)    // => false\r\n * isReactive(shallowReactive({}))     // => true\r\n * ```\r\n *\r\n * @param value - The value to check.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#isreactive}\r\n */\r\nexport function isReactive(value: unknown): boolean {\r\n  if (isReadonly(value)) {\r\n    return isReactive((value as Target)[ReactiveFlags.RAW])\r\n  }\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_REACTIVE])\r\n}\r\n\r\n/**\r\n * Checks whether the passed value is a readonly object. The properties of a\r\n * readonly object can change, but they can't be assigned directly via the\r\n * passed object.\r\n *\r\n * The proxies created by {@link readonly()} and {@link shallowReadonly()} are\r\n * both considered readonly, as is a computed ref without a set function.\r\n *\r\n * @param value - The value to check.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#isreadonly}\r\n */\r\nexport function isReadonly(value: unknown): boolean {\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_READONLY])\r\n}\r\n\r\nexport function isShallow(value: unknown): boolean {\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_SHALLOW])\r\n}\r\n\r\n/**\r\n * Checks if an object is a proxy created by {@link reactive},\r\n * {@link readonly}, {@link shallowReactive} or {@link shallowReadonly()}.\r\n *\r\n * @param value - The value to check.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#isproxy}\r\n */\r\nexport function isProxy(value: unknown): boolean {\r\n  return isReactive(value) || isReadonly(value)\r\n}\r\n\r\n/**\r\n * Returns the raw, original object of a Vue-created proxy.\r\n *\r\n * `toRaw()` can return the original object from proxies created by\r\n * {@link reactive()}, {@link readonly()}, {@link shallowReactive()} or\r\n * {@link shallowReadonly()}.\r\n *\r\n * This is an escape hatch that can be used to temporarily read without\r\n * incurring proxy access / tracking overhead or write without triggering\r\n * changes. It is **not** recommended to hold a persistent reference to the\r\n * original object. Use with caution.\r\n *\r\n * @example\r\n * ```js\r\n * const foo = {}\r\n * const reactiveFoo = reactive(foo)\r\n *\r\n * console.log(toRaw(reactiveFoo) === foo) // true\r\n * ```\r\n *\r\n * @param observed - The object for which the \"raw\" value is requested.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#toraw}\r\n */\r\nexport function toRaw<T>(observed: T): T {\r\n  const raw = observed && (observed as Target)[ReactiveFlags.RAW]\r\n  return raw ? toRaw(raw) : observed\r\n}\r\n\r\nexport type Raw<T> = T & { [RawSymbol]?: true }\r\n\r\n/**\r\n * Marks an object so that it will never be converted to a proxy. Returns the\r\n * object itself.\r\n *\r\n * @example\r\n * ```js\r\n * const foo = markRaw({})\r\n * console.log(isReactive(reactive(foo))) // false\r\n *\r\n * // also works when nested inside other reactive objects\r\n * const bar = reactive({ foo })\r\n * console.log(isReactive(bar.foo)) // false\r\n * ```\r\n *\r\n * **Warning:** `markRaw()` together with the shallow APIs such as\r\n * {@link shallowReactive()} allow you to selectively opt-out of the default\r\n * deep reactive/readonly conversion and embed raw, non-proxied objects in your\r\n * state graph.\r\n *\r\n * @param value - The object to be marked as \"raw\".\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#markraw}\r\n */\r\nexport function markRaw<T extends object>(value: T): Raw<T> {\r\n  def(value, ReactiveFlags.SKIP, true)\r\n  return value\r\n}\r\n\r\n/**\r\n * Returns a reactive proxy of the given value (if possible).\r\n *\r\n * If the given value is not an object, the original value itself is returned.\r\n *\r\n * @param value - The value for which a reactive proxy shall be created.\r\n */\r\nexport const toReactive = <T extends unknown>(value: T): T =>\r\n  isObject(value) ? reactive(value) : value\r\n\r\n/**\r\n * Returns a readonly proxy of the given value (if possible).\r\n *\r\n * If the given value is not an object, the original value itself is returned.\r\n *\r\n * @param value - The value for which a readonly proxy shall be created.\r\n */\r\nexport const toReadonly = <T extends unknown>(value: T): T =>\r\n  isObject(value) ? readonly(value) : value\r\n","import type { ComputedRef } from './computed'\r\nimport {\r\n  activeEffect,\r\n  shouldTrack,\r\n  trackEffect,\r\n  triggerEffects,\r\n} from './effect'\r\nimport { DirtyLevels, TrackOpTypes, TriggerOpTypes } from './constants'\r\nimport {\r\n  type IfAny,\r\n  hasChanged,\r\n  isArray,\r\n  isFunction,\r\n  isObject,\r\n} from '@vue/shared'\r\nimport {\r\n  isProxy,\r\n  isReactive,\r\n  isReadonly,\r\n  isShallow,\r\n  toRaw,\r\n  toReactive,\r\n} from './reactive'\r\nimport type { ShallowReactiveMarker } from './reactive'\r\nimport { type Dep, createDep } from './dep'\r\nimport { ComputedRefImpl } from './computed'\r\nimport { getDepFromReactive } from './reactiveEffect'\r\n\r\ndeclare const RefSymbol: unique symbol\r\nexport declare const RawSymbol: unique symbol\r\n\r\nexport interface Ref<T = any> {\r\n  value: T\r\n  /**\r\n   * Type differentiator only.\r\n   * We need this to be in public d.ts but don't want it to show up in IDE\r\n   * autocomplete, so we use a private Symbol instead.\r\n   */\r\n  [RefSymbol]: true\r\n}\r\n\r\ntype RefBase<T> = {\r\n  dep?: Dep\r\n  value: T\r\n}\r\n\r\nexport function trackRefValue(ref: RefBase<any>) {\r\n  if (shouldTrack && activeEffect) {\r\n    ref = toRaw(ref)\r\n    trackEffect(\r\n      activeEffect,\r\n      ref.dep ||\r\n        (ref.dep = createDep(\r\n          () => (ref.dep = undefined),\r\n          ref instanceof ComputedRefImpl ? ref : undefined,\r\n        )),\r\n      __DEV__\r\n        ? {\r\n            target: ref,\r\n            type: TrackOpTypes.GET,\r\n            key: 'value',\r\n          }\r\n        : void 0,\r\n    )\r\n  }\r\n}\r\n\r\nexport function triggerRefValue(\r\n  ref: RefBase<any>,\r\n  dirtyLevel: DirtyLevels = DirtyLevels.Dirty,\r\n  newVal?: any,\r\n) {\r\n  ref = toRaw(ref)\r\n  const dep = ref.dep\r\n  if (dep) {\r\n    triggerEffects(\r\n      dep,\r\n      dirtyLevel,\r\n      __DEV__\r\n        ? {\r\n            target: ref,\r\n            type: TriggerOpTypes.SET,\r\n            key: 'value',\r\n            newValue: newVal,\r\n          }\r\n        : void 0,\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if a value is a ref object.\r\n *\r\n * @param r - The value to inspect.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#isref}\r\n */\r\nexport function isRef<T>(r: Ref<T> | unknown): r is Ref<T>\r\nexport function isRef(r: any): r is Ref {\r\n  return !!(r && r.__v_isRef === true)\r\n}\r\n\r\n/**\r\n * Takes an inner value and returns a reactive and mutable ref object, which\r\n * has a single property `.value` that points to the inner value.\r\n *\r\n * @param value - The object to wrap in the ref.\r\n * @see {@link https://vuejs.org/api/reactivity-core.html#ref}\r\n */\r\nexport function ref<T>(value: T): Ref<UnwrapRef<T>>\r\nexport function ref<T = any>(): Ref<T | undefined>\r\nexport function ref(value?: unknown) {\r\n  return createRef(value, false)\r\n}\r\n\r\ndeclare const ShallowRefMarker: unique symbol\r\n\r\nexport type ShallowRef<T = any> = Ref<T> & { [ShallowRefMarker]?: true }\r\n\r\n/**\r\n * Shallow version of {@link ref()}.\r\n *\r\n * @example\r\n * ```js\r\n * const state = shallowRef({ count: 1 })\r\n *\r\n * // does NOT trigger change\r\n * state.value.count = 2\r\n *\r\n * // does trigger change\r\n * state.value = { count: 2 }\r\n * ```\r\n *\r\n * @param value - The \"inner value\" for the shallow ref.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#shallowref}\r\n */\r\nexport function shallowRef<T>(\r\n  value: T,\r\n): Ref extends T\r\n  ? T extends Ref\r\n    ? IfAny<T, ShallowRef<T>, T>\r\n    : ShallowRef<T>\r\n  : ShallowRef<T>\r\nexport function shallowRef<T = any>(): ShallowRef<T | undefined>\r\nexport function shallowRef(value?: unknown) {\r\n  return createRef(value, true)\r\n}\r\n\r\nfunction createRef(rawValue: unknown, shallow: boolean) {\r\n  if (isRef(rawValue)) {\r\n    return rawValue\r\n  }\r\n  return new RefImpl(rawValue, shallow)\r\n}\r\n\r\nclass RefImpl<T> {\r\n  private _value: T\r\n  private _rawValue: T\r\n\r\n  public dep?: Dep = undefined\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(\r\n    value: T,\r\n    public readonly __v_isShallow: boolean,\r\n  ) {\r\n    this._rawValue = __v_isShallow ? value : toRaw(value)\r\n    this._value = __v_isShallow ? value : toReactive(value)\r\n  }\r\n\r\n  get value() {\r\n    trackRefValue(this)\r\n    return this._value\r\n  }\r\n\r\n  set value(newVal) {\r\n    const useDirectValue =\r\n      this.__v_isShallow || isShallow(newVal) || isReadonly(newVal)\r\n    newVal = useDirectValue ? newVal : toRaw(newVal)\r\n    if (hasChanged(newVal, this._rawValue)) {\r\n      this._rawValue = newVal\r\n      this._value = useDirectValue ? newVal : toReactive(newVal)\r\n      triggerRefValue(this, DirtyLevels.Dirty, newVal)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Force trigger effects that depends on a shallow ref. This is typically used\r\n * after making deep mutations to the inner value of a shallow ref.\r\n *\r\n * @example\r\n * ```js\r\n * const shallow = shallowRef({\r\n *   greet: 'Hello, world'\r\n * })\r\n *\r\n * // Logs \"Hello, world\" once for the first run-through\r\n * watchEffect(() => {\r\n *   console.log(shallow.value.greet)\r\n * })\r\n *\r\n * // This won't trigger the effect because the ref is shallow\r\n * shallow.value.greet = 'Hello, universe'\r\n *\r\n * // Logs \"Hello, universe\"\r\n * triggerRef(shallow)\r\n * ```\r\n *\r\n * @param ref - The ref whose tied effects shall be executed.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#triggerref}\r\n */\r\nexport function triggerRef(ref: Ref) {\r\n  triggerRefValue(ref, DirtyLevels.Dirty, __DEV__ ? ref.value : void 0)\r\n}\r\n\r\nexport type MaybeRef<T = any> = T | Ref<T>\r\nexport type MaybeRefOrGetter<T = any> = MaybeRef<T> | (() => T)\r\n\r\n/**\r\n * Returns the inner value if the argument is a ref, otherwise return the\r\n * argument itself. This is a sugar function for\r\n * `val = isRef(val) ? val.value : val`.\r\n *\r\n * @example\r\n * ```js\r\n * function useFoo(x: number | Ref<number>) {\r\n *   const unwrapped = unref(x)\r\n *   // unwrapped is guaranteed to be number now\r\n * }\r\n * ```\r\n *\r\n * @param ref - Ref or plain value to be converted into the plain value.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#unref}\r\n */\r\nexport function unref<T>(ref: MaybeRef<T> | ComputedRef<T>): T {\r\n  return isRef(ref) ? ref.value : ref\r\n}\r\n\r\n/**\r\n * Normalizes values / refs / getters to values.\r\n * This is similar to {@link unref()}, except that it also normalizes getters.\r\n * If the argument is a getter, it will be invoked and its return value will\r\n * be returned.\r\n *\r\n * @example\r\n * ```js\r\n * toValue(1) // 1\r\n * toValue(ref(1)) // 1\r\n * toValue(() => 1) // 1\r\n * ```\r\n *\r\n * @param source - A getter, an existing ref, or a non-function value.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#tovalue}\r\n */\r\nexport function toValue<T>(source: MaybeRefOrGetter<T> | ComputedRef<T>): T {\r\n  return isFunction(source) ? source() : unref(source)\r\n}\r\n\r\nconst shallowUnwrapHandlers: ProxyHandler<any> = {\r\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n  set: (target, key, value, receiver) => {\r\n    const oldValue = target[key]\r\n    if (isRef(oldValue) && !isRef(value)) {\r\n      oldValue.value = value\r\n      return true\r\n    } else {\r\n      return Reflect.set(target, key, value, receiver)\r\n    }\r\n  },\r\n}\r\n\r\n/**\r\n * Returns a reactive proxy for the given object.\r\n *\r\n * If the object already is reactive, it's returned as-is. If not, a new\r\n * reactive proxy is created. Direct child properties that are refs are properly\r\n * handled, as well.\r\n *\r\n * @param objectWithRefs - Either an already-reactive object or a simple object\r\n * that contains refs.\r\n */\r\nexport function proxyRefs<T extends object>(\r\n  objectWithRefs: T,\r\n): ShallowUnwrapRef<T> {\r\n  return isReactive(objectWithRefs)\r\n    ? objectWithRefs\r\n    : new Proxy(objectWithRefs, shallowUnwrapHandlers)\r\n}\r\n\r\nexport type CustomRefFactory<T> = (\r\n  track: () => void,\r\n  trigger: () => void,\r\n) => {\r\n  get: () => T\r\n  set: (value: T) => void\r\n}\r\n\r\nclass CustomRefImpl<T> {\r\n  public dep?: Dep = undefined\r\n\r\n  private readonly _get: ReturnType<CustomRefFactory<T>>['get']\r\n  private readonly _set: ReturnType<CustomRefFactory<T>>['set']\r\n\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(factory: CustomRefFactory<T>) {\r\n    const { get, set } = factory(\r\n      () => trackRefValue(this),\r\n      () => triggerRefValue(this),\r\n    )\r\n    this._get = get\r\n    this._set = set\r\n  }\r\n\r\n  get value() {\r\n    return this._get()\r\n  }\r\n\r\n  set value(newVal) {\r\n    this._set(newVal)\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a customized ref with explicit control over its dependency tracking\r\n * and updates triggering.\r\n *\r\n * @param factory - The function that receives the `track` and `trigger` callbacks.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#customref}\r\n */\r\nexport function customRef<T>(factory: CustomRefFactory<T>): Ref<T> {\r\n  return new CustomRefImpl(factory) as any\r\n}\r\n\r\nexport type ToRefs<T = any> = {\r\n  [K in keyof T]: ToRef<T[K]>\r\n}\r\n\r\n/**\r\n * Converts a reactive object to a plain object where each property of the\r\n * resulting object is a ref pointing to the corresponding property of the\r\n * original object. Each individual ref is created using {@link toRef()}.\r\n *\r\n * @param object - Reactive object to be made into an object of linked refs.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#torefs}\r\n */\r\nexport function toRefs<T extends object>(object: T): ToRefs<T> {\r\n  if (__DEV__ && !isProxy(object)) {\r\n    console.warn(`toRefs() expects a reactive object but received a plain one.`)\r\n  }\r\n  const ret: any = isArray(object) ? new Array(object.length) : {}\r\n  for (const key in object) {\r\n    ret[key] = propertyToRef(object, key)\r\n  }\r\n  return ret\r\n}\r\n\r\nclass ObjectRefImpl<T extends object, K extends keyof T> {\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(\r\n    private readonly _object: T,\r\n    private readonly _key: K,\r\n    private readonly _defaultValue?: T[K],\r\n  ) {}\r\n\r\n  get value() {\r\n    const val = this._object[this._key]\r\n    return val === undefined ? this._defaultValue! : val\r\n  }\r\n\r\n  set value(newVal) {\r\n    this._object[this._key] = newVal\r\n  }\r\n\r\n  get dep(): Dep | undefined {\r\n    return getDepFromReactive(toRaw(this._object), this._key)\r\n  }\r\n}\r\n\r\nclass GetterRefImpl<T> {\r\n  public readonly __v_isRef = true\r\n  public readonly __v_isReadonly = true\r\n  constructor(private readonly _getter: () => T) {}\r\n  get value() {\r\n    return this._getter()\r\n  }\r\n}\r\n\r\nexport type ToRef<T> = IfAny<T, Ref<T>, [T] extends [Ref] ? T : Ref<T>>\r\n\r\n/**\r\n * Used to normalize values / refs / getters into refs.\r\n *\r\n * @example\r\n * ```js\r\n * // returns existing refs as-is\r\n * toRef(existingRef)\r\n *\r\n * // creates a ref that calls the getter on .value access\r\n * toRef(() => props.foo)\r\n *\r\n * // creates normal refs from non-function values\r\n * // equivalent to ref(1)\r\n * toRef(1)\r\n * ```\r\n *\r\n * Can also be used to create a ref for a property on a source reactive object.\r\n * The created ref is synced with its source property: mutating the source\r\n * property will update the ref, and vice-versa.\r\n *\r\n * @example\r\n * ```js\r\n * const state = reactive({\r\n *   foo: 1,\r\n *   bar: 2\r\n * })\r\n *\r\n * const fooRef = toRef(state, 'foo')\r\n *\r\n * // mutating the ref updates the original\r\n * fooRef.value++\r\n * console.log(state.foo) // 2\r\n *\r\n * // mutating the original also updates the ref\r\n * state.foo++\r\n * console.log(fooRef.value) // 3\r\n * ```\r\n *\r\n * @param source - A getter, an existing ref, a non-function value, or a\r\n *                 reactive object to create a property ref from.\r\n * @param [key] - (optional) Name of the property in the reactive object.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#toref}\r\n */\r\nexport function toRef<T>(\r\n  value: T,\r\n): T extends () => infer R\r\n  ? Readonly<Ref<R>>\r\n  : T extends Ref\r\n    ? T\r\n    : Ref<UnwrapRef<T>>\r\nexport function toRef<T extends object, K extends keyof T>(\r\n  object: T,\r\n  key: K,\r\n): ToRef<T[K]>\r\nexport function toRef<T extends object, K extends keyof T>(\r\n  object: T,\r\n  key: K,\r\n  defaultValue: T[K],\r\n): ToRef<Exclude<T[K], undefined>>\r\nexport function toRef(\r\n  source: Record<string, any> | MaybeRef,\r\n  key?: string,\r\n  defaultValue?: unknown,\r\n): Ref {\r\n  if (isRef(source)) {\r\n    return source\r\n  } else if (isFunction(source)) {\r\n    return new GetterRefImpl(source) as any\r\n  } else if (isObject(source) && arguments.length > 1) {\r\n    return propertyToRef(source, key!, defaultValue)\r\n  } else {\r\n    return ref(source)\r\n  }\r\n}\r\n\r\nfunction propertyToRef(\r\n  source: Record<string, any>,\r\n  key: string,\r\n  defaultValue?: unknown,\r\n) {\r\n  const val = source[key]\r\n  return isRef(val)\r\n    ? val\r\n    : (new ObjectRefImpl(source, key, defaultValue) as any)\r\n}\r\n\r\n// corner case when use narrows type\r\n// Ex. type RelativePath = string & { __brand: unknown }\r\n// RelativePath extends object -> true\r\ntype BaseTypes = string | number | boolean\r\n\r\n/**\r\n * This is a special exported interface for other packages to declare\r\n * additional types that should bail out for ref unwrapping. For example\r\n * \\@vue/runtime-dom can declare it like so in its d.ts:\r\n *\r\n * ``` ts\r\n * declare module '@vue/reactivity' {\r\n *   export interface RefUnwrapBailTypes {\r\n *     runtimeDOMBailTypes: Node | Window\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport interface RefUnwrapBailTypes {}\r\n\r\nexport type ShallowUnwrapRef<T> = {\r\n  [K in keyof T]: DistrubuteRef<T[K]>\r\n}\r\n\r\ntype DistrubuteRef<T> = T extends Ref<infer V> ? V : T\r\n\r\nexport type UnwrapRef<T> =\r\n  T extends ShallowRef<infer V>\r\n    ? V\r\n    : T extends Ref<infer V>\r\n      ? UnwrapRefSimple<V>\r\n      : UnwrapRefSimple<T>\r\n\r\nexport type UnwrapRefSimple<T> = T extends\r\n  | Function\r\n  | BaseTypes\r\n  | Ref\r\n  | RefUnwrapBailTypes[keyof RefUnwrapBailTypes]\r\n  | { [RawSymbol]?: true }\r\n  ? T\r\n  : T extends Map<infer K, infer V>\r\n    ? Map<K, UnwrapRefSimple<V>> & UnwrapRef<Omit<T, keyof Map<any, any>>>\r\n    : T extends WeakMap<infer K, infer V>\r\n      ? WeakMap<K, UnwrapRefSimple<V>> &\r\n          UnwrapRef<Omit<T, keyof WeakMap<any, any>>>\r\n      : T extends Set<infer V>\r\n        ? Set<UnwrapRefSimple<V>> & UnwrapRef<Omit<T, keyof Set<any>>>\r\n        : T extends WeakSet<infer V>\r\n          ? WeakSet<UnwrapRefSimple<V>> & UnwrapRef<Omit<T, keyof WeakSet<any>>>\r\n          : T extends ReadonlyArray<any>\r\n            ? { [K in keyof T]: UnwrapRefSimple<T[K]> }\r\n            : T extends object & { [ShallowReactiveMarker]?: never }\r\n              ? {\r\n                  [P in keyof T]: P extends symbol ? T[P] : UnwrapRef<T[P]>\r\n                }\r\n              : T\r\n","import type { VNode } from './vnode'\r\nimport {\r\n  type ComponentInternalInstance,\r\n  type ConcreteComponent,\r\n  type Data,\r\n  formatComponentName,\r\n} from './component'\r\nimport { isFunction, isString } from '@vue/shared'\r\nimport { isRef, pauseTracking, resetTracking, toRaw } from '@vue/reactivity'\r\nimport { ErrorCodes, callWithErrorHandling } from './errorHandling'\r\n\r\ntype ComponentVNode = VNode & {\r\n  type: ConcreteComponent\r\n}\r\n\r\nconst stack: VNode[] = []\r\n\r\ntype TraceEntry = {\r\n  vnode: ComponentVNode\r\n  recurseCount: number\r\n}\r\n\r\ntype ComponentTraceStack = TraceEntry[]\r\n\r\nexport function pushWarningContext(vnode: VNode) {\r\n  stack.push(vnode)\r\n}\r\n\r\nexport function popWarningContext() {\r\n  stack.pop()\r\n}\r\n\r\nexport function warn(msg: string, ...args: any[]) {\r\n  // avoid props formatting or warn handler tracking deps that might be mutated\r\n  // during patch, leading to infinite recursion.\r\n  pauseTracking()\r\n\r\n  const instance = stack.length ? stack[stack.length - 1].component : null\r\n  const appWarnHandler = instance && instance.appContext.config.warnHandler\r\n  const trace = getComponentTrace()\r\n\r\n  if (appWarnHandler) {\r\n    callWithErrorHandling(\r\n      appWarnHandler,\r\n      instance,\r\n      ErrorCodes.APP_WARN_HANDLER,\r\n      [\r\n        msg + args.join(''),\r\n        instance && instance.proxy,\r\n        trace\r\n          .map(\r\n            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`,\r\n          )\r\n          .join('\\n'),\r\n        trace,\r\n      ],\r\n    )\r\n  } else {\r\n    const warnArgs = [`[Vue warn]: ${msg}`, ...args]\r\n    /* istanbul ignore if */\r\n    if (\r\n      trace.length &&\r\n      // avoid spamming console during tests\r\n      !__TEST__\r\n    ) {\r\n      warnArgs.push(`\\n`, ...formatTrace(trace))\r\n    }\r\n    console.warn(...warnArgs)\r\n  }\r\n\r\n  resetTracking()\r\n}\r\n\r\nexport function getComponentTrace(): ComponentTraceStack {\r\n  let currentVNode: VNode | null = stack[stack.length - 1]\r\n  if (!currentVNode) {\r\n    return []\r\n  }\r\n\r\n  // we can't just use the stack because it will be incomplete during updates\r\n  // that did not start from the root. Re-construct the parent chain using\r\n  // instance parent pointers.\r\n  const normalizedStack: ComponentTraceStack = []\r\n\r\n  while (currentVNode) {\r\n    const last = normalizedStack[0]\r\n    if (last && last.vnode === currentVNode) {\r\n      last.recurseCount++\r\n    } else {\r\n      normalizedStack.push({\r\n        vnode: currentVNode as ComponentVNode,\r\n        recurseCount: 0,\r\n      })\r\n    }\r\n    const parentInstance: ComponentInternalInstance | null =\r\n      currentVNode.component && currentVNode.component.parent\r\n    currentVNode = parentInstance && parentInstance.vnode\r\n  }\r\n\r\n  return normalizedStack\r\n}\r\n\r\n/* istanbul ignore next */\r\nfunction formatTrace(trace: ComponentTraceStack): any[] {\r\n  const logs: any[] = []\r\n  trace.forEach((entry, i) => {\r\n    logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry))\r\n  })\r\n  return logs\r\n}\r\n\r\nfunction formatTraceEntry({ vnode, recurseCount }: TraceEntry): any[] {\r\n  const postfix =\r\n    recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``\r\n  const isRoot = vnode.component ? vnode.component.parent == null : false\r\n  const open = ` at <${formatComponentName(\r\n    vnode.component,\r\n    vnode.type,\r\n    isRoot,\r\n  )}`\r\n  const close = `>` + postfix\r\n  return vnode.props\r\n    ? [open, ...formatProps(vnode.props), close]\r\n    : [open + close]\r\n}\r\n\r\n/* istanbul ignore next */\r\nfunction formatProps(props: Data): any[] {\r\n  const res: any[] = []\r\n  const keys = Object.keys(props)\r\n  keys.slice(0, 3).forEach(key => {\r\n    res.push(...formatProp(key, props[key]))\r\n  })\r\n  if (keys.length > 3) {\r\n    res.push(` ...`)\r\n  }\r\n  return res\r\n}\r\n\r\nfunction formatProp(key: string, value: unknown): any[]\r\nfunction formatProp(key: string, value: unknown, raw: true): any\r\n/* istanbul ignore next */\r\nfunction formatProp(key: string, value: unknown, raw?: boolean): any {\r\n  if (isString(value)) {\r\n    value = JSON.stringify(value)\r\n    return raw ? value : [`${key}=${value}`]\r\n  } else if (\r\n    typeof value === 'number' ||\r\n    typeof value === 'boolean' ||\r\n    value == null\r\n  ) {\r\n    return raw ? value : [`${key}=${value}`]\r\n  } else if (isRef(value)) {\r\n    value = formatProp(key, toRaw(value.value), true)\r\n    return raw ? value : [`${key}=Ref<`, value, `>`]\r\n  } else if (isFunction(value)) {\r\n    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`]\r\n  } else {\r\n    value = toRaw(value)\r\n    return raw ? value : [`${key}=`, value]\r\n  }\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function assertNumber(val: unknown, type: string) {\r\n  if (!__DEV__) return\r\n  if (val === undefined) {\r\n    return\r\n  } else if (typeof val !== 'number') {\r\n    warn(`${type} is not a valid number - ` + `got ${JSON.stringify(val)}.`)\r\n  } else if (isNaN(val)) {\r\n    warn(`${type} is NaN - ` + 'the duration expression might be incorrect.')\r\n  }\r\n}\r\n","import type { VNode } from './vnode'\r\nimport type { ComponentInternalInstance } from './component'\r\nimport { popWarningContext, pushWarningContext, warn } from './warning'\r\nimport { isFunction, isPromise } from '@vue/shared'\r\nimport { LifecycleHooks } from './enums'\r\n\r\n// contexts where user provided function may be executed, in addition to\r\n// lifecycle hooks.\r\nexport enum ErrorCodes {\r\n  SETUP_FUNCTION,\r\n  RENDER_FUNCTION,\r\n  WATCH_GETTER,\r\n  WATCH_CALLBACK,\r\n  WATCH_CLEANUP,\r\n  NATIVE_EVENT_HANDLER,\r\n  COMPONENT_EVENT_HANDLER,\r\n  VNODE_HOOK,\r\n  DIRECTIVE_HOOK,\r\n  TRANSITION_HOOK,\r\n  APP_ERROR_HANDLER,\r\n  APP_WARN_HANDLER,\r\n  FUNCTION_REF,\r\n  ASYNC_COMPONENT_LOADER,\r\n  SCHEDULER,\r\n}\r\n\r\nexport const ErrorTypeStrings: Record<LifecycleHooks | ErrorCodes, string> = {\r\n  [LifecycleHooks.SERVER_PREFETCH]: 'serverPrefetch hook',\r\n  [LifecycleHooks.BEFORE_CREATE]: 'beforeCreate hook',\r\n  [LifecycleHooks.CREATED]: 'created hook',\r\n  [LifecycleHooks.BEFORE_MOUNT]: 'beforeMount hook',\r\n  [LifecycleHooks.MOUNTED]: 'mounted hook',\r\n  [LifecycleHooks.BEFORE_UPDATE]: 'beforeUpdate hook',\r\n  [LifecycleHooks.UPDATED]: 'updated',\r\n  [LifecycleHooks.BEFORE_UNMOUNT]: 'beforeUnmount hook',\r\n  [LifecycleHooks.UNMOUNTED]: 'unmounted hook',\r\n  [LifecycleHooks.ACTIVATED]: 'activated hook',\r\n  [LifecycleHooks.DEACTIVATED]: 'deactivated hook',\r\n  [LifecycleHooks.ERROR_CAPTURED]: 'errorCaptured hook',\r\n  [LifecycleHooks.RENDER_TRACKED]: 'renderTracked hook',\r\n  [LifecycleHooks.RENDER_TRIGGERED]: 'renderTriggered hook',\r\n  [ErrorCodes.SETUP_FUNCTION]: 'setup function',\r\n  [ErrorCodes.RENDER_FUNCTION]: 'render function',\r\n  [ErrorCodes.WATCH_GETTER]: 'watcher getter',\r\n  [ErrorCodes.WATCH_CALLBACK]: 'watcher callback',\r\n  [ErrorCodes.WATCH_CLEANUP]: 'watcher cleanup function',\r\n  [ErrorCodes.NATIVE_EVENT_HANDLER]: 'native event handler',\r\n  [ErrorCodes.COMPONENT_EVENT_HANDLER]: 'component event handler',\r\n  [ErrorCodes.VNODE_HOOK]: 'vnode hook',\r\n  [ErrorCodes.DIRECTIVE_HOOK]: 'directive hook',\r\n  [ErrorCodes.TRANSITION_HOOK]: 'transition hook',\r\n  [ErrorCodes.APP_ERROR_HANDLER]: 'app errorHandler',\r\n  [ErrorCodes.APP_WARN_HANDLER]: 'app warnHandler',\r\n  [ErrorCodes.FUNCTION_REF]: 'ref function',\r\n  [ErrorCodes.ASYNC_COMPONENT_LOADER]: 'async component loader',\r\n  [ErrorCodes.SCHEDULER]:\r\n    'scheduler flush. This is likely a Vue internals bug. ' +\r\n    'Please open an issue at https://github.com/vuejs/core .',\r\n}\r\n\r\nexport type ErrorTypes = LifecycleHooks | ErrorCodes\r\n\r\nexport function callWithErrorHandling(\r\n  fn: Function,\r\n  instance: ComponentInternalInstance | null,\r\n  type: ErrorTypes,\r\n  args?: unknown[],\r\n) {\r\n  let res\r\n  try {\r\n    res = args ? fn(...args) : fn()\r\n  } catch (err) {\r\n    handleError(err, instance, type)\r\n  }\r\n  return res\r\n}\r\n\r\nexport function callWithAsyncErrorHandling(\r\n  fn: Function | Function[],\r\n  instance: ComponentInternalInstance | null,\r\n  type: ErrorTypes,\r\n  args?: unknown[],\r\n): any[] {\r\n  if (isFunction(fn)) {\r\n    const res = callWithErrorHandling(fn, instance, type, args)\r\n    if (res && isPromise(res)) {\r\n      res.catch(err => {\r\n        handleError(err, instance, type)\r\n      })\r\n    }\r\n    return res\r\n  }\r\n\r\n  const values = []\r\n  for (let i = 0; i < fn.length; i++) {\r\n    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args))\r\n  }\r\n  return values\r\n}\r\n\r\nexport function handleError(\r\n  err: unknown,\r\n  instance: ComponentInternalInstance | null,\r\n  type: ErrorTypes,\r\n  throwInDev = true,\r\n) {\r\n  const contextVNode = instance ? instance.vnode : null\r\n  if (instance) {\r\n    let cur = instance.parent\r\n    // the exposed instance is the render proxy to keep it consistent with 2.x\r\n    const exposedInstance = instance.proxy\r\n    // in production the hook receives only the error code\r\n    const errorInfo = __DEV__\r\n      ? ErrorTypeStrings[type]\r\n      : `https://vuejs.org/error-reference/#runtime-${type}`\r\n    while (cur) {\r\n      const errorCapturedHooks = cur.ec\r\n      if (errorCapturedHooks) {\r\n        for (let i = 0; i < errorCapturedHooks.length; i++) {\r\n          if (\r\n            errorCapturedHooks[i](err, exposedInstance, errorInfo) === false\r\n          ) {\r\n            return\r\n          }\r\n        }\r\n      }\r\n      cur = cur.parent\r\n    }\r\n    // app-level handling\r\n    const appErrorHandler = instance.appContext.config.errorHandler\r\n    if (appErrorHandler) {\r\n      callWithErrorHandling(\r\n        appErrorHandler,\r\n        null,\r\n        ErrorCodes.APP_ERROR_HANDLER,\r\n        [err, exposedInstance, errorInfo],\r\n      )\r\n      return\r\n    }\r\n  }\r\n  logError(err, type, contextVNode, throwInDev)\r\n}\r\n\r\nfunction logError(\r\n  err: unknown,\r\n  type: ErrorTypes,\r\n  contextVNode: VNode | null,\r\n  throwInDev = true,\r\n) {\r\n  if (__DEV__) {\r\n    const info = ErrorTypeStrings[type]\r\n    if (contextVNode) {\r\n      pushWarningContext(contextVNode)\r\n    }\r\n    warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`)\r\n    if (contextVNode) {\r\n      popWarningContext()\r\n    }\r\n    // crash in dev by default so it's more noticeable\r\n    if (throwInDev) {\r\n      throw err\r\n    } else if (!__TEST__) {\r\n      console.error(err)\r\n    }\r\n  } else {\r\n    // recover in prod to reduce the impact on end-user\r\n    console.error(err)\r\n  }\r\n}\r\n","import { type VNode, type VNodeChild, isVNode } from './vnode'\r\nimport {\r\n  EffectScope,\r\n  type ReactiveEffect,\r\n  TrackOpTypes,\r\n  isRef,\r\n  markRaw,\r\n  pauseTracking,\r\n  proxyRefs,\r\n  resetTracking,\r\n  shallowReadonly,\r\n  track,\r\n} from '@vue/reactivity'\r\nimport {\r\n  type ComponentPublicInstance,\r\n  type ComponentPublicInstanceConstructor,\r\n  PublicInstanceProxyHandlers,\r\n  RuntimeCompiledPublicInstanceProxyHandlers,\r\n  createDevRenderContext,\r\n  exposePropsOnRenderContext,\r\n  exposeSetupStateOnRenderContext,\r\n  publicPropertiesMap,\r\n} from './componentPublicInstance'\r\nimport {\r\n  type ComponentPropsOptions,\r\n  type NormalizedPropsOptions,\r\n  initProps,\r\n  normalizePropsOptions,\r\n} from './componentProps'\r\nimport {\r\n  type InternalSlots,\r\n  type Slots,\r\n  type SlotsType,\r\n  type UnwrapSlotsType,\r\n  initSlots,\r\n} from './componentSlots'\r\nimport { warn } from './warning'\r\nimport { ErrorCodes, callWithErrorHandling, handleError } from './errorHandling'\r\nimport {\r\n  type AppConfig,\r\n  type AppContext,\r\n  createAppContext,\r\n} from './apiCreateApp'\r\nimport { type Directive, validateDirectiveName } from './directives'\r\nimport {\r\n  type ComponentOptions,\r\n  type ComputedOptions,\r\n  type MethodOptions,\r\n  applyOptions,\r\n  resolveMergedOptions,\r\n} from './componentOptions'\r\nimport {\r\n  type EmitFn,\r\n  type EmitsOptions,\r\n  type EmitsToProps,\r\n  type ObjectEmitsOptions,\r\n  type ShortEmitsToObject,\r\n  emit,\r\n  normalizeEmitsOptions,\r\n} from './componentEmits'\r\nimport {\r\n  EMPTY_OBJ,\r\n  type IfAny,\r\n  NO,\r\n  NOOP,\r\n  ShapeFlags,\r\n  extend,\r\n  getGlobalThis,\r\n  isArray,\r\n  isFunction,\r\n  isObject,\r\n  isPromise,\r\n  makeMap,\r\n} from '@vue/shared'\r\nimport type { SuspenseBoundary } from './components/Suspense'\r\nimport type { CompilerOptions } from '@vue/compiler-core'\r\nimport { markAttrsAccessed } from './componentRenderUtils'\r\nimport { currentRenderingInstance } from './componentRenderContext'\r\nimport { endMeasure, startMeasure } from './profiling'\r\nimport { convertLegacyRenderFn } from './compat/renderFn'\r\nimport {\r\n  type CompatConfig,\r\n  globalCompatConfig,\r\n  validateCompatConfig,\r\n} from './compat/compatConfig'\r\nimport type { SchedulerJob } from './scheduler'\r\nimport type { LifecycleHooks } from './enums'\r\n\r\nexport type Data = Record<string, unknown>\r\n\r\n/**\r\n * Public utility type for extracting the instance type of a component.\r\n * Works with all valid component definition types. This is intended to replace\r\n * the usage of `InstanceType<typeof Comp>` which only works for\r\n * constructor-based component definition types.\r\n *\r\n * Exmaple:\r\n * ```ts\r\n * const MyComp = { ... }\r\n * declare const instance: ComponentInstance<typeof MyComp>\r\n * ```\r\n */\r\nexport type ComponentInstance<T> = T extends { new (): ComponentPublicInstance }\r\n  ? InstanceType<T>\r\n  : T extends FunctionalComponent<infer Props, infer Emits>\r\n    ? ComponentPublicInstance<Props, {}, {}, {}, {}, ShortEmitsToObject<Emits>>\r\n    : T extends Component<\r\n          infer Props,\r\n          infer RawBindings,\r\n          infer D,\r\n          infer C,\r\n          infer M\r\n        >\r\n      ? // NOTE we override Props/RawBindings/D to make sure is not `unknown`\r\n        ComponentPublicInstance<\r\n          unknown extends Props ? {} : Props,\r\n          unknown extends RawBindings ? {} : RawBindings,\r\n          unknown extends D ? {} : D,\r\n          C,\r\n          M\r\n        >\r\n      : never // not a vue Component\r\n\r\n/**\r\n * For extending allowed non-declared props on components in TSX\r\n */\r\nexport interface ComponentCustomProps {}\r\n\r\n/**\r\n * Default allowed non-declared props on component in TSX\r\n */\r\nexport interface AllowedComponentProps {\r\n  class?: unknown\r\n  style?: unknown\r\n}\r\n\r\n// Note: can't mark this whole interface internal because some public interfaces\r\n// extend it.\r\nexport interface ComponentInternalOptions {\r\n  /**\r\n   * @internal\r\n   */\r\n  __scopeId?: string\r\n  /**\r\n   * @internal\r\n   */\r\n  __cssModules?: Data\r\n  /**\r\n   * @internal\r\n   */\r\n  __hmrId?: string\r\n  /**\r\n   * Compat build only, for bailing out of certain compatibility behavior\r\n   */\r\n  __isBuiltIn?: boolean\r\n  /**\r\n   * This one should be exposed so that devtools can make use of it\r\n   */\r\n  __file?: string\r\n  /**\r\n   * name inferred from filename\r\n   */\r\n  __name?: string\r\n}\r\n\r\nexport interface FunctionalComponent<\r\n  P = {},\r\n  E extends EmitsOptions | Record<string, any[]> = {},\r\n  S extends Record<string, any> = any,\r\n  EE extends EmitsOptions = ShortEmitsToObject<E>,\r\n> extends ComponentInternalOptions {\r\n  // use of any here is intentional so it can be a valid JSX Element constructor\r\n  (\r\n    props: P & EmitsToProps<EE>,\r\n    ctx: Omit<SetupContext<EE, IfAny<S, {}, SlotsType<S>>>, 'expose'>,\r\n  ): any\r\n  props?: ComponentPropsOptions<P>\r\n  emits?: EE | (keyof EE)[]\r\n  slots?: IfAny<S, Slots, SlotsType<S>>\r\n  inheritAttrs?: boolean\r\n  displayName?: string\r\n  compatConfig?: CompatConfig\r\n}\r\n\r\nexport interface ClassComponent {\r\n  new (...args: any[]): ComponentPublicInstance<any, any, any, any, any>\r\n  __vccOpts: ComponentOptions\r\n}\r\n\r\n/**\r\n * Concrete component type matches its actual value: it's either an options\r\n * object, or a function. Use this where the code expects to work with actual\r\n * values, e.g. checking if its a function or not. This is mostly for internal\r\n * implementation code.\r\n */\r\nexport type ConcreteComponent<\r\n  Props = {},\r\n  RawBindings = any,\r\n  D = any,\r\n  C extends ComputedOptions = ComputedOptions,\r\n  M extends MethodOptions = MethodOptions,\r\n  E extends EmitsOptions | Record<string, any[]> = {},\r\n  S extends Record<string, any> = any,\r\n> =\r\n  | ComponentOptions<Props, RawBindings, D, C, M>\r\n  | FunctionalComponent<Props, E, S>\r\n\r\n/**\r\n * A type used in public APIs where a component type is expected.\r\n * The constructor type is an artificial type returned by defineComponent().\r\n */\r\nexport type Component<\r\n  Props = any,\r\n  RawBindings = any,\r\n  D = any,\r\n  C extends ComputedOptions = ComputedOptions,\r\n  M extends MethodOptions = MethodOptions,\r\n  E extends EmitsOptions | Record<string, any[]> = {},\r\n  S extends Record<string, any> = any,\r\n> =\r\n  | ConcreteComponent<Props, RawBindings, D, C, M, E, S>\r\n  | ComponentPublicInstanceConstructor<Props>\r\n\r\nexport type { ComponentOptions }\r\n\r\ntype LifecycleHook<TFn = Function> = TFn[] | null\r\n\r\n// use `E extends any` to force evaluating type to fix #2362\r\nexport type SetupContext<\r\n  E = EmitsOptions,\r\n  S extends SlotsType = {},\r\n> = E extends any\r\n  ? {\r\n      attrs: Data\r\n      slots: UnwrapSlotsType<S>\r\n      emit: EmitFn<E>\r\n      expose: (exposed?: Record<string, any>) => void\r\n    }\r\n  : never\r\n\r\n/**\r\n * @internal\r\n */\r\nexport type InternalRenderFunction = {\r\n  (\r\n    ctx: ComponentPublicInstance,\r\n    cache: ComponentInternalInstance['renderCache'],\r\n    // for compiler-optimized bindings\r\n    $props: ComponentInternalInstance['props'],\r\n    $setup: ComponentInternalInstance['setupState'],\r\n    $data: ComponentInternalInstance['data'],\r\n    $options: ComponentInternalInstance['ctx'],\r\n  ): VNodeChild\r\n  _rc?: boolean // isRuntimeCompiled\r\n\r\n  // __COMPAT__ only\r\n  _compatChecked?: boolean // v3 and already checked for v2 compat\r\n  _compatWrapped?: boolean // is wrapped for v2 compat\r\n}\r\n\r\n/**\r\n * We expose a subset of properties on the internal instance as they are\r\n * useful for advanced external libraries and tools.\r\n */\r\nexport interface ComponentInternalInstance {\r\n  uid: number\r\n  type: ConcreteComponent\r\n  parent: ComponentInternalInstance | null\r\n  root: ComponentInternalInstance\r\n  appContext: AppContext\r\n  /**\r\n   * Vnode representing this component in its parent's vdom tree\r\n   */\r\n  vnode: VNode\r\n  /**\r\n   * The pending new vnode from parent updates\r\n   * @internal\r\n   */\r\n  next: VNode | null\r\n  /**\r\n   * Root vnode of this component's own vdom tree\r\n   */\r\n  subTree: VNode\r\n  /**\r\n   * Render effect instance\r\n   */\r\n  effect: ReactiveEffect\r\n  /**\r\n   * Bound effect runner to be passed to schedulers\r\n   */\r\n  update: SchedulerJob\r\n  /**\r\n   * The render function that returns vdom tree.\r\n   * @internal\r\n   */\r\n  render: InternalRenderFunction | null\r\n  /**\r\n   * SSR render function\r\n   * @internal\r\n   */\r\n  ssrRender?: Function | null\r\n  /**\r\n   * Object containing values this component provides for its descendants\r\n   * @internal\r\n   */\r\n  provides: Data\r\n  /**\r\n   * Tracking reactive effects (e.g. watchers) associated with this component\r\n   * so that they can be automatically stopped on component unmount\r\n   * @internal\r\n   */\r\n  scope: EffectScope\r\n  /**\r\n   * cache for proxy access type to avoid hasOwnProperty calls\r\n   * @internal\r\n   */\r\n  accessCache: Data | null\r\n  /**\r\n   * cache for render function values that rely on _ctx but won't need updates\r\n   * after initialized (e.g. inline handlers)\r\n   * @internal\r\n   */\r\n  renderCache: (Function | VNode)[]\r\n\r\n  /**\r\n   * Resolved component registry, only for components with mixins or extends\r\n   * @internal\r\n   */\r\n  components: Record<string, ConcreteComponent> | null\r\n  /**\r\n   * Resolved directive registry, only for components with mixins or extends\r\n   * @internal\r\n   */\r\n  directives: Record<string, Directive> | null\r\n  /**\r\n   * Resolved filters registry, v2 compat only\r\n   * @internal\r\n   */\r\n  filters?: Record<string, Function>\r\n  /**\r\n   * resolved props options\r\n   * @internal\r\n   */\r\n  propsOptions: NormalizedPropsOptions\r\n  /**\r\n   * resolved emits options\r\n   * @internal\r\n   */\r\n  emitsOptions: ObjectEmitsOptions | null\r\n  /**\r\n   * resolved inheritAttrs options\r\n   * @internal\r\n   */\r\n  inheritAttrs?: boolean\r\n  /**\r\n   * is custom element?\r\n   * @internal\r\n   */\r\n  isCE?: boolean\r\n  /**\r\n   * custom element specific HMR method\r\n   * @internal\r\n   */\r\n  ceReload?: (newStyles?: string[]) => void\r\n\r\n  // the rest are only for stateful components ---------------------------------\r\n\r\n  // main proxy that serves as the public instance (`this`)\r\n  proxy: ComponentPublicInstance | null\r\n\r\n  // exposed properties via expose()\r\n  exposed: Record<string, any> | null\r\n  exposeProxy: Record<string, any> | null\r\n\r\n  /**\r\n   * alternative proxy used only for runtime-compiled render functions using\r\n   * `with` block\r\n   * @internal\r\n   */\r\n  withProxy: ComponentPublicInstance | null\r\n  /**\r\n   * This is the target for the public instance proxy. It also holds properties\r\n   * injected by user options (computed, methods etc.) and user-attached\r\n   * custom properties (via `this.x = ...`)\r\n   * @internal\r\n   */\r\n  ctx: Data\r\n\r\n  // state\r\n  data: Data\r\n  props: Data\r\n  attrs: Data\r\n  slots: InternalSlots\r\n  refs: Data\r\n  emit: EmitFn\r\n\r\n  attrsProxy: Data | null\r\n  slotsProxy: Slots | null\r\n\r\n  /**\r\n   * used for keeping track of .once event handlers on components\r\n   * @internal\r\n   */\r\n  emitted: Record<string, boolean> | null\r\n  /**\r\n   * used for caching the value returned from props default factory functions to\r\n   * avoid unnecessary watcher trigger\r\n   * @internal\r\n   */\r\n  propsDefaults: Data\r\n  /**\r\n   * setup related\r\n   * @internal\r\n   */\r\n  setupState: Data\r\n  /**\r\n   * devtools access to additional info\r\n   * @internal\r\n   */\r\n  devtoolsRawSetupState?: any\r\n  /**\r\n   * @internal\r\n   */\r\n  setupContext: SetupContext | null\r\n\r\n  /**\r\n   * suspense related\r\n   * @internal\r\n   */\r\n  suspense: SuspenseBoundary | null\r\n  /**\r\n   * suspense pending batch id\r\n   * @internal\r\n   */\r\n  suspenseId: number\r\n  /**\r\n   * @internal\r\n   */\r\n  asyncDep: Promise<any> | null\r\n  /**\r\n   * @internal\r\n   */\r\n  asyncResolved: boolean\r\n\r\n  // lifecycle\r\n  isMounted: boolean\r\n  isUnmounted: boolean\r\n  isDeactivated: boolean\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.BEFORE_CREATE]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.CREATED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.BEFORE_MOUNT]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.MOUNTED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.BEFORE_UPDATE]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.UPDATED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.BEFORE_UNMOUNT]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.UNMOUNTED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.RENDER_TRACKED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.RENDER_TRIGGERED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.ACTIVATED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.DEACTIVATED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.ERROR_CAPTURED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.SERVER_PREFETCH]: LifecycleHook<() => Promise<unknown>>\r\n\r\n  /**\r\n   * For caching bound $forceUpdate on public proxy access\r\n   * @internal\r\n   */\r\n  f?: () => void\r\n  /**\r\n   * For caching bound $nextTick on public proxy access\r\n   * @internal\r\n   */\r\n  n?: () => Promise<void>\r\n  /**\r\n   * `updateTeleportCssVars`\r\n   * For updating css vars on contained teleports\r\n   * @internal\r\n   */\r\n  ut?: (vars?: Record<string, string>) => void\r\n}\r\n\r\nconst emptyAppContext = createAppContext()\r\n\r\nlet uid = 0\r\n\r\nexport function createComponentInstance(\r\n  vnode: VNode,\r\n  parent: ComponentInternalInstance | null,\r\n  suspense: SuspenseBoundary | null,\r\n) {\r\n  const type = vnode.type as ConcreteComponent\r\n  // inherit parent app context - or - if root, adopt from root vnode\r\n  const appContext =\r\n    (parent ? parent.appContext : vnode.appContext) || emptyAppContext\r\n\r\n  // 定义的组件（ConcreteComponent）--> 创建虚拟Dom（VNode，包含了context） --> 创建组件实例（包含type/vnode）\r\n  const instance: ComponentInternalInstance = {\r\n    uid: uid++, // 组件的唯一标识\r\n    vnode, // 虚拟dom\r\n    type, // 用户定义的组件\r\n    parent,\r\n    appContext,//全局的context上下文\r\n    root: null!, // to be immediately set\r\n    next: null,\r\n    subTree: null!, // will be set synchronously right after creation\r\n    effect: null!,\r\n    update: null!, // will be set synchronously right after creation\r\n    scope: new EffectScope(true /* detached */),\r\n    render: null,\r\n    proxy: null,\r\n    exposed: null,\r\n    exposeProxy: null,\r\n    withProxy: null,\r\n    provides: parent ? parent.provides : Object.create(appContext.provides),\r\n    accessCache: null!,\r\n    renderCache: [],\r\n\r\n    // local resolved assets\r\n    components: null,\r\n    directives: null,\r\n\r\n    // resolved props and emits options\r\n    propsOptions: normalizePropsOptions(type, appContext),\r\n    emitsOptions: normalizeEmitsOptions(type, appContext),\r\n\r\n    // emit\r\n    emit: null!, // to be set immediately\r\n    emitted: null,\r\n\r\n    // props default value\r\n    propsDefaults: EMPTY_OBJ,\r\n\r\n    // inheritAttrs\r\n    inheritAttrs: type.inheritAttrs,\r\n\r\n    // state\r\n    ctx: EMPTY_OBJ,\r\n    data: EMPTY_OBJ,\r\n    props: EMPTY_OBJ,\r\n    attrs: EMPTY_OBJ,\r\n    slots: EMPTY_OBJ,\r\n    refs: EMPTY_OBJ,\r\n    setupState: EMPTY_OBJ,\r\n    setupContext: null,\r\n\r\n    attrsProxy: null,\r\n    slotsProxy: null,\r\n\r\n    // suspense related\r\n    suspense,\r\n    suspenseId: suspense ? suspense.pendingId : 0,\r\n    asyncDep: null,\r\n    asyncResolved: false,\r\n\r\n    // lifecycle hooks\r\n    // not using enums here because it results in computed properties\r\n    isMounted: false,\r\n    isUnmounted: false,\r\n    isDeactivated: false,\r\n    bc: null,\r\n    c: null,\r\n    bm: null,\r\n    m: null,\r\n    bu: null,\r\n    u: null,\r\n    um: null,\r\n    bum: null,\r\n    da: null,\r\n    a: null,\r\n    rtg: null,\r\n    rtc: null,\r\n    ec: null,\r\n    sp: null,\r\n  }\r\n  // 将组件实例本身作为ctx字段的值存储起来\r\n  if (__DEV__) {\r\n    instance.ctx = createDevRenderContext(instance)\r\n  } else {\r\n    instance.ctx = { _: instance }\r\n  }\r\n  instance.root = parent ? parent.root : instance\r\n  instance.emit = emit.bind(null, instance)\r\n\r\n  // apply custom element special handling\r\n  if (vnode.ce) {\r\n    vnode.ce(instance)\r\n  }\r\n\r\n  return instance\r\n}\r\n\r\nexport let currentInstance: ComponentInternalInstance | null = null\r\n\r\nexport const getCurrentInstance: () => ComponentInternalInstance | null = () =>\r\n  currentInstance || currentRenderingInstance\r\n\r\nlet internalSetCurrentInstance: (\r\n  instance: ComponentInternalInstance | null,\r\n) => void\r\nlet setInSSRSetupState: (state: boolean) => void\r\n\r\n/**\r\n * The following makes getCurrentInstance() usage across multiple copies of Vue\r\n * work. Some cases of how this can happen are summarized in #7590. In principle\r\n * the duplication should be avoided, but in practice there are often cases\r\n * where the user is unable to resolve on their own, especially in complicated\r\n * SSR setups.\r\n *\r\n * Note this fix is technically incomplete, as we still rely on other singletons\r\n * for effectScope and global reactive dependency maps. However, it does make\r\n * some of the most common cases work. It also warns if the duplication is\r\n * found during browser execution.\r\n */\r\nif (__SSR__) {\r\n  type Setter = (v: any) => void\r\n  const g = getGlobalThis()\r\n  const registerGlobalSetter = (key: string, setter: Setter) => {\r\n    let setters: Setter[]\r\n    if (!(setters = g[key])) setters = g[key] = []\r\n    setters.push(setter)\r\n    return (v: any) => {\r\n      if (setters.length > 1) setters.forEach(set => set(v))\r\n      else setters[0](v)\r\n    }\r\n  }\r\n  internalSetCurrentInstance = registerGlobalSetter(\r\n    `__VUE_INSTANCE_SETTERS__`,\r\n    v => (currentInstance = v),\r\n  )\r\n  // also make `isInSSRComponentSetup` sharable across copies of Vue.\r\n  // this is needed in the SFC playground when SSRing async components, since\r\n  // we have to load both the runtime and the server-renderer from CDNs, they\r\n  // contain duplicated copies of Vue runtime code.\r\n  setInSSRSetupState = registerGlobalSetter(\r\n    `__VUE_SSR_SETTERS__`,\r\n    v => (isInSSRComponentSetup = v),\r\n  )\r\n} else {\r\n  internalSetCurrentInstance = i => {\r\n    currentInstance = i\r\n  }\r\n  setInSSRSetupState = v => {\r\n    isInSSRComponentSetup = v\r\n  }\r\n}\r\n\r\nexport const setCurrentInstance = (instance: ComponentInternalInstance) => {\r\n  const prev = currentInstance\r\n  internalSetCurrentInstance(instance)\r\n  instance.scope.on()\r\n  return () => {\r\n    instance.scope.off()\r\n    internalSetCurrentInstance(prev)\r\n  }\r\n}\r\n\r\nexport const unsetCurrentInstance = () => {\r\n  currentInstance && currentInstance.scope.off()\r\n  internalSetCurrentInstance(null)\r\n}\r\n\r\nconst isBuiltInTag = /*#__PURE__*/ makeMap('slot,component')\r\n\r\nexport function validateComponentName(name: string, config: AppConfig) {\r\n  const appIsNativeTag = config.isNativeTag || NO\r\n  if (isBuiltInTag(name) || appIsNativeTag(name)) {\r\n    warn(\r\n      'Do not use built-in or reserved HTML elements as component id: ' + name,\r\n    )\r\n  }\r\n}\r\n\r\nexport function isStatefulComponent(instance: ComponentInternalInstance) {\r\n  return instance.vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT\r\n}\r\n\r\nexport let isInSSRComponentSetup = false\r\n\r\nexport function setupComponent(\r\n  instance: ComponentInternalInstance,\r\n  isSSR = false,\r\n) {\r\n  isSSR && setInSSRSetupState(isSSR)\r\n\r\n  const { props, children } = instance.vnode\r\n  // 是否是一个有状态的组件\r\n  const isStateful = isStatefulComponent(instance)\r\n  initProps(instance, props, isStateful, isSSR)\r\n  initSlots(instance, children)\r\n\r\n  const setupResult = isStateful\r\n    ? setupStatefulComponent(instance, isSSR)\r\n    : undefined\r\n\r\n  isSSR && setInSSRSetupState(false)\r\n  return setupResult\r\n}\r\n\r\nfunction setupStatefulComponent(\r\n  instance: ComponentInternalInstance,\r\n  isSSR: boolean,\r\n) {\r\n  const Component = instance.type as ComponentOptions\r\n\r\n  if (__DEV__) {\r\n    if (Component.name) {\r\n      validateComponentName(Component.name, instance.appContext.config)\r\n    }\r\n    if (Component.components) {\r\n      const names = Object.keys(Component.components)\r\n      for (let i = 0; i < names.length; i++) {\r\n        validateComponentName(names[i], instance.appContext.config)\r\n      }\r\n    }\r\n    if (Component.directives) {\r\n      const names = Object.keys(Component.directives)\r\n      for (let i = 0; i < names.length; i++) {\r\n        validateDirectiveName(names[i])\r\n      }\r\n    }\r\n    if (Component.compilerOptions && isRuntimeOnly()) {\r\n      warn(\r\n        `\"compilerOptions\" is only supported when using a build of Vue that ` +\r\n          `includes the runtime compiler. Since you are using a runtime-only ` +\r\n          `build, the options should be passed via your build tool config instead.`,\r\n      )\r\n    }\r\n  }\r\n  // 0. create render proxy property access cache\r\n  // 组件的属性访问缓存\r\n  instance.accessCache = Object.create(null)\r\n  // 1. create public instance / render proxy\r\n  // also mark it raw so it's never observed\r\n  /**\r\n   * 给ctx创建一个代理对象，并标识为非响应式，赋值给proxy字段\r\n   * 代理的处理对象为PublicInstanceProxyHandlers\r\n   */\r\n  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers))\r\n  if (__DEV__) {\r\n    exposePropsOnRenderContext(instance)\r\n  }\r\n  // 2. call setup()\r\n  const { setup } = Component\r\n  // 如果存在setup函数就调用setup函数\r\n  if (setup) {\r\n    const setupContext = (instance.setupContext =\r\n      setup.length > 1 ? createSetupContext(instance) : null)\r\n\r\n    const reset = setCurrentInstance(instance)\r\n    pauseTracking()\r\n    const setupResult = callWithErrorHandling(\r\n      setup,\r\n      instance,\r\n      ErrorCodes.SETUP_FUNCTION,\r\n      [\r\n        __DEV__ ? shallowReadonly(instance.props) : instance.props,\r\n        setupContext,\r\n      ],\r\n    )\r\n    resetTracking()\r\n    reset()\r\n\r\n    if (isPromise(setupResult)) {\r\n      setupResult.then(unsetCurrentInstance, unsetCurrentInstance)\r\n      if (isSSR) {\r\n        // return the promise so server-renderer can wait on it\r\n        return setupResult\r\n          .then((resolvedResult: unknown) => {\r\n            handleSetupResult(instance, resolvedResult, isSSR)\r\n          })\r\n          .catch(e => {\r\n            handleError(e, instance, ErrorCodes.SETUP_FUNCTION)\r\n          })\r\n      } else if (__FEATURE_SUSPENSE__) {\r\n        // async setup returned Promise.\r\n        // bail here and wait for re-entry.\r\n        instance.asyncDep = setupResult\r\n        if (__DEV__ && !instance.suspense) {\r\n          const name = Component.name ?? 'Anonymous'\r\n          warn(\r\n            `Component <${name}>: setup function returned a promise, but no ` +\r\n              `<Suspense> boundary was found in the parent component tree. ` +\r\n              `A component with async setup() must be nested in a <Suspense> ` +\r\n              `in order to be rendered.`,\r\n          )\r\n        }\r\n      } else if (__DEV__) {\r\n        warn(\r\n          `setup() returned a Promise, but the version of Vue you are using ` +\r\n            `does not support it yet.`,\r\n        )\r\n      }\r\n    } else {\r\n      handleSetupResult(instance, setupResult, isSSR)\r\n    }\r\n  } else {\r\n    finishComponentSetup(instance, isSSR)\r\n  }\r\n}\r\n\r\nexport function handleSetupResult(\r\n  instance: ComponentInternalInstance,\r\n  setupResult: unknown,\r\n  isSSR: boolean,\r\n) {\r\n  if (isFunction(setupResult)) {\r\n    // setup returned an inline render function\r\n    if (__SSR__ && (instance.type as ComponentOptions).__ssrInlineRender) {\r\n      // when the function's name is `ssrRender` (compiled by SFC inline mode),\r\n      // set it as ssrRender instead.\r\n      instance.ssrRender = setupResult\r\n    } else {\r\n      instance.render = setupResult as InternalRenderFunction\r\n    }\r\n  } else if (isObject(setupResult)) {\r\n    if (__DEV__ && isVNode(setupResult)) {\r\n      warn(\r\n        `setup() should not return VNodes directly - ` +\r\n          `return a render function instead.`,\r\n      )\r\n    }\r\n    // setup returned bindings.\r\n    // assuming a render function compiled from template is present.\r\n    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n      instance.devtoolsRawSetupState = setupResult\r\n    }\r\n    instance.setupState = proxyRefs(setupResult)\r\n    if (__DEV__) {\r\n      exposeSetupStateOnRenderContext(instance)\r\n    }\r\n  } else if (__DEV__ && setupResult !== undefined) {\r\n    warn(\r\n      `setup() should return an object. Received: ${\r\n        setupResult === null ? 'null' : typeof setupResult\r\n      }`,\r\n    )\r\n  }\r\n  finishComponentSetup(instance, isSSR)\r\n}\r\n\r\ntype CompileFunction = (\r\n  template: string | object,\r\n  options?: CompilerOptions,\r\n) => InternalRenderFunction\r\n\r\nlet compile: CompileFunction | undefined\r\nlet installWithProxy: (i: ComponentInternalInstance) => void\r\n\r\n/**\r\n * For runtime-dom to register the compiler.\r\n * Note the exported method uses any to avoid d.ts relying on the compiler types.\r\n */\r\nexport function registerRuntimeCompiler(_compile: any) {\r\n  compile = _compile\r\n  installWithProxy = i => {\r\n    if (i.render!._rc) {\r\n      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers)\r\n    }\r\n  }\r\n}\r\n\r\n// dev only\r\nexport const isRuntimeOnly = () => !compile\r\n\r\n/**\r\n * 先执行组件的setup方法，然后判断组件是否有render函数，如果没有render函数，通过template构建render函数\r\n * \r\n */\r\nexport function finishComponentSetup(\r\n  instance: ComponentInternalInstance,\r\n  isSSR: boolean,\r\n  skipOptions?: boolean,\r\n) {\r\n  const Component = instance.type as ComponentOptions\r\n\r\n  if (__COMPAT__) {\r\n    convertLegacyRenderFn(instance)\r\n\r\n    if (__DEV__ && Component.compatConfig) {\r\n      validateCompatConfig(Component.compatConfig)\r\n    }\r\n  }\r\n\r\n  // template / render function normalization\r\n  // could be already set when returned from setup()\r\n  if (!instance.render) {\r\n    // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation\r\n    // is done by server-renderer\r\n    if (!isSSR && compile && !Component.render) {\r\n      const template =\r\n        (__COMPAT__ &&\r\n          instance.vnode.props &&\r\n          instance.vnode.props['inline-template']) ||\r\n        Component.template ||\r\n        resolveMergedOptions(instance).template\r\n      if (template) {\r\n        if (__DEV__) {\r\n          startMeasure(instance, `compile`)\r\n        }\r\n        const { isCustomElement, compilerOptions } = instance.appContext.config\r\n        const { delimiters, compilerOptions: componentCompilerOptions } =\r\n          Component\r\n        const finalCompilerOptions: CompilerOptions = extend(\r\n          extend(\r\n            {\r\n              isCustomElement,\r\n              delimiters,\r\n            },\r\n            compilerOptions,\r\n          ),\r\n          componentCompilerOptions,\r\n        )\r\n        if (__COMPAT__) {\r\n          // pass runtime compat config into the compiler\r\n          finalCompilerOptions.compatConfig = Object.create(globalCompatConfig)\r\n          if (Component.compatConfig) {\r\n            // @ts-expect-error types are not compatible\r\n            extend(finalCompilerOptions.compatConfig, Component.compatConfig)\r\n          }\r\n        }\r\n        /**\r\n         * 生成render渲染函数\r\n         * 如果template是dom元素，就取dom元素的innerHtml\r\n         * 如果是dom元素的id，就取该dom元素的innerHtml\r\n         * 最后生成render函数\r\n         */\r\n        Component.render = compile(template, finalCompilerOptions)\r\n        if (__DEV__) {\r\n          endMeasure(instance, `compile`)\r\n        }\r\n      }\r\n    }\r\n\r\n    instance.render = (Component.render || NOOP) as InternalRenderFunction\r\n\r\n    // for runtime-compiled render functions using `with` blocks, the render\r\n    // proxy used needs a different `has` handler which is more performant and\r\n    // also only allows a whitelist of globals to fallthrough.\r\n    if (installWithProxy) {\r\n      installWithProxy(instance)\r\n    }\r\n  }\r\n\r\n  // support for 2.x options\r\n  if (__FEATURE_OPTIONS_API__ && !(__COMPAT__ && skipOptions)) {\r\n    const reset = setCurrentInstance(instance)\r\n    pauseTracking()\r\n    try {\r\n      applyOptions(instance)\r\n    } finally {\r\n      resetTracking()\r\n      reset()\r\n    }\r\n  }\r\n\r\n  // warn missing template/render\r\n  // the runtime compilation of template in SSR is done by server-render\r\n  if (__DEV__ && !Component.render && instance.render === NOOP && !isSSR) {\r\n    /* istanbul ignore if */\r\n    if (!compile && Component.template) {\r\n      warn(\r\n        `Component provided template option but ` +\r\n          `runtime compilation is not supported in this build of Vue.` +\r\n          (__ESM_BUNDLER__\r\n            ? ` Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".`\r\n            : __ESM_BROWSER__\r\n              ? ` Use \"vue.esm-browser.js\" instead.`\r\n              : __GLOBAL__\r\n                ? ` Use \"vue.global.js\" instead.`\r\n                : ``) /* should not happen */,\r\n      )\r\n    } else {\r\n      warn(`Component is missing template or render function.`)\r\n    }\r\n  }\r\n}\r\n\r\nfunction getAttrsProxy(instance: ComponentInternalInstance): Data {\r\n  return (\r\n    instance.attrsProxy ||\r\n    (instance.attrsProxy = new Proxy(\r\n      instance.attrs,\r\n      __DEV__\r\n        ? {\r\n            get(target, key: string) {\r\n              markAttrsAccessed()\r\n              track(instance, TrackOpTypes.GET, '$attrs')\r\n              return target[key]\r\n            },\r\n            set() {\r\n              warn(`setupContext.attrs is readonly.`)\r\n              return false\r\n            },\r\n            deleteProperty() {\r\n              warn(`setupContext.attrs is readonly.`)\r\n              return false\r\n            },\r\n          }\r\n        : {\r\n            get(target, key: string) {\r\n              track(instance, TrackOpTypes.GET, '$attrs')\r\n              return target[key]\r\n            },\r\n          },\r\n    ))\r\n  )\r\n}\r\n\r\n/**\r\n * Dev-only\r\n */\r\nfunction getSlotsProxy(instance: ComponentInternalInstance): Slots {\r\n  return (\r\n    instance.slotsProxy ||\r\n    (instance.slotsProxy = new Proxy(instance.slots, {\r\n      get(target, key: string) {\r\n        track(instance, TrackOpTypes.GET, '$slots')\r\n        return target[key]\r\n      },\r\n    }))\r\n  )\r\n}\r\n\r\nexport function createSetupContext(\r\n  instance: ComponentInternalInstance,\r\n): SetupContext {\r\n  const expose: SetupContext['expose'] = exposed => {\r\n    if (__DEV__) {\r\n      if (instance.exposed) {\r\n        warn(`expose() should be called only once per setup().`)\r\n      }\r\n      if (exposed != null) {\r\n        let exposedType: string = typeof exposed\r\n        if (exposedType === 'object') {\r\n          if (isArray(exposed)) {\r\n            exposedType = 'array'\r\n          } else if (isRef(exposed)) {\r\n            exposedType = 'ref'\r\n          }\r\n        }\r\n        if (exposedType !== 'object') {\r\n          warn(\r\n            `expose() should be passed a plain object, received ${exposedType}.`,\r\n          )\r\n        }\r\n      }\r\n    }\r\n    instance.exposed = exposed || {}\r\n  }\r\n\r\n  if (__DEV__) {\r\n    // We use getters in dev in case libs like test-utils overwrite instance\r\n    // properties (overwrites should not be done in prod)\r\n    return Object.freeze({\r\n      get attrs() {\r\n        return getAttrsProxy(instance)\r\n      },\r\n      get slots() {\r\n        return getSlotsProxy(instance)\r\n      },\r\n      get emit() {\r\n        return (event: string, ...args: any[]) => instance.emit(event, ...args)\r\n      },\r\n      expose,\r\n    })\r\n  } else {\r\n    return {\r\n      get attrs() {\r\n        return getAttrsProxy(instance)\r\n      },\r\n      slots: instance.slots,\r\n      emit: instance.emit,\r\n      expose,\r\n    }\r\n  }\r\n}\r\n\r\nexport function getExposeProxy(instance: ComponentInternalInstance) {\r\n  if (instance.exposed) {\r\n    return (\r\n      instance.exposeProxy ||\r\n      (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {\r\n        get(target, key: string) {\r\n          if (key in target) {\r\n            return target[key]\r\n          } else if (key in publicPropertiesMap) {\r\n            return publicPropertiesMap[key](instance)\r\n          }\r\n        },\r\n        has(target, key: string) {\r\n          return key in target || key in publicPropertiesMap\r\n        },\r\n      }))\r\n    )\r\n  }\r\n}\r\n\r\nconst classifyRE = /(?:^|[-_])(\\w)/g\r\nconst classify = (str: string): string =>\r\n  str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '')\r\n\r\nexport function getComponentName(\r\n  Component: ConcreteComponent,\r\n  includeInferred = true,\r\n): string | false | undefined {\r\n  return isFunction(Component)\r\n    ? Component.displayName || Component.name\r\n    : Component.name || (includeInferred && Component.__name)\r\n}\r\n\r\n/* istanbul ignore next */\r\nexport function formatComponentName(\r\n  instance: ComponentInternalInstance | null,\r\n  Component: ConcreteComponent,\r\n  isRoot = false,\r\n): string {\r\n  let name = getComponentName(Component)\r\n  if (!name && Component.__file) {\r\n    const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/)\r\n    if (match) {\r\n      name = match[1]\r\n    }\r\n  }\r\n\r\n  if (!name && instance && instance.parent) {\r\n    // try to infer the name based on reverse resolution\r\n    const inferFromRegistry = (registry: Record<string, any> | undefined) => {\r\n      for (const key in registry) {\r\n        if (registry[key] === Component) {\r\n          return key\r\n        }\r\n      }\r\n    }\r\n    name =\r\n      inferFromRegistry(\r\n        instance.components ||\r\n          (instance.parent.type as ComponentOptions).components,\r\n      ) || inferFromRegistry(instance.appContext.components)\r\n  }\r\n\r\n  return name ? classify(name) : isRoot ? `App` : `Anonymous`\r\n}\r\n\r\nexport function isClassComponent(value: unknown): value is ClassComponent {\r\n  return isFunction(value) && '__vccOpts' in value\r\n}\r\n","// Core API ------------------------------------------------------------------\r\n\r\nexport const version = __VERSION__\r\nexport {\r\n  // core\r\n  reactive,\r\n  ref,\r\n  readonly,\r\n  // utilities\r\n  unref,\r\n  proxyRefs,\r\n  isRef,\r\n  toRef,\r\n  toValue,\r\n  toRefs,\r\n  isProxy,\r\n  isReactive,\r\n  isReadonly,\r\n  isShallow,\r\n  // advanced\r\n  customRef,\r\n  triggerRef,\r\n  shallowRef,\r\n  shallowReactive,\r\n  shallowReadonly,\r\n  markRaw,\r\n  toRaw,\r\n  // effect\r\n  effect,\r\n  stop,\r\n  ReactiveEffect,\r\n  // effect scope\r\n  effectScope,\r\n  EffectScope,\r\n  getCurrentScope,\r\n  onScopeDispose,\r\n} from '@vue/reactivity'\r\nexport { computed } from './apiComputed'\r\nexport {\r\n  watch,\r\n  watchEffect,\r\n  watchPostEffect,\r\n  watchSyncEffect,\r\n} from './apiWatch'\r\nexport {\r\n  onBeforeMount,\r\n  onMounted,\r\n  onBeforeUpdate,\r\n  onUpdated,\r\n  onBeforeUnmount,\r\n  onUnmounted,\r\n  onActivated,\r\n  onDeactivated,\r\n  onRenderTracked,\r\n  onRenderTriggered,\r\n  onErrorCaptured,\r\n  onServerPrefetch,\r\n} from './apiLifecycle'\r\nexport { provide, inject, hasInjectionContext } from './apiInject'\r\nexport { nextTick } from './scheduler'\r\nexport { defineComponent } from './apiDefineComponent'\r\nexport { defineAsyncComponent } from './apiAsyncComponent'\r\nexport { useAttrs, useSlots } from './apiSetupHelpers'\r\nexport { useModel } from './helpers/useModel'\r\n\r\n// <script setup> API ----------------------------------------------------------\r\n\r\nexport {\r\n  // macros runtime, for typing and warnings only\r\n  defineProps,\r\n  defineEmits,\r\n  defineExpose,\r\n  defineOptions,\r\n  defineSlots,\r\n  defineModel,\r\n  withDefaults,\r\n  type DefineProps,\r\n  type ModelRef,\r\n} from './apiSetupHelpers'\r\n\r\n/**\r\n * @internal\r\n */\r\nexport {\r\n  mergeDefaults,\r\n  mergeModels,\r\n  createPropsRestProxy,\r\n  withAsyncContext,\r\n} from './apiSetupHelpers'\r\n\r\n// Advanced API ----------------------------------------------------------------\r\n\r\n// For getting a hold of the internal instance in setup() - useful for advanced\r\n// plugins\r\nexport { getCurrentInstance } from './component'\r\n\r\n// For raw render function users\r\nexport { h } from './h'\r\n// Advanced render function utilities\r\nexport { createVNode, cloneVNode, mergeProps, isVNode } from './vnode'\r\n// VNode types\r\nexport { Fragment, Text, Comment, Static, type VNodeRef } from './vnode'\r\n// Built-in components\r\nexport { Teleport, type TeleportProps } from './components/Teleport'\r\nexport { Suspense, type SuspenseProps } from './components/Suspense'\r\nexport { KeepAlive, type KeepAliveProps } from './components/KeepAlive'\r\nexport {\r\n  BaseTransition,\r\n  BaseTransitionPropsValidators,\r\n  type BaseTransitionProps,\r\n} from './components/BaseTransition'\r\n// For using custom directives\r\nexport { withDirectives } from './directives'\r\n// SSR context\r\nexport { useSSRContext, ssrContextKey } from './helpers/useSsrContext'\r\n\r\n// Custom Renderer API ---------------------------------------------------------\r\n\r\nexport { createRenderer, createHydrationRenderer } from './renderer'\r\nexport { queuePostFlushCb } from './scheduler'\r\nimport { warn as _warn } from './warning'\r\nexport const warn = (__DEV__ ? _warn : NOOP) as typeof _warn\r\n\r\n/** @internal */\r\nexport { assertNumber } from './warning'\r\nexport {\r\n  handleError,\r\n  callWithErrorHandling,\r\n  callWithAsyncErrorHandling,\r\n  ErrorCodes,\r\n} from './errorHandling'\r\nexport {\r\n  resolveComponent,\r\n  resolveDirective,\r\n  resolveDynamicComponent,\r\n} from './helpers/resolveAssets'\r\n// For integration with runtime compiler\r\nexport { registerRuntimeCompiler, isRuntimeOnly } from './component'\r\nexport {\r\n  useTransitionState,\r\n  resolveTransitionHooks,\r\n  setTransitionHooks,\r\n  getTransitionRawChildren,\r\n} from './components/BaseTransition'\r\nexport { initCustomFormatter } from './customFormatter'\r\n\r\nimport { ErrorTypeStrings as _ErrorTypeStrings } from './errorHandling'\r\n/**\r\n * Runtime error messages. Only exposed in dev or esm builds.\r\n * @internal\r\n */\r\nexport const ErrorTypeStrings = (\r\n  __ESM_BUNDLER__ || __CJS__ || __DEV__ ? _ErrorTypeStrings : null\r\n) as typeof _ErrorTypeStrings\r\n\r\n// For devtools\r\nimport {\r\n  type DevtoolsHook,\r\n  devtools as _devtools,\r\n  setDevtoolsHook as _setDevtoolsHook,\r\n} from './devtools'\r\n\r\nexport const devtools = (\r\n  __DEV__ || __ESM_BUNDLER__ ? _devtools : undefined\r\n) as DevtoolsHook\r\nexport const setDevtoolsHook = (\r\n  __DEV__ || __ESM_BUNDLER__ ? _setDevtoolsHook : NOOP\r\n) as typeof _setDevtoolsHook\r\n\r\n// Types -----------------------------------------------------------------------\r\n\r\nimport type { VNode } from './vnode'\r\nimport type { ComponentInternalInstance } from './component'\r\n\r\n// Augment Ref unwrap bail types.\r\ndeclare module '@vue/reactivity' {\r\n  export interface RefUnwrapBailTypes {\r\n    runtimeCoreBailTypes:\r\n      | VNode\r\n      | {\r\n          // directly bailing on ComponentPublicInstance results in recursion\r\n          // so we use this as a bail hint\r\n          $: ComponentInternalInstance\r\n        }\r\n  }\r\n}\r\n\r\nexport { TrackOpTypes, TriggerOpTypes } from '@vue/reactivity'\r\nexport type {\r\n  Ref,\r\n  MaybeRef,\r\n  MaybeRefOrGetter,\r\n  ToRef,\r\n  ToRefs,\r\n  UnwrapRef,\r\n  ShallowRef,\r\n  ShallowUnwrapRef,\r\n  CustomRefFactory,\r\n  ReactiveFlags,\r\n  DeepReadonly,\r\n  ShallowReactive,\r\n  UnwrapNestedRefs,\r\n  ComputedRef,\r\n  WritableComputedRef,\r\n  WritableComputedOptions,\r\n  ComputedGetter,\r\n  ComputedSetter,\r\n  ReactiveEffectRunner,\r\n  ReactiveEffectOptions,\r\n  EffectScheduler,\r\n  DebuggerOptions,\r\n  DebuggerEvent,\r\n  DebuggerEventExtraInfo,\r\n  Raw,\r\n} from '@vue/reactivity'\r\nexport type {\r\n  WatchEffect,\r\n  WatchOptions,\r\n  WatchOptionsBase,\r\n  WatchCallback,\r\n  WatchSource,\r\n  WatchStopHandle,\r\n} from './apiWatch'\r\nexport type { InjectionKey } from './apiInject'\r\nexport type {\r\n  App,\r\n  AppConfig,\r\n  AppContext,\r\n  Plugin,\r\n  ObjectPlugin,\r\n  FunctionPlugin,\r\n  CreateAppFunction,\r\n  OptionMergeFunction,\r\n} from './apiCreateApp'\r\nexport type {\r\n  VNode,\r\n  VNodeChild,\r\n  VNodeTypes,\r\n  VNodeProps,\r\n  VNodeArrayChildren,\r\n  VNodeNormalizedChildren,\r\n} from './vnode'\r\nexport type {\r\n  Component,\r\n  ConcreteComponent,\r\n  FunctionalComponent,\r\n  ComponentInternalInstance,\r\n  SetupContext,\r\n  ComponentCustomProps,\r\n  AllowedComponentProps,\r\n  ComponentInstance,\r\n} from './component'\r\nexport type { DefineComponent, PublicProps } from './apiDefineComponent'\r\nexport type {\r\n  ComponentOptions,\r\n  ComponentOptionsMixin,\r\n  ComponentOptionsWithoutProps,\r\n  ComponentOptionsWithObjectProps,\r\n  ComponentOptionsWithArrayProps,\r\n  ComponentCustomOptions,\r\n  ComponentOptionsBase,\r\n  ComponentProvideOptions,\r\n  RenderFunction,\r\n  MethodOptions,\r\n  ComputedOptions,\r\n  RuntimeCompilerOptions,\r\n  ComponentInjectOptions,\r\n} from './componentOptions'\r\nexport type { EmitsOptions, ObjectEmitsOptions } from './componentEmits'\r\nexport type {\r\n  ComponentPublicInstance,\r\n  ComponentCustomProperties,\r\n  CreateComponentPublicInstance,\r\n} from './componentPublicInstance'\r\nexport type {\r\n  Renderer,\r\n  RendererNode,\r\n  RendererElement,\r\n  HydrationRenderer,\r\n  RendererOptions,\r\n  RootRenderFunction,\r\n  ElementNamespace,\r\n} from './renderer'\r\nexport type { RootHydrateFunction } from './hydration'\r\nexport type { Slot, Slots, SlotsType } from './componentSlots'\r\nexport type {\r\n  Prop,\r\n  PropType,\r\n  ComponentPropsOptions,\r\n  ComponentObjectPropsOptions,\r\n  ExtractPropTypes,\r\n  ExtractPublicPropTypes,\r\n  ExtractDefaultPropTypes,\r\n} from './componentProps'\r\nexport type {\r\n  Directive,\r\n  DirectiveBinding,\r\n  DirectiveHook,\r\n  ObjectDirective,\r\n  FunctionDirective,\r\n  DirectiveArguments,\r\n} from './directives'\r\nexport type { SuspenseBoundary } from './components/Suspense'\r\nexport type {\r\n  TransitionState,\r\n  TransitionHooks,\r\n} from './components/BaseTransition'\r\nexport type {\r\n  AsyncComponentOptions,\r\n  AsyncComponentLoader,\r\n} from './apiAsyncComponent'\r\nexport type { HMRRuntime } from './hmr'\r\n\r\n// Internal API ----------------------------------------------------------------\r\n\r\n// **IMPORTANT** Internal APIs may change without notice between versions and\r\n// user code should avoid relying on them.\r\n\r\n// For compiler generated code\r\n// should sync with '@vue/compiler-core/src/runtimeHelpers.ts'\r\nexport {\r\n  withCtx,\r\n  pushScopeId,\r\n  popScopeId,\r\n  withScopeId,\r\n} from './componentRenderContext'\r\nexport { renderList } from './helpers/renderList'\r\nexport { toHandlers } from './helpers/toHandlers'\r\nexport { renderSlot } from './helpers/renderSlot'\r\nexport { createSlots } from './helpers/createSlots'\r\nexport { withMemo, isMemoSame } from './helpers/withMemo'\r\nexport {\r\n  openBlock,\r\n  createBlock,\r\n  setBlockTracking,\r\n  createTextVNode,\r\n  createCommentVNode,\r\n  createStaticVNode,\r\n  createElementVNode,\r\n  createElementBlock,\r\n  guardReactiveProps,\r\n} from './vnode'\r\nexport {\r\n  toDisplayString,\r\n  camelize,\r\n  capitalize,\r\n  toHandlerKey,\r\n  normalizeProps,\r\n  normalizeClass,\r\n  normalizeStyle,\r\n} from '@vue/shared'\r\n\r\n// For test-utils\r\nexport { transformVNodeArgs } from './vnode'\r\n\r\n// SSR -------------------------------------------------------------------------\r\n\r\n// **IMPORTANT** These APIs are exposed solely for @vue/server-renderer and may\r\n// change without notice between versions. User code should never rely on them.\r\n\r\nimport { createComponentInstance, setupComponent } from './component'\r\nimport { renderComponentRoot } from './componentRenderUtils'\r\nimport { setCurrentRenderingInstance } from './componentRenderContext'\r\nimport { isVNode, normalizeVNode } from './vnode'\r\n\r\nconst _ssrUtils = {\r\n  createComponentInstance,\r\n  setupComponent,\r\n  renderComponentRoot,\r\n  setCurrentRenderingInstance,\r\n  isVNode,\r\n  normalizeVNode,\r\n}\r\n\r\n/**\r\n * SSR utils for \\@vue/server-renderer. Only exposed in ssr-possible builds.\r\n * @internal\r\n */\r\nexport const ssrUtils = (__SSR__ ? _ssrUtils : null) as typeof _ssrUtils\r\n\r\n// 2.x COMPAT ------------------------------------------------------------------\r\n\r\nimport { DeprecationTypes as _DeprecationTypes } from './compat/compatConfig'\r\nexport type { CompatVue } from './compat/global'\r\nexport type { LegacyConfig } from './compat/globalConfig'\r\n\r\nimport { warnDeprecation } from './compat/compatConfig'\r\nimport { createCompatVue } from './compat/global'\r\nimport {\r\n  checkCompatEnabled,\r\n  isCompatEnabled,\r\n  softAssertCompatEnabled,\r\n} from './compat/compatConfig'\r\nimport { resolveFilter as _resolveFilter } from './helpers/resolveAssets'\r\nimport { NOOP } from '@vue/shared'\r\n\r\n/**\r\n * @internal only exposed in compat builds\r\n */\r\nexport const resolveFilter = __COMPAT__ ? _resolveFilter : null\r\n\r\nconst _compatUtils = {\r\n  warnDeprecation,\r\n  createCompatVue,\r\n  isCompatEnabled,\r\n  checkCompatEnabled,\r\n  softAssertCompatEnabled,\r\n}\r\n\r\n/**\r\n * @internal only exposed in compat builds.\r\n */\r\nexport const compatUtils = (\r\n  __COMPAT__ ? _compatUtils : null\r\n) as typeof _compatUtils\r\n\r\nexport const DeprecationTypes = (\r\n  __COMPAT__ ? _DeprecationTypes : null\r\n) as typeof _DeprecationTypes\r\n","import { isArray, isObject, isString } from '@vue/shared'\r\nimport { warn } from '@vue/runtime-core'\r\n\r\nexport function ssrRenderList(\r\n  source: unknown,\r\n  renderItem: (value: unknown, key: string | number, index?: number) => void,\r\n) {\r\n  if (isArray(source) || isString(source)) {\r\n    for (let i = 0, l = source.length; i < l; i++) {\r\n      renderItem(source[i], i)\r\n    }\r\n  } else if (typeof source === 'number') {\r\n    if (__DEV__ && !Number.isInteger(source)) {\r\n      warn(`The v-for range expect an integer value but got ${source}.`)\r\n      return\r\n    }\r\n    for (let i = 0; i < source; i++) {\r\n      renderItem(i + 1, i)\r\n    }\r\n  } else if (isObject(source)) {\r\n    if (source[Symbol.iterator as any]) {\r\n      const arr = Array.from(source as Iterable<any>)\r\n      for (let i = 0, l = arr.length; i < l; i++) {\r\n        renderItem(arr[i], i)\r\n      }\r\n    } else {\r\n      const keys = Object.keys(source)\r\n      for (let i = 0, l = keys.length; i < l; i++) {\r\n        const key = keys[i]\r\n        renderItem(source[key], key, i)\r\n      }\r\n    }\r\n  }\r\n}\r\n","import type { PushFn } from '../render'\r\n\r\nexport async function ssrRenderSuspense(\r\n  push: PushFn,\r\n  { default: renderContent }: Record<string, (() => void) | undefined>,\r\n) {\r\n  if (renderContent) {\r\n    renderContent()\r\n  } else {\r\n    push(`<!---->`)\r\n  }\r\n}\r\n","import type { ComponentPublicInstance, Directive } from '@vue/runtime-core'\r\n\r\nexport function ssrGetDirectiveProps(\r\n  instance: ComponentPublicInstance,\r\n  dir: Directive,\r\n  value?: any,\r\n  arg?: string,\r\n  modifiers: Record<string, boolean> = {},\r\n): Record<string, any> {\r\n  if (typeof dir !== 'function' && dir.getSSRProps) {\r\n    return (\r\n      dir.getSSRProps(\r\n        {\r\n          dir,\r\n          instance,\r\n          value,\r\n          oldValue: undefined,\r\n          arg,\r\n          modifiers,\r\n        },\r\n        null as any,\r\n      ) || {}\r\n    )\r\n  }\r\n  return {}\r\n}\r\n","import { isArray, looseEqual, looseIndexOf } from '@vue/shared'\r\nimport { ssrRenderAttr } from './ssrRenderAttrs'\r\n\r\nexport const ssrLooseEqual = looseEqual as (a: unknown, b: unknown) => boolean\r\n\r\nexport function ssrLooseContain(arr: unknown[], value: unknown): boolean {\r\n  return looseIndexOf(arr, value) > -1\r\n}\r\n\r\n// for <input :type=\"type\" v-model=\"model\" value=\"value\">\r\nexport function ssrRenderDynamicModel(\r\n  type: unknown,\r\n  model: unknown,\r\n  value: unknown,\r\n) {\r\n  switch (type) {\r\n    case 'radio':\r\n      return looseEqual(model, value) ? ' checked' : ''\r\n    case 'checkbox':\r\n      return (isArray(model) ? ssrLooseContain(model, value) : model)\r\n        ? ' checked'\r\n        : ''\r\n    default:\r\n      // text types\r\n      return ssrRenderAttr('value', model)\r\n  }\r\n}\r\n\r\n// for <input v-bind=\"obj\" v-model=\"model\">\r\nexport function ssrGetDynamicModelProps(\r\n  existingProps: any = {},\r\n  model: unknown,\r\n) {\r\n  const { type, value } = existingProps\r\n  switch (type) {\r\n    case 'radio':\r\n      return looseEqual(model, value) ? { checked: true } : null\r\n    case 'checkbox':\r\n      return (isArray(model) ? ssrLooseContain(model, value) : model)\r\n        ? { checked: true }\r\n        : null\r\n    default:\r\n      // text types\r\n      return { value: model }\r\n  }\r\n}\r\n","import {\r\n  type ComponentInternalInstance,\r\n  type ComponentOptions,\r\n  warn,\r\n} from 'vue'\r\nimport { compile } from '@vue/compiler-ssr'\r\nimport { NO, extend, generateCodeFrame, isFunction } from '@vue/shared'\r\nimport type { CompilerError, CompilerOptions } from '@vue/compiler-core'\r\nimport type { PushFn } from '../render'\r\n\r\nimport * as Vue from 'vue'\r\nimport * as helpers from '../internal'\r\n\r\ntype SSRRenderFunction = (\r\n  context: any,\r\n  push: PushFn,\r\n  parentInstance: ComponentInternalInstance,\r\n) => void\r\n\r\nconst compileCache: Record<string, SSRRenderFunction> = Object.create(null)\r\n\r\nexport function ssrCompile(\r\n  template: string,\r\n  instance: ComponentInternalInstance,\r\n): SSRRenderFunction {\r\n  // TODO: this branch should now work in ESM builds, enable it in a minor\r\n  if (!__CJS__) {\r\n    throw new Error(\r\n      `On-the-fly template compilation is not supported in the ESM build of ` +\r\n        `@vue/server-renderer. All templates must be pre-compiled into ` +\r\n        `render functions.`,\r\n    )\r\n  }\r\n\r\n  // TODO: This is copied from runtime-core/src/component.ts and should probably be refactored\r\n  const Component = instance.type as ComponentOptions\r\n  const { isCustomElement, compilerOptions } = instance.appContext.config\r\n  const { delimiters, compilerOptions: componentCompilerOptions } = Component\r\n\r\n  const finalCompilerOptions: CompilerOptions = extend(\r\n    extend(\r\n      {\r\n        isCustomElement,\r\n        delimiters,\r\n      },\r\n      compilerOptions,\r\n    ),\r\n    componentCompilerOptions,\r\n  )\r\n\r\n  finalCompilerOptions.isCustomElement =\r\n    finalCompilerOptions.isCustomElement || NO\r\n  finalCompilerOptions.isNativeTag = finalCompilerOptions.isNativeTag || NO\r\n\r\n  const cacheKey = JSON.stringify(\r\n    {\r\n      template,\r\n      compilerOptions: finalCompilerOptions,\r\n    },\r\n    (key, value) => {\r\n      return isFunction(value) ? value.toString() : value\r\n    },\r\n  )\r\n\r\n  const cached = compileCache[cacheKey]\r\n  if (cached) {\r\n    return cached\r\n  }\r\n\r\n  finalCompilerOptions.onError = (err: CompilerError) => {\r\n    if (__DEV__) {\r\n      const message = `[@vue/server-renderer] Template compilation error: ${err.message}`\r\n      const codeFrame =\r\n        err.loc &&\r\n        generateCodeFrame(\r\n          template as string,\r\n          err.loc.start.offset,\r\n          err.loc.end.offset,\r\n        )\r\n      warn(codeFrame ? `${message}\\n${codeFrame}` : message)\r\n    } else {\r\n      throw err\r\n    }\r\n  }\r\n\r\n  const { code } = compile(template, finalCompilerOptions)\r\n  const requireMap = {\r\n    vue: Vue,\r\n    'vue/server-renderer': helpers,\r\n  }\r\n  const fakeRequire = (id: 'vue' | 'vue/server-renderer') => requireMap[id]\r\n  return (compileCache[cacheKey] = Function('require', code)(fakeRequire))\r\n}\r\n","import {\r\n  Comment,\r\n  type Component,\r\n  type ComponentInternalInstance,\r\n  type DirectiveBinding,\r\n  Fragment,\r\n  type FunctionalComponent,\r\n  Static,\r\n  Text,\r\n  type VNode,\r\n  type VNodeArrayChildren,\r\n  type VNodeProps,\r\n  mergeProps,\r\n  ssrUtils,\r\n  warn,\r\n} from 'vue'\r\nimport {\r\n  NOOP,\r\n  ShapeFlags,\r\n  escapeHtml,\r\n  escapeHtmlComment,\r\n  isArray,\r\n  isFunction,\r\n  isPromise,\r\n  isString,\r\n  isVoidTag,\r\n} from '@vue/shared'\r\nimport { ssrRenderAttrs } from './helpers/ssrRenderAttrs'\r\nimport { ssrCompile } from './helpers/ssrCompile'\r\nimport { ssrRenderTeleport } from './helpers/ssrRenderTeleport'\r\n\r\nconst {\r\n  createComponentInstance,\r\n  setCurrentRenderingInstance,\r\n  setupComponent,\r\n  renderComponentRoot,\r\n  normalizeVNode,\r\n} = ssrUtils\r\n\r\nexport type SSRBuffer = SSRBufferItem[] & { hasAsync?: boolean }\r\nexport type SSRBufferItem = string | SSRBuffer | Promise<SSRBuffer>\r\nexport type PushFn = (item: SSRBufferItem) => void\r\nexport type Props = Record<string, unknown>\r\n\r\nexport type SSRContext = {\r\n  [key: string]: any\r\n  teleports?: Record<string, string>\r\n  /**\r\n   * @internal\r\n   */\r\n  __teleportBuffers?: Record<string, SSRBuffer>\r\n  /**\r\n   * @internal\r\n   */\r\n  __watcherHandles?: (() => void)[]\r\n}\r\n\r\n// Each component has a buffer array.\r\n// A buffer array can contain one of the following:\r\n// - plain string\r\n// - A resolved buffer (recursive arrays of strings that can be unrolled\r\n//   synchronously)\r\n// - An async buffer (a Promise that resolves to a resolved buffer)\r\nexport function createBuffer() {\r\n  let appendable = false\r\n  const buffer: SSRBuffer = []\r\n  return {\r\n    getBuffer(): SSRBuffer {\r\n      // Return static buffer and await on items during unroll stage\r\n      return buffer\r\n    },\r\n    push(item: SSRBufferItem) {\r\n      const isStringItem = isString(item)\r\n      if (appendable && isStringItem) {\r\n        buffer[buffer.length - 1] += item as string\r\n      } else {\r\n        buffer.push(item)\r\n      }\r\n      appendable = isStringItem\r\n      if (isPromise(item) || (isArray(item) && item.hasAsync)) {\r\n        // promise, or child buffer with async, mark as async.\r\n        // this allows skipping unnecessary await ticks during unroll stage\r\n        buffer.hasAsync = true\r\n      }\r\n    },\r\n  }\r\n}\r\n\r\nexport function renderComponentVNode(\r\n  vnode: VNode,\r\n  parentComponent: ComponentInternalInstance | null = null,\r\n  slotScopeId?: string,\r\n): SSRBuffer | Promise<SSRBuffer> {\r\n  const instance = createComponentInstance(vnode, parentComponent, null)\r\n  const res = setupComponent(instance, true /* isSSR */)\r\n  const hasAsyncSetup = isPromise(res)\r\n  const prefetches = instance.sp /* LifecycleHooks.SERVER_PREFETCH */\r\n  if (hasAsyncSetup || prefetches) {\r\n    let p: Promise<unknown> = hasAsyncSetup\r\n      ? (res as Promise<void>)\r\n      : Promise.resolve()\r\n    if (prefetches) {\r\n      p = p\r\n        .then(() =>\r\n          Promise.all(\r\n            prefetches.map(prefetch => prefetch.call(instance.proxy)),\r\n          ),\r\n        )\r\n        // Note: error display is already done by the wrapped lifecycle hook function.\r\n        .catch(NOOP)\r\n    }\r\n    return p.then(() => renderComponentSubTree(instance, slotScopeId))\r\n  } else {\r\n    return renderComponentSubTree(instance, slotScopeId)\r\n  }\r\n}\r\n\r\nfunction renderComponentSubTree(\r\n  instance: ComponentInternalInstance,\r\n  slotScopeId?: string,\r\n): SSRBuffer | Promise<SSRBuffer> {\r\n  const comp = instance.type as Component\r\n  const { getBuffer, push } = createBuffer()\r\n  if (isFunction(comp)) {\r\n    let root = renderComponentRoot(instance)\r\n    // #5817 scope ID attrs not falling through if functional component doesn't\r\n    // have props\r\n    if (!(comp as FunctionalComponent).props) {\r\n      for (const key in instance.attrs) {\r\n        if (key.startsWith(`data-v-`)) {\r\n          ;(root.props || (root.props = {}))[key] = ``\r\n        }\r\n      }\r\n    }\r\n    renderVNode(push, (instance.subTree = root), instance, slotScopeId)\r\n  } else {\r\n    if (\r\n      (!instance.render || instance.render === NOOP) &&\r\n      !instance.ssrRender &&\r\n      !comp.ssrRender &&\r\n      isString(comp.template)\r\n    ) {\r\n      comp.ssrRender = ssrCompile(comp.template, instance)\r\n    }\r\n\r\n    // perf: enable caching of computed getters during render\r\n    // since there cannot be state mutations during render.\r\n    for (const e of instance.scope.effects) {\r\n      if (e.computed) {\r\n        e.computed._dirty = true\r\n        e.computed._cacheable = true\r\n      }\r\n    }\r\n\r\n    const ssrRender = instance.ssrRender || comp.ssrRender\r\n    if (ssrRender) {\r\n      // optimized\r\n      // resolve fallthrough attrs\r\n      let attrs = instance.inheritAttrs !== false ? instance.attrs : undefined\r\n      let hasCloned = false\r\n\r\n      let cur = instance\r\n      while (true) {\r\n        const scopeId = cur.vnode.scopeId\r\n        if (scopeId) {\r\n          if (!hasCloned) {\r\n            attrs = { ...attrs }\r\n            hasCloned = true\r\n          }\r\n          attrs![scopeId] = ''\r\n        }\r\n        const parent = cur.parent\r\n        if (parent && parent.subTree && parent.subTree === cur.vnode) {\r\n          // parent is a non-SSR compiled component and is rendering this\r\n          // component as root. inherit its scopeId if present.\r\n          cur = parent\r\n        } else {\r\n          break\r\n        }\r\n      }\r\n\r\n      if (slotScopeId) {\r\n        if (!hasCloned) attrs = { ...attrs }\r\n        attrs![slotScopeId.trim()] = ''\r\n      }\r\n\r\n      // set current rendering instance for asset resolution\r\n      const prev = setCurrentRenderingInstance(instance)\r\n      try {\r\n        ssrRender(\r\n          instance.proxy,\r\n          push,\r\n          instance,\r\n          attrs,\r\n          // compiler-optimized bindings\r\n          instance.props,\r\n          instance.setupState,\r\n          instance.data,\r\n          instance.ctx,\r\n        )\r\n      } finally {\r\n        setCurrentRenderingInstance(prev)\r\n      }\r\n    } else if (instance.render && instance.render !== NOOP) {\r\n      renderVNode(\r\n        push,\r\n        (instance.subTree = renderComponentRoot(instance)),\r\n        instance,\r\n        slotScopeId,\r\n      )\r\n    } else {\r\n      const componentName = comp.name || comp.__file || `<Anonymous>`\r\n      warn(`Component ${componentName} is missing template or render function.`)\r\n      push(`<!---->`)\r\n    }\r\n  }\r\n  return getBuffer()\r\n}\r\n\r\nexport function renderVNode(\r\n  push: PushFn,\r\n  vnode: VNode,\r\n  parentComponent: ComponentInternalInstance,\r\n  slotScopeId?: string,\r\n) {\r\n  const { type, shapeFlag, children } = vnode\r\n  switch (type) {\r\n    case Text:\r\n      push(escapeHtml(children as string))\r\n      break\r\n    case Comment:\r\n      push(\r\n        children\r\n          ? `<!--${escapeHtmlComment(children as string)}-->`\r\n          : `<!---->`,\r\n      )\r\n      break\r\n    case Static:\r\n      push(children as string)\r\n      break\r\n    case Fragment:\r\n      if (vnode.slotScopeIds) {\r\n        slotScopeId =\r\n          (slotScopeId ? slotScopeId + ' ' : '') + vnode.slotScopeIds.join(' ')\r\n      }\r\n      push(`<!--[-->`) // open\r\n      renderVNodeChildren(\r\n        push,\r\n        children as VNodeArrayChildren,\r\n        parentComponent,\r\n        slotScopeId,\r\n      )\r\n      push(`<!--]-->`) // close\r\n      break\r\n    default:\r\n      if (shapeFlag & ShapeFlags.ELEMENT) {\r\n        renderElementVNode(push, vnode, parentComponent, slotScopeId)\r\n      } else if (shapeFlag & ShapeFlags.COMPONENT) {\r\n        push(renderComponentVNode(vnode, parentComponent, slotScopeId))\r\n      } else if (shapeFlag & ShapeFlags.TELEPORT) {\r\n        renderTeleportVNode(push, vnode, parentComponent, slotScopeId)\r\n      } else if (shapeFlag & ShapeFlags.SUSPENSE) {\r\n        renderVNode(push, vnode.ssContent!, parentComponent, slotScopeId)\r\n      } else {\r\n        warn(\r\n          '[@vue/server-renderer] Invalid VNode type:',\r\n          type,\r\n          `(${typeof type})`,\r\n        )\r\n      }\r\n  }\r\n}\r\n\r\nexport function renderVNodeChildren(\r\n  push: PushFn,\r\n  children: VNodeArrayChildren,\r\n  parentComponent: ComponentInternalInstance,\r\n  slotScopeId: string | undefined,\r\n) {\r\n  for (let i = 0; i < children.length; i++) {\r\n    renderVNode(push, normalizeVNode(children[i]), parentComponent, slotScopeId)\r\n  }\r\n}\r\n\r\nfunction renderElementVNode(\r\n  push: PushFn,\r\n  vnode: VNode,\r\n  parentComponent: ComponentInternalInstance,\r\n  slotScopeId: string | undefined,\r\n) {\r\n  const tag = vnode.type as string\r\n  let { props, children, shapeFlag, scopeId, dirs } = vnode\r\n  let openTag = `<${tag}`\r\n\r\n  if (dirs) {\r\n    props = applySSRDirectives(vnode, props, dirs)\r\n  }\r\n\r\n  if (props) {\r\n    openTag += ssrRenderAttrs(props, tag)\r\n  }\r\n\r\n  if (scopeId) {\r\n    openTag += ` ${scopeId}`\r\n  }\r\n  // inherit parent chain scope id if this is the root node\r\n  let curParent: ComponentInternalInstance | null = parentComponent\r\n  let curVnode = vnode\r\n  while (curParent && curVnode === curParent.subTree) {\r\n    curVnode = curParent.vnode\r\n    if (curVnode.scopeId) {\r\n      openTag += ` ${curVnode.scopeId}`\r\n    }\r\n    curParent = curParent.parent\r\n  }\r\n  if (slotScopeId) {\r\n    openTag += ` ${slotScopeId}`\r\n  }\r\n\r\n  push(openTag + `>`)\r\n  if (!isVoidTag(tag)) {\r\n    let hasChildrenOverride = false\r\n    if (props) {\r\n      if (props.innerHTML) {\r\n        hasChildrenOverride = true\r\n        push(props.innerHTML)\r\n      } else if (props.textContent) {\r\n        hasChildrenOverride = true\r\n        push(escapeHtml(props.textContent))\r\n      } else if (tag === 'textarea' && props.value) {\r\n        hasChildrenOverride = true\r\n        push(escapeHtml(props.value))\r\n      }\r\n    }\r\n    if (!hasChildrenOverride) {\r\n      if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n        push(escapeHtml(children as string))\r\n      } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n        renderVNodeChildren(\r\n          push,\r\n          children as VNodeArrayChildren,\r\n          parentComponent,\r\n          slotScopeId,\r\n        )\r\n      }\r\n    }\r\n    push(`</${tag}>`)\r\n  }\r\n}\r\n\r\nfunction applySSRDirectives(\r\n  vnode: VNode,\r\n  rawProps: VNodeProps | null,\r\n  dirs: DirectiveBinding[],\r\n): VNodeProps {\r\n  const toMerge: VNodeProps[] = []\r\n  for (let i = 0; i < dirs.length; i++) {\r\n    const binding = dirs[i]\r\n    const {\r\n      dir: { getSSRProps },\r\n    } = binding\r\n    if (getSSRProps) {\r\n      const props = getSSRProps(binding, vnode)\r\n      if (props) toMerge.push(props)\r\n    }\r\n  }\r\n  return mergeProps(rawProps || {}, ...toMerge)\r\n}\r\n\r\nfunction renderTeleportVNode(\r\n  push: PushFn,\r\n  vnode: VNode,\r\n  parentComponent: ComponentInternalInstance,\r\n  slotScopeId: string | undefined,\r\n) {\r\n  const target = vnode.props && vnode.props.to\r\n  const disabled = vnode.props && vnode.props.disabled\r\n  if (!target) {\r\n    if (!disabled) {\r\n      warn(`[@vue/server-renderer] Teleport is missing target prop.`)\r\n    }\r\n    return []\r\n  }\r\n  if (!isString(target)) {\r\n    warn(\r\n      `[@vue/server-renderer] Teleport target must be a query selector string.`,\r\n    )\r\n    return []\r\n  }\r\n  ssrRenderTeleport(\r\n    push,\r\n    push => {\r\n      renderVNodeChildren(\r\n        push,\r\n        vnode.children as VNodeArrayChildren,\r\n        parentComponent,\r\n        slotScopeId,\r\n      )\r\n    },\r\n    target,\r\n    disabled || disabled === '',\r\n    parentComponent,\r\n  )\r\n}\r\n","import {\r\n  type App,\r\n  type VNode,\r\n  createApp,\r\n  createVNode,\r\n  ssrContextKey,\r\n  ssrUtils,\r\n} from 'vue'\r\nimport { isPromise, isString } from '@vue/shared'\r\nimport { type SSRBuffer, type SSRContext, renderComponentVNode } from './render'\r\n\r\nconst { isVNode } = ssrUtils\r\n\r\nasync function unrollBuffer(buffer: SSRBuffer): Promise<string> {\r\n  if (buffer.hasAsync) {\r\n    let ret = ''\r\n    for (let i = 0; i < buffer.length; i++) {\r\n      let item = buffer[i]\r\n      if (isPromise(item)) {\r\n        item = await item\r\n      }\r\n      if (isString(item)) {\r\n        ret += item\r\n      } else {\r\n        ret += await unrollBuffer(item)\r\n      }\r\n    }\r\n    return ret\r\n  } else {\r\n    // sync buffer can be more efficiently unrolled without unnecessary await\r\n    // ticks\r\n    return unrollBufferSync(buffer)\r\n  }\r\n}\r\n\r\nfunction unrollBufferSync(buffer: SSRBuffer): string {\r\n  let ret = ''\r\n  for (let i = 0; i < buffer.length; i++) {\r\n    let item = buffer[i]\r\n    if (isString(item)) {\r\n      ret += item\r\n    } else {\r\n      // since this is a sync buffer, child buffers are never promises\r\n      ret += unrollBufferSync(item as SSRBuffer)\r\n    }\r\n  }\r\n  return ret\r\n}\r\n\r\nexport async function renderToString(\r\n  input: App | VNode,\r\n  context: SSRContext = {},\r\n): Promise<string> {\r\n  if (isVNode(input)) {\r\n    // raw vnode, wrap with app (for context)\r\n    return renderToString(createApp({ render: () => input }), context)\r\n  }\r\n\r\n  // rendering an app\r\n  const vnode = createVNode(input._component, input._props)\r\n  vnode.appContext = input._context\r\n  // provide the ssr context to the tree\r\n  input.provide(ssrContextKey, context)\r\n  const buffer = await renderComponentVNode(vnode)\r\n\r\n  const result = await unrollBuffer(buffer as SSRBuffer)\r\n\r\n  await resolveTeleports(context)\r\n\r\n  if (context.__watcherHandles) {\r\n    for (const unwatch of context.__watcherHandles) {\r\n      unwatch()\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nexport async function resolveTeleports(context: SSRContext) {\r\n  if (context.__teleportBuffers) {\r\n    context.teleports = context.teleports || {}\r\n    for (const key in context.__teleportBuffers) {\r\n      // note: it's OK to await sequentially here because the Promises were\r\n      // created eagerly in parallel.\r\n      context.teleports[key] = await unrollBuffer(\r\n        await Promise.all([context.__teleportBuffers[key]]),\r\n      )\r\n    }\r\n  }\r\n}\r\n","import {\r\n  type App,\r\n  type VNode,\r\n  createApp,\r\n  createVNode,\r\n  ssrContextKey,\r\n  ssrUtils,\r\n} from 'vue'\r\nimport { isPromise, isString } from '@vue/shared'\r\nimport { type SSRBuffer, type SSRContext, renderComponentVNode } from './render'\r\nimport type { Readable, Writable } from 'node:stream'\r\nimport { resolveTeleports } from './renderToString'\r\n\r\nconst { isVNode } = ssrUtils\r\n\r\nexport interface SimpleReadable {\r\n  push(chunk: string | null): void\r\n  destroy(err: any): void\r\n}\r\n\r\nasync function unrollBuffer(\r\n  buffer: SSRBuffer,\r\n  stream: SimpleReadable,\r\n): Promise<void> {\r\n  if (buffer.hasAsync) {\r\n    for (let i = 0; i < buffer.length; i++) {\r\n      let item = buffer[i]\r\n      if (isPromise(item)) {\r\n        item = await item\r\n      }\r\n      if (isString(item)) {\r\n        stream.push(item)\r\n      } else {\r\n        await unrollBuffer(item, stream)\r\n      }\r\n    }\r\n  } else {\r\n    // sync buffer can be more efficiently unrolled without unnecessary await\r\n    // ticks\r\n    unrollBufferSync(buffer, stream)\r\n  }\r\n}\r\n\r\nfunction unrollBufferSync(buffer: SSRBuffer, stream: SimpleReadable) {\r\n  for (let i = 0; i < buffer.length; i++) {\r\n    let item = buffer[i]\r\n    if (isString(item)) {\r\n      stream.push(item)\r\n    } else {\r\n      // since this is a sync buffer, child buffers are never promises\r\n      unrollBufferSync(item as SSRBuffer, stream)\r\n    }\r\n  }\r\n}\r\n\r\nexport function renderToSimpleStream<T extends SimpleReadable>(\r\n  input: App | VNode,\r\n  context: SSRContext,\r\n  stream: T,\r\n): T {\r\n  if (isVNode(input)) {\r\n    // raw vnode, wrap with app (for context)\r\n    return renderToSimpleStream(\r\n      createApp({ render: () => input }),\r\n      context,\r\n      stream,\r\n    )\r\n  }\r\n\r\n  // rendering an app\r\n  const vnode = createVNode(input._component, input._props)\r\n  vnode.appContext = input._context\r\n  // provide the ssr context to the tree\r\n  input.provide(ssrContextKey, context)\r\n\r\n  Promise.resolve(renderComponentVNode(vnode))\r\n    .then(buffer => unrollBuffer(buffer, stream))\r\n    .then(() => resolveTeleports(context))\r\n    .then(() => {\r\n      if (context.__watcherHandles) {\r\n        for (const unwatch of context.__watcherHandles) {\r\n          unwatch()\r\n        }\r\n      }\r\n    })\r\n    .then(() => stream.push(null))\r\n    .catch(error => {\r\n      stream.destroy(error)\r\n    })\r\n\r\n  return stream\r\n}\r\n\r\n/**\r\n * @deprecated\r\n */\r\nexport function renderToStream(\r\n  input: App | VNode,\r\n  context: SSRContext = {},\r\n): Readable {\r\n  console.warn(\r\n    `[@vue/server-renderer] renderToStream is deprecated - use renderToNodeStream instead.`,\r\n  )\r\n  return renderToNodeStream(input, context)\r\n}\r\n\r\nexport function renderToNodeStream(\r\n  input: App | VNode,\r\n  context: SSRContext = {},\r\n): Readable {\r\n  const stream: Readable = __CJS__\r\n    ? new (require('node:stream').Readable)({ read() {} })\r\n    : null\r\n\r\n  if (!stream) {\r\n    throw new Error(\r\n      `ESM build of renderToStream() does not support renderToNodeStream(). ` +\r\n        `Use pipeToNodeWritable() with an existing Node.js Writable stream ` +\r\n        `instance instead.`,\r\n    )\r\n  }\r\n\r\n  return renderToSimpleStream(input, context, stream)\r\n}\r\n\r\nexport function pipeToNodeWritable(\r\n  input: App | VNode,\r\n  context: SSRContext = {},\r\n  writable: Writable,\r\n) {\r\n  renderToSimpleStream(input, context, {\r\n    push(content) {\r\n      if (content != null) {\r\n        writable.write(content)\r\n      } else {\r\n        writable.end()\r\n      }\r\n    },\r\n    destroy(err) {\r\n      writable.destroy(err)\r\n    },\r\n  })\r\n}\r\n\r\nexport function renderToWebStream(\r\n  input: App | VNode,\r\n  context: SSRContext = {},\r\n): ReadableStream {\r\n  if (typeof ReadableStream !== 'function') {\r\n    throw new Error(\r\n      `ReadableStream constructor is not available in the global scope. ` +\r\n        `If the target environment does support web streams, consider using ` +\r\n        `pipeToWebWritable() with an existing WritableStream instance instead.`,\r\n    )\r\n  }\r\n\r\n  const encoder = new TextEncoder()\r\n  let cancelled = false\r\n\r\n  return new ReadableStream({\r\n    start(controller) {\r\n      renderToSimpleStream(input, context, {\r\n        push(content) {\r\n          if (cancelled) return\r\n          if (content != null) {\r\n            controller.enqueue(encoder.encode(content))\r\n          } else {\r\n            controller.close()\r\n          }\r\n        },\r\n        destroy(err) {\r\n          controller.error(err)\r\n        },\r\n      })\r\n    },\r\n    cancel() {\r\n      cancelled = true\r\n    },\r\n  })\r\n}\r\n\r\nexport function pipeToWebWritable(\r\n  input: App | VNode,\r\n  context: SSRContext = {},\r\n  writable: WritableStream,\r\n): void {\r\n  const writer = writable.getWriter()\r\n  const encoder = new TextEncoder()\r\n\r\n  // #4287 CloudFlare workers do not implement `ready` property\r\n  let hasReady = false\r\n  try {\r\n    hasReady = isPromise(writer.ready)\r\n  } catch (e: any) {}\r\n\r\n  renderToSimpleStream(input, context, {\r\n    async push(content) {\r\n      if (hasReady) {\r\n        await writer.ready\r\n      }\r\n      if (content != null) {\r\n        return writer.write(encoder.encode(content))\r\n      } else {\r\n        return writer.close()\r\n      }\r\n    },\r\n    destroy(err) {\r\n      // TODO better error handling?\r\n      // eslint-disable-next-line no-console\r\n      console.log(err)\r\n      writer.close()\r\n    },\r\n  })\r\n}\r\n","import { initDirectivesForSSR } from 'vue'\r\ninitDirectivesForSSR()\r\n\r\n// public\r\nexport type { SSRContext } from './render'\r\nexport { renderToString } from './renderToString'\r\nexport {\r\n  renderToSimpleStream,\r\n  renderToNodeStream,\r\n  pipeToNodeWritable,\r\n  renderToWebStream,\r\n  pipeToWebWritable,\r\n  type SimpleReadable,\r\n  // deprecated\r\n  renderToStream,\r\n} from './renderToStream'\r\n\r\n// internal runtime helpers\r\nexport * from './internal'\r\n"],"names":["makeMap","isOn","isRenderableAttrValue","isSVGTag","propsToAttrMap","isBooleanAttr","includeBooleanAttr","isSSRSafeAttrName","escapeHtml","normalizeClass","isString","normalizeStyle","stringifyStyle","createVNode","isArray","ssrContextKey","toDisplayString","warn","isFunction","getGlobalThis","_warn","isObject","looseEqual","looseIndexOf","extend","NO","generateCodeFrame","compile","Vue","ssrUtils","isPromise","NOOP","Text","Comment","escapeHtmlComment","Static","Fragment","isVoidTag","mergeProps","push","isVNode","unrollBuffer","unrollBufferSync","createApp","initDirectivesForSSR"],"mappings":"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"}