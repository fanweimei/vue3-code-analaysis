{"version":3,"file":"server-renderer.esm-browser.prod.js","sources":["../../shared/src/makeMap.ts","../../shared/src/general.ts","../../shared/src/normalizeProp.ts","../../shared/src/domTagConfig.ts","../../shared/src/domAttrConfig.ts","../../shared/src/escapeHtml.ts","../../shared/src/looseEqual.ts","../../shared/src/toDisplayString.ts","../../reactivity/src/effectScope.ts","../../reactivity/src/effect.ts","../../reactivity/src/dep.ts","../../reactivity/src/reactiveEffect.ts","../../reactivity/src/baseHandlers.ts","../../reactivity/src/collectionHandlers.ts","../../reactivity/src/reactive.ts","../../reactivity/src/computed.ts","../../reactivity/src/ref.ts","../../runtime-core/src/errorHandling.ts","../../runtime-core/src/scheduler.ts","../../runtime-core/src/componentEmits.ts","../../runtime-core/src/componentRenderContext.ts","../../runtime-core/src/componentRenderUtils.ts","../../runtime-core/src/helpers/resolveAssets.ts","../../runtime-core/src/helpers/useSsrContext.ts","../../runtime-core/src/apiWatch.ts","../../runtime-core/src/directives.ts","../../runtime-core/src/apiAsyncComponent.ts","../../runtime-core/src/components/KeepAlive.ts","../../runtime-core/src/apiLifecycle.ts","../../runtime-core/src/componentPublicInstance.ts","../../runtime-core/src/apiSetupHelpers.ts","../../runtime-core/src/componentOptions.ts","../../runtime-core/src/apiInject.ts","../../runtime-core/src/apiCreateApp.ts","../../runtime-core/src/componentProps.ts","../../runtime-core/src/componentSlots.ts","../../runtime-core/src/rendererTemplateRef.ts","../../runtime-core/src/renderer.ts","../../runtime-core/src/components/Suspense.ts","../../runtime-core/src/components/Teleport.ts","../../runtime-core/src/vnode.ts","../../runtime-core/src/component.ts","../../runtime-core/src/apiComputed.ts","../../runtime-core/src/index.ts","../../runtime-dom/src/nodeOps.ts","../../runtime-dom/src/components/Transition.ts","../../runtime-dom/src/directives/vShow.ts","../../runtime-dom/src/helpers/useCssVars.ts","../../runtime-dom/src/modules/style.ts","../../runtime-dom/src/modules/attrs.ts","../../runtime-dom/src/modules/events.ts","../../runtime-dom/src/patchProp.ts","../../runtime-dom/src/directives/vModel.ts","../../runtime-dom/src/index.ts","../../runtime-dom/src/modules/class.ts","../../runtime-dom/src/modules/props.ts","../src/helpers/ssrRenderAttrs.ts","../src/helpers/ssrRenderComponent.ts","../src/helpers/ssrRenderSlot.ts","../src/helpers/ssrRenderTeleport.ts","../src/helpers/ssrInterpolate.ts","../src/helpers/ssrRenderList.ts","../src/helpers/ssrRenderSuspense.ts","../src/helpers/ssrGetDirectiveProps.ts","../src/helpers/ssrVModelHelpers.ts","../src/render.ts","../src/helpers/ssrCompile.ts","../src/renderToString.ts","../src/renderToStream.ts"],"sourcesContent":["/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nexport function makeMap(\r\n  str: string,\r\n  expectsLowerCase?: boolean,\r\n): (key: string) => boolean {\r\n  const set = new Set(str.split(','))\r\n  return expectsLowerCase\r\n    ? val => set.has(val.toLowerCase())\r\n    : val => set.has(val)\r\n}\r\n","import { makeMap } from './makeMap'\r\n\r\nexport const EMPTY_OBJ: { readonly [key: string]: any } = __DEV__\r\n  ? Object.freeze({})\r\n  : {}\r\nexport const EMPTY_ARR = __DEV__ ? Object.freeze([]) : []\r\n\r\nexport const NOOP = () => {}\r\n\r\n/**\r\n * Always return false.\r\n */\r\nexport const NO = () => false\r\n\r\nexport const isOn = (key: string) =>\r\n  key.charCodeAt(0) === 111 /* o */ &&\r\n  key.charCodeAt(1) === 110 /* n */ &&\r\n  // uppercase letter\r\n  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97)\r\n\r\nexport const isModelListener = (key: string) => key.startsWith('onUpdate:')\r\n\r\nexport const extend = Object.assign\r\n\r\nexport const remove = <T>(arr: T[], el: T) => {\r\n  const i = arr.indexOf(el)\r\n  if (i > -1) {\r\n    arr.splice(i, 1)\r\n  }\r\n}\r\n\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty\r\nexport const hasOwn = (\r\n  val: object,\r\n  key: string | symbol,\r\n): key is keyof typeof val => hasOwnProperty.call(val, key)\r\n\r\nexport const isArray = Array.isArray\r\nexport const isMap = (val: unknown): val is Map<any, any> =>\r\n  toTypeString(val) === '[object Map]'\r\nexport const isSet = (val: unknown): val is Set<any> =>\r\n  toTypeString(val) === '[object Set]'\r\n\r\nexport const isDate = (val: unknown): val is Date =>\r\n  toTypeString(val) === '[object Date]'\r\nexport const isRegExp = (val: unknown): val is RegExp =>\r\n  toTypeString(val) === '[object RegExp]'\r\nexport const isFunction = (val: unknown): val is Function =>\r\n  typeof val === 'function'\r\nexport const isString = (val: unknown): val is string => typeof val === 'string'\r\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\r\nexport const isObject = (val: unknown): val is Record<any, any> =>\r\n  val !== null && typeof val === 'object'\r\n\r\nexport const isPromise = <T = any>(val: unknown): val is Promise<T> => {\r\n  return (\r\n    (isObject(val) || isFunction(val)) &&\r\n    isFunction((val as any).then) &&\r\n    isFunction((val as any).catch)\r\n  )\r\n}\r\n\r\nexport const objectToString = Object.prototype.toString\r\nexport const toTypeString = (value: unknown): string =>\r\n  objectToString.call(value)\r\n\r\nexport const toRawType = (value: unknown): string => {\r\n  // extract \"RawType\" from strings like \"[object RawType]\"\r\n  return toTypeString(value).slice(8, -1)\r\n}\r\n\r\nexport const isPlainObject = (val: unknown): val is object =>\r\n  toTypeString(val) === '[object Object]'\r\n\r\nexport const isIntegerKey = (key: unknown) =>\r\n  isString(key) &&\r\n  key !== 'NaN' &&\r\n  key[0] !== '-' &&\r\n  '' + parseInt(key, 10) === key\r\n\r\nexport const isReservedProp = /*#__PURE__*/ makeMap(\r\n  // the leading comma is intentional so empty string \"\" is also included\r\n  ',key,ref,ref_for,ref_key,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted',\r\n)\r\n\r\nexport const isBuiltInDirective = /*#__PURE__*/ makeMap(\r\n  'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo',\r\n)\r\n\r\nconst cacheStringFunction = <T extends (str: string) => string>(fn: T): T => {\r\n  const cache: Record<string, string> = Object.create(null)\r\n  return ((str: string) => {\r\n    const hit = cache[str]\r\n    return hit || (cache[str] = fn(str))\r\n  }) as T\r\n}\r\n\r\nconst camelizeRE = /-(\\w)/g\r\n/**\r\n * @private\r\n */\r\nexport const camelize = cacheStringFunction((str: string): string => {\r\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\r\n})\r\n\r\nconst hyphenateRE = /\\B([A-Z])/g\r\n/**\r\n * @private\r\n */\r\nexport const hyphenate = cacheStringFunction((str: string) =>\r\n  str.replace(hyphenateRE, '-$1').toLowerCase(),\r\n)\r\n\r\n/**\r\n * @private\r\n */\r\nexport const capitalize = cacheStringFunction(<T extends string>(str: T) => {\r\n  return (str.charAt(0).toUpperCase() + str.slice(1)) as Capitalize<T>\r\n})\r\n\r\n/**\r\n * @private\r\n */\r\nexport const toHandlerKey = cacheStringFunction(<T extends string>(str: T) => {\r\n  const s = str ? `on${capitalize(str)}` : ``\r\n  return s as T extends '' ? '' : `on${Capitalize<T>}`\r\n})\r\n\r\n// compare whether a value has changed, accounting for NaN.\r\nexport const hasChanged = (value: any, oldValue: any): boolean =>\r\n  !Object.is(value, oldValue)\r\n\r\nexport const invokeArrayFns = (fns: Function[], arg?: any) => {\r\n  for (let i = 0; i < fns.length; i++) {\r\n    fns[i](arg)\r\n  }\r\n}\r\n\r\nexport const def = (obj: object, key: string | symbol, value: any) => {\r\n  Object.defineProperty(obj, key, {\r\n    configurable: true,\r\n    enumerable: false,\r\n    value,\r\n  })\r\n}\r\n\r\n/**\r\n * \"123-foo\" will be parsed to 123\r\n * This is used for the .number modifier in v-model\r\n */\r\nexport const looseToNumber = (val: any): any => {\r\n  const n = parseFloat(val)\r\n  return isNaN(n) ? val : n\r\n}\r\n\r\n/**\r\n * Only concerns number-like strings\r\n * \"123-foo\" will be returned as-is\r\n */\r\nexport const toNumber = (val: any): any => {\r\n  const n = isString(val) ? Number(val) : NaN\r\n  return isNaN(n) ? val : n\r\n}\r\n\r\nlet _globalThis: any\r\nexport const getGlobalThis = (): any => {\r\n  return (\r\n    _globalThis ||\r\n    (_globalThis =\r\n      typeof globalThis !== 'undefined'\r\n        ? globalThis\r\n        : typeof self !== 'undefined'\r\n          ? self\r\n          : typeof window !== 'undefined'\r\n            ? window\r\n            : typeof global !== 'undefined'\r\n              ? global\r\n              : {})\r\n  )\r\n}\r\n\r\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/\r\n\r\nexport function genPropsAccessExp(name: string) {\r\n  return identRE.test(name)\r\n    ? `__props.${name}`\r\n    : `__props[${JSON.stringify(name)}]`\r\n}\r\n","import { hyphenate, isArray, isObject, isString } from './general'\r\n\r\nexport type NormalizedStyle = Record<string, string | number>\r\n\r\nexport function normalizeStyle(\r\n  value: unknown,\r\n): NormalizedStyle | string | undefined {\r\n  if (isArray(value)) {\r\n    const res: NormalizedStyle = {}\r\n    for (let i = 0; i < value.length; i++) {\r\n      const item = value[i]\r\n      const normalized = isString(item)\r\n        ? parseStringStyle(item)\r\n        : (normalizeStyle(item) as NormalizedStyle)\r\n      if (normalized) {\r\n        for (const key in normalized) {\r\n          res[key] = normalized[key]\r\n        }\r\n      }\r\n    }\r\n    return res\r\n  } else if (isString(value) || isObject(value)) {\r\n    return value\r\n  }\r\n}\r\n\r\nconst listDelimiterRE = /;(?![^(]*\\))/g\r\nconst propertyDelimiterRE = /:([^]+)/\r\nconst styleCommentRE = /\\/\\*[^]*?\\*\\//g\r\n\r\nexport function parseStringStyle(cssText: string): NormalizedStyle {\r\n  const ret: NormalizedStyle = {}\r\n  cssText\r\n    .replace(styleCommentRE, '')\r\n    .split(listDelimiterRE)\r\n    .forEach(item => {\r\n      if (item) {\r\n        const tmp = item.split(propertyDelimiterRE)\r\n        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim())\r\n      }\r\n    })\r\n  return ret\r\n}\r\n\r\nexport function stringifyStyle(\r\n  styles: NormalizedStyle | string | undefined,\r\n): string {\r\n  let ret = ''\r\n  if (!styles || isString(styles)) {\r\n    return ret\r\n  }\r\n  for (const key in styles) {\r\n    const value = styles[key]\r\n    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key)\r\n    if (isString(value) || typeof value === 'number') {\r\n      // only render valid values\r\n      ret += `${normalizedKey}:${value};`\r\n    }\r\n  }\r\n  return ret\r\n}\r\n\r\nexport function normalizeClass(value: unknown): string {\r\n  let res = ''\r\n  if (isString(value)) {\r\n    res = value\r\n  } else if (isArray(value)) {\r\n    for (let i = 0; i < value.length; i++) {\r\n      const normalized = normalizeClass(value[i])\r\n      if (normalized) {\r\n        res += normalized + ' '\r\n      }\r\n    }\r\n  } else if (isObject(value)) {\r\n    for (const name in value) {\r\n      if (value[name]) {\r\n        res += name + ' '\r\n      }\r\n    }\r\n  }\r\n  return res.trim()\r\n}\r\n\r\nexport function normalizeProps(props: Record<string, any> | null) {\r\n  if (!props) return null\r\n  let { class: klass, style } = props\r\n  if (klass && !isString(klass)) {\r\n    props.class = normalizeClass(klass)\r\n  }\r\n  if (style) {\r\n    props.style = normalizeStyle(style)\r\n  }\r\n  return props\r\n}\r\n","// These tag configs are shared between compiler-dom and runtime-dom, so they\r\n// must be extracted in shared to avoid creating a dependency between the two.\r\nimport { makeMap } from './makeMap'\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\r\nconst HTML_TAGS =\r\n  'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\r\n  'header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\r\n  'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\r\n  'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\r\n  'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\r\n  'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\r\n  'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\r\n  'option,output,progress,select,textarea,details,dialog,menu,' +\r\n  'summary,template,blockquote,iframe,tfoot'\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\r\nconst SVG_TAGS =\r\n  'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\r\n  'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\r\n  'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\r\n  'feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\r\n  'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\r\n  'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\r\n  'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\r\n  'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\r\n  'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\r\n  'text,textPath,title,tspan,unknown,use,view'\r\n\r\n// https://www.w3.org/TR/mathml4/ (content elements excluded)\r\nconst MATH_TAGS =\r\n  'annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,' +\r\n  'merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,' +\r\n  'mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,' +\r\n  'mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,' +\r\n  'msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics'\r\n\r\nconst VOID_TAGS =\r\n  'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'\r\n\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `__DEV__` flag.\r\n */\r\nexport const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS)\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `__DEV__` flag.\r\n */\r\nexport const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS)\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `__DEV__` flag.\r\n */\r\nexport const isMathMLTag = /*#__PURE__*/ makeMap(MATH_TAGS)\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `__DEV__` flag.\r\n */\r\nexport const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS)\r\n","import { makeMap } from './makeMap'\r\n\r\n/**\r\n * On the client we only need to offer special cases for boolean attributes that\r\n * have different names from their corresponding dom properties:\r\n * - itemscope -> N/A\r\n * - allowfullscreen -> allowFullscreen\r\n * - formnovalidate -> formNoValidate\r\n * - ismap -> isMap\r\n * - nomodule -> noModule\r\n * - novalidate -> noValidate\r\n * - readonly -> readOnly\r\n */\r\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`\r\nexport const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs)\r\n\r\n/**\r\n * The full list is needed during SSR to produce the correct initial markup.\r\n */\r\nexport const isBooleanAttr = /*#__PURE__*/ makeMap(\r\n  specialBooleanAttrs +\r\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\r\n    `inert,loop,open,required,reversed,scoped,seamless,` +\r\n    `checked,muted,multiple,selected`,\r\n)\r\n\r\n/**\r\n * Boolean attributes should be included if the value is truthy or ''.\r\n * e.g. `<select multiple>` compiles to `{ multiple: '' }`\r\n */\r\nexport function includeBooleanAttr(value: unknown): boolean {\r\n  return !!value || value === ''\r\n}\r\n\r\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/\r\nconst attrValidationCache: Record<string, boolean> = {}\r\n\r\nexport function isSSRSafeAttrName(name: string): boolean {\r\n  if (attrValidationCache.hasOwnProperty(name)) {\r\n    return attrValidationCache[name]\r\n  }\r\n  const isUnsafe = unsafeAttrCharRE.test(name)\r\n  if (isUnsafe) {\r\n    console.error(`unsafe attribute name: ${name}`)\r\n  }\r\n  return (attrValidationCache[name] = !isUnsafe)\r\n}\r\n\r\nexport const propsToAttrMap: Record<string, string | undefined> = {\r\n  acceptCharset: 'accept-charset',\r\n  className: 'class',\r\n  htmlFor: 'for',\r\n  httpEquiv: 'http-equiv',\r\n}\r\n\r\n/**\r\n * Known attributes, this is used for stringification of runtime static nodes\r\n * so that we don't stringify bindings that cannot be set from HTML.\r\n * Don't also forget to allow `data-*` and `aria-*`!\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\r\n */\r\nexport const isKnownHtmlAttr = /*#__PURE__*/ makeMap(\r\n  `accept,accept-charset,accesskey,action,align,allow,alt,async,` +\r\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\r\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\r\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\r\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\r\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\r\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\r\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,` +\r\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\r\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\r\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\r\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\r\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\r\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\r\n    `value,width,wrap`,\r\n)\r\n\r\n/**\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute\r\n */\r\nexport const isKnownSvgAttr = /*#__PURE__*/ makeMap(\r\n  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +\r\n    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +\r\n    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +\r\n    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +\r\n    `color-interpolation-filters,color-profile,color-rendering,` +\r\n    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +\r\n    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +\r\n    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +\r\n    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +\r\n    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +\r\n    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +\r\n    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +\r\n    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +\r\n    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +\r\n    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +\r\n    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +\r\n    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +\r\n    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +\r\n    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +\r\n    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +\r\n    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +\r\n    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +\r\n    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +\r\n    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +\r\n    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +\r\n    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +\r\n    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +\r\n    `strikethrough-position,strikethrough-thickness,string,stroke,` +\r\n    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +\r\n    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +\r\n    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +\r\n    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +\r\n    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +\r\n    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +\r\n    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +\r\n    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +\r\n    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +\r\n    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,` +\r\n    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`,\r\n)\r\n\r\n/**\r\n * Shared between server-renderer and runtime-core hydration logic\r\n */\r\nexport function isRenderableAttrValue(value: unknown): boolean {\r\n  if (value == null) {\r\n    return false\r\n  }\r\n  const type = typeof value\r\n  return type === 'string' || type === 'number' || type === 'boolean'\r\n}\r\n","const escapeRE = /[\"'&<>]/\r\n\r\nexport function escapeHtml(string: unknown) {\r\n  const str = '' + string\r\n  const match = escapeRE.exec(str)\r\n\r\n  if (!match) {\r\n    return str\r\n  }\r\n\r\n  let html = ''\r\n  let escaped: string\r\n  let index: number\r\n  let lastIndex = 0\r\n  for (index = match.index; index < str.length; index++) {\r\n    switch (str.charCodeAt(index)) {\r\n      case 34: // \"\r\n        escaped = '&quot;'\r\n        break\r\n      case 38: // &\r\n        escaped = '&amp;'\r\n        break\r\n      case 39: // '\r\n        escaped = '&#39;'\r\n        break\r\n      case 60: // <\r\n        escaped = '&lt;'\r\n        break\r\n      case 62: // >\r\n        escaped = '&gt;'\r\n        break\r\n      default:\r\n        continue\r\n    }\r\n\r\n    if (lastIndex !== index) {\r\n      html += str.slice(lastIndex, index)\r\n    }\r\n\r\n    lastIndex = index + 1\r\n    html += escaped\r\n  }\r\n\r\n  return lastIndex !== index ? html + str.slice(lastIndex, index) : html\r\n}\r\n\r\n// https://www.w3.org/TR/html52/syntax.html#comments\r\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g\r\n\r\nexport function escapeHtmlComment(src: string): string {\r\n  return src.replace(commentStripRE, '')\r\n}\r\n","import { isArray, isDate, isObject, isSymbol } from './general'\r\n\r\nfunction looseCompareArrays(a: any[], b: any[]) {\r\n  if (a.length !== b.length) return false\r\n  let equal = true\r\n  for (let i = 0; equal && i < a.length; i++) {\r\n    equal = looseEqual(a[i], b[i])\r\n  }\r\n  return equal\r\n}\r\n\r\nexport function looseEqual(a: any, b: any): boolean {\r\n  if (a === b) return true\r\n  let aValidType = isDate(a)\r\n  let bValidType = isDate(b)\r\n  if (aValidType || bValidType) {\r\n    return aValidType && bValidType ? a.getTime() === b.getTime() : false\r\n  }\r\n  aValidType = isSymbol(a)\r\n  bValidType = isSymbol(b)\r\n  if (aValidType || bValidType) {\r\n    return a === b\r\n  }\r\n  aValidType = isArray(a)\r\n  bValidType = isArray(b)\r\n  if (aValidType || bValidType) {\r\n    return aValidType && bValidType ? looseCompareArrays(a, b) : false\r\n  }\r\n  aValidType = isObject(a)\r\n  bValidType = isObject(b)\r\n  if (aValidType || bValidType) {\r\n    /* istanbul ignore if: this if will probably never be called */\r\n    if (!aValidType || !bValidType) {\r\n      return false\r\n    }\r\n    const aKeysCount = Object.keys(a).length\r\n    const bKeysCount = Object.keys(b).length\r\n    if (aKeysCount !== bKeysCount) {\r\n      return false\r\n    }\r\n    for (const key in a) {\r\n      const aHasKey = a.hasOwnProperty(key)\r\n      const bHasKey = b.hasOwnProperty(key)\r\n      if (\r\n        (aHasKey && !bHasKey) ||\r\n        (!aHasKey && bHasKey) ||\r\n        !looseEqual(a[key], b[key])\r\n      ) {\r\n        return false\r\n      }\r\n    }\r\n  }\r\n  return String(a) === String(b)\r\n}\r\n\r\nexport function looseIndexOf(arr: any[], val: any): number {\r\n  return arr.findIndex(item => looseEqual(item, val))\r\n}\r\n","import {\r\n  isArray,\r\n  isFunction,\r\n  isMap,\r\n  isObject,\r\n  isPlainObject,\r\n  isSet,\r\n  isString,\r\n  isSymbol,\r\n  objectToString,\r\n} from './general'\r\n\r\n/**\r\n * For converting {{ interpolation }} values to displayed strings.\r\n * @private\r\n */\r\nexport const toDisplayString = (val: unknown): string => {\r\n  return isString(val)\r\n    ? val\r\n    : val == null\r\n      ? ''\r\n      : isArray(val) ||\r\n          (isObject(val) &&\r\n            (val.toString === objectToString || !isFunction(val.toString)))\r\n        ? JSON.stringify(val, replacer, 2)\r\n        : String(val)\r\n}\r\n\r\nconst replacer = (_key: string, val: any): any => {\r\n  // can't use isRef here since @vue/shared has no deps\r\n  if (val && val.__v_isRef) {\r\n    return replacer(_key, val.value)\r\n  } else if (isMap(val)) {\r\n    return {\r\n      [`Map(${val.size})`]: [...val.entries()].reduce(\r\n        (entries, [key, val], i) => {\r\n          entries[stringifySymbol(key, i) + ' =>'] = val\r\n          return entries\r\n        },\r\n        {} as Record<string, any>,\r\n      ),\r\n    }\r\n  } else if (isSet(val)) {\r\n    return {\r\n      [`Set(${val.size})`]: [...val.values()].map(v => stringifySymbol(v)),\r\n    }\r\n  } else if (isSymbol(val)) {\r\n    return stringifySymbol(val)\r\n  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\r\n    // native elements\r\n    return String(val)\r\n  }\r\n  return val\r\n}\r\n\r\nconst stringifySymbol = (v: unknown, i: number | string = ''): any =>\r\n  isSymbol(v) ? `Symbol(${v.description ?? i})` : v\r\n","import type { ReactiveEffect } from './effect'\r\nimport { warn } from './warning'\r\n\r\nlet activeEffectScope: EffectScope | undefined\r\n\r\nexport class EffectScope {\r\n  /**\r\n   * @internal\r\n   */\r\n  private _active = true\r\n  /**\r\n   * @internal\r\n   */\r\n  effects: ReactiveEffect[] = []\r\n  /**\r\n   * @internal\r\n   */\r\n  cleanups: (() => void)[] = []\r\n\r\n  /**\r\n   * only assigned by undetached scope\r\n   * @internal\r\n   */\r\n  parent: EffectScope | undefined\r\n  /**\r\n   * record undetached scopes\r\n   * @internal\r\n   */\r\n  scopes: EffectScope[] | undefined\r\n  /**\r\n   * track a child scope's index in its parent's scopes array for optimized\r\n   * removal\r\n   * @internal\r\n   */\r\n  private index: number | undefined\r\n\r\n  constructor(public detached = false) {\r\n    this.parent = activeEffectScope\r\n    if (!detached && activeEffectScope) {\r\n      this.index =\r\n        (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\r\n          this,\r\n        ) - 1\r\n    }\r\n  }\r\n\r\n  get active() {\r\n    return this._active\r\n  }\r\n\r\n  run<T>(fn: () => T): T | undefined {\r\n    if (this._active) {\r\n      const currentEffectScope = activeEffectScope\r\n      try {\r\n        activeEffectScope = this\r\n        return fn()\r\n      } finally {\r\n        activeEffectScope = currentEffectScope\r\n      }\r\n    } else if (__DEV__) {\r\n      warn(`cannot run an inactive effect scope.`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This should only be called on non-detached scopes\r\n   * @internal\r\n   */\r\n  on() {\r\n    activeEffectScope = this\r\n  }\r\n\r\n  /**\r\n   * This should only be called on non-detached scopes\r\n   * @internal\r\n   */\r\n  off() {\r\n    activeEffectScope = this.parent\r\n  }\r\n\r\n  stop(fromParent?: boolean) {\r\n    if (this._active) {\r\n      let i, l\r\n      for (i = 0, l = this.effects.length; i < l; i++) {\r\n        this.effects[i].stop()\r\n      }\r\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\r\n        this.cleanups[i]()\r\n      }\r\n      if (this.scopes) {\r\n        for (i = 0, l = this.scopes.length; i < l; i++) {\r\n          this.scopes[i].stop(true)\r\n        }\r\n      }\r\n      // nested scope, dereference from parent to avoid memory leaks\r\n      if (!this.detached && this.parent && !fromParent) {\r\n        // optimized O(1) removal\r\n        const last = this.parent.scopes!.pop()\r\n        if (last && last !== this) {\r\n          this.parent.scopes![this.index!] = last\r\n          last.index = this.index!\r\n        }\r\n      }\r\n      this.parent = undefined\r\n      this._active = false\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Creates an effect scope object which can capture the reactive effects (i.e.\r\n * computed and watchers) created within it so that these effects can be\r\n * disposed together. For detailed use cases of this API, please consult its\r\n * corresponding {@link https://github.com/vuejs/rfcs/blob/master/active-rfcs/0041-reactivity-effect-scope.md | RFC}.\r\n *\r\n * @param detached - Can be used to create a \"detached\" effect scope.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#effectscope}\r\n */\r\nexport function effectScope(detached?: boolean) {\r\n  return new EffectScope(detached)\r\n}\r\n\r\nexport function recordEffectScope(\r\n  effect: ReactiveEffect,\r\n  scope: EffectScope | undefined = activeEffectScope,\r\n) {\r\n  if (scope && scope.active) {\r\n    scope.effects.push(effect)\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the current active effect scope if there is one.\r\n *\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#getcurrentscope}\r\n */\r\nexport function getCurrentScope() {\r\n  return activeEffectScope\r\n}\r\n\r\n/**\r\n * Registers a dispose callback on the current active effect scope. The\r\n * callback will be invoked when the associated effect scope is stopped.\r\n *\r\n * @param fn - The callback function to attach to the scope's cleanup.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#onscopedispose}\r\n */\r\nexport function onScopeDispose(fn: () => void) {\r\n  if (activeEffectScope) {\r\n    activeEffectScope.cleanups.push(fn)\r\n  } else if (__DEV__) {\r\n    warn(\r\n      `onScopeDispose() is called when there is no active effect scope` +\r\n        ` to be associated with.`,\r\n    )\r\n  }\r\n}\r\n","import { NOOP, extend } from '@vue/shared'\r\nimport type { ComputedRefImpl } from './computed'\r\nimport {\r\n  DirtyLevels,\r\n  type TrackOpTypes,\r\n  type TriggerOpTypes,\r\n} from './constants'\r\nimport type { Dep } from './dep'\r\nimport { type EffectScope, recordEffectScope } from './effectScope'\r\n\r\nexport type EffectScheduler = (...args: any[]) => any\r\n\r\nexport type DebuggerEvent = {\r\n  effect: ReactiveEffect\r\n} & DebuggerEventExtraInfo\r\n\r\nexport type DebuggerEventExtraInfo = {\r\n  target: object\r\n  type: TrackOpTypes | TriggerOpTypes\r\n  key: any\r\n  newValue?: any\r\n  oldValue?: any\r\n  oldTarget?: Map<any, any> | Set<any>\r\n}\r\n\r\nexport let activeEffect: ReactiveEffect | undefined\r\n\r\n// 副作用函数\r\nexport class ReactiveEffect<T = any> {\r\n  active = true\r\n  /**\r\n   * 多对多的关系，一个副作用函数可以包含多个依赖的响应对象，一个响应对象可以存在多个副作用函数中\r\n   */\r\n  deps: Dep[] = []\r\n\r\n  /**\r\n   * Can be attached after creation\r\n   * @internal\r\n   */\r\n  computed?: ComputedRefImpl<T>\r\n  /**\r\n   * @internal\r\n   */\r\n  allowRecurse?: boolean\r\n\r\n  onStop?: () => void\r\n  // dev only\r\n  onTrack?: (event: DebuggerEvent) => void\r\n  // dev only\r\n  onTrigger?: (event: DebuggerEvent) => void\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  _dirtyLevel = DirtyLevels.Dirty\r\n  /**\r\n   * @internal\r\n   */\r\n  _trackId = 0\r\n  /**\r\n   * @internal\r\n   */\r\n  _runnings = 0\r\n  /**\r\n   * @internal\r\n   */\r\n  _shouldSchedule = false\r\n  /**\r\n   * @internal\r\n   */\r\n  _depsLength = 0\r\n\r\n  constructor(\r\n    public fn: () => T,\r\n    public trigger: () => void,\r\n    public scheduler?: EffectScheduler,\r\n    scope?: EffectScope,\r\n  ) {\r\n    recordEffectScope(this, scope)\r\n  }\r\n\r\n  public get dirty() {\r\n    if (this._dirtyLevel === DirtyLevels.MaybeDirty) {\r\n      pauseTracking()\r\n      for (let i = 0; i < this._depsLength; i++) {\r\n        const dep = this.deps[i]\r\n        if (dep.computed) {\r\n          triggerComputed(dep.computed)\r\n          if (this._dirtyLevel >= DirtyLevels.Dirty) {\r\n            break\r\n          }\r\n        }\r\n      }\r\n      if (this._dirtyLevel < DirtyLevels.Dirty) {\r\n        this._dirtyLevel = DirtyLevels.NotDirty\r\n      }\r\n      resetTracking()\r\n    }\r\n    return this._dirtyLevel >= DirtyLevels.Dirty\r\n  }\r\n\r\n  public set dirty(v) {\r\n    this._dirtyLevel = v ? DirtyLevels.Dirty : DirtyLevels.NotDirty\r\n  }\r\n\r\n  // 1 last null active p1\r\n  // 2 last p1 active p2\r\n  // 3 last p2 active p3\r\n  // p3执行完 active p2\r\n  // p2环境 执行完 active p1\r\n  // p3环境执行完\r\n  /**\r\n   * 总而言之：\r\n   * 1. lastEffect和activeEffect是为了防止堆栈递归调用effect函数的情况；\r\n   * 2. preCleanupEffect和postCleanupEffect结合_trackId目的就是为了每次执行前先斩断依赖对象和副作用函数之间的关系，\r\n   * 执行之后再重新收集依赖关系，但是呢从性能上考虑清空的时候不是直接把deps数组长度清空，\r\n   * 而是先通过_depsLength设置为0，重新建立正确的依赖关系，把多余的元素再剪短依赖关系\r\n   * 3. _trackId是副作用对象的执行次数追踪id\r\n   */\r\n  run() {\r\n    this._dirtyLevel = DirtyLevels.NotDirty // 只要即将执行，就是标志为NotDirty，比如一些异步函数，如果等执行完，\r\n    if (!this.active) {\r\n      return this.fn()\r\n    }\r\n    let lastShouldTrack = shouldTrack\r\n    let lastEffect = activeEffect\r\n    try {\r\n      shouldTrack = true\r\n      activeEffect = this\r\n      this._runnings++\r\n      /**\r\n       * 通过preCleaupEffect方法\r\n       * 标识执行状态_trackId加1了，然后把_depsLength设置为零\r\n       */\r\n      preCleanupEffect(this);\r\n      /**\r\n       * 执行fn副作用函数的时候，会重新手机依赖对象\r\n       * 收集的过程有多种情况：\r\n       * （1）只是把Dep中的key对应的value（_trackId）更新，它们的依赖关系依赖没变\r\n       * （2）存在有一些依赖对象没有执行到的，那这个时候deps里面的元素是比_depsLength要多\r\n       */\r\n      return this.fn()\r\n    } finally {\r\n      /**\r\n       * 收集过程中，走到清空2，\r\n       * 通过postCleanupEffect，把deps中多余的元素清空，并且见到多余的依赖对象和副作用函数之间的关系\r\n       */\r\n      postCleanupEffect(this)\r\n      /**\r\n       * _running的作用：\r\n       * （1）如果一个副作用函数对一个key先有get,然后set操作，因为_running不为0，所以后面的set操作不会再次触发副作用函数的执行\r\n       * （2）如果副作用函数是一个异步函数，在副作用函数还没执行结束之前，就发生了依赖对象key的改变，因为_running也不会再次触发副作用函数\r\n       */\r\n      this._runnings--\r\n      activeEffect = lastEffect\r\n      shouldTrack = lastShouldTrack\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    if (this.active) {\r\n      preCleanupEffect(this)\r\n      postCleanupEffect(this)\r\n      this.onStop?.()\r\n      this.active = false\r\n    }\r\n  }\r\n}\r\n\r\nfunction triggerComputed(computed: ComputedRefImpl<any>) {\r\n  return computed.value\r\n}\r\n\r\nfunction preCleanupEffect(effect: ReactiveEffect) {\r\n  effect._trackId++\r\n  effect._depsLength = 0\r\n}\r\n\r\nfunction postCleanupEffect(effect: ReactiveEffect) {\r\n  if (effect.deps && effect.deps.length > effect._depsLength) {\r\n    for (let i = effect._depsLength; i < effect.deps.length; i++) {\r\n      cleanupDepEffect(effect.deps[i], effect)\r\n    }\r\n    effect.deps.length = effect._depsLength\r\n  }\r\n}\r\n\r\nfunction cleanupDepEffect(dep: Dep, effect: ReactiveEffect) {\r\n  const trackId = dep.get(effect)\r\n   //这里判断原因\r\n  /**\r\n   * 比如说ok text name三个属性，\r\n   * 第二次ok为true了，\r\n   * text对应的代码不会再执行到了，name就占据到deps中的第二个位置，再执行postCleanupEffect方法时候\r\n   * 第三个元素其实就是第二个元素，trackId是等于effect._trackId的\r\n   */\r\n  if (trackId !== undefined && effect._trackId !== trackId) {\r\n    dep.delete(effect)\r\n    if (dep.size === 0) {\r\n      dep.cleanup()\r\n    }\r\n  }\r\n}\r\n\r\nexport interface DebuggerOptions {\r\n  onTrack?: (event: DebuggerEvent) => void\r\n  onTrigger?: (event: DebuggerEvent) => void\r\n}\r\n\r\nexport interface ReactiveEffectOptions extends DebuggerOptions {\r\n  lazy?: boolean\r\n  scheduler?: EffectScheduler\r\n  scope?: EffectScope\r\n  allowRecurse?: boolean\r\n  onStop?: () => void\r\n}\r\n\r\nexport interface ReactiveEffectRunner<T = any> {\r\n  (): T\r\n  effect: ReactiveEffect\r\n}\r\n\r\n/**\r\n * Registers the given function to track reactive updates.\r\n *\r\n * The given function will be run once immediately. Every time any reactive\r\n * property that's accessed within it gets updated, the function will run again.\r\n *\r\n * @param fn - The function that will track reactive updates.\r\n * @param options - Allows to control the effect's behaviour.\r\n * @returns A runner that can be used to control the effect after creation.\r\n */\r\nexport function effect<T = any>(\r\n  fn: () => T,\r\n  options?: ReactiveEffectOptions,\r\n): ReactiveEffectRunner {\r\n  if ((fn as ReactiveEffectRunner).effect instanceof ReactiveEffect) {\r\n    fn = (fn as ReactiveEffectRunner).effect.fn\r\n  }\r\n\r\n  const _effect = new ReactiveEffect(fn, NOOP, () => {\r\n    if (_effect.dirty) {\r\n      _effect.run()\r\n    }\r\n  })\r\n  if (options) {\r\n    extend(_effect, options)\r\n    if (options.scope) recordEffectScope(_effect, options.scope)\r\n  }\r\n  if (!options || !options.lazy) {\r\n    _effect.run()\r\n  }\r\n  const runner = _effect.run.bind(_effect) as ReactiveEffectRunner\r\n  runner.effect = _effect\r\n  return runner\r\n}\r\n\r\n/**\r\n * Stops the effect associated with the given runner.\r\n *\r\n * @param runner - Association with the effect to stop tracking.\r\n */\r\nexport function stop(runner: ReactiveEffectRunner) {\r\n  runner.effect.stop()\r\n}\r\n\r\nexport let shouldTrack = true\r\nexport let pauseScheduleStack = 0\r\n\r\nconst trackStack: boolean[] = []\r\n\r\n/**\r\n * Temporarily pauses tracking.\r\n */\r\nexport function pauseTracking() {\r\n  trackStack.push(shouldTrack)\r\n  shouldTrack = false\r\n}\r\n\r\n/**\r\n * Re-enables effect tracking (if it was paused).\r\n */\r\nexport function enableTracking() {\r\n  trackStack.push(shouldTrack)\r\n  shouldTrack = true\r\n}\r\n\r\n/**\r\n * Resets the previous global effect tracking state.\r\n */\r\nexport function resetTracking() {\r\n  const last = trackStack.pop()\r\n  shouldTrack = last === undefined ? true : last\r\n}\r\n\r\nexport function pauseScheduling() {\r\n  pauseScheduleStack++\r\n}\r\n\r\nexport function resetScheduling() {\r\n  pauseScheduleStack--\r\n  while (!pauseScheduleStack && queueEffectSchedulers.length) {\r\n    queueEffectSchedulers.shift()!()\r\n  }\r\n}\r\n\r\nexport function trackEffect(\r\n  effect: ReactiveEffect,\r\n  dep: Dep,\r\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo,\r\n) {\r\n  /**\r\n   * 比如在一个副作用函数中两次及以上使用了同一个代理对象的key的值，那第二次进入的时候，因为已经存在了且_trackId是相同的，就不会重复添加\r\n   * effect的_trackId的作用就是一个状态id，每执行一次，_trackId就加1，这样做目的：\r\n   * 第一次执行副作用函数的时候，会记录所有依赖对象的deps，但是后面执行条件发生改变了，可能某些依赖对象根本不会执行到，所以每次执行副作用函数\r\n   * 之前需要清空副作用函数对应的依赖对象，执行后又重新创建依赖对象，通过_depsLength和deps这样每次清空的时候，不会直接先把数组给清空了\r\n   * 所以第二次执行的时候_trackId是已经改变了\r\n   */\r\n  if (dep.get(effect) !== effect._trackId) {\r\n    dep.set(effect, effect._trackId)\r\n    const oldDep = effect.deps[effect._depsLength]\r\n    if (oldDep !== dep) {\r\n      if (oldDep) {\r\n        cleanupDepEffect(oldDep, effect)\r\n      }\r\n      effect.deps[effect._depsLength++] = dep\r\n    } else {\r\n      effect._depsLength++\r\n    }\r\n    if (__DEV__) {\r\n      effect.onTrack?.(extend({ effect }, debuggerEventExtraInfo!))\r\n    }\r\n  }\r\n}\r\n\r\nconst queueEffectSchedulers: EffectScheduler[] = []\r\n\r\n/**\r\n * 比如一个副作用函数即引用了代理A对象p属性的值，又循环遍历代理对象A\r\n * 那么A对象p属性的值更改时，即会触发p属性对应的副作用，也会触发迭代器对应的副作用\r\n * 第一次_dirtyLevel是NotDirty，改为Dirty，然后把该副作用函数先计入副作用调度器队列里面\r\n * 第二次通过迭代器进入triggerEffects的时候，因为都是同一个副作用对象，因为lastDirtyLevel已经是Dirty，所以不会再进入if里面，\r\n * 避免重复执行，比如以下场景：\r\n * const observed = reactive([1,2,3]);\r\n     effect(() => {\r\n        console.log(observed[3]);\r\n        for(let item of observed) {\r\n            console.log(item);\r\n        }\r\n    });\r\n    setTimeout(() => {\r\n        observed[3] = 5;\r\n    }, 500)\r\n    属性值length和key为3都会对effect建立依赖关系，observed[3]改变的时候，length和3对应的effect都会执行，因为通过_dirtyLevel和队列的形式，副作用只会加入到队列中一次并只执行一次（队列的作用不仅仅只有这一个）。\r\n */\r\nexport function triggerEffects(\r\n  dep: Dep,\r\n  dirtyLevel: DirtyLevels,\r\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo,\r\n) {\r\n  pauseScheduling()\r\n  for (const effect of dep.keys()) {\r\n    if (\r\n      effect._dirtyLevel < dirtyLevel && // 上一次没有dirty，这一次dirty，如果上一次正在dirty中，说明上一次副作用函数还没执行完，每次执行副作用函数之前都会把dirty设置为notdirty\r\n      dep.get(effect) === effect._trackId \r\n    ) {\r\n      const lastDirtyLevel = effect._dirtyLevel\r\n      effect._dirtyLevel = dirtyLevel\r\n      if (lastDirtyLevel === DirtyLevels.NotDirty) {\r\n        effect._shouldSchedule = true\r\n        if (__DEV__) {\r\n          effect.onTrigger?.(extend({ effect }, debuggerEventExtraInfo))\r\n        }\r\n        effect.trigger()\r\n      }\r\n    }\r\n  }\r\n  scheduleEffects(dep)\r\n  resetScheduling()\r\n}\r\n\r\n/**\r\n * 如果一个副作用函数对某个key先get，再set，那么set触发trigger，进入这个函数，_runnings不为0，allowRecurse默认是false\r\n * 所以不会重新调用副作用函数，不然就有可能进入死循环\r\n */\r\nexport function scheduleEffects(dep: Dep) {\r\n  for (const effect of dep.keys()) {\r\n    if (\r\n      effect.scheduler &&\r\n      effect._shouldSchedule &&\r\n      (!effect._runnings || effect.allowRecurse) &&\r\n      dep.get(effect) === effect._trackId\r\n    ) {\r\n      effect._shouldSchedule = false\r\n      queueEffectSchedulers.push(effect.scheduler)\r\n    }\r\n  }\r\n}\r\n","import type { ReactiveEffect } from './effect'\r\nimport type { ComputedRefImpl } from './computed'\r\n\r\nexport type Dep = Map<ReactiveEffect, number> & {\r\n  cleanup: () => void\r\n  computed?: ComputedRefImpl<any>\r\n}\r\n\r\nexport const createDep = (\r\n  cleanup: () => void,\r\n  computed?: ComputedRefImpl<any>,\r\n): Dep => {\r\n  const dep = new Map() as Dep\r\n  dep.cleanup = cleanup\r\n  dep.computed = computed\r\n  return dep\r\n}\r\n","import { isArray, isIntegerKey, isMap, isSymbol } from '@vue/shared'\r\nimport { DirtyLevels, type TrackOpTypes, TriggerOpTypes } from './constants'\r\nimport { type Dep, createDep } from './dep'\r\nimport {\r\n  activeEffect,\r\n  pauseScheduling,\r\n  resetScheduling,\r\n  shouldTrack,\r\n  trackEffect,\r\n  triggerEffects,\r\n} from './effect'\r\n\r\n// The main WeakMap that stores {target -> key -> dep} connections.\r\n// Conceptually, it's easier to think of a dependency as a Dep class\r\n// which maintains a Set of subscribers, but we simply store them as\r\n// raw Maps to reduce memory overhead.\r\ntype KeyToDepMap = Map<any, Dep>\r\nconst targetMap = new WeakMap<object, KeyToDepMap>()\r\n\r\nexport const ITERATE_KEY = Symbol(__DEV__ ? 'iterate' : '')\r\nexport const MAP_KEY_ITERATE_KEY = Symbol(__DEV__ ? 'Map key iterate' : '')\r\n\r\n/**\r\n * Tracks access to a reactive property.\r\n *\r\n * This will check which effect is running at the moment and record it as dep\r\n * which records all effects that depend on the reactive property.\r\n *\r\n * @param target - Object holding the reactive property.\r\n * @param type - Defines the type of access to the reactive property.\r\n * @param key - Identifier of the reactive property to track.\r\n */\r\n/**\r\n * 有三层：\r\n * 所有的响应对象target构成一个WeapMap\r\n * 简单地说，WeakMap 对 key 是弱引用，不影响垃圾回收器的工作。据这个特性可知，一旦 key 被垃圾回收器回收，那么对应的键和值就访问不到了。所以 WeakMap 经常用于存储那些只有当 key 所引用的对象存在时（没有被回收）才有价值的信息，例如上面的场景中，如果 target 对象没有任何引用了，说明用户侧不再需要它了，这时垃圾回收器会完成回收任务。但如果使用 Map 来代替WeakMap，那么即使用户侧的代码对 target 没有任何引用，这个 target 也不会被回收，最终可能导致内存溢出。\r\n * 单个响应对象中所有key构成一个map\r\n * 单个key对应的是Dep对象，但是Dep也是一个包含cleanup方法的map\r\n * \r\n */\r\nexport function track(target: object, type: TrackOpTypes, key: unknown) {\r\n  /**\r\n   * 判断activeEffect：只要当前执行的环境是在副作用函数中才需要去手机\r\n   * 判断shouldTrack：比如对于数组，调用push方法，会先获取length（get操作获取length），再往数组中添加元素（set操作）。\r\n   * 如下场景：两个副作用之间会进入一个互相触发执行的死循环的，所以对于像push方法，应该shouldTrack标识为false，这样就不会去进行副作用的依赖收集，本质上push是改变数组的值，也不需要去track依赖\r\n   * effect(() => {\r\n        observed.push(1)\r\n      });\r\n      effect(() => {\r\n          observed.push(2)\r\n      })\r\n   */\r\n  if (shouldTrack && activeEffect) {\r\n    let depsMap = targetMap.get(target)\r\n    if (!depsMap) {\r\n      targetMap.set(target, (depsMap = new Map()))\r\n    }\r\n    let dep = depsMap.get(key)\r\n    if (!dep) {\r\n      depsMap.set(key, (dep = createDep(() => depsMap!.delete(key))))\r\n    }\r\n    trackEffect(\r\n      activeEffect,\r\n      dep,\r\n      __DEV__\r\n        ? {\r\n            target,\r\n            type,\r\n            key,\r\n          }\r\n        : void 0,\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * Finds all deps associated with the target (or a specific property) and\r\n * triggers the effects stored within.\r\n *\r\n * @param target - The reactive object.\r\n * @param type - Defines the type of the operation that needs to trigger effects.\r\n * @param key - Can be used to target a specific reactive property in the target object.\r\n */\r\nexport function trigger(\r\n  target: object,\r\n  type: TriggerOpTypes,\r\n  key?: unknown,\r\n  newValue?: unknown,\r\n  oldValue?: unknown,\r\n  oldTarget?: Map<unknown, unknown> | Set<unknown>,\r\n) {\r\n  const depsMap = targetMap.get(target)\r\n  if (!depsMap) {\r\n    // never been tracked\r\n    return\r\n  }\r\n\r\n  let deps: (Dep | undefined)[] = []\r\n  /**\r\n   * map和set对象中clear方法调用，所有元素都被清空了，所有元素对应的副作用都需要执行\r\n   */\r\n  if (type === TriggerOpTypes.CLEAR) {\r\n    // collection being cleared\r\n    // trigger all effects for target\r\n    deps = [...depsMap.values()]\r\n  } else if (key === 'length' && isArray(target)) {\r\n    /**\r\n     * for in 会在ownKeys方法中track收集length的依赖；\r\n     * for of内部会先获取length，所以会在get中收集length的依赖\r\n     * \r\n     * 这样的场景：直接改变数组的长度，除了触发length（for in/for of）的依赖副作用之外，还有超出设置长度的那些元素也会触发依赖（相当于超出长度的那些元素被删除了）\r\n     * const observed = reactive([1,2,3]);\r\n      effect(() => {\r\n          for(let key of observed) {\r\n              console.log(key)\r\n          }\r\n      });\r\n      setTimeout(() => {\r\n          observed.length = 2;\r\n      }, 1000)\r\n     */\r\n    const newLength = Number(newValue)\r\n    depsMap.forEach((dep, key) => {\r\n      if (key === 'length' || (!isSymbol(key) && key >= newLength)) {\r\n        deps.push(dep)\r\n      }\r\n    })\r\n  } else {\r\n    // schedule runs for SET | ADD | DELETE\r\n    if (key !== void 0) {\r\n      deps.push(depsMap.get(key))\r\n    }\r\n\r\n    // also run for iteration key on ADD | DELETE | Map.SET\r\n    switch (type) {\r\n      /**\r\n       * 对象添加属性、数组添加元素、Map的set方法执行、Set的add方法执行\r\n       */\r\n      case TriggerOpTypes.ADD:\r\n        if (!isArray(target)) {\r\n          /**\r\n           * ITERATE_KEY：\r\n           *（1）普通对象的for in \r\n           * (2) Map和Set的size\r\n           * (3) Map和Set的forEach\r\n           * (4) Set和Map的迭代器（values/entries)\r\n           * \r\n           * MAP_KEY_ITERATE_KEY：\r\n           * （1）Map的迭代器方法keys\r\n           */\r\n          deps.push(depsMap.get(ITERATE_KEY))\r\n          if (isMap(target)) {\r\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\r\n          }\r\n        } else if (isIntegerKey(key)) {\r\n          // 如果是数组，那么对应还需要触发length\r\n          // new index added to array -> length changes\r\n          deps.push(depsMap.get('length'))\r\n        }\r\n        break\r\n      case TriggerOpTypes.DELETE:\r\n        if (!isArray(target)) {\r\n          /**\r\n           * 原理同上\r\n           * 不会去delete 一个数组的元素\r\n           */\r\n          deps.push(depsMap.get(ITERATE_KEY))\r\n          if (isMap(target)) {\r\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\r\n          }\r\n        }\r\n        break\r\n      case TriggerOpTypes.SET:\r\n        /**\r\n         * 如果是Map，修改值的话，还需要触发对应的迭代器（values/entries/forEach）\r\n         */\r\n        if (isMap(target)) {\r\n          deps.push(depsMap.get(ITERATE_KEY))\r\n        }\r\n        break\r\n    }\r\n  }\r\n\r\n  pauseScheduling()\r\n  for (const dep of deps) {\r\n    if (dep) {\r\n      triggerEffects(\r\n        dep,\r\n        DirtyLevels.Dirty,\r\n        __DEV__\r\n          ? {\r\n              target,\r\n              type,\r\n              key,\r\n              newValue,\r\n              oldValue,\r\n              oldTarget,\r\n            }\r\n          : void 0,\r\n      )\r\n    }\r\n  }\r\n  resetScheduling()\r\n}\r\n\r\nexport function getDepFromReactive(object: any, key: string | number | symbol) {\r\n  return targetMap.get(object)?.get(key)\r\n}\r\n","import {\r\n  type Target,\r\n  isReadonly,\r\n  isShallow,\r\n  reactive,\r\n  reactiveMap,\r\n  readonly,\r\n  readonlyMap,\r\n  shallowReactiveMap,\r\n  shallowReadonlyMap,\r\n  toRaw,\r\n} from './reactive'\r\nimport { ReactiveFlags, TrackOpTypes, TriggerOpTypes } from './constants'\r\nimport {\r\n  pauseScheduling,\r\n  pauseTracking,\r\n  resetScheduling,\r\n  resetTracking,\r\n} from './effect'\r\nimport { ITERATE_KEY, track, trigger } from './reactiveEffect'\r\nimport {\r\n  hasChanged,\r\n  hasOwn,\r\n  isArray,\r\n  isIntegerKey,\r\n  isObject,\r\n  isSymbol,\r\n  makeMap,\r\n} from '@vue/shared'\r\nimport { isRef } from './ref'\r\nimport { warn } from './warning'\r\n\r\nconst isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`)\r\n\r\nconst builtInSymbols = new Set(\r\n  /*#__PURE__*/\r\n  Object.getOwnPropertyNames(Symbol)\r\n    /**\r\n     * 在iOS10.x中，Object.getOwnPropertyNames(Symbol)可以枚举\"arguments\"和\"caller\"，但是Symbol对象上访问\r\n     * 这些属性会导致TypeError，因为Symbol是一个严格模式函数\r\n     */\r\n    .filter(key => key !== 'arguments' && key !== 'caller')\r\n    .map(key => (Symbol as any)[key])\r\n    .filter(isSymbol),\r\n)\r\n\r\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations()\r\n\r\nfunction createArrayInstrumentations() {\r\n  const instrumentations: Record<string, Function> = {}\r\n  // instrument identity-sensitive Array methods to account for possible reactive\r\n  // values\r\n  ;(['includes', 'indexOf', 'lastIndexOf'] as const).forEach(key => {\r\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\r\n      const arr = toRaw(this) as any\r\n      for (let i = 0, l = this.length; i < l; i++) {\r\n        track(arr, TrackOpTypes.GET, i + '')\r\n      }\r\n      // we run the method using the original args first (which may be reactive)\r\n      const res = arr[key](...args)\r\n      if (res === -1 || res === false) {\r\n        // if that didn't work, run it again using raw values.\r\n        return arr[key](...args.map(toRaw))\r\n      } else {\r\n        return res\r\n      }\r\n    }\r\n  })\r\n  // instrument length-altering mutation methods to avoid length being tracked\r\n  // which leads to infinite loops in some cases (#2137)\r\n  ;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach(key => {\r\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\r\n      pauseTracking()\r\n      pauseScheduling()\r\n      const res = (toRaw(this) as any)[key].apply(this, args)\r\n      resetScheduling()\r\n      resetTracking()\r\n      return res\r\n    }\r\n  })\r\n  return instrumentations\r\n}\r\n\r\nfunction hasOwnProperty(this: object, key: string) {\r\n  const obj = toRaw(this)\r\n  track(obj, TrackOpTypes.HAS, key)\r\n  return obj.hasOwnProperty(key)\r\n}\r\n\r\nclass BaseReactiveHandler implements ProxyHandler<Target> {\r\n  constructor(\r\n    protected readonly _isReadonly = false,\r\n    protected readonly _shallow = false,\r\n  ) {}\r\n\r\n  // 获取对象的属性值\r\n  get(target: Target, key: string | symbol, receiver: object) {\r\n    const isReadonly = this._isReadonly,\r\n      shallow = this._shallow\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return !isReadonly\r\n    } else if (key === ReactiveFlags.IS_READONLY) {\r\n      return isReadonly\r\n    } else if (key === ReactiveFlags.IS_SHALLOW) {\r\n      return shallow\r\n    } else if (key === ReactiveFlags.RAW) {\r\n      // 判断receiver是否是target的代理对象，或者receiver和target被同一个对象代理了\r\n      // 获取原始对象\r\n      /**\r\n       * 如下情况：\r\n       * const { reactive, effect } = Vue;\r\n        const o1 = {s: 'c'};\r\n        const o2 = {id: 1, s: 'p'};\r\n        const c = reactive(o1);\r\n        const p = reactive(o2);\r\n        Object.setPrototypeOf(c, p);\r\n        effect(() => {\r\n            console.log(c.id);\r\n        }) \r\n        获取c.id的时候第一次进入child的get方法，发现没有id属性，然后就会进入parent的get方法，这个时候target是o2，但是receiver是c\r\n       */\r\n      if (\r\n        receiver ===\r\n          (isReadonly\r\n            ? shallow\r\n              ? shallowReadonlyMap\r\n              : readonlyMap\r\n            : shallow\r\n              ? shallowReactiveMap\r\n              : reactiveMap\r\n          ).get(target) ||\r\n        // receiver is not the reactive proxy, but has the same prototype\r\n        // this means the reciever is a user proxy of the reactive proxy\r\n        Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)\r\n      ) {\r\n        return target\r\n      }\r\n      // early return undefined\r\n      return\r\n    }\r\n\r\n    const targetIsArray = isArray(target)\r\n\r\n    if (!isReadonly) {\r\n      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n        return Reflect.get(arrayInstrumentations, key, receiver)\r\n      }\r\n      if (key === 'hasOwnProperty') {\r\n        return hasOwnProperty\r\n      }\r\n    }\r\n    /**\r\n     * target是原对象，\r\n     * receiver是代理对象\r\n     * 这里之所以使用Reflect\r\n     * const obj = {\r\n     *  id: 1,\r\n     *  get uuid () {\r\n     *    return this.id\r\n     * }\r\n     * }\r\n     * const proxy = new Proxy(obj)\r\n     * 方法proxy.uuid时，this始终指向代理对象\r\n     */\r\n    const res = Reflect.get(target, key, receiver)\r\n\r\n    // 是否是哪些不被追踪的属性\r\n    // 防止数组的[Symbol.iterator]被收集，for of遍历的时候会先调用[Symbol.iterator]，然后再获取内部的length，所以[Symbol.iterator]被忽略，值收集length的依赖，防止一个副作用函数被收集两次\r\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\r\n      return res\r\n    }\r\n\r\n    // 只读对象不需要追踪依赖，对象的属性值是不会改变的，所以不需要追踪\r\n    if (!isReadonly) {\r\n      track(target, TrackOpTypes.GET, key)\r\n    }\r\n    // 如果是浅依赖的就直接返回，不需要再递归创建代理\r\n    if (shallow) {\r\n      return res\r\n    }\r\n    /**\r\n     * 所以即使props中传入给子组件的值是ref也能正确取值，返回的是ref的value值\r\n     */\r\n    if (isRef(res)) {\r\n      // ref unwrapping - skip unwrap for Array + integer key.\r\n      return targetIsArray && isIntegerKey(key) ? res : res.value\r\n    }\r\n\r\n    if (isObject(res)) {\r\n      // Convert returned value into a proxy as well. we do the isObject check\r\n      // here to avoid invalid value warning. Also need to lazy access readonly\r\n      // and reactive here to avoid circular dependency.\r\n      return isReadonly ? readonly(res) : reactive(res)\r\n    }\r\n\r\n    return res\r\n  }\r\n}\r\n\r\nclass MutableReactiveHandler extends BaseReactiveHandler {\r\n  constructor(shallow = false) {\r\n    super(false, shallow)\r\n  }\r\n\r\n  // 给对象添加属性值/或者给对象修改属性值\r\n  set(\r\n    target: object,\r\n    key: string | symbol,\r\n    value: unknown,\r\n    receiver: object,\r\n  ): boolean {\r\n    let oldValue = (target as any)[key]\r\n    /**\r\n     * 如果是浅层的，那么自然只有第一层，第二层都是原始对象了\r\n     */\r\n    if (!this._shallow) {\r\n      // 原来key对应的值是响应式的，且只可读，则不允许设置\r\n      /**\r\n       * value可能本身就是oldvalue的代理对象，所以需要先把value原始的对象取出来，这样，再hasChanged比较的时候就不会有问题\r\n       * 这种情况下，hasChanged应该是false，如果不这样操作，hasChanged就会变成true，\r\n       * 反正在get方法的时候取出来会递归调用reactive，获取值的时候仍然是代理对象\r\n       * let obj = {city: 'gz', address: 'panyu'};\r\n        const d = reactive(obj);\r\n        const person = reactive({id: 1, name: 'ff', d: obj});\r\n        effect(() => {\r\n            console.log(person.d) \r\n        })\r\n        setTimeout(() => {\r\n            person.d = d; //不会触发以上的effect\r\n        }, 100)\r\n       * \r\n       * 如果oldValue是元素对象，value是oldValue的可读的对象，那说明value是不会被track/trigger，value根本不会被改变，不用担心trigger\r\n       * 如果是shallow，因为this._shallow已经是false，说明本身target创建的代理对象就是深度，而现在要给他复制shallowReactive，\r\n       * 虽然对应的是同一个代理对象，但是属性值仍然是改变了的\r\n       * let obj = {city: 'gz', address: 'panyu'};\r\n          const d = shallowReactive(obj);\r\n          const person = reactive({id: 1, name: 'ff', d: obj});\r\n          effect(() => {\r\n              console.log(person.d)\r\n          })\r\n          setTimeout(() => {\r\n              person.d = d; // 会再次触发以上的effect\r\n          }, 100)\r\n       * 这里还有一个原因就是为了防止数据污染，比如有两个响应对象p1,p2，将p2设置成p1的某个属性值，\r\n          const obj = {city: 'gz', address: 'panyu'};\r\n          const p1 = reactive(obj);\r\n          const p2 = reactive({});\r\n          p1['p2'] = p2;\r\n          effect(() => {\r\n              console.log(obj.p2.id)\r\n          });\r\n          console.log(p1.p2, obj.p2)\r\n          setTimeout(() => {\r\n              obj.p2.id = 11;\r\n          })\r\n          如果不经过这样的操作，那么obj.p2对应的就是p2响应对象，那么obj.p2.id改变的时候就会触发effect执行，\r\n          现在因为obj.p2是原始对象了，所以不会有这个数据污染问题\r\n          （把响应式数据设置到原始数据上的行为称为样式污染\r\n       */\r\n      const isOldValueReadonly = isReadonly(oldValue)\r\n      if (!isShallow(value) && !isReadonly(value)) {\r\n        oldValue = toRaw(oldValue)\r\n        value = toRaw(value)\r\n      }\r\n      // 如果对象的key值原来是ref，新的值不是ref，则将新的值赋值给原来key对应的值\r\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n        if (isOldValueReadonly) {\r\n          return false\r\n        } else {\r\n          oldValue.value = value\r\n          return true\r\n        }\r\n      }\r\n    } else {\r\n      // in shallow mode, objects are set as-is regardless of reactive or not\r\n    }\r\n\r\n    const hadKey =\r\n      isArray(target) && isIntegerKey(key)\r\n        ? Number(key) < target.length\r\n        : hasOwn(target, key)\r\n    const result = Reflect.set(target, key, value, receiver)\r\n    // don't trigger if target is something up in the prototype chain of original\r\n    if (target === toRaw(receiver)) {\r\n      if (!hadKey) {\r\n        // 如果是给对象新增加值，增加的值夜不是ref，则触发add\r\n        trigger(target, TriggerOpTypes.ADD, key, value)\r\n      } else if (hasChanged(value, oldValue)) {\r\n        // 如果是修改原来的值，则触发set\r\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)\r\n      }\r\n    }\r\n    return result\r\n  }\r\n\r\n  // delete操作触发，比如 delete observed.foo\r\n  deleteProperty(target: object, key: string | symbol): boolean {\r\n    const hadKey = hasOwn(target, key)\r\n    const oldValue = (target as any)[key]\r\n    const result = Reflect.deleteProperty(target, key)\r\n    if (result && hadKey) {\r\n      // 存在这个key并且成功删除了，才会触发delete\r\n      trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\r\n    }\r\n    return result\r\n  }\r\n\r\n  // 'foo' in observed 触发的就是has函数\r\n  has(target: object, key: string | symbol): boolean {\r\n    const result = Reflect.has(target, key)\r\n    /**\r\n     * 这里为什么要排除symbol函数呢\r\n     * 因为在for of循环遍历数组的时候，除了会触发length，还会触发symbol迭代器的方法，就会重复执行副作用函数\r\n     * 所以for of循序只记录一个length的track就可以了\r\n     */\r\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n      track(target, TrackOpTypes.HAS, key)\r\n    }\r\n    return result\r\n  }\r\n  /**\r\n   * （1）for in 触发的就是ownKeys函数\r\n   * （2）Object.keys(proxy)\r\n   */\r\n  ownKeys(target: object): (string | symbol)[] {\r\n    // for in和 in会进入到这个方法，如果是数组，只要记录length改变就行了，\r\n    /**\r\n     * 比如一个副作用函数内for in一个数组，那么后面这个数组长度改变了，都应该触发这个副作用函数的执行\r\n     * 如果是for in一个对象，那么这个对象的属性添加了或者减少了，都应该触发ITERATE_KEY，所以记录的也是ITERATE_KEY\r\n     */\r\n    track(\r\n      target,\r\n      TrackOpTypes.ITERATE,\r\n      isArray(target) ? 'length' : ITERATE_KEY,\r\n    )\r\n    return Reflect.ownKeys(target)\r\n  }\r\n}\r\n\r\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\r\n  constructor(shallow = false) {\r\n    super(true, shallow)\r\n  }\r\n\r\n  set(target: object, key: string | symbol) {\r\n    if (__DEV__) {\r\n      warn(\r\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\r\n        target,\r\n      )\r\n    }\r\n    return true\r\n  }\r\n\r\n  deleteProperty(target: object, key: string | symbol) {\r\n    if (__DEV__) {\r\n      warn(\r\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\r\n        target,\r\n      )\r\n    }\r\n    return true\r\n  }\r\n}\r\n\r\nexport const mutableHandlers: ProxyHandler<object> =\r\n  /*#__PURE__*/ new MutableReactiveHandler()\r\n\r\nexport const readonlyHandlers: ProxyHandler<object> =\r\n  /*#__PURE__*/ new ReadonlyReactiveHandler()\r\n\r\nexport const shallowReactiveHandlers = /*#__PURE__*/ new MutableReactiveHandler(\r\n  true,\r\n)\r\n\r\n// props handlers特殊之处在于它不应该解包顶层refs，但它仍然保持普通只读对象的响应性\r\nexport const shallowReadonlyHandlers =\r\n  /*#__PURE__*/ new ReadonlyReactiveHandler(true)\r\n","import { toRaw, toReactive, toReadonly } from './reactive'\r\nimport {\r\n  ITERATE_KEY,\r\n  MAP_KEY_ITERATE_KEY,\r\n  track,\r\n  trigger,\r\n} from './reactiveEffect'\r\nimport { ReactiveFlags, TrackOpTypes, TriggerOpTypes } from './constants'\r\nimport { capitalize, hasChanged, hasOwn, isMap, toRawType } from '@vue/shared'\r\n\r\ntype CollectionTypes = IterableCollections | WeakCollections\r\n\r\ntype IterableCollections = Map<any, any> | Set<any>\r\ntype WeakCollections = WeakMap<any, any> | WeakSet<any>\r\ntype MapTypes = Map<any, any> | WeakMap<any, any>\r\ntype SetTypes = Set<any> | WeakSet<any>\r\n\r\nconst toShallow = <T extends unknown>(value: T): T => value\r\n\r\nconst getProto = <T extends CollectionTypes>(v: T): any =>\r\n  Reflect.getPrototypeOf(v)\r\n\r\nfunction get(\r\n  target: MapTypes,\r\n  key: unknown,\r\n  isReadonly = false,\r\n  isShallow = false,\r\n) {\r\n  // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n  // of the value\r\n  /**\r\n   * （1）关于rawTarget和target不相等的场景：\r\n   * const map = reactive(new Map())\r\n    const roMap = readonly(map)\r\n      map.set(4, { foo: 'bar' })\r\n      effect(() => {\r\n          const roMapItem = roMap.get(5);\r\n          console.log(roMapItem)\r\n      })\r\n      setTimeout(() => {\r\n          map.set(5, 'hello')\r\n      }, 1000)\r\n      解释：readonly一个reactive响应对象，虽然roMap是readonly非响应式的，但是因为原始对象是响应式的，所以roMapItem依然是响应式的，很少会这样使用\r\n\r\n      （2）关于key和rawKey不相等的场景：key是响应式对象,rawkey是原始对象\r\n      如果map代理对象中本来包含了key响应对象，那么map.get(key)收集了key和rawKey的依赖关系，set(key, value)的时候会触发key的依赖；\r\n      如果map代理对象中没有包括key的响应对象，那么set(key, value)会触发rawKey的依赖\r\n   */\r\n  target = (target as any)[ReactiveFlags.RAW]\r\n  const rawTarget = toRaw(target)\r\n  const rawKey = toRaw(key)\r\n  if (!isReadonly) {\r\n    if (hasChanged(key, rawKey)) {\r\n      // 如果key也是响应式的对象，那么也要track key\r\n      track(rawTarget, TrackOpTypes.GET, key)\r\n    }\r\n    track(rawTarget, TrackOpTypes.GET, rawKey)\r\n  }\r\n  const { has } = getProto(rawTarget)\r\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\r\n  if (has.call(rawTarget, key)) {\r\n    return wrap(target.get(key))\r\n  } else if (has.call(rawTarget, rawKey)) {\r\n    return wrap(target.get(rawKey))\r\n  } else if (target !== rawTarget) {\r\n    // #3602 readonly(reactive(Map))\r\n    // ensure that the nested reactive `Map` can do tracking for itself\r\n    target.get(key)\r\n  }\r\n}\r\n\r\nfunction has(this: CollectionTypes, key: unknown, isReadonly = false): boolean {\r\n  const target = (this as any)[ReactiveFlags.RAW]\r\n  const rawTarget = toRaw(target)\r\n  const rawKey = toRaw(key)\r\n  if (!isReadonly) {\r\n    if (hasChanged(key, rawKey)) {\r\n      track(rawTarget, TrackOpTypes.HAS, key)\r\n    }\r\n    track(rawTarget, TrackOpTypes.HAS, rawKey)\r\n  }\r\n  return key === rawKey\r\n    ? target.has(key)\r\n    : target.has(key) || target.has(rawKey)\r\n}\r\n\r\nfunction size(target: IterableCollections, isReadonly = false) {\r\n  target = (target as any)[ReactiveFlags.RAW]\r\n  !isReadonly && track(toRaw(target), TrackOpTypes.ITERATE, ITERATE_KEY)\r\n  return Reflect.get(target, 'size', target)\r\n}\r\n\r\nfunction add(this: SetTypes, value: unknown) {\r\n  value = toRaw(value)\r\n  const target = toRaw(this)\r\n  const proto = getProto(target)\r\n  const hadKey = proto.has.call(target, value)\r\n  if (!hadKey) {\r\n    target.add(value)\r\n    trigger(target, TriggerOpTypes.ADD, value, value)\r\n  }\r\n  return this\r\n}\r\n\r\nfunction set(this: MapTypes, key: unknown, value: unknown) {\r\n  // 这里设置需要用原始对象\r\n  value = toRaw(value)\r\n  const target = toRaw(this)\r\n  const { has, get } = getProto(target)\r\n\r\n  let hadKey = has.call(target, key)\r\n  if (!hadKey) {\r\n    key = toRaw(key)\r\n    hadKey = has.call(target, key)\r\n  } else if (__DEV__) {\r\n    // key是响应式对象，并且target中包含key的原始对象\r\n    checkIdentityKeys(target, has, key)\r\n  }\r\n\r\n  const oldValue = get.call(target, key)\r\n  target.set(key, value)\r\n  if (!hadKey) {\r\n    trigger(target, TriggerOpTypes.ADD, key, value)\r\n  } else if (hasChanged(value, oldValue)) {\r\n    trigger(target, TriggerOpTypes.SET, key, value, oldValue)\r\n  }\r\n  return this\r\n}\r\n\r\nfunction deleteEntry(this: CollectionTypes, key: unknown) {\r\n  const target = toRaw(this)\r\n  const { has, get } = getProto(target)\r\n  let hadKey = has.call(target, key)\r\n  if (!hadKey) {\r\n    key = toRaw(key)\r\n    hadKey = has.call(target, key)\r\n  } else if (__DEV__) {\r\n    checkIdentityKeys(target, has, key)\r\n  }\r\n\r\n  const oldValue = get ? get.call(target, key) : undefined\r\n  // forward the operation before queueing reactions\r\n  const result = target.delete(key)\r\n  if (hadKey) {\r\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction clear(this: IterableCollections) {\r\n  const target = toRaw(this)\r\n  const hadItems = target.size !== 0\r\n  const oldTarget = __DEV__\r\n    ? isMap(target)\r\n      ? new Map(target)\r\n      : new Set(target)\r\n    : undefined\r\n  // forward the operation before queueing reactions\r\n  const result = target.clear()\r\n  if (hadItems) {\r\n    trigger(target, TriggerOpTypes.CLEAR, undefined, undefined, oldTarget)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction createForEach(isReadonly: boolean, isShallow: boolean) {\r\n  return function forEach(\r\n    this: IterableCollections,\r\n    callback: Function,\r\n    thisArg?: unknown,\r\n  ) {\r\n    const observed = this as any\r\n    const target = observed[ReactiveFlags.RAW]\r\n    const rawTarget = toRaw(target)\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\r\n    !isReadonly && track(rawTarget, TrackOpTypes.ITERATE, ITERATE_KEY)\r\n    return target.forEach((value: unknown, key: unknown) => {\r\n      // important: make sure the callback is\r\n      // 1. invoked with the reactive map as `this` and 3rd arg\r\n      // 2. the value received should be a corresponding reactive/readonly.\r\n      return callback.call(thisArg, wrap(value), wrap(key), observed)\r\n    })\r\n  }\r\n}\r\n\r\ninterface Iterable {\r\n  [Symbol.iterator](): Iterator\r\n}\r\n\r\ninterface Iterator {\r\n  next(value?: any): IterationResult\r\n}\r\n\r\ninterface IterationResult {\r\n  value: any\r\n  done: boolean\r\n}\r\n\r\nfunction createIterableMethod(\r\n  method: string | symbol,\r\n  isReadonly: boolean,\r\n  isShallow: boolean,\r\n) {\r\n  return function (\r\n    this: IterableCollections,\r\n    ...args: unknown[]\r\n  ): Iterable & Iterator {\r\n    const target = (this as any)[ReactiveFlags.RAW]\r\n    const rawTarget = toRaw(target)\r\n    const targetIsMap = isMap(rawTarget)\r\n    const isPair =\r\n      method === 'entries' || (method === Symbol.iterator && targetIsMap)\r\n    const isKeyOnly = method === 'keys' && targetIsMap\r\n    const innerIterator = target[method](...args)\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\r\n    !isReadonly &&\r\n      track(\r\n        rawTarget,\r\n        TrackOpTypes.ITERATE,\r\n        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY,\r\n      )\r\n    // return a wrapped iterator which returns observed versions of the\r\n    // values emitted from the real iterator\r\n    return {\r\n      // iterator protocol\r\n      next() {\r\n        const { value, done } = innerIterator.next()\r\n        return done\r\n          ? { value, done }\r\n          : {\r\n              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n              done,\r\n            }\r\n      },\r\n      // iterable protocol\r\n      [Symbol.iterator]() {\r\n        return this\r\n      },\r\n    }\r\n  }\r\n}\r\n\r\nfunction createReadonlyMethod(type: TriggerOpTypes): Function {\r\n  return function (this: CollectionTypes, ...args: unknown[]) {\r\n    if (__DEV__) {\r\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``\r\n      console.warn(\r\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\r\n        toRaw(this),\r\n      )\r\n    }\r\n    return type === TriggerOpTypes.DELETE\r\n      ? false\r\n      : type === TriggerOpTypes.CLEAR\r\n        ? undefined\r\n        : this\r\n  }\r\n}\r\n\r\nfunction createInstrumentations() {\r\n  const mutableInstrumentations: Record<string, Function | number> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key)\r\n    },\r\n    //获取size先track，从原始对象中获取size\r\n    get size() {\r\n      return size(this as unknown as IterableCollections)\r\n    },\r\n    has,\r\n    add,\r\n    set,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false),\r\n  }\r\n\r\n  const shallowInstrumentations: Record<string, Function | number> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key, false, true)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections)\r\n    },\r\n    has,\r\n    add,\r\n    set,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true),\r\n  }\r\n\r\n  const readonlyInstrumentations: Record<string, Function | number> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key, true)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections, true)\r\n    },\r\n    has(this: MapTypes, key: unknown) {\r\n      return has.call(this, key, true)\r\n    },\r\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\r\n    set: createReadonlyMethod(TriggerOpTypes.SET),\r\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\r\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\r\n    forEach: createForEach(true, false),\r\n  }\r\n\r\n  const shallowReadonlyInstrumentations: Record<string, Function | number> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key, true, true)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections, true)\r\n    },\r\n    has(this: MapTypes, key: unknown) {\r\n      return has.call(this, key, true)\r\n    },\r\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\r\n    set: createReadonlyMethod(TriggerOpTypes.SET),\r\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\r\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\r\n    forEach: createForEach(true, true),\r\n  }\r\n\r\n  const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator]\r\n  iteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      false,\r\n      false,\r\n    )\r\n    readonlyInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      true,\r\n      false,\r\n    )\r\n    shallowInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      false,\r\n      true,\r\n    )\r\n    shallowReadonlyInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      true,\r\n      true,\r\n    )\r\n  })\r\n\r\n  return [\r\n    mutableInstrumentations,\r\n    readonlyInstrumentations,\r\n    shallowInstrumentations,\r\n    shallowReadonlyInstrumentations,\r\n  ]\r\n}\r\n\r\nconst [\r\n  mutableInstrumentations,\r\n  readonlyInstrumentations,\r\n  shallowInstrumentations,\r\n  shallowReadonlyInstrumentations,\r\n] = /* #__PURE__*/ createInstrumentations()\r\n\r\nfunction createInstrumentationGetter(isReadonly: boolean, shallow: boolean) {\r\n  const instrumentations = shallow\r\n    ? isReadonly\r\n      ? shallowReadonlyInstrumentations\r\n      : shallowInstrumentations\r\n    : isReadonly\r\n      ? readonlyInstrumentations\r\n      : mutableInstrumentations\r\n\r\n  return (\r\n    target: CollectionTypes,\r\n    key: string | symbol,\r\n    receiver: CollectionTypes,\r\n  ) => {\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return !isReadonly\r\n    } else if (key === ReactiveFlags.IS_READONLY) {\r\n      return isReadonly\r\n    } else if (key === ReactiveFlags.RAW) {\r\n      return target\r\n    }\r\n\r\n    return Reflect.get(\r\n      hasOwn(instrumentations, key) && key in target\r\n        ? instrumentations\r\n        : target,\r\n      key,\r\n      receiver,\r\n    )\r\n  }\r\n}\r\n\r\nexport const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: /*#__PURE__*/ createInstrumentationGetter(false, false),\r\n}\r\n\r\nexport const shallowCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: /*#__PURE__*/ createInstrumentationGetter(false, true),\r\n}\r\n\r\nexport const readonlyCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: /*#__PURE__*/ createInstrumentationGetter(true, false),\r\n}\r\n\r\nexport const shallowReadonlyCollectionHandlers: ProxyHandler<CollectionTypes> =\r\n  {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true),\r\n  }\r\n\r\nfunction checkIdentityKeys(\r\n  target: CollectionTypes,\r\n  has: (key: unknown) => boolean,\r\n  key: unknown,\r\n) {\r\n  const rawKey = toRaw(key)\r\n  if (rawKey !== key && has.call(target, rawKey)) {\r\n    const type = toRawType(target)\r\n    console.warn(\r\n      `Reactive ${type} contains both the raw and reactive ` +\r\n        `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n        `which can lead to inconsistencies. ` +\r\n        `Avoid differentiating between the raw and reactive versions ` +\r\n        `of an object and only use the reactive version if possible.`,\r\n    )\r\n  }\r\n}\r\n","import { def, isObject, toRawType } from '@vue/shared'\r\nimport {\r\n  mutableHandlers,\r\n  readonlyHandlers,\r\n  shallowReactiveHandlers,\r\n  shallowReadonlyHandlers,\r\n} from './baseHandlers'\r\nimport {\r\n  mutableCollectionHandlers,\r\n  readonlyCollectionHandlers,\r\n  shallowCollectionHandlers,\r\n  shallowReadonlyCollectionHandlers,\r\n} from './collectionHandlers'\r\nimport type { RawSymbol, Ref, UnwrapRefSimple } from './ref'\r\nimport { ReactiveFlags } from './constants'\r\n\r\nexport interface Target {\r\n  [ReactiveFlags.SKIP]?: boolean\r\n  [ReactiveFlags.IS_REACTIVE]?: boolean\r\n  [ReactiveFlags.IS_READONLY]?: boolean\r\n  [ReactiveFlags.IS_SHALLOW]?: boolean\r\n  [ReactiveFlags.RAW]?: any\r\n}\r\n\r\nexport const reactiveMap = new WeakMap<Target, any>()\r\nexport const shallowReactiveMap = new WeakMap<Target, any>()\r\nexport const readonlyMap = new WeakMap<Target, any>()\r\nexport const shallowReadonlyMap = new WeakMap<Target, any>()\r\n\r\nenum TargetType {\r\n  INVALID = 0,\r\n  COMMON = 1,\r\n  COLLECTION = 2,\r\n}\r\n\r\nfunction targetTypeMap(rawType: string) {\r\n  switch (rawType) {\r\n    case 'Object':\r\n    case 'Array':\r\n      return TargetType.COMMON // 通用的类型\r\n    case 'Map':\r\n    case 'Set':\r\n    case 'WeakMap':\r\n    case 'WeakSet':\r\n      return TargetType.COLLECTION // set/map类型\r\n    default:\r\n      return TargetType.INVALID\r\n  }\r\n}\r\n\r\nfunction getTargetType(value: Target) {\r\n  // 有skip标志或者不能被扩展的就是无效的类型\r\n  return value[ReactiveFlags.SKIP] || !Object.isExtensible(value)\r\n    ? TargetType.INVALID\r\n    : targetTypeMap(toRawType(value))\r\n}\r\n\r\n// only unwrap nested ref\r\nexport type UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRefSimple<T>\r\n\r\n/**\r\n * Returns a reactive proxy of the object.\r\n *\r\n * The reactive conversion is \"deep\": it affects all nested properties. A\r\n * reactive object also deeply unwraps any properties that are refs while\r\n * maintaining reactivity.\r\n *\r\n * @example\r\n * ```js\r\n * const obj = reactive({ count: 0 })\r\n * ```\r\n *\r\n * @param target - The source object.\r\n * @see {@link https://vuejs.org/api/reactivity-core.html#reactive}\r\n */\r\nexport function reactive<T extends object>(target: T): UnwrapNestedRefs<T>\r\nexport function reactive(target: object) {\r\n  // if trying to observe a readonly proxy, return the readonly version.\r\n  // 如果创建的target本身就是reactive就直接返回\r\n  if (isReadonly(target)) {\r\n    return target\r\n  }\r\n  return createReactiveObject(\r\n    target,\r\n    false,\r\n    mutableHandlers,\r\n    mutableCollectionHandlers,\r\n    reactiveMap,\r\n  )\r\n}\r\n\r\nexport declare const ShallowReactiveMarker: unique symbol\r\n\r\nexport type ShallowReactive<T> = T & { [ShallowReactiveMarker]?: true }\r\n\r\n/**\r\n * Shallow version of {@link reactive()}.\r\n *\r\n * Unlike {@link reactive()}, there is no deep conversion: only root-level\r\n * properties are reactive for a shallow reactive object. Property values are\r\n * stored and exposed as-is - this also means properties with ref values will\r\n * not be automatically unwrapped.\r\n *\r\n * @example\r\n * ```js\r\n * const state = shallowReactive({\r\n *   foo: 1,\r\n *   nested: {\r\n *     bar: 2\r\n *   }\r\n * })\r\n *\r\n * // mutating state's own properties is reactive\r\n * state.foo++\r\n *\r\n * // ...but does not convert nested objects\r\n * isReactive(state.nested) // false\r\n *\r\n * // NOT reactive\r\n * state.nested.bar++\r\n * ```\r\n *\r\n * @param target - The source object.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#shallowreactive}\r\n */\r\nexport function shallowReactive<T extends object>(\r\n  target: T,\r\n): ShallowReactive<T> {\r\n  return createReactiveObject(\r\n    target,\r\n    false,\r\n    shallowReactiveHandlers,\r\n    shallowCollectionHandlers,\r\n    shallowReactiveMap,\r\n  )\r\n}\r\n\r\ntype Primitive = string | number | boolean | bigint | symbol | undefined | null\r\ntype Builtin = Primitive | Function | Date | Error | RegExp\r\nexport type DeepReadonly<T> = T extends Builtin\r\n  ? T\r\n  : T extends Map<infer K, infer V>\r\n    ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\r\n    : T extends ReadonlyMap<infer K, infer V>\r\n      ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\r\n      : T extends WeakMap<infer K, infer V>\r\n        ? WeakMap<DeepReadonly<K>, DeepReadonly<V>>\r\n        : T extends Set<infer U>\r\n          ? ReadonlySet<DeepReadonly<U>>\r\n          : T extends ReadonlySet<infer U>\r\n            ? ReadonlySet<DeepReadonly<U>>\r\n            : T extends WeakSet<infer U>\r\n              ? WeakSet<DeepReadonly<U>>\r\n              : T extends Promise<infer U>\r\n                ? Promise<DeepReadonly<U>>\r\n                : T extends Ref<infer U>\r\n                  ? Readonly<Ref<DeepReadonly<U>>>\r\n                  : T extends {}\r\n                    ? { readonly [K in keyof T]: DeepReadonly<T[K]> }\r\n                    : Readonly<T>\r\n\r\n/**\r\n * Takes an object (reactive or plain) or a ref and returns a readonly proxy to\r\n * the original.\r\n *\r\n * A readonly proxy is deep: any nested property accessed will be readonly as\r\n * well. It also has the same ref-unwrapping behavior as {@link reactive()},\r\n * except the unwrapped values will also be made readonly.\r\n *\r\n * @example\r\n * ```js\r\n * const original = reactive({ count: 0 })\r\n *\r\n * const copy = readonly(original)\r\n *\r\n * watchEffect(() => {\r\n *   // works for reactivity tracking\r\n *   console.log(copy.count)\r\n * })\r\n *\r\n * // mutating original will trigger watchers relying on the copy\r\n * original.count++\r\n *\r\n * // mutating the copy will fail and result in a warning\r\n * copy.count++ // warning!\r\n * ```\r\n *\r\n * @param target - The source object.\r\n * @see {@link https://vuejs.org/api/reactivity-core.html#readonly}\r\n */\r\nexport function readonly<T extends object>(\r\n  target: T,\r\n): DeepReadonly<UnwrapNestedRefs<T>> {\r\n  return createReactiveObject(\r\n    target,\r\n    true,\r\n    readonlyHandlers,\r\n    readonlyCollectionHandlers,\r\n    readonlyMap,\r\n  )\r\n}\r\n\r\n/**\r\n * Shallow version of {@link readonly()}.\r\n *\r\n * Unlike {@link readonly()}, there is no deep conversion: only root-level\r\n * properties are made readonly. Property values are stored and exposed as-is -\r\n * this also means properties with ref values will not be automatically\r\n * unwrapped.\r\n *\r\n * @example\r\n * ```js\r\n * const state = shallowReadonly({\r\n *   foo: 1,\r\n *   nested: {\r\n *     bar: 2\r\n *   }\r\n * })\r\n *\r\n * // mutating state's own properties will fail\r\n * state.foo++\r\n *\r\n * // ...but works on nested objects\r\n * isReadonly(state.nested) // false\r\n *\r\n * // works\r\n * state.nested.bar++\r\n * ```\r\n *\r\n * @param target - The source object.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#shallowreadonly}\r\n */\r\nexport function shallowReadonly<T extends object>(target: T): Readonly<T> {\r\n  return createReactiveObject(\r\n    target,\r\n    true,\r\n    shallowReadonlyHandlers,\r\n    shallowReadonlyCollectionHandlers,\r\n    shallowReadonlyMap,\r\n  )\r\n}\r\n\r\nfunction createReactiveObject(\r\n  target: Target,\r\n  isReadonly: boolean,\r\n  baseHandlers: ProxyHandler<any>,\r\n  collectionHandlers: ProxyHandler<any>,\r\n  proxyMap: WeakMap<Target, any>,\r\n) {\r\n  // 不是对象就直接返回\r\n  if (!isObject(target)) {\r\n    if (__DEV__) {\r\n      console.warn(`value cannot be made reactive: ${String(target)}`)\r\n    }\r\n    return target\r\n  }\r\n  // target is already a Proxy, return it.\r\n  // exception: calling readonly() on a reactive object\r\n  // 如果已经是一个代理对象，并且不是只读的响应式对象，直接返回\r\n  if (\r\n    target[ReactiveFlags.RAW] &&\r\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\r\n  ) {\r\n    return target\r\n  }\r\n  // target already has corresponding Proxy\r\n  const existingProxy = proxyMap.get(target)\r\n  if (existingProxy) {\r\n    return existingProxy\r\n  }\r\n  // only specific value types can be observed.\r\n  const targetType = getTargetType(target)\r\n  if (targetType === TargetType.INVALID) {\r\n    return target\r\n  }\r\n  // 创建代理\r\n  // collectionHandlers重写的是set/map对象，数组和普通对象就是走baseHandlers\r\n  const proxy = new Proxy(\r\n    target,\r\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers,\r\n  )\r\n  // 创建的代理对象都放到proxyMap中记录\r\n  proxyMap.set(target, proxy)\r\n  return proxy\r\n}\r\n\r\n/**\r\n * Checks if an object is a proxy created by {@link reactive()} or\r\n * {@link shallowReactive()} (or {@link ref()} in some cases).\r\n *\r\n * @example\r\n * ```js\r\n * isReactive(reactive({}))            // => true\r\n * isReactive(readonly(reactive({})))  // => true\r\n * isReactive(ref({}).value)           // => true\r\n * isReactive(readonly(ref({})).value) // => true\r\n * isReactive(ref(true))               // => false\r\n * isReactive(shallowRef({}).value)    // => false\r\n * isReactive(shallowReactive({}))     // => true\r\n * ```\r\n *\r\n * @param value - The value to check.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#isreactive}\r\n */\r\nexport function isReactive(value: unknown): boolean {\r\n  if (isReadonly(value)) {\r\n    return isReactive((value as Target)[ReactiveFlags.RAW])\r\n  }\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_REACTIVE])\r\n}\r\n\r\n/**\r\n * Checks whether the passed value is a readonly object. The properties of a\r\n * readonly object can change, but they can't be assigned directly via the\r\n * passed object.\r\n *\r\n * The proxies created by {@link readonly()} and {@link shallowReadonly()} are\r\n * both considered readonly, as is a computed ref without a set function.\r\n *\r\n * @param value - The value to check.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#isreadonly}\r\n */\r\nexport function isReadonly(value: unknown): boolean {\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_READONLY])\r\n}\r\n\r\nexport function isShallow(value: unknown): boolean {\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_SHALLOW])\r\n}\r\n\r\n/**\r\n * Checks if an object is a proxy created by {@link reactive},\r\n * {@link readonly}, {@link shallowReactive} or {@link shallowReadonly()}.\r\n *\r\n * @param value - The value to check.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#isproxy}\r\n */\r\nexport function isProxy(value: unknown): boolean {\r\n  return isReactive(value) || isReadonly(value)\r\n}\r\n\r\n/**\r\n * Returns the raw, original object of a Vue-created proxy.\r\n *\r\n * `toRaw()` can return the original object from proxies created by\r\n * {@link reactive()}, {@link readonly()}, {@link shallowReactive()} or\r\n * {@link shallowReadonly()}.\r\n *\r\n * This is an escape hatch that can be used to temporarily read without\r\n * incurring proxy access / tracking overhead or write without triggering\r\n * changes. It is **not** recommended to hold a persistent reference to the\r\n * original object. Use with caution.\r\n *\r\n * @example\r\n * ```js\r\n * const foo = {}\r\n * const reactiveFoo = reactive(foo)\r\n *\r\n * console.log(toRaw(reactiveFoo) === foo) // true\r\n * ```\r\n *\r\n * @param observed - The object for which the \"raw\" value is requested.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#toraw}\r\n */\r\nexport function toRaw<T>(observed: T): T {\r\n  const raw = observed && (observed as Target)[ReactiveFlags.RAW]\r\n  return raw ? toRaw(raw) : observed\r\n}\r\n\r\nexport type Raw<T> = T & { [RawSymbol]?: true }\r\n\r\n/**\r\n * Marks an object so that it will never be converted to a proxy. Returns the\r\n * object itself.\r\n *\r\n * @example\r\n * ```js\r\n * const foo = markRaw({})\r\n * console.log(isReactive(reactive(foo))) // false\r\n *\r\n * // also works when nested inside other reactive objects\r\n * const bar = reactive({ foo })\r\n * console.log(isReactive(bar.foo)) // false\r\n * ```\r\n *\r\n * **Warning:** `markRaw()` together with the shallow APIs such as\r\n * {@link shallowReactive()} allow you to selectively opt-out of the default\r\n * deep reactive/readonly conversion and embed raw, non-proxied objects in your\r\n * state graph.\r\n *\r\n * @param value - The object to be marked as \"raw\".\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#markraw}\r\n */\r\nexport function markRaw<T extends object>(value: T): Raw<T> {\r\n  def(value, ReactiveFlags.SKIP, true)\r\n  return value\r\n}\r\n\r\n/**\r\n * Returns a reactive proxy of the given value (if possible).\r\n *\r\n * If the given value is not an object, the original value itself is returned.\r\n *\r\n * @param value - The value for which a reactive proxy shall be created.\r\n */\r\nexport const toReactive = <T extends unknown>(value: T): T =>\r\n  isObject(value) ? reactive(value) : value\r\n\r\n/**\r\n * Returns a readonly proxy of the given value (if possible).\r\n *\r\n * If the given value is not an object, the original value itself is returned.\r\n *\r\n * @param value - The value for which a readonly proxy shall be created.\r\n */\r\nexport const toReadonly = <T extends unknown>(value: T): T =>\r\n  isObject(value) ? readonly(value) : value\r\n","import { type DebuggerOptions, ReactiveEffect, scheduleEffects } from './effect'\r\nimport { type Ref, trackRefValue, triggerRefValue } from './ref'\r\nimport { NOOP, hasChanged, isFunction } from '@vue/shared'\r\nimport { toRaw } from './reactive'\r\nimport type { Dep } from './dep'\r\nimport { DirtyLevels, ReactiveFlags } from './constants'\r\n\r\ndeclare const ComputedRefSymbol: unique symbol\r\n\r\nexport interface ComputedRef<T = any> extends WritableComputedRef<T> {\r\n  readonly value: T\r\n  [ComputedRefSymbol]: true\r\n}\r\n\r\nexport interface WritableComputedRef<T> extends Ref<T> {\r\n  readonly effect: ReactiveEffect<T>\r\n}\r\n\r\nexport type ComputedGetter<T> = (oldValue?: T) => T\r\nexport type ComputedSetter<T> = (newValue: T) => void\r\n\r\nexport interface WritableComputedOptions<T> {\r\n  get: ComputedGetter<T>\r\n  set: ComputedSetter<T>\r\n}\r\n\r\nexport class ComputedRefImpl<T> {\r\n  public dep?: Dep = undefined\r\n\r\n  private _value!: T\r\n  public readonly effect: ReactiveEffect<T>\r\n\r\n  public readonly __v_isRef = true\r\n  public readonly [ReactiveFlags.IS_READONLY]: boolean = false\r\n\r\n  public _cacheable: boolean\r\n\r\n  constructor(\r\n    getter: ComputedGetter<T>,\r\n    private readonly _setter: ComputedSetter<T>,\r\n    isReadonly: boolean,\r\n    isSSR: boolean,\r\n  ) {\r\n    this.effect = new ReactiveEffect(\r\n      () => getter(this._value),\r\n      () => triggerRefValue(this, DirtyLevels.MaybeDirty),\r\n      () => this.dep && scheduleEffects(this.dep),\r\n    )\r\n    this.effect.computed = this\r\n    this.effect.active = this._cacheable = !isSSR\r\n    this[ReactiveFlags.IS_READONLY] = isReadonly\r\n  }\r\n\r\n  get value() {\r\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n    const self = toRaw(this)\r\n    if (!self._cacheable || self.effect.dirty) {\r\n      if (hasChanged(self._value, (self._value = self.effect.run()!))) {\r\n        triggerRefValue(self, DirtyLevels.Dirty)\r\n      }\r\n    }\r\n    trackRefValue(self)\r\n    if (self.effect._dirtyLevel >= DirtyLevels.MaybeDirty) {\r\n      triggerRefValue(self, DirtyLevels.MaybeDirty)\r\n    }\r\n    return self._value\r\n  }\r\n\r\n  set value(newValue: T) {\r\n    this._setter(newValue)\r\n  }\r\n\r\n  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x\r\n  get _dirty() {\r\n    return this.effect.dirty\r\n  }\r\n\r\n  set _dirty(v) {\r\n    this.effect.dirty = v\r\n  }\r\n  // #endregion\r\n}\r\n\r\n/**\r\n * Takes a getter function and returns a readonly reactive ref object for the\r\n * returned value from the getter. It can also take an object with get and set\r\n * functions to create a writable ref object.\r\n *\r\n * @example\r\n * ```js\r\n * // Creating a readonly computed ref:\r\n * const count = ref(1)\r\n * const plusOne = computed(() => count.value + 1)\r\n *\r\n * console.log(plusOne.value) // 2\r\n * plusOne.value++ // error\r\n * ```\r\n *\r\n * ```js\r\n * // Creating a writable computed ref:\r\n * const count = ref(1)\r\n * const plusOne = computed({\r\n *   get: () => count.value + 1,\r\n *   set: (val) => {\r\n *     count.value = val - 1\r\n *   }\r\n * })\r\n *\r\n * plusOne.value = 1\r\n * console.log(count.value) // 0\r\n * ```\r\n *\r\n * @param getter - Function that produces the next value.\r\n * @param debugOptions - For debugging. See {@link https://vuejs.org/guide/extras/reactivity-in-depth.html#computed-debugging}.\r\n * @see {@link https://vuejs.org/api/reactivity-core.html#computed}\r\n */\r\nexport function computed<T>(\r\n  getter: ComputedGetter<T>,\r\n  debugOptions?: DebuggerOptions,\r\n): ComputedRef<T>\r\nexport function computed<T>(\r\n  options: WritableComputedOptions<T>,\r\n  debugOptions?: DebuggerOptions,\r\n): WritableComputedRef<T>\r\nexport function computed<T>(\r\n  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>,\r\n  debugOptions?: DebuggerOptions,\r\n  isSSR = false,\r\n) {\r\n  let getter: ComputedGetter<T>\r\n  let setter: ComputedSetter<T>\r\n\r\n  const onlyGetter = isFunction(getterOrOptions)\r\n  if (onlyGetter) {\r\n    getter = getterOrOptions\r\n    setter = __DEV__\r\n      ? () => {\r\n          console.warn('Write operation failed: computed value is readonly')\r\n        }\r\n      : NOOP\r\n  } else {\r\n    getter = getterOrOptions.get\r\n    setter = getterOrOptions.set\r\n  }\r\n\r\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR)\r\n\r\n  if (__DEV__ && debugOptions && !isSSR) {\r\n    cRef.effect.onTrack = debugOptions.onTrack\r\n    cRef.effect.onTrigger = debugOptions.onTrigger\r\n  }\r\n\r\n  return cRef as any\r\n}\r\n","import type { ComputedRef } from './computed'\r\nimport {\r\n  activeEffect,\r\n  shouldTrack,\r\n  trackEffect,\r\n  triggerEffects,\r\n} from './effect'\r\nimport { DirtyLevels, TrackOpTypes, TriggerOpTypes } from './constants'\r\nimport {\r\n  type IfAny,\r\n  hasChanged,\r\n  isArray,\r\n  isFunction,\r\n  isObject,\r\n} from '@vue/shared'\r\nimport {\r\n  isProxy,\r\n  isReactive,\r\n  isReadonly,\r\n  isShallow,\r\n  toRaw,\r\n  toReactive,\r\n} from './reactive'\r\nimport type { ShallowReactiveMarker } from './reactive'\r\nimport { type Dep, createDep } from './dep'\r\nimport { ComputedRefImpl } from './computed'\r\nimport { getDepFromReactive } from './reactiveEffect'\r\n\r\ndeclare const RefSymbol: unique symbol\r\nexport declare const RawSymbol: unique symbol\r\n\r\nexport interface Ref<T = any> {\r\n  value: T\r\n  /**\r\n   * Type differentiator only.\r\n   * We need this to be in public d.ts but don't want it to show up in IDE\r\n   * autocomplete, so we use a private Symbol instead.\r\n   */\r\n  [RefSymbol]: true\r\n}\r\n\r\ntype RefBase<T> = {\r\n  dep?: Dep\r\n  value: T\r\n}\r\n\r\nexport function trackRefValue(ref: RefBase<any>) {\r\n  if (shouldTrack && activeEffect) {\r\n    ref = toRaw(ref)\r\n    trackEffect(\r\n      activeEffect,\r\n      ref.dep ||\r\n        (ref.dep = createDep(\r\n          () => (ref.dep = undefined),\r\n          ref instanceof ComputedRefImpl ? ref : undefined,\r\n        )),\r\n      __DEV__\r\n        ? {\r\n            target: ref,\r\n            type: TrackOpTypes.GET,\r\n            key: 'value',\r\n          }\r\n        : void 0,\r\n    )\r\n  }\r\n}\r\n\r\nexport function triggerRefValue(\r\n  ref: RefBase<any>,\r\n  dirtyLevel: DirtyLevels = DirtyLevels.Dirty,\r\n  newVal?: any,\r\n) {\r\n  ref = toRaw(ref)\r\n  const dep = ref.dep\r\n  if (dep) {\r\n    triggerEffects(\r\n      dep,\r\n      dirtyLevel,\r\n      __DEV__\r\n        ? {\r\n            target: ref,\r\n            type: TriggerOpTypes.SET,\r\n            key: 'value',\r\n            newValue: newVal,\r\n          }\r\n        : void 0,\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if a value is a ref object.\r\n *\r\n * @param r - The value to inspect.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#isref}\r\n */\r\nexport function isRef<T>(r: Ref<T> | unknown): r is Ref<T>\r\nexport function isRef(r: any): r is Ref {\r\n  return !!(r && r.__v_isRef === true)\r\n}\r\n\r\n/**\r\n * Takes an inner value and returns a reactive and mutable ref object, which\r\n * has a single property `.value` that points to the inner value.\r\n *\r\n * @param value - The object to wrap in the ref.\r\n * @see {@link https://vuejs.org/api/reactivity-core.html#ref}\r\n */\r\nexport function ref<T>(value: T): Ref<UnwrapRef<T>>\r\nexport function ref<T = any>(): Ref<T | undefined>\r\nexport function ref(value?: unknown) {\r\n  return createRef(value, false)\r\n}\r\n\r\ndeclare const ShallowRefMarker: unique symbol\r\n\r\nexport type ShallowRef<T = any> = Ref<T> & { [ShallowRefMarker]?: true }\r\n\r\n/**\r\n * Shallow version of {@link ref()}.\r\n *\r\n * @example\r\n * ```js\r\n * const state = shallowRef({ count: 1 })\r\n *\r\n * // does NOT trigger change\r\n * state.value.count = 2\r\n *\r\n * // does trigger change\r\n * state.value = { count: 2 }\r\n * ```\r\n *\r\n * @param value - The \"inner value\" for the shallow ref.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#shallowref}\r\n */\r\nexport function shallowRef<T>(\r\n  value: T,\r\n): Ref extends T\r\n  ? T extends Ref\r\n    ? IfAny<T, ShallowRef<T>, T>\r\n    : ShallowRef<T>\r\n  : ShallowRef<T>\r\nexport function shallowRef<T = any>(): ShallowRef<T | undefined>\r\nexport function shallowRef(value?: unknown) {\r\n  return createRef(value, true)\r\n}\r\n\r\nfunction createRef(rawValue: unknown, shallow: boolean) {\r\n  if (isRef(rawValue)) {\r\n    return rawValue\r\n  }\r\n  return new RefImpl(rawValue, shallow)\r\n}\r\n\r\nclass RefImpl<T> {\r\n  private _value: T\r\n  private _rawValue: T\r\n\r\n  public dep?: Dep = undefined\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(\r\n    value: T,\r\n    public readonly __v_isShallow: boolean,\r\n  ) {\r\n    this._rawValue = __v_isShallow ? value : toRaw(value)\r\n    this._value = __v_isShallow ? value : toReactive(value)\r\n  }\r\n\r\n  get value() {\r\n    trackRefValue(this)\r\n    return this._value\r\n  }\r\n\r\n  set value(newVal) {\r\n    const useDirectValue =\r\n      this.__v_isShallow || isShallow(newVal) || isReadonly(newVal)\r\n    newVal = useDirectValue ? newVal : toRaw(newVal)\r\n    if (hasChanged(newVal, this._rawValue)) {\r\n      this._rawValue = newVal\r\n      this._value = useDirectValue ? newVal : toReactive(newVal)\r\n      triggerRefValue(this, DirtyLevels.Dirty, newVal)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Force trigger effects that depends on a shallow ref. This is typically used\r\n * after making deep mutations to the inner value of a shallow ref.\r\n *\r\n * @example\r\n * ```js\r\n * const shallow = shallowRef({\r\n *   greet: 'Hello, world'\r\n * })\r\n *\r\n * // Logs \"Hello, world\" once for the first run-through\r\n * watchEffect(() => {\r\n *   console.log(shallow.value.greet)\r\n * })\r\n *\r\n * // This won't trigger the effect because the ref is shallow\r\n * shallow.value.greet = 'Hello, universe'\r\n *\r\n * // Logs \"Hello, universe\"\r\n * triggerRef(shallow)\r\n * ```\r\n *\r\n * @param ref - The ref whose tied effects shall be executed.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#triggerref}\r\n */\r\nexport function triggerRef(ref: Ref) {\r\n  triggerRefValue(ref, DirtyLevels.Dirty, __DEV__ ? ref.value : void 0)\r\n}\r\n\r\nexport type MaybeRef<T = any> = T | Ref<T>\r\nexport type MaybeRefOrGetter<T = any> = MaybeRef<T> | (() => T)\r\n\r\n/**\r\n * Returns the inner value if the argument is a ref, otherwise return the\r\n * argument itself. This is a sugar function for\r\n * `val = isRef(val) ? val.value : val`.\r\n *\r\n * @example\r\n * ```js\r\n * function useFoo(x: number | Ref<number>) {\r\n *   const unwrapped = unref(x)\r\n *   // unwrapped is guaranteed to be number now\r\n * }\r\n * ```\r\n *\r\n * @param ref - Ref or plain value to be converted into the plain value.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#unref}\r\n */\r\nexport function unref<T>(ref: MaybeRef<T> | ComputedRef<T>): T {\r\n  return isRef(ref) ? ref.value : ref\r\n}\r\n\r\n/**\r\n * Normalizes values / refs / getters to values.\r\n * This is similar to {@link unref()}, except that it also normalizes getters.\r\n * If the argument is a getter, it will be invoked and its return value will\r\n * be returned.\r\n *\r\n * @example\r\n * ```js\r\n * toValue(1) // 1\r\n * toValue(ref(1)) // 1\r\n * toValue(() => 1) // 1\r\n * ```\r\n *\r\n * @param source - A getter, an existing ref, or a non-function value.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#tovalue}\r\n */\r\nexport function toValue<T>(source: MaybeRefOrGetter<T> | ComputedRef<T>): T {\r\n  return isFunction(source) ? source() : unref(source)\r\n}\r\n\r\nconst shallowUnwrapHandlers: ProxyHandler<any> = {\r\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n  set: (target, key, value, receiver) => {\r\n    const oldValue = target[key]\r\n    if (isRef(oldValue) && !isRef(value)) {\r\n      oldValue.value = value\r\n      return true\r\n    } else {\r\n      return Reflect.set(target, key, value, receiver)\r\n    }\r\n  },\r\n}\r\n\r\n/**\r\n * Returns a reactive proxy for the given object.\r\n *\r\n * If the object already is reactive, it's returned as-is. If not, a new\r\n * reactive proxy is created. Direct child properties that are refs are properly\r\n * handled, as well.\r\n *\r\n * @param objectWithRefs - Either an already-reactive object or a simple object\r\n * that contains refs.\r\n */\r\nexport function proxyRefs<T extends object>(\r\n  objectWithRefs: T,\r\n): ShallowUnwrapRef<T> {\r\n  return isReactive(objectWithRefs)\r\n    ? objectWithRefs\r\n    : new Proxy(objectWithRefs, shallowUnwrapHandlers)\r\n}\r\n\r\nexport type CustomRefFactory<T> = (\r\n  track: () => void,\r\n  trigger: () => void,\r\n) => {\r\n  get: () => T\r\n  set: (value: T) => void\r\n}\r\n\r\nclass CustomRefImpl<T> {\r\n  public dep?: Dep = undefined\r\n\r\n  private readonly _get: ReturnType<CustomRefFactory<T>>['get']\r\n  private readonly _set: ReturnType<CustomRefFactory<T>>['set']\r\n\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(factory: CustomRefFactory<T>) {\r\n    const { get, set } = factory(\r\n      () => trackRefValue(this),\r\n      () => triggerRefValue(this),\r\n    )\r\n    this._get = get\r\n    this._set = set\r\n  }\r\n\r\n  get value() {\r\n    return this._get()\r\n  }\r\n\r\n  set value(newVal) {\r\n    this._set(newVal)\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a customized ref with explicit control over its dependency tracking\r\n * and updates triggering.\r\n *\r\n * @param factory - The function that receives the `track` and `trigger` callbacks.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#customref}\r\n */\r\nexport function customRef<T>(factory: CustomRefFactory<T>): Ref<T> {\r\n  return new CustomRefImpl(factory) as any\r\n}\r\n\r\nexport type ToRefs<T = any> = {\r\n  [K in keyof T]: ToRef<T[K]>\r\n}\r\n\r\n/**\r\n * Converts a reactive object to a plain object where each property of the\r\n * resulting object is a ref pointing to the corresponding property of the\r\n * original object. Each individual ref is created using {@link toRef()}.\r\n *\r\n * @param object - Reactive object to be made into an object of linked refs.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#torefs}\r\n */\r\nexport function toRefs<T extends object>(object: T): ToRefs<T> {\r\n  if (__DEV__ && !isProxy(object)) {\r\n    console.warn(`toRefs() expects a reactive object but received a plain one.`)\r\n  }\r\n  const ret: any = isArray(object) ? new Array(object.length) : {}\r\n  for (const key in object) {\r\n    ret[key] = propertyToRef(object, key)\r\n  }\r\n  return ret\r\n}\r\n\r\nclass ObjectRefImpl<T extends object, K extends keyof T> {\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(\r\n    private readonly _object: T,\r\n    private readonly _key: K,\r\n    private readonly _defaultValue?: T[K],\r\n  ) {}\r\n\r\n  get value() {\r\n    const val = this._object[this._key]\r\n    return val === undefined ? this._defaultValue! : val\r\n  }\r\n\r\n  set value(newVal) {\r\n    this._object[this._key] = newVal\r\n  }\r\n\r\n  get dep(): Dep | undefined {\r\n    return getDepFromReactive(toRaw(this._object), this._key)\r\n  }\r\n}\r\n\r\nclass GetterRefImpl<T> {\r\n  public readonly __v_isRef = true\r\n  public readonly __v_isReadonly = true\r\n  constructor(private readonly _getter: () => T) {}\r\n  get value() {\r\n    return this._getter()\r\n  }\r\n}\r\n\r\nexport type ToRef<T> = IfAny<T, Ref<T>, [T] extends [Ref] ? T : Ref<T>>\r\n\r\n/**\r\n * Used to normalize values / refs / getters into refs.\r\n *\r\n * @example\r\n * ```js\r\n * // returns existing refs as-is\r\n * toRef(existingRef)\r\n *\r\n * // creates a ref that calls the getter on .value access\r\n * toRef(() => props.foo)\r\n *\r\n * // creates normal refs from non-function values\r\n * // equivalent to ref(1)\r\n * toRef(1)\r\n * ```\r\n *\r\n * Can also be used to create a ref for a property on a source reactive object.\r\n * The created ref is synced with its source property: mutating the source\r\n * property will update the ref, and vice-versa.\r\n *\r\n * @example\r\n * ```js\r\n * const state = reactive({\r\n *   foo: 1,\r\n *   bar: 2\r\n * })\r\n *\r\n * const fooRef = toRef(state, 'foo')\r\n *\r\n * // mutating the ref updates the original\r\n * fooRef.value++\r\n * console.log(state.foo) // 2\r\n *\r\n * // mutating the original also updates the ref\r\n * state.foo++\r\n * console.log(fooRef.value) // 3\r\n * ```\r\n *\r\n * @param source - A getter, an existing ref, a non-function value, or a\r\n *                 reactive object to create a property ref from.\r\n * @param [key] - (optional) Name of the property in the reactive object.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#toref}\r\n */\r\nexport function toRef<T>(\r\n  value: T,\r\n): T extends () => infer R\r\n  ? Readonly<Ref<R>>\r\n  : T extends Ref\r\n    ? T\r\n    : Ref<UnwrapRef<T>>\r\nexport function toRef<T extends object, K extends keyof T>(\r\n  object: T,\r\n  key: K,\r\n): ToRef<T[K]>\r\nexport function toRef<T extends object, K extends keyof T>(\r\n  object: T,\r\n  key: K,\r\n  defaultValue: T[K],\r\n): ToRef<Exclude<T[K], undefined>>\r\nexport function toRef(\r\n  source: Record<string, any> | MaybeRef,\r\n  key?: string,\r\n  defaultValue?: unknown,\r\n): Ref {\r\n  if (isRef(source)) {\r\n    return source\r\n  } else if (isFunction(source)) {\r\n    return new GetterRefImpl(source) as any\r\n  } else if (isObject(source) && arguments.length > 1) {\r\n    return propertyToRef(source, key!, defaultValue)\r\n  } else {\r\n    return ref(source)\r\n  }\r\n}\r\n\r\nfunction propertyToRef(\r\n  source: Record<string, any>,\r\n  key: string,\r\n  defaultValue?: unknown,\r\n) {\r\n  const val = source[key]\r\n  return isRef(val)\r\n    ? val\r\n    : (new ObjectRefImpl(source, key, defaultValue) as any)\r\n}\r\n\r\n// corner case when use narrows type\r\n// Ex. type RelativePath = string & { __brand: unknown }\r\n// RelativePath extends object -> true\r\ntype BaseTypes = string | number | boolean\r\n\r\n/**\r\n * This is a special exported interface for other packages to declare\r\n * additional types that should bail out for ref unwrapping. For example\r\n * \\@vue/runtime-dom can declare it like so in its d.ts:\r\n *\r\n * ``` ts\r\n * declare module '@vue/reactivity' {\r\n *   export interface RefUnwrapBailTypes {\r\n *     runtimeDOMBailTypes: Node | Window\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport interface RefUnwrapBailTypes {}\r\n\r\nexport type ShallowUnwrapRef<T> = {\r\n  [K in keyof T]: DistrubuteRef<T[K]>\r\n}\r\n\r\ntype DistrubuteRef<T> = T extends Ref<infer V> ? V : T\r\n\r\nexport type UnwrapRef<T> =\r\n  T extends ShallowRef<infer V>\r\n    ? V\r\n    : T extends Ref<infer V>\r\n      ? UnwrapRefSimple<V>\r\n      : UnwrapRefSimple<T>\r\n\r\nexport type UnwrapRefSimple<T> = T extends\r\n  | Function\r\n  | BaseTypes\r\n  | Ref\r\n  | RefUnwrapBailTypes[keyof RefUnwrapBailTypes]\r\n  | { [RawSymbol]?: true }\r\n  ? T\r\n  : T extends Map<infer K, infer V>\r\n    ? Map<K, UnwrapRefSimple<V>> & UnwrapRef<Omit<T, keyof Map<any, any>>>\r\n    : T extends WeakMap<infer K, infer V>\r\n      ? WeakMap<K, UnwrapRefSimple<V>> &\r\n          UnwrapRef<Omit<T, keyof WeakMap<any, any>>>\r\n      : T extends Set<infer V>\r\n        ? Set<UnwrapRefSimple<V>> & UnwrapRef<Omit<T, keyof Set<any>>>\r\n        : T extends WeakSet<infer V>\r\n          ? WeakSet<UnwrapRefSimple<V>> & UnwrapRef<Omit<T, keyof WeakSet<any>>>\r\n          : T extends ReadonlyArray<any>\r\n            ? { [K in keyof T]: UnwrapRefSimple<T[K]> }\r\n            : T extends object & { [ShallowReactiveMarker]?: never }\r\n              ? {\r\n                  [P in keyof T]: P extends symbol ? T[P] : UnwrapRef<T[P]>\r\n                }\r\n              : T\r\n","import type { VNode } from './vnode'\r\nimport type { ComponentInternalInstance } from './component'\r\nimport { popWarningContext, pushWarningContext, warn } from './warning'\r\nimport { isFunction, isPromise } from '@vue/shared'\r\nimport { LifecycleHooks } from './enums'\r\n\r\n// contexts where user provided function may be executed, in addition to\r\n// lifecycle hooks.\r\nexport enum ErrorCodes {\r\n  SETUP_FUNCTION,\r\n  RENDER_FUNCTION,\r\n  WATCH_GETTER,\r\n  WATCH_CALLBACK,\r\n  WATCH_CLEANUP,\r\n  NATIVE_EVENT_HANDLER,\r\n  COMPONENT_EVENT_HANDLER,\r\n  VNODE_HOOK,\r\n  DIRECTIVE_HOOK,\r\n  TRANSITION_HOOK,\r\n  APP_ERROR_HANDLER,\r\n  APP_WARN_HANDLER,\r\n  FUNCTION_REF,\r\n  ASYNC_COMPONENT_LOADER,\r\n  SCHEDULER,\r\n}\r\n\r\nexport const ErrorTypeStrings: Record<LifecycleHooks | ErrorCodes, string> = {\r\n  [LifecycleHooks.SERVER_PREFETCH]: 'serverPrefetch hook',\r\n  [LifecycleHooks.BEFORE_CREATE]: 'beforeCreate hook',\r\n  [LifecycleHooks.CREATED]: 'created hook',\r\n  [LifecycleHooks.BEFORE_MOUNT]: 'beforeMount hook',\r\n  [LifecycleHooks.MOUNTED]: 'mounted hook',\r\n  [LifecycleHooks.BEFORE_UPDATE]: 'beforeUpdate hook',\r\n  [LifecycleHooks.UPDATED]: 'updated',\r\n  [LifecycleHooks.BEFORE_UNMOUNT]: 'beforeUnmount hook',\r\n  [LifecycleHooks.UNMOUNTED]: 'unmounted hook',\r\n  [LifecycleHooks.ACTIVATED]: 'activated hook',\r\n  [LifecycleHooks.DEACTIVATED]: 'deactivated hook',\r\n  [LifecycleHooks.ERROR_CAPTURED]: 'errorCaptured hook',\r\n  [LifecycleHooks.RENDER_TRACKED]: 'renderTracked hook',\r\n  [LifecycleHooks.RENDER_TRIGGERED]: 'renderTriggered hook',\r\n  [ErrorCodes.SETUP_FUNCTION]: 'setup function',\r\n  [ErrorCodes.RENDER_FUNCTION]: 'render function',\r\n  [ErrorCodes.WATCH_GETTER]: 'watcher getter',\r\n  [ErrorCodes.WATCH_CALLBACK]: 'watcher callback',\r\n  [ErrorCodes.WATCH_CLEANUP]: 'watcher cleanup function',\r\n  [ErrorCodes.NATIVE_EVENT_HANDLER]: 'native event handler',\r\n  [ErrorCodes.COMPONENT_EVENT_HANDLER]: 'component event handler',\r\n  [ErrorCodes.VNODE_HOOK]: 'vnode hook',\r\n  [ErrorCodes.DIRECTIVE_HOOK]: 'directive hook',\r\n  [ErrorCodes.TRANSITION_HOOK]: 'transition hook',\r\n  [ErrorCodes.APP_ERROR_HANDLER]: 'app errorHandler',\r\n  [ErrorCodes.APP_WARN_HANDLER]: 'app warnHandler',\r\n  [ErrorCodes.FUNCTION_REF]: 'ref function',\r\n  [ErrorCodes.ASYNC_COMPONENT_LOADER]: 'async component loader',\r\n  [ErrorCodes.SCHEDULER]:\r\n    'scheduler flush. This is likely a Vue internals bug. ' +\r\n    'Please open an issue at https://github.com/vuejs/core .',\r\n}\r\n\r\nexport type ErrorTypes = LifecycleHooks | ErrorCodes\r\n\r\nexport function callWithErrorHandling(\r\n  fn: Function,\r\n  instance: ComponentInternalInstance | null,\r\n  type: ErrorTypes,\r\n  args?: unknown[],\r\n) {\r\n  let res\r\n  try {\r\n    res = args ? fn(...args) : fn()\r\n  } catch (err) {\r\n    handleError(err, instance, type)\r\n  }\r\n  return res\r\n}\r\n\r\nexport function callWithAsyncErrorHandling(\r\n  fn: Function | Function[],\r\n  instance: ComponentInternalInstance | null,\r\n  type: ErrorTypes,\r\n  args?: unknown[],\r\n): any[] {\r\n  if (isFunction(fn)) {\r\n    const res = callWithErrorHandling(fn, instance, type, args)\r\n    if (res && isPromise(res)) {\r\n      res.catch(err => {\r\n        handleError(err, instance, type)\r\n      })\r\n    }\r\n    return res\r\n  }\r\n\r\n  const values = []\r\n  for (let i = 0; i < fn.length; i++) {\r\n    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args))\r\n  }\r\n  return values\r\n}\r\n\r\nexport function handleError(\r\n  err: unknown,\r\n  instance: ComponentInternalInstance | null,\r\n  type: ErrorTypes,\r\n  throwInDev = true,\r\n) {\r\n  const contextVNode = instance ? instance.vnode : null\r\n  if (instance) {\r\n    let cur = instance.parent\r\n    // the exposed instance is the render proxy to keep it consistent with 2.x\r\n    const exposedInstance = instance.proxy\r\n    // in production the hook receives only the error code\r\n    const errorInfo = __DEV__\r\n      ? ErrorTypeStrings[type]\r\n      : `https://vuejs.org/error-reference/#runtime-${type}`\r\n    while (cur) {\r\n      const errorCapturedHooks = cur.ec\r\n      if (errorCapturedHooks) {\r\n        for (let i = 0; i < errorCapturedHooks.length; i++) {\r\n          if (\r\n            errorCapturedHooks[i](err, exposedInstance, errorInfo) === false\r\n          ) {\r\n            return\r\n          }\r\n        }\r\n      }\r\n      cur = cur.parent\r\n    }\r\n    // app-level handling\r\n    const appErrorHandler = instance.appContext.config.errorHandler\r\n    if (appErrorHandler) {\r\n      callWithErrorHandling(\r\n        appErrorHandler,\r\n        null,\r\n        ErrorCodes.APP_ERROR_HANDLER,\r\n        [err, exposedInstance, errorInfo],\r\n      )\r\n      return\r\n    }\r\n  }\r\n  logError(err, type, contextVNode, throwInDev)\r\n}\r\n\r\nfunction logError(\r\n  err: unknown,\r\n  type: ErrorTypes,\r\n  contextVNode: VNode | null,\r\n  throwInDev = true,\r\n) {\r\n  if (__DEV__) {\r\n    const info = ErrorTypeStrings[type]\r\n    if (contextVNode) {\r\n      pushWarningContext(contextVNode)\r\n    }\r\n    warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`)\r\n    if (contextVNode) {\r\n      popWarningContext()\r\n    }\r\n    // crash in dev by default so it's more noticeable\r\n    if (throwInDev) {\r\n      throw err\r\n    } else if (!__TEST__) {\r\n      console.error(err)\r\n    }\r\n  } else {\r\n    // recover in prod to reduce the impact on end-user\r\n    console.error(err)\r\n  }\r\n}\r\n","import { ErrorCodes, callWithErrorHandling, handleError } from './errorHandling'\r\nimport { type Awaited, NOOP, isArray } from '@vue/shared'\r\nimport { type ComponentInternalInstance, getComponentName } from './component'\r\n\r\nexport interface SchedulerJob extends Function {\r\n  id?: number\r\n  pre?: boolean\r\n  active?: boolean\r\n  computed?: boolean\r\n  /**\r\n   * Indicates whether the effect is allowed to recursively trigger itself\r\n   * when managed by the scheduler.\r\n   *\r\n   * By default, a job cannot trigger itself because some built-in method calls,\r\n   * e.g. Array.prototype.push actually performs reads as well (#1740) which\r\n   * can lead to confusing infinite loops.\r\n   * The allowed cases are component update functions and watch callbacks.\r\n   * Component update functions may update child component props, which in turn\r\n   * trigger flush: \"pre\" watch callbacks that mutates state that the parent\r\n   * relies on (#1801). Watch callbacks doesn't track its dependencies so if it\r\n   * triggers itself again, it's likely intentional and it is the user's\r\n   * responsibility to perform recursive state mutation that eventually\r\n   * stabilizes (#1727).\r\n   */\r\n  allowRecurse?: boolean\r\n  /**\r\n   * Attached by renderer.ts when setting up a component's render effect\r\n   * Used to obtain component information when reporting max recursive updates.\r\n   * dev only.\r\n   */\r\n  ownerInstance?: ComponentInternalInstance\r\n}\r\n\r\nexport type SchedulerJobs = SchedulerJob | SchedulerJob[]\r\n\r\nlet isFlushing = false\r\nlet isFlushPending = false\r\n\r\nconst queue: SchedulerJob[] = []\r\nlet flushIndex = 0\r\n\r\nconst pendingPostFlushCbs: SchedulerJob[] = []\r\nlet activePostFlushCbs: SchedulerJob[] | null = null\r\nlet postFlushIndex = 0\r\n\r\nconst resolvedPromise = /*#__PURE__*/ Promise.resolve() as Promise<any>\r\nlet currentFlushPromise: Promise<void> | null = null\r\n\r\nconst RECURSION_LIMIT = 100\r\ntype CountMap = Map<SchedulerJob, number>\r\n\r\nexport function nextTick<T = void, R = void>(\r\n  this: T,\r\n  fn?: (this: T) => R,\r\n): Promise<Awaited<R>> {\r\n  const p = currentFlushPromise || resolvedPromise\r\n  return fn ? p.then(this ? fn.bind(this) : fn) : p\r\n}\r\n\r\n// #2768\r\n// Use binary-search to find a suitable position in the queue,\r\n// so that the queue maintains the increasing order of job's id,\r\n// which can prevent the job from being skipped and also can avoid repeated patching.\r\nfunction findInsertionIndex(id: number) {\r\n  // the start index should be `flushIndex + 1`\r\n  let start = flushIndex + 1\r\n  let end = queue.length\r\n\r\n  while (start < end) {\r\n    const middle = (start + end) >>> 1\r\n    const middleJob = queue[middle]\r\n    const middleJobId = getId(middleJob)\r\n    if (middleJobId < id || (middleJobId === id && middleJob.pre)) {\r\n      start = middle + 1\r\n    } else {\r\n      end = middle\r\n    }\r\n  }\r\n\r\n  return start\r\n}\r\n\r\nexport function queueJob(job: SchedulerJob) {\r\n  // the dedupe search uses the startIndex argument of Array.includes()\r\n  // by default the search index includes the current job that is being run\r\n  // so it cannot recursively trigger itself again.\r\n  // if the job is a watch() callback, the search will start with a +1 index to\r\n  // allow it recursively trigger itself - it is the user's responsibility to\r\n  // ensure it doesn't end up in an infinite loop.\r\n  if (\r\n    !queue.length ||\r\n    !queue.includes(\r\n      job,\r\n      isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex,\r\n    )\r\n  ) {\r\n    if (job.id == null) {\r\n      queue.push(job)\r\n    } else {\r\n      queue.splice(findInsertionIndex(job.id), 0, job)\r\n    }\r\n    queueFlush()\r\n  }\r\n}\r\n\r\nfunction queueFlush() {\r\n  if (!isFlushing && !isFlushPending) {\r\n    isFlushPending = true\r\n    currentFlushPromise = resolvedPromise.then(flushJobs)\r\n  }\r\n}\r\n\r\nexport function invalidateJob(job: SchedulerJob) {\r\n  const i = queue.indexOf(job)\r\n  if (i > flushIndex) {\r\n    queue.splice(i, 1)\r\n  }\r\n}\r\n\r\nexport function queuePostFlushCb(cb: SchedulerJobs) {\r\n  if (!isArray(cb)) {\r\n    if (\r\n      !activePostFlushCbs ||\r\n      !activePostFlushCbs.includes(\r\n        cb,\r\n        cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex,\r\n      )\r\n    ) {\r\n      pendingPostFlushCbs.push(cb)\r\n    }\r\n  } else {\r\n    // if cb is an array, it is a component lifecycle hook which can only be\r\n    // triggered by a job, which is already deduped in the main queue, so\r\n    // we can skip duplicate check here to improve perf\r\n    pendingPostFlushCbs.push(...cb)\r\n  }\r\n  queueFlush()\r\n}\r\n\r\nexport function flushPreFlushCbs(\r\n  instance?: ComponentInternalInstance,\r\n  seen?: CountMap,\r\n  // if currently flushing, skip the current job itself\r\n  i = isFlushing ? flushIndex + 1 : 0,\r\n) {\r\n  if (__DEV__) {\r\n    seen = seen || new Map()\r\n  }\r\n  for (; i < queue.length; i++) {\r\n    const cb = queue[i]\r\n    if (cb && cb.pre) {\r\n      if (instance && cb.id !== instance.uid) {\r\n        continue\r\n      }\r\n      if (__DEV__ && checkRecursiveUpdates(seen!, cb)) {\r\n        continue\r\n      }\r\n      queue.splice(i, 1)\r\n      i--\r\n      cb()\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushPostFlushCbs(seen?: CountMap) {\r\n  if (pendingPostFlushCbs.length) {\r\n    const deduped = [...new Set(pendingPostFlushCbs)].sort(\r\n      (a, b) => getId(a) - getId(b),\r\n    )\r\n    pendingPostFlushCbs.length = 0\r\n\r\n    // #1947 already has active queue, nested flushPostFlushCbs call\r\n    if (activePostFlushCbs) {\r\n      activePostFlushCbs.push(...deduped)\r\n      return\r\n    }\r\n\r\n    activePostFlushCbs = deduped\r\n    if (__DEV__) {\r\n      seen = seen || new Map()\r\n    }\r\n\r\n    for (\r\n      postFlushIndex = 0;\r\n      postFlushIndex < activePostFlushCbs.length;\r\n      postFlushIndex++\r\n    ) {\r\n      if (\r\n        __DEV__ &&\r\n        checkRecursiveUpdates(seen!, activePostFlushCbs[postFlushIndex])\r\n      ) {\r\n        continue\r\n      }\r\n      activePostFlushCbs[postFlushIndex]()\r\n    }\r\n    activePostFlushCbs = null\r\n    postFlushIndex = 0\r\n  }\r\n}\r\n\r\nconst getId = (job: SchedulerJob): number =>\r\n  job.id == null ? Infinity : job.id\r\n\r\nconst comparator = (a: SchedulerJob, b: SchedulerJob): number => {\r\n  const diff = getId(a) - getId(b)\r\n  if (diff === 0) {\r\n    if (a.pre && !b.pre) return -1\r\n    if (b.pre && !a.pre) return 1\r\n  }\r\n  return diff\r\n}\r\n\r\nfunction flushJobs(seen?: CountMap) {\r\n  isFlushPending = false\r\n  isFlushing = true\r\n  if (__DEV__) {\r\n    seen = seen || new Map()\r\n  }\r\n\r\n  // Sort queue before flush.\r\n  // This ensures that:\r\n  // 1. Components are updated from parent to child. (because parent is always\r\n  //    created before the child so its render effect will have smaller\r\n  //    priority number)\r\n  // 2. If a component is unmounted during a parent component's update,\r\n  //    its update can be skipped.\r\n  queue.sort(comparator)\r\n\r\n  // conditional usage of checkRecursiveUpdate must be determined out of\r\n  // try ... catch block since Rollup by default de-optimizes treeshaking\r\n  // inside try-catch. This can leave all warning code unshaked. Although\r\n  // they would get eventually shaken by a minifier like terser, some minifiers\r\n  // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)\r\n  const check = __DEV__\r\n    ? (job: SchedulerJob) => checkRecursiveUpdates(seen!, job)\r\n    : NOOP\r\n\r\n  try {\r\n    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\r\n      const job = queue[flushIndex]\r\n      if (job && job.active !== false) {\r\n        if (__DEV__ && check(job)) {\r\n          continue\r\n        }\r\n        callWithErrorHandling(job, null, ErrorCodes.SCHEDULER)\r\n      }\r\n    }\r\n  } finally {\r\n    flushIndex = 0\r\n    queue.length = 0\r\n\r\n    flushPostFlushCbs(seen)\r\n\r\n    isFlushing = false\r\n    currentFlushPromise = null\r\n    // some postFlushCb queued jobs!\r\n    // keep flushing until it drains.\r\n    if (queue.length || pendingPostFlushCbs.length) {\r\n      flushJobs(seen)\r\n    }\r\n  }\r\n}\r\n\r\nfunction checkRecursiveUpdates(seen: CountMap, fn: SchedulerJob) {\r\n  if (!seen.has(fn)) {\r\n    seen.set(fn, 1)\r\n  } else {\r\n    const count = seen.get(fn)!\r\n    if (count > RECURSION_LIMIT) {\r\n      const instance = fn.ownerInstance\r\n      const componentName = instance && getComponentName(instance.type)\r\n      handleError(\r\n        `Maximum recursive updates exceeded${\r\n          componentName ? ` in component <${componentName}>` : ``\r\n        }. ` +\r\n          `This means you have a reactive effect that is mutating its own ` +\r\n          `dependencies and thus recursively triggering itself. Possible sources ` +\r\n          `include component template, render function, updated hook or ` +\r\n          `watcher source function.`,\r\n        null,\r\n        ErrorCodes.APP_ERROR_HANDLER,\r\n      )\r\n      return true\r\n    } else {\r\n      seen.set(fn, count + 1)\r\n    }\r\n  }\r\n}\r\n","import {\r\n  EMPTY_OBJ,\r\n  type UnionToIntersection,\r\n  camelize,\r\n  extend,\r\n  hasOwn,\r\n  hyphenate,\r\n  isArray,\r\n  isFunction,\r\n  isObject,\r\n  isOn,\r\n  isString,\r\n  looseToNumber,\r\n  toHandlerKey,\r\n} from '@vue/shared'\r\nimport {\r\n  type ComponentInternalInstance,\r\n  type ComponentOptions,\r\n  type ConcreteComponent,\r\n  formatComponentName,\r\n} from './component'\r\nimport { ErrorCodes, callWithAsyncErrorHandling } from './errorHandling'\r\nimport { warn } from './warning'\r\nimport { devtoolsComponentEmit } from './devtools'\r\nimport type { AppContext } from './apiCreateApp'\r\nimport { emit as compatInstanceEmit } from './compat/instanceEventEmitter'\r\nimport {\r\n  compatModelEmit,\r\n  compatModelEventPrefix,\r\n} from './compat/componentVModel'\r\n\r\nexport type ObjectEmitsOptions = Record<\r\n  string,\r\n  ((...args: any[]) => any) | null\r\n>\r\n\r\nexport type EmitsOptions = ObjectEmitsOptions | string[]\r\n\r\nexport type EmitsToProps<T extends EmitsOptions> = T extends string[]\r\n  ? {\r\n      [K in `on${Capitalize<T[number]>}`]?: (...args: any[]) => any\r\n    }\r\n  : T extends ObjectEmitsOptions\r\n    ? {\r\n        [K in `on${Capitalize<string & keyof T>}`]?: K extends `on${infer C}`\r\n          ? (\r\n              ...args: T[Uncapitalize<C>] extends (...args: infer P) => any\r\n                ? P\r\n                : T[Uncapitalize<C>] extends null\r\n                  ? any[]\r\n                  : never\r\n            ) => any\r\n          : never\r\n      }\r\n    : {}\r\n\r\nexport type ShortEmitsToObject<E> =\r\n  E extends Record<string, any[]>\r\n    ? {\r\n        [K in keyof E]: (...args: E[K]) => any\r\n      }\r\n    : E\r\n\r\nexport type EmitFn<\r\n  Options = ObjectEmitsOptions,\r\n  Event extends keyof Options = keyof Options,\r\n> =\r\n  Options extends Array<infer V>\r\n    ? (event: V, ...args: any[]) => void\r\n    : {} extends Options // if the emit is empty object (usually the default value for emit) should be converted to function\r\n      ? (event: string, ...args: any[]) => void\r\n      : UnionToIntersection<\r\n          {\r\n            [key in Event]: Options[key] extends (...args: infer Args) => any\r\n              ? (event: key, ...args: Args) => void\r\n              : Options[key] extends any[]\r\n                ? (event: key, ...args: Options[key]) => void\r\n                : (event: key, ...args: any[]) => void\r\n          }[Event]\r\n        >\r\n\r\nexport function emit(\r\n  instance: ComponentInternalInstance,\r\n  event: string,\r\n  ...rawArgs: any[]\r\n) {\r\n  if (instance.isUnmounted) return\r\n  const props = instance.vnode.props || EMPTY_OBJ\r\n\r\n  if (__DEV__) {\r\n    const {\r\n      emitsOptions,\r\n      propsOptions: [propsOptions],\r\n    } = instance\r\n    if (emitsOptions) {\r\n      if (\r\n        !(event in emitsOptions) &&\r\n        !(\r\n          __COMPAT__ &&\r\n          (event.startsWith('hook:') ||\r\n            event.startsWith(compatModelEventPrefix))\r\n        )\r\n      ) {\r\n        if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {\r\n          warn(\r\n            `Component emitted event \"${event}\" but it is neither declared in ` +\r\n              `the emits option nor as an \"${toHandlerKey(event)}\" prop.`,\r\n          )\r\n        }\r\n      } else {\r\n        const validator = emitsOptions[event]\r\n        if (isFunction(validator)) {\r\n          const isValid = validator(...rawArgs)\r\n          if (!isValid) {\r\n            warn(\r\n              `Invalid event arguments: event validation failed for event \"${event}\".`,\r\n            )\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  let args = rawArgs\r\n  const isModelListener = event.startsWith('update:')\r\n\r\n  // for v-model update:xxx events, apply modifiers on args\r\n  const modelArg = isModelListener && event.slice(7)\r\n  if (modelArg && modelArg in props) {\r\n    const modifiersKey = `${\r\n      modelArg === 'modelValue' ? 'model' : modelArg\r\n    }Modifiers`\r\n    const { number, trim } = props[modifiersKey] || EMPTY_OBJ\r\n    if (trim) {\r\n      args = rawArgs.map(a => (isString(a) ? a.trim() : a))\r\n    }\r\n    if (number) {\r\n      args = rawArgs.map(looseToNumber)\r\n    }\r\n  }\r\n\r\n  if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n    devtoolsComponentEmit(instance, event, args)\r\n  }\r\n\r\n  if (__DEV__) {\r\n    const lowerCaseEvent = event.toLowerCase()\r\n    if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {\r\n      warn(\r\n        `Event \"${lowerCaseEvent}\" is emitted in component ` +\r\n          `${formatComponentName(\r\n            instance,\r\n            instance.type,\r\n          )} but the handler is registered for \"${event}\". ` +\r\n          `Note that HTML attributes are case-insensitive and you cannot use ` +\r\n          `v-on to listen to camelCase events when using in-DOM templates. ` +\r\n          `You should probably use \"${hyphenate(\r\n            event,\r\n          )}\" instead of \"${event}\".`,\r\n      )\r\n    }\r\n  }\r\n\r\n  let handlerName\r\n  let handler =\r\n    props[(handlerName = toHandlerKey(event))] ||\r\n    // also try camelCase event handler (#2249)\r\n    props[(handlerName = toHandlerKey(camelize(event)))]\r\n  // for v-model update:xxx events, also trigger kebab-case equivalent\r\n  // for props passed via kebab-case\r\n  if (!handler && isModelListener) {\r\n    handler = props[(handlerName = toHandlerKey(hyphenate(event)))]\r\n  }\r\n\r\n  if (handler) {\r\n    callWithAsyncErrorHandling(\r\n      handler,\r\n      instance,\r\n      ErrorCodes.COMPONENT_EVENT_HANDLER,\r\n      args,\r\n    )\r\n  }\r\n\r\n  const onceHandler = props[handlerName + `Once`]\r\n  if (onceHandler) {\r\n    if (!instance.emitted) {\r\n      instance.emitted = {}\r\n    } else if (instance.emitted[handlerName]) {\r\n      return\r\n    }\r\n    instance.emitted[handlerName] = true\r\n    callWithAsyncErrorHandling(\r\n      onceHandler,\r\n      instance,\r\n      ErrorCodes.COMPONENT_EVENT_HANDLER,\r\n      args,\r\n    )\r\n  }\r\n\r\n  if (__COMPAT__) {\r\n    compatModelEmit(instance, event, args)\r\n    return compatInstanceEmit(instance, event, args)\r\n  }\r\n}\r\n\r\nexport function normalizeEmitsOptions(\r\n  comp: ConcreteComponent,\r\n  appContext: AppContext,\r\n  asMixin = false,\r\n): ObjectEmitsOptions | null {\r\n  const cache = appContext.emitsCache\r\n  const cached = cache.get(comp)\r\n  if (cached !== undefined) {\r\n    return cached\r\n  }\r\n\r\n  const raw = comp.emits\r\n  let normalized: ObjectEmitsOptions = {}\r\n\r\n  // apply mixin/extends props\r\n  let hasExtends = false\r\n  if (__FEATURE_OPTIONS_API__ && !isFunction(comp)) {\r\n    const extendEmits = (raw: ComponentOptions) => {\r\n      const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true)\r\n      if (normalizedFromExtend) {\r\n        hasExtends = true\r\n        extend(normalized, normalizedFromExtend)\r\n      }\r\n    }\r\n    if (!asMixin && appContext.mixins.length) {\r\n      appContext.mixins.forEach(extendEmits)\r\n    }\r\n    if (comp.extends) {\r\n      extendEmits(comp.extends)\r\n    }\r\n    if (comp.mixins) {\r\n      comp.mixins.forEach(extendEmits)\r\n    }\r\n  }\r\n\r\n  if (!raw && !hasExtends) {\r\n    if (isObject(comp)) {\r\n      cache.set(comp, null)\r\n    }\r\n    return null\r\n  }\r\n\r\n  if (isArray(raw)) {\r\n    raw.forEach(key => (normalized[key] = null))\r\n  } else {\r\n    extend(normalized, raw)\r\n  }\r\n\r\n  if (isObject(comp)) {\r\n    cache.set(comp, normalized)\r\n  }\r\n  return normalized\r\n}\r\n\r\n// Check if an incoming prop key is a declared emit event listener.\r\n// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are\r\n// both considered matched listeners.\r\nexport function isEmitListener(\r\n  options: ObjectEmitsOptions | null,\r\n  key: string,\r\n): boolean {\r\n  if (!options || !isOn(key)) {\r\n    return false\r\n  }\r\n\r\n  if (__COMPAT__ && key.startsWith(compatModelEventPrefix)) {\r\n    return true\r\n  }\r\n\r\n  key = key.slice(2).replace(/Once$/, '')\r\n  return (\r\n    hasOwn(options, key[0].toLowerCase() + key.slice(1)) ||\r\n    hasOwn(options, hyphenate(key)) ||\r\n    hasOwn(options, key)\r\n  )\r\n}\r\n","import type { ComponentInternalInstance } from './component'\r\nimport { devtoolsComponentUpdated } from './devtools'\r\nimport { setBlockTracking } from './vnode'\r\n\r\n/**\r\n * mark the current rendering instance for asset resolution (e.g.\r\n * resolveComponent, resolveDirective) during render\r\n */\r\nexport let currentRenderingInstance: ComponentInternalInstance | null = null\r\nexport let currentScopeId: string | null = null\r\n\r\n/**\r\n * Note: rendering calls maybe nested. The function returns the parent rendering\r\n * instance if present, which should be restored after the render is done:\r\n *\r\n * ```js\r\n * const prev = setCurrentRenderingInstance(i)\r\n * // ...render\r\n * setCurrentRenderingInstance(prev)\r\n * ```\r\n */\r\nexport function setCurrentRenderingInstance(\r\n  instance: ComponentInternalInstance | null,\r\n): ComponentInternalInstance | null {\r\n  const prev = currentRenderingInstance\r\n  currentRenderingInstance = instance\r\n  currentScopeId = (instance && instance.type.__scopeId) || null\r\n  // v2 pre-compiled components uses _scopeId instead of __scopeId\r\n  if (__COMPAT__ && !currentScopeId) {\r\n    currentScopeId = (instance && (instance.type as any)._scopeId) || null\r\n  }\r\n  return prev\r\n}\r\n\r\n/**\r\n * Set scope id when creating hoisted vnodes.\r\n * @private compiler helper\r\n */\r\nexport function pushScopeId(id: string | null) {\r\n  currentScopeId = id\r\n}\r\n\r\n/**\r\n * Technically we no longer need this after 3.0.8 but we need to keep the same\r\n * API for backwards compat w/ code generated by compilers.\r\n * @private\r\n */\r\nexport function popScopeId() {\r\n  currentScopeId = null\r\n}\r\n\r\n/**\r\n * Only for backwards compat\r\n * @private\r\n */\r\nexport const withScopeId = (_id: string) => withCtx\r\n\r\nexport type ContextualRenderFn = {\r\n  (...args: any[]): any\r\n  _n: boolean /* already normalized */\r\n  _c: boolean /* compiled */\r\n  _d: boolean /* disableTracking */\r\n  _ns: boolean /* nonScoped */\r\n}\r\n\r\n/**\r\n * Wrap a slot function to memoize current rendering instance\r\n * @private compiler helper\r\n */\r\nexport function withCtx(\r\n  fn: Function,\r\n  ctx: ComponentInternalInstance | null = currentRenderingInstance,\r\n  isNonScopedSlot?: boolean, // __COMPAT__ only\r\n) {\r\n  if (!ctx) return fn\r\n\r\n  // already normalized\r\n  if ((fn as ContextualRenderFn)._n) {\r\n    return fn\r\n  }\r\n\r\n  const renderFnWithContext: ContextualRenderFn = (...args: any[]) => {\r\n    // If a user calls a compiled slot inside a template expression (#1745), it\r\n    // can mess up block tracking, so by default we disable block tracking and\r\n    // force bail out when invoking a compiled slot (indicated by the ._d flag).\r\n    // This isn't necessary if rendering a compiled `<slot>`, so we flip the\r\n    // ._d flag off when invoking the wrapped fn inside `renderSlot`.\r\n    if (renderFnWithContext._d) {\r\n      setBlockTracking(-1)\r\n    }\r\n    const prevInstance = setCurrentRenderingInstance(ctx)\r\n    let res\r\n    try {\r\n      res = fn(...args)\r\n    } finally {\r\n      setCurrentRenderingInstance(prevInstance)\r\n      if (renderFnWithContext._d) {\r\n        setBlockTracking(1)\r\n      }\r\n    }\r\n\r\n    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n      devtoolsComponentUpdated(ctx)\r\n    }\r\n\r\n    return res\r\n  }\r\n\r\n  // mark normalized to avoid duplicated wrapping\r\n  renderFnWithContext._n = true\r\n  // mark this as compiled by default\r\n  // this is used in vnode.ts -> normalizeChildren() to set the slot\r\n  // rendering flag.\r\n  renderFnWithContext._c = true\r\n  // disable block tracking by default\r\n  renderFnWithContext._d = true\r\n  // compat build only flag to distinguish scoped slots from non-scoped ones\r\n  if (__COMPAT__ && isNonScopedSlot) {\r\n    renderFnWithContext._ns = true\r\n  }\r\n  return renderFnWithContext\r\n}\r\n","import {\r\n  type ComponentInternalInstance,\r\n  type Data,\r\n  type FunctionalComponent,\r\n  getComponentName,\r\n} from './component'\r\nimport {\r\n  Comment,\r\n  type VNode,\r\n  type VNodeArrayChildren,\r\n  blockStack,\r\n  cloneVNode,\r\n  createVNode,\r\n  isVNode,\r\n  normalizeVNode,\r\n} from './vnode'\r\nimport { ErrorCodes, handleError } from './errorHandling'\r\nimport { PatchFlags, ShapeFlags, isModelListener, isOn } from '@vue/shared'\r\nimport { warn } from './warning'\r\nimport { isHmrUpdating } from './hmr'\r\nimport type { NormalizedProps } from './componentProps'\r\nimport { isEmitListener } from './componentEmits'\r\nimport { setCurrentRenderingInstance } from './componentRenderContext'\r\nimport {\r\n  DeprecationTypes,\r\n  isCompatEnabled,\r\n  warnDeprecation,\r\n} from './compat/compatConfig'\r\n\r\n/**\r\n * dev only flag to track whether $attrs was used during render.\r\n * If $attrs was used during render then the warning for failed attrs\r\n * fallthrough can be suppressed.\r\n */\r\nlet accessedAttrs: boolean = false\r\n\r\nexport function markAttrsAccessed() {\r\n  accessedAttrs = true\r\n}\r\n\r\ntype SetRootFn = ((root: VNode) => void) | undefined\r\n\r\nexport function renderComponentRoot(\r\n  instance: ComponentInternalInstance,\r\n): VNode {\r\n  const {\r\n    type: Component,\r\n    vnode,\r\n    proxy,\r\n    withProxy,\r\n    props,\r\n    propsOptions: [propsOptions],\r\n    slots,\r\n    attrs,\r\n    emit,\r\n    render,\r\n    renderCache,\r\n    data,\r\n    setupState,\r\n    ctx,\r\n    inheritAttrs,\r\n  } = instance\r\n\r\n  let result\r\n  let fallthroughAttrs\r\n  const prev = setCurrentRenderingInstance(instance)\r\n  if (__DEV__) {\r\n    accessedAttrs = false\r\n  }\r\n\r\n  try {\r\n    if (vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {\r\n      // withProxy is a proxy with a different `has` trap only for\r\n      // runtime-compiled render functions using `with` block.\r\n      const proxyToUse = withProxy || proxy\r\n      // 'this' isn't available in production builds with `<script setup>`,\r\n      // so warn if it's used in dev.\r\n      const thisProxy =\r\n        __DEV__ && setupState.__isScriptSetup\r\n          ? new Proxy(proxyToUse!, {\r\n              get(target, key, receiver) {\r\n                warn(\r\n                  `Property '${String(\r\n                    key,\r\n                  )}' was accessed via 'this'. Avoid using 'this' in templates.`,\r\n                )\r\n                return Reflect.get(target, key, receiver)\r\n              },\r\n            })\r\n          : proxyToUse\r\n      result = normalizeVNode(\r\n        render!.call(\r\n          thisProxy,\r\n          proxyToUse!,\r\n          renderCache,\r\n          props,\r\n          setupState,\r\n          data,\r\n          ctx,\r\n        ),\r\n      )\r\n      fallthroughAttrs = attrs\r\n    } else {\r\n      // functional\r\n      const render = Component as FunctionalComponent\r\n      // in dev, mark attrs accessed if optional props (attrs === props)\r\n      if (__DEV__ && attrs === props) {\r\n        markAttrsAccessed()\r\n      }\r\n      result = normalizeVNode(\r\n        render.length > 1\r\n          ? render(\r\n              props,\r\n              __DEV__\r\n                ? {\r\n                    get attrs() {\r\n                      markAttrsAccessed()\r\n                      return attrs\r\n                    },\r\n                    slots,\r\n                    emit,\r\n                  }\r\n                : { attrs, slots, emit },\r\n            )\r\n          : render(props, null as any /* we know it doesn't need it */),\r\n      )\r\n      fallthroughAttrs = Component.props\r\n        ? attrs\r\n        : getFunctionalFallthrough(attrs)\r\n    }\r\n  } catch (err) {\r\n    blockStack.length = 0\r\n    handleError(err, instance, ErrorCodes.RENDER_FUNCTION)\r\n    result = createVNode(Comment)\r\n  }\r\n\r\n  // attr merging\r\n  // in dev mode, comments are preserved, and it's possible for a template\r\n  // to have comments along side the root element which makes it a fragment\r\n  let root = result\r\n  let setRoot: SetRootFn = undefined\r\n  if (\r\n    __DEV__ &&\r\n    result.patchFlag > 0 &&\r\n    result.patchFlag & PatchFlags.DEV_ROOT_FRAGMENT\r\n  ) {\r\n    ;[root, setRoot] = getChildRoot(result)\r\n  }\r\n\r\n  if (fallthroughAttrs && inheritAttrs !== false) {\r\n    const keys = Object.keys(fallthroughAttrs)\r\n    const { shapeFlag } = root\r\n    if (keys.length) {\r\n      if (shapeFlag & (ShapeFlags.ELEMENT | ShapeFlags.COMPONENT)) {\r\n        if (propsOptions && keys.some(isModelListener)) {\r\n          // If a v-model listener (onUpdate:xxx) has a corresponding declared\r\n          // prop, it indicates this component expects to handle v-model and\r\n          // it should not fallthrough.\r\n          // related: #1543, #1643, #1989\r\n          fallthroughAttrs = filterModelListeners(\r\n            fallthroughAttrs,\r\n            propsOptions,\r\n          )\r\n        }\r\n        root = cloneVNode(root, fallthroughAttrs)\r\n      } else if (__DEV__ && !accessedAttrs && root.type !== Comment) {\r\n        const allAttrs = Object.keys(attrs)\r\n        const eventAttrs: string[] = []\r\n        const extraAttrs: string[] = []\r\n        for (let i = 0, l = allAttrs.length; i < l; i++) {\r\n          const key = allAttrs[i]\r\n          if (isOn(key)) {\r\n            // ignore v-model handlers when they fail to fallthrough\r\n            if (!isModelListener(key)) {\r\n              // remove `on`, lowercase first letter to reflect event casing\r\n              // accurately\r\n              eventAttrs.push(key[2].toLowerCase() + key.slice(3))\r\n            }\r\n          } else {\r\n            extraAttrs.push(key)\r\n          }\r\n        }\r\n        if (extraAttrs.length) {\r\n          warn(\r\n            `Extraneous non-props attributes (` +\r\n              `${extraAttrs.join(', ')}) ` +\r\n              `were passed to component but could not be automatically inherited ` +\r\n              `because component renders fragment or text root nodes.`,\r\n          )\r\n        }\r\n        if (eventAttrs.length) {\r\n          warn(\r\n            `Extraneous non-emits event listeners (` +\r\n              `${eventAttrs.join(', ')}) ` +\r\n              `were passed to component but could not be automatically inherited ` +\r\n              `because component renders fragment or text root nodes. ` +\r\n              `If the listener is intended to be a component custom event listener only, ` +\r\n              `declare it using the \"emits\" option.`,\r\n          )\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (\r\n    __COMPAT__ &&\r\n    isCompatEnabled(DeprecationTypes.INSTANCE_ATTRS_CLASS_STYLE, instance) &&\r\n    vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT &&\r\n    root.shapeFlag & (ShapeFlags.ELEMENT | ShapeFlags.COMPONENT)\r\n  ) {\r\n    const { class: cls, style } = vnode.props || {}\r\n    if (cls || style) {\r\n      if (__DEV__ && inheritAttrs === false) {\r\n        warnDeprecation(\r\n          DeprecationTypes.INSTANCE_ATTRS_CLASS_STYLE,\r\n          instance,\r\n          getComponentName(instance.type),\r\n        )\r\n      }\r\n      root = cloneVNode(root, {\r\n        class: cls,\r\n        style: style,\r\n      })\r\n    }\r\n  }\r\n\r\n  // inherit directives\r\n  if (vnode.dirs) {\r\n    if (__DEV__ && !isElementRoot(root)) {\r\n      warn(\r\n        `Runtime directive used on component with non-element root node. ` +\r\n          `The directives will not function as intended.`,\r\n      )\r\n    }\r\n    // clone before mutating since the root may be a hoisted vnode\r\n    root = cloneVNode(root)\r\n    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs\r\n  }\r\n  // inherit transition data\r\n  if (vnode.transition) {\r\n    if (__DEV__ && !isElementRoot(root)) {\r\n      warn(\r\n        `Component inside <Transition> renders non-element root node ` +\r\n          `that cannot be animated.`,\r\n      )\r\n    }\r\n    root.transition = vnode.transition\r\n  }\r\n\r\n  if (__DEV__ && setRoot) {\r\n    setRoot(root)\r\n  } else {\r\n    result = root\r\n  }\r\n\r\n  setCurrentRenderingInstance(prev)\r\n  return result\r\n}\r\n\r\n/**\r\n * dev only\r\n * In dev mode, template root level comments are rendered, which turns the\r\n * template into a fragment root, but we need to locate the single element\r\n * root for attrs and scope id processing.\r\n */\r\nconst getChildRoot = (vnode: VNode): [VNode, SetRootFn] => {\r\n  const rawChildren = vnode.children as VNodeArrayChildren\r\n  const dynamicChildren = vnode.dynamicChildren\r\n  const childRoot = filterSingleRoot(rawChildren, false)\r\n  if (!childRoot) {\r\n    return [vnode, undefined]\r\n  } else if (\r\n    __DEV__ &&\r\n    childRoot.patchFlag > 0 &&\r\n    childRoot.patchFlag & PatchFlags.DEV_ROOT_FRAGMENT\r\n  ) {\r\n    return getChildRoot(childRoot)\r\n  }\r\n\r\n  const index = rawChildren.indexOf(childRoot)\r\n  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1\r\n  const setRoot: SetRootFn = (updatedRoot: VNode) => {\r\n    rawChildren[index] = updatedRoot\r\n    if (dynamicChildren) {\r\n      if (dynamicIndex > -1) {\r\n        dynamicChildren[dynamicIndex] = updatedRoot\r\n      } else if (updatedRoot.patchFlag > 0) {\r\n        vnode.dynamicChildren = [...dynamicChildren, updatedRoot]\r\n      }\r\n    }\r\n  }\r\n  return [normalizeVNode(childRoot), setRoot]\r\n}\r\n\r\nexport function filterSingleRoot(\r\n  children: VNodeArrayChildren,\r\n  recurse = true,\r\n): VNode | undefined {\r\n  let singleRoot\r\n  for (let i = 0; i < children.length; i++) {\r\n    const child = children[i]\r\n    if (isVNode(child)) {\r\n      // ignore user comment\r\n      if (child.type !== Comment || child.children === 'v-if') {\r\n        if (singleRoot) {\r\n          // has more than 1 non-comment child, return now\r\n          return\r\n        } else {\r\n          singleRoot = child\r\n          if (\r\n            __DEV__ &&\r\n            recurse &&\r\n            singleRoot.patchFlag > 0 &&\r\n            singleRoot.patchFlag & PatchFlags.DEV_ROOT_FRAGMENT\r\n          ) {\r\n            return filterSingleRoot(singleRoot.children as VNodeArrayChildren)\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      return\r\n    }\r\n  }\r\n  return singleRoot\r\n}\r\n\r\nconst getFunctionalFallthrough = (attrs: Data): Data | undefined => {\r\n  let res: Data | undefined\r\n  for (const key in attrs) {\r\n    if (key === 'class' || key === 'style' || isOn(key)) {\r\n      ;(res || (res = {}))[key] = attrs[key]\r\n    }\r\n  }\r\n  return res\r\n}\r\n\r\nconst filterModelListeners = (attrs: Data, props: NormalizedProps): Data => {\r\n  const res: Data = {}\r\n  for (const key in attrs) {\r\n    if (!isModelListener(key) || !(key.slice(9) in props)) {\r\n      res[key] = attrs[key]\r\n    }\r\n  }\r\n  return res\r\n}\r\n\r\nconst isElementRoot = (vnode: VNode) => {\r\n  return (\r\n    vnode.shapeFlag & (ShapeFlags.COMPONENT | ShapeFlags.ELEMENT) ||\r\n    vnode.type === Comment // potential v-if branch switch\r\n  )\r\n}\r\n\r\nexport function shouldUpdateComponent(\r\n  prevVNode: VNode,\r\n  nextVNode: VNode,\r\n  optimized?: boolean,\r\n): boolean {\r\n  const { props: prevProps, children: prevChildren, component } = prevVNode\r\n  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode\r\n  const emits = component!.emitsOptions\r\n\r\n  // Parent component's render function was hot-updated. Since this may have\r\n  // caused the child component's slots content to have changed, we need to\r\n  // force the child to update as well.\r\n  if (__DEV__ && (prevChildren || nextChildren) && isHmrUpdating) {\r\n    return true\r\n  }\r\n\r\n  // force child update for runtime directive or transition on component vnode.\r\n  if (nextVNode.dirs || nextVNode.transition) {\r\n    return true\r\n  }\r\n\r\n  if (optimized && patchFlag >= 0) {\r\n    if (patchFlag & PatchFlags.DYNAMIC_SLOTS) {\r\n      // slot content that references values that might have changed,\r\n      // e.g. in a v-for\r\n      return true\r\n    }\r\n    if (patchFlag & PatchFlags.FULL_PROPS) {\r\n      if (!prevProps) {\r\n        return !!nextProps\r\n      }\r\n      // presence of this flag indicates props are always non-null\r\n      return hasPropsChanged(prevProps, nextProps!, emits)\r\n    } else if (patchFlag & PatchFlags.PROPS) {\r\n      const dynamicProps = nextVNode.dynamicProps!\r\n      for (let i = 0; i < dynamicProps.length; i++) {\r\n        const key = dynamicProps[i]\r\n        if (\r\n          nextProps![key] !== prevProps![key] &&\r\n          !isEmitListener(emits, key)\r\n        ) {\r\n          return true\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    // this path is only taken by manually written render functions\r\n    // so presence of any children leads to a forced update\r\n    if (prevChildren || nextChildren) {\r\n      if (!nextChildren || !(nextChildren as any).$stable) {\r\n        return true\r\n      }\r\n    }\r\n    if (prevProps === nextProps) {\r\n      return false\r\n    }\r\n    if (!prevProps) {\r\n      return !!nextProps\r\n    }\r\n    if (!nextProps) {\r\n      return true\r\n    }\r\n    return hasPropsChanged(prevProps, nextProps, emits)\r\n  }\r\n\r\n  return false\r\n}\r\n\r\nfunction hasPropsChanged(\r\n  prevProps: Data,\r\n  nextProps: Data,\r\n  emitsOptions: ComponentInternalInstance['emitsOptions'],\r\n): boolean {\r\n  const nextKeys = Object.keys(nextProps)\r\n  if (nextKeys.length !== Object.keys(prevProps).length) {\r\n    return true\r\n  }\r\n  for (let i = 0; i < nextKeys.length; i++) {\r\n    const key = nextKeys[i]\r\n    if (\r\n      nextProps[key] !== prevProps[key] &&\r\n      !isEmitListener(emitsOptions, key)\r\n    ) {\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nexport function updateHOCHostEl(\r\n  { vnode, parent }: ComponentInternalInstance,\r\n  el: typeof vnode.el, // HostNode\r\n) {\r\n  while (parent) {\r\n    const root = parent.subTree\r\n    if (root.suspense && root.suspense.activeBranch === vnode) {\r\n      root.el = vnode.el\r\n    }\r\n    if (root === vnode) {\r\n      ;(vnode = parent.vnode).el = el\r\n      parent = parent.parent\r\n    } else {\r\n      break\r\n    }\r\n  }\r\n}\r\n","import {\r\n  type ComponentOptions,\r\n  type ConcreteComponent,\r\n  currentInstance,\r\n  getComponentName,\r\n} from '../component'\r\nimport { currentRenderingInstance } from '../componentRenderContext'\r\nimport type { Directive } from '../directives'\r\nimport { camelize, capitalize, isString } from '@vue/shared'\r\nimport { warn } from '../warning'\r\nimport type { VNodeTypes } from '../vnode'\r\n\r\nexport const COMPONENTS = 'components'\r\nexport const DIRECTIVES = 'directives'\r\nexport const FILTERS = 'filters'\r\n\r\nexport type AssetTypes = typeof COMPONENTS | typeof DIRECTIVES | typeof FILTERS\r\n\r\n/**\r\n * @private\r\n */\r\nexport function resolveComponent(\r\n  name: string,\r\n  maybeSelfReference?: boolean,\r\n): ConcreteComponent | string {\r\n  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name\r\n}\r\n\r\nexport const NULL_DYNAMIC_COMPONENT = Symbol.for('v-ndc')\r\n\r\n/**\r\n * @private\r\n */\r\nexport function resolveDynamicComponent(component: unknown): VNodeTypes {\r\n  if (isString(component)) {\r\n    return resolveAsset(COMPONENTS, component, false) || component\r\n  } else {\r\n    // invalid types will fallthrough to createVNode and raise warning\r\n    return (component || NULL_DYNAMIC_COMPONENT) as any\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function resolveDirective(name: string): Directive | undefined {\r\n  return resolveAsset(DIRECTIVES, name)\r\n}\r\n\r\n/**\r\n * v2 compat only\r\n * @internal\r\n */\r\nexport function resolveFilter(name: string): Function | undefined {\r\n  return resolveAsset(FILTERS, name)\r\n}\r\n\r\n/**\r\n * @private\r\n * overload 1: components\r\n */\r\nfunction resolveAsset(\r\n  type: typeof COMPONENTS,\r\n  name: string,\r\n  warnMissing?: boolean,\r\n  maybeSelfReference?: boolean,\r\n): ConcreteComponent | undefined\r\n// overload 2: directives\r\nfunction resolveAsset(\r\n  type: typeof DIRECTIVES,\r\n  name: string,\r\n): Directive | undefined\r\n// implementation\r\n// overload 3: filters (compat only)\r\nfunction resolveAsset(type: typeof FILTERS, name: string): Function | undefined\r\n// implementation\r\nfunction resolveAsset(\r\n  type: AssetTypes,\r\n  name: string,\r\n  warnMissing = true,\r\n  maybeSelfReference = false,\r\n) {\r\n  const instance = currentRenderingInstance || currentInstance\r\n  if (instance) {\r\n    const Component = instance.type\r\n\r\n    // explicit self name has highest priority\r\n    if (type === COMPONENTS) {\r\n      const selfName = getComponentName(\r\n        Component,\r\n        false /* do not include inferred name to avoid breaking existing code */,\r\n      )\r\n      if (\r\n        selfName &&\r\n        (selfName === name ||\r\n          selfName === camelize(name) ||\r\n          selfName === capitalize(camelize(name)))\r\n      ) {\r\n        return Component\r\n      }\r\n    }\r\n\r\n    const res =\r\n      // local registration\r\n      // check instance[type] first which is resolved for options API\r\n      resolve(instance[type] || (Component as ComponentOptions)[type], name) ||\r\n      // global registration\r\n      resolve(instance.appContext[type], name)\r\n\r\n    if (!res && maybeSelfReference) {\r\n      // fallback to implicit self-reference\r\n      return Component\r\n    }\r\n\r\n    if (__DEV__ && warnMissing && !res) {\r\n      const extra =\r\n        type === COMPONENTS\r\n          ? `\\nIf this is a native custom element, make sure to exclude it from ` +\r\n            `component resolution via compilerOptions.isCustomElement.`\r\n          : ``\r\n      warn(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`)\r\n    }\r\n\r\n    return res\r\n  } else if (__DEV__) {\r\n    warn(\r\n      `resolve${capitalize(type.slice(0, -1))} ` +\r\n        `can only be used in render() or setup().`,\r\n    )\r\n  }\r\n}\r\n\r\nfunction resolve(registry: Record<string, any> | undefined, name: string) {\r\n  return (\r\n    registry &&\r\n    (registry[name] ||\r\n      registry[camelize(name)] ||\r\n      registry[capitalize(camelize(name))])\r\n  )\r\n}\r\n","import { inject } from '../apiInject'\r\nimport { warn } from '../warning'\r\n\r\nexport const ssrContextKey = Symbol.for('v-scx')\r\n\r\nexport const useSSRContext = <T = Record<string, any>>() => {\r\n  if (!__GLOBAL__) {\r\n    const ctx = inject<T>(ssrContextKey)\r\n    if (!ctx) {\r\n      __DEV__ &&\r\n        warn(\r\n          `Server rendering context not provided. Make sure to only call ` +\r\n            `useSSRContext() conditionally in the server build.`,\r\n        )\r\n    }\r\n    return ctx\r\n  } else if (__DEV__) {\r\n    warn(`useSSRContext() is not supported in the global build.`)\r\n  }\r\n}\r\n","import {\r\n  type ComputedRef,\r\n  type DebuggerOptions,\r\n  type EffectScheduler,\r\n  ReactiveEffect,\r\n  ReactiveFlags,\r\n  type Ref,\r\n  getCurrentScope,\r\n  isReactive,\r\n  isRef,\r\n  isShallow,\r\n} from '@vue/reactivity'\r\nimport { type SchedulerJob, queueJob } from './scheduler'\r\nimport {\r\n  EMPTY_OBJ,\r\n  NOOP,\r\n  extend,\r\n  hasChanged,\r\n  isArray,\r\n  isFunction,\r\n  isMap,\r\n  isObject,\r\n  isPlainObject,\r\n  isSet,\r\n  isString,\r\n  remove,\r\n} from '@vue/shared'\r\nimport {\r\n  type ComponentInternalInstance,\r\n  currentInstance,\r\n  isInSSRComponentSetup,\r\n  setCurrentInstance,\r\n} from './component'\r\nimport {\r\n  ErrorCodes,\r\n  callWithAsyncErrorHandling,\r\n  callWithErrorHandling,\r\n} from './errorHandling'\r\nimport { queuePostRenderEffect } from './renderer'\r\nimport { warn } from './warning'\r\nimport { DeprecationTypes } from './compat/compatConfig'\r\nimport { checkCompatEnabled, isCompatEnabled } from './compat/compatConfig'\r\nimport type { ObjectWatchOptionItem } from './componentOptions'\r\nimport { useSSRContext } from './helpers/useSsrContext'\r\n\r\nexport type WatchEffect = (onCleanup: OnCleanup) => void\r\n\r\nexport type WatchSource<T = any> = Ref<T> | ComputedRef<T> | (() => T)\r\n\r\nexport type WatchCallback<V = any, OV = any> = (\r\n  value: V,\r\n  oldValue: OV,\r\n  onCleanup: OnCleanup,\r\n) => any\r\n\r\ntype MapSources<T, Immediate> = {\r\n  [K in keyof T]: T[K] extends WatchSource<infer V>\r\n    ? Immediate extends true\r\n      ? V | undefined\r\n      : V\r\n    : T[K] extends object\r\n      ? Immediate extends true\r\n        ? T[K] | undefined\r\n        : T[K]\r\n      : never\r\n}\r\n\r\ntype OnCleanup = (cleanupFn: () => void) => void\r\n\r\nexport interface WatchOptionsBase extends DebuggerOptions {\r\n  flush?: 'pre' | 'post' | 'sync'\r\n}\r\n\r\nexport interface WatchOptions<Immediate = boolean> extends WatchOptionsBase {\r\n  immediate?: Immediate\r\n  deep?: boolean\r\n  once?: boolean\r\n}\r\n\r\nexport type WatchStopHandle = () => void\r\n\r\n// Simple effect.\r\nexport function watchEffect(\r\n  effect: WatchEffect,\r\n  options?: WatchOptionsBase,\r\n): WatchStopHandle {\r\n  return doWatch(effect, null, options)\r\n}\r\n\r\nexport function watchPostEffect(\r\n  effect: WatchEffect,\r\n  options?: DebuggerOptions,\r\n) {\r\n  return doWatch(\r\n    effect,\r\n    null,\r\n    __DEV__ ? extend({}, options as any, { flush: 'post' }) : { flush: 'post' },\r\n  )\r\n}\r\n\r\nexport function watchSyncEffect(\r\n  effect: WatchEffect,\r\n  options?: DebuggerOptions,\r\n) {\r\n  return doWatch(\r\n    effect,\r\n    null,\r\n    __DEV__ ? extend({}, options as any, { flush: 'sync' }) : { flush: 'sync' },\r\n  )\r\n}\r\n\r\n// initial value for watchers to trigger on undefined initial values\r\nconst INITIAL_WATCHER_VALUE = {}\r\n\r\ntype MultiWatchSources = (WatchSource<unknown> | object)[]\r\n\r\n// overload: single source + cb\r\nexport function watch<T, Immediate extends Readonly<boolean> = false>(\r\n  source: WatchSource<T>,\r\n  cb: WatchCallback<T, Immediate extends true ? T | undefined : T>,\r\n  options?: WatchOptions<Immediate>,\r\n): WatchStopHandle\r\n\r\n// overload: array of multiple sources + cb\r\nexport function watch<\r\n  T extends MultiWatchSources,\r\n  Immediate extends Readonly<boolean> = false,\r\n>(\r\n  sources: [...T],\r\n  cb: WatchCallback<MapSources<T, false>, MapSources<T, Immediate>>,\r\n  options?: WatchOptions<Immediate>,\r\n): WatchStopHandle\r\n\r\n// overload: multiple sources w/ `as const`\r\n// watch([foo, bar] as const, () => {})\r\n// somehow [...T] breaks when the type is readonly\r\nexport function watch<\r\n  T extends Readonly<MultiWatchSources>,\r\n  Immediate extends Readonly<boolean> = false,\r\n>(\r\n  source: T,\r\n  cb: WatchCallback<MapSources<T, false>, MapSources<T, Immediate>>,\r\n  options?: WatchOptions<Immediate>,\r\n): WatchStopHandle\r\n\r\n// overload: watching reactive object w/ cb\r\nexport function watch<\r\n  T extends object,\r\n  Immediate extends Readonly<boolean> = false,\r\n>(\r\n  source: T,\r\n  cb: WatchCallback<T, Immediate extends true ? T | undefined : T>,\r\n  options?: WatchOptions<Immediate>,\r\n): WatchStopHandle\r\n\r\n// implementation\r\nexport function watch<T = any, Immediate extends Readonly<boolean> = false>(\r\n  source: T | WatchSource<T>,\r\n  cb: any,\r\n  options?: WatchOptions<Immediate>,\r\n): WatchStopHandle {\r\n  if (__DEV__ && !isFunction(cb)) {\r\n    warn(\r\n      `\\`watch(fn, options?)\\` signature has been moved to a separate API. ` +\r\n        `Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only ` +\r\n        `supports \\`watch(source, cb, options?) signature.`,\r\n    )\r\n  }\r\n  return doWatch(source as any, cb, options)\r\n}\r\n\r\nfunction doWatch(\r\n  source: WatchSource | WatchSource[] | WatchEffect | object,\r\n  cb: WatchCallback | null,\r\n  {\r\n    immediate,\r\n    deep,\r\n    flush,\r\n    once,\r\n    onTrack,\r\n    onTrigger,\r\n  }: WatchOptions = EMPTY_OBJ,\r\n): WatchStopHandle {\r\n  if (cb && once) {\r\n    const _cb = cb\r\n    cb = (...args) => {\r\n      _cb(...args)\r\n      unwatch()\r\n    }\r\n  }\r\n\r\n  // TODO remove in 3.5\r\n  if (__DEV__ && deep !== void 0 && typeof deep === 'number') {\r\n    warn(\r\n      `watch() \"deep\" option with number value will be used as watch depth in future versions. ` +\r\n        `Please use a boolean instead to avoid potential breakage.`,\r\n    )\r\n  }\r\n\r\n  if (__DEV__ && !cb) {\r\n    if (immediate !== undefined) {\r\n      warn(\r\n        `watch() \"immediate\" option is only respected when using the ` +\r\n          `watch(source, callback, options?) signature.`,\r\n      )\r\n    }\r\n    if (deep !== undefined) {\r\n      warn(\r\n        `watch() \"deep\" option is only respected when using the ` +\r\n          `watch(source, callback, options?) signature.`,\r\n      )\r\n    }\r\n    if (once !== undefined) {\r\n      warn(\r\n        `watch() \"once\" option is only respected when using the ` +\r\n          `watch(source, callback, options?) signature.`,\r\n      )\r\n    }\r\n  }\r\n\r\n  const warnInvalidSource = (s: unknown) => {\r\n    warn(\r\n      `Invalid watch source: `,\r\n      s,\r\n      `A watch source can only be a getter/effect function, a ref, ` +\r\n        `a reactive object, or an array of these types.`,\r\n    )\r\n  }\r\n\r\n  const instance = currentInstance\r\n  const reactiveGetter = (source: object) =>\r\n    deep === true\r\n      ? source // traverse will happen in wrapped getter below\r\n      : // for deep: false, only traverse root-level properties\r\n        traverse(source, deep === false ? 1 : undefined)\r\n\r\n  let getter: () => any\r\n  let forceTrigger = false\r\n  let isMultiSource = false\r\n\r\n  if (isRef(source)) {\r\n    getter = () => source.value\r\n    forceTrigger = isShallow(source)\r\n  } else if (isReactive(source)) {\r\n    getter = () => reactiveGetter(source)\r\n    forceTrigger = true\r\n  } else if (isArray(source)) {\r\n    isMultiSource = true\r\n    forceTrigger = source.some(s => isReactive(s) || isShallow(s))\r\n    getter = () =>\r\n      source.map(s => {\r\n        if (isRef(s)) {\r\n          return s.value\r\n        } else if (isReactive(s)) {\r\n          return reactiveGetter(s)\r\n        } else if (isFunction(s)) {\r\n          return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER)\r\n        } else {\r\n          __DEV__ && warnInvalidSource(s)\r\n        }\r\n      })\r\n  } else if (isFunction(source)) {\r\n    if (cb) {\r\n      // getter with cb\r\n      getter = () =>\r\n        callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER)\r\n    } else {\r\n      // no cb -> simple effect\r\n      getter = () => {\r\n        if (cleanup) {\r\n          cleanup()\r\n        }\r\n        return callWithAsyncErrorHandling(\r\n          source,\r\n          instance,\r\n          ErrorCodes.WATCH_CALLBACK,\r\n          [onCleanup],\r\n        )\r\n      }\r\n    }\r\n  } else {\r\n    getter = NOOP\r\n    __DEV__ && warnInvalidSource(source)\r\n  }\r\n\r\n  // 2.x array mutation watch compat\r\n  if (__COMPAT__ && cb && !deep) {\r\n    const baseGetter = getter\r\n    getter = () => {\r\n      const val = baseGetter()\r\n      if (\r\n        isArray(val) &&\r\n        checkCompatEnabled(DeprecationTypes.WATCH_ARRAY, instance)\r\n      ) {\r\n        traverse(val)\r\n      }\r\n      return val\r\n    }\r\n  }\r\n\r\n  if (cb && deep) {\r\n    const baseGetter = getter\r\n    getter = () => traverse(baseGetter())\r\n  }\r\n\r\n  let cleanup: (() => void) | undefined\r\n  let onCleanup: OnCleanup = (fn: () => void) => {\r\n    cleanup = effect.onStop = () => {\r\n      callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP)\r\n      cleanup = effect.onStop = undefined\r\n    }\r\n  }\r\n\r\n  // in SSR there is no need to setup an actual effect, and it should be noop\r\n  // unless it's eager or sync flush\r\n  let ssrCleanup: (() => void)[] | undefined\r\n  if (__SSR__ && isInSSRComponentSetup) {\r\n    // we will also not call the invalidate callback (+ runner is not set up)\r\n    onCleanup = NOOP\r\n    if (!cb) {\r\n      getter()\r\n    } else if (immediate) {\r\n      callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [\r\n        getter(),\r\n        isMultiSource ? [] : undefined,\r\n        onCleanup,\r\n      ])\r\n    }\r\n    if (flush === 'sync') {\r\n      const ctx = useSSRContext()!\r\n      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = [])\r\n    } else {\r\n      return NOOP\r\n    }\r\n  }\r\n\r\n  let oldValue: any = isMultiSource\r\n    ? new Array((source as []).length).fill(INITIAL_WATCHER_VALUE)\r\n    : INITIAL_WATCHER_VALUE\r\n  const job: SchedulerJob = () => {\r\n    if (!effect.active || !effect.dirty) {\r\n      return\r\n    }\r\n    if (cb) {\r\n      // watch(source, cb)\r\n      const newValue = effect.run()\r\n      if (\r\n        deep ||\r\n        forceTrigger ||\r\n        (isMultiSource\r\n          ? (newValue as any[]).some((v, i) => hasChanged(v, oldValue[i]))\r\n          : hasChanged(newValue, oldValue)) ||\r\n        (__COMPAT__ &&\r\n          isArray(newValue) &&\r\n          isCompatEnabled(DeprecationTypes.WATCH_ARRAY, instance))\r\n      ) {\r\n        // cleanup before running cb again\r\n        if (cleanup) {\r\n          cleanup()\r\n        }\r\n        callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [\r\n          newValue,\r\n          // pass undefined as the old value when it's changed for the first time\r\n          oldValue === INITIAL_WATCHER_VALUE\r\n            ? undefined\r\n            : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE\r\n              ? []\r\n              : oldValue,\r\n          onCleanup,\r\n        ])\r\n        oldValue = newValue\r\n      }\r\n    } else {\r\n      // watchEffect\r\n      effect.run()\r\n    }\r\n  }\r\n\r\n  // important: mark the job as a watcher callback so that scheduler knows\r\n  // it is allowed to self-trigger (#1727)\r\n  job.allowRecurse = !!cb\r\n\r\n  let scheduler: EffectScheduler\r\n  if (flush === 'sync') {\r\n    scheduler = job as any // the scheduler function gets called directly\r\n  } else if (flush === 'post') {\r\n    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense)\r\n  } else {\r\n    // default: 'pre'\r\n    job.pre = true\r\n    if (instance) job.id = instance.uid\r\n    scheduler = () => queueJob(job)\r\n  }\r\n\r\n  const effect = new ReactiveEffect(getter, NOOP, scheduler)\r\n\r\n  const scope = getCurrentScope()\r\n  const unwatch = () => {\r\n    effect.stop()\r\n    if (scope) {\r\n      remove(scope.effects, effect)\r\n    }\r\n  }\r\n\r\n  if (__DEV__) {\r\n    effect.onTrack = onTrack\r\n    effect.onTrigger = onTrigger\r\n  }\r\n\r\n  // initial run\r\n  if (cb) {\r\n    if (immediate) {\r\n      job()\r\n    } else {\r\n      oldValue = effect.run()\r\n    }\r\n  } else if (flush === 'post') {\r\n    queuePostRenderEffect(\r\n      effect.run.bind(effect),\r\n      instance && instance.suspense,\r\n    )\r\n  } else {\r\n    effect.run()\r\n  }\r\n\r\n  if (__SSR__ && ssrCleanup) ssrCleanup.push(unwatch)\r\n  return unwatch\r\n}\r\n\r\n// this.$watch\r\nexport function instanceWatch(\r\n  this: ComponentInternalInstance,\r\n  source: string | Function,\r\n  value: WatchCallback | ObjectWatchOptionItem,\r\n  options?: WatchOptions,\r\n): WatchStopHandle {\r\n  const publicThis = this.proxy as any\r\n  const getter = isString(source)\r\n    ? source.includes('.')\r\n      ? createPathGetter(publicThis, source)\r\n      : () => publicThis[source]\r\n    : source.bind(publicThis, publicThis)\r\n  let cb\r\n  if (isFunction(value)) {\r\n    cb = value\r\n  } else {\r\n    cb = value.handler as Function\r\n    options = value\r\n  }\r\n  const reset = setCurrentInstance(this)\r\n  const res = doWatch(getter, cb.bind(publicThis), options)\r\n  reset()\r\n  return res\r\n}\r\n\r\nexport function createPathGetter(ctx: any, path: string) {\r\n  const segments = path.split('.')\r\n  return () => {\r\n    let cur = ctx\r\n    for (let i = 0; i < segments.length && cur; i++) {\r\n      cur = cur[segments[i]]\r\n    }\r\n    return cur\r\n  }\r\n}\r\n\r\n/**\r\n * 递归遍历对象的每一个属性\r\n * @param value \r\n * @param depth \r\n * @param currentDepth \r\n * @param seen \r\n * @returns \r\n */\r\nexport function traverse(\r\n  value: unknown,\r\n  depth?: number,\r\n  currentDepth = 0,\r\n  seen?: Set<unknown>,\r\n) {\r\n  if (!isObject(value) || (value as any)[ReactiveFlags.SKIP]) {\r\n    return value\r\n  }\r\n\r\n  if (depth && depth > 0) {\r\n    if (currentDepth >= depth) {\r\n      return value\r\n    }\r\n    currentDepth++\r\n  }\r\n\r\n  seen = seen || new Set()\r\n  if (seen.has(value)) {\r\n    return value\r\n  }\r\n  seen.add(value)\r\n  if (isRef(value)) {\r\n    traverse(value.value, depth, currentDepth, seen)\r\n  } else if (isArray(value)) {\r\n    for (let i = 0; i < value.length; i++) {\r\n      traverse(value[i], depth, currentDepth, seen)\r\n    }\r\n  } else if (isSet(value) || isMap(value)) {\r\n    value.forEach((v: any) => {\r\n      traverse(v, depth, currentDepth, seen)\r\n    })\r\n  } else if (isPlainObject(value)) {\r\n    for (const key in value) {\r\n      traverse(value[key], depth, currentDepth, seen)\r\n    }\r\n  }\r\n  return value\r\n}\r\n","/**\r\nRuntime helper for applying directives to a vnode. Example usage:\r\n\r\nconst comp = resolveComponent('comp')\r\nconst foo = resolveDirective('foo')\r\nconst bar = resolveDirective('bar')\r\n\r\nreturn withDirectives(h(comp), [\r\n  [foo, this.x],\r\n  [bar, this.y]\r\n])\r\n*/\r\n\r\nimport type { VNode } from './vnode'\r\nimport { EMPTY_OBJ, isBuiltInDirective, isFunction } from '@vue/shared'\r\nimport { warn } from './warning'\r\nimport {\r\n  type ComponentInternalInstance,\r\n  type Data,\r\n  getExposeProxy,\r\n} from './component'\r\nimport { currentRenderingInstance } from './componentRenderContext'\r\nimport { ErrorCodes, callWithAsyncErrorHandling } from './errorHandling'\r\nimport type { ComponentPublicInstance } from './componentPublicInstance'\r\nimport { mapCompatDirectiveHook } from './compat/customDirective'\r\nimport { pauseTracking, resetTracking } from '@vue/reactivity'\r\nimport { traverse } from './apiWatch'\r\n\r\nexport interface DirectiveBinding<V = any> {\r\n  instance: ComponentPublicInstance | null\r\n  value: V\r\n  oldValue: V | null\r\n  arg?: string\r\n  modifiers: DirectiveModifiers\r\n  dir: ObjectDirective<any, V>\r\n}\r\n\r\nexport type DirectiveHook<T = any, Prev = VNode<any, T> | null, V = any> = (\r\n  el: T,\r\n  binding: DirectiveBinding<V>,\r\n  vnode: VNode<any, T>,\r\n  prevVNode: Prev,\r\n) => void\r\n\r\nexport type SSRDirectiveHook = (\r\n  binding: DirectiveBinding,\r\n  vnode: VNode,\r\n) => Data | undefined\r\n\r\nexport interface ObjectDirective<T = any, V = any> {\r\n  created?: DirectiveHook<T, null, V>\r\n  beforeMount?: DirectiveHook<T, null, V>\r\n  mounted?: DirectiveHook<T, null, V>\r\n  beforeUpdate?: DirectiveHook<T, VNode<any, T>, V>\r\n  updated?: DirectiveHook<T, VNode<any, T>, V>\r\n  beforeUnmount?: DirectiveHook<T, null, V>\r\n  unmounted?: DirectiveHook<T, null, V>\r\n  getSSRProps?: SSRDirectiveHook\r\n  deep?: boolean\r\n}\r\n\r\nexport type FunctionDirective<T = any, V = any> = DirectiveHook<T, any, V>\r\n\r\nexport type Directive<T = any, V = any> =\r\n  | ObjectDirective<T, V>\r\n  | FunctionDirective<T, V>\r\n\r\nexport type DirectiveModifiers = Record<string, boolean>\r\n\r\nexport function validateDirectiveName(name: string) {\r\n  if (isBuiltInDirective(name)) {\r\n    warn('Do not use built-in directive ids as custom directive id: ' + name)\r\n  }\r\n}\r\n\r\n// Directive, value, argument, modifiers\r\nexport type DirectiveArguments = Array<\r\n  | [Directive | undefined]\r\n  | [Directive | undefined, any]\r\n  | [Directive | undefined, any, string]\r\n  | [Directive | undefined, any, string, DirectiveModifiers]\r\n>\r\n\r\n/**\r\n * Adds directives to a VNode.\r\n */\r\nexport function withDirectives<T extends VNode>(\r\n  vnode: T,\r\n  directives: DirectiveArguments,\r\n): T {\r\n  if (currentRenderingInstance === null) {\r\n    __DEV__ && warn(`withDirectives can only be used inside render functions.`)\r\n    return vnode\r\n  }\r\n  const instance =\r\n    (getExposeProxy(currentRenderingInstance) as ComponentPublicInstance) ||\r\n    currentRenderingInstance.proxy\r\n  const bindings: DirectiveBinding[] = vnode.dirs || (vnode.dirs = [])\r\n  for (let i = 0; i < directives.length; i++) {\r\n    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i]\r\n    if (dir) {\r\n      if (isFunction(dir)) {\r\n        dir = {\r\n          mounted: dir,\r\n          updated: dir,\r\n        } as ObjectDirective\r\n      }\r\n      if (dir.deep) {\r\n        traverse(value)\r\n      }\r\n      bindings.push({\r\n        dir,\r\n        instance,\r\n        value,\r\n        oldValue: void 0,\r\n        arg,\r\n        modifiers,\r\n      })\r\n    }\r\n  }\r\n  return vnode\r\n}\r\n\r\nexport function invokeDirectiveHook(\r\n  vnode: VNode,\r\n  prevVNode: VNode | null,\r\n  instance: ComponentInternalInstance | null,\r\n  name: keyof ObjectDirective,\r\n) {\r\n  const bindings = vnode.dirs!\r\n  const oldBindings = prevVNode && prevVNode.dirs!\r\n  for (let i = 0; i < bindings.length; i++) {\r\n    const binding = bindings[i]\r\n    if (oldBindings) {\r\n      binding.oldValue = oldBindings[i].value\r\n    }\r\n    let hook = binding.dir[name] as DirectiveHook | DirectiveHook[] | undefined\r\n    if (__COMPAT__ && !hook) {\r\n      hook = mapCompatDirectiveHook(name, binding.dir, instance)\r\n    }\r\n    if (hook) {\r\n      // disable tracking inside all lifecycle hooks\r\n      // since they can potentially be called inside effects.\r\n      pauseTracking()\r\n      callWithAsyncErrorHandling(hook, instance, ErrorCodes.DIRECTIVE_HOOK, [\r\n        vnode.el,\r\n        binding,\r\n        vnode,\r\n        prevVNode,\r\n      ])\r\n      resetTracking()\r\n    }\r\n  }\r\n}\r\n","import {\r\n  type Component,\r\n  type ComponentInternalInstance,\r\n  type ComponentOptions,\r\n  type ConcreteComponent,\r\n  currentInstance,\r\n  isInSSRComponentSetup,\r\n} from './component'\r\nimport { isFunction, isObject } from '@vue/shared'\r\nimport type { ComponentPublicInstance } from './componentPublicInstance'\r\nimport { type VNode, createVNode } from './vnode'\r\nimport { defineComponent } from './apiDefineComponent'\r\nimport { warn } from './warning'\r\nimport { ref } from '@vue/reactivity'\r\nimport { ErrorCodes, handleError } from './errorHandling'\r\nimport { isKeepAlive } from './components/KeepAlive'\r\nimport { queueJob } from './scheduler'\r\n\r\nexport type AsyncComponentResolveResult<T = Component> = T | { default: T } // es modules\r\n\r\nexport type AsyncComponentLoader<T = any> = () => Promise<\r\n  AsyncComponentResolveResult<T>\r\n>\r\n\r\nexport interface AsyncComponentOptions<T = any> {\r\n  loader: AsyncComponentLoader<T>\r\n  loadingComponent?: Component\r\n  errorComponent?: Component\r\n  delay?: number\r\n  timeout?: number\r\n  suspensible?: boolean\r\n  onError?: (\r\n    error: Error,\r\n    retry: () => void,\r\n    fail: () => void,\r\n    attempts: number,\r\n  ) => any\r\n}\r\n\r\nexport const isAsyncWrapper = (i: ComponentInternalInstance | VNode): boolean =>\r\n  !!(i.type as ComponentOptions).__asyncLoader\r\n\r\n/*! #__NO_SIDE_EFFECTS__ */\r\nexport function defineAsyncComponent<\r\n  T extends Component = { new (): ComponentPublicInstance },\r\n>(source: AsyncComponentLoader<T> | AsyncComponentOptions<T>): T {\r\n  if (isFunction(source)) {\r\n    source = { loader: source }\r\n  }\r\n\r\n  const {\r\n    loader,\r\n    loadingComponent,\r\n    errorComponent,\r\n    delay = 200,\r\n    timeout, // undefined = never times out\r\n    suspensible = true,\r\n    onError: userOnError,\r\n  } = source\r\n\r\n  let pendingRequest: Promise<ConcreteComponent> | null = null\r\n  let resolvedComp: ConcreteComponent | undefined\r\n\r\n  let retries = 0\r\n  const retry = () => {\r\n    retries++\r\n    pendingRequest = null\r\n    return load()\r\n  }\r\n\r\n  const load = (): Promise<ConcreteComponent> => {\r\n    let thisRequest: Promise<ConcreteComponent>\r\n    return (\r\n      pendingRequest ||\r\n      (thisRequest = pendingRequest =\r\n        loader()\r\n          .catch(err => {\r\n            err = err instanceof Error ? err : new Error(String(err))\r\n            if (userOnError) {\r\n              return new Promise((resolve, reject) => {\r\n                const userRetry = () => resolve(retry())\r\n                const userFail = () => reject(err)\r\n                userOnError(err, userRetry, userFail, retries + 1)\r\n              })\r\n            } else {\r\n              throw err\r\n            }\r\n          })\r\n          .then((comp: any) => {\r\n            if (thisRequest !== pendingRequest && pendingRequest) {\r\n              return pendingRequest\r\n            }\r\n            if (__DEV__ && !comp) {\r\n              warn(\r\n                `Async component loader resolved to undefined. ` +\r\n                  `If you are using retry(), make sure to return its return value.`,\r\n              )\r\n            }\r\n            // interop module default\r\n            if (\r\n              comp &&\r\n              (comp.__esModule || comp[Symbol.toStringTag] === 'Module')\r\n            ) {\r\n              comp = comp.default\r\n            }\r\n            if (__DEV__ && comp && !isObject(comp) && !isFunction(comp)) {\r\n              throw new Error(`Invalid async component load result: ${comp}`)\r\n            }\r\n            resolvedComp = comp\r\n            return comp\r\n          }))\r\n    )\r\n  }\r\n\r\n  return defineComponent({\r\n    name: 'AsyncComponentWrapper',\r\n\r\n    __asyncLoader: load,\r\n\r\n    get __asyncResolved() {\r\n      return resolvedComp\r\n    },\r\n\r\n    setup() {\r\n      const instance = currentInstance!\r\n\r\n      // already resolved\r\n      if (resolvedComp) {\r\n        return () => createInnerComp(resolvedComp!, instance)\r\n      }\r\n\r\n      const onError = (err: Error) => {\r\n        pendingRequest = null\r\n        handleError(\r\n          err,\r\n          instance,\r\n          ErrorCodes.ASYNC_COMPONENT_LOADER,\r\n          !errorComponent /* do not throw in dev if user provided error component */,\r\n        )\r\n      }\r\n\r\n      // suspense-controlled or SSR.\r\n      if (\r\n        (__FEATURE_SUSPENSE__ && suspensible && instance.suspense) ||\r\n        (__SSR__ && isInSSRComponentSetup)\r\n      ) {\r\n        return load()\r\n          .then(comp => {\r\n            return () => createInnerComp(comp, instance)\r\n          })\r\n          .catch(err => {\r\n            onError(err)\r\n            return () =>\r\n              errorComponent\r\n                ? createVNode(errorComponent as ConcreteComponent, {\r\n                    error: err,\r\n                  })\r\n                : null\r\n          })\r\n      }\r\n\r\n      const loaded = ref(false)\r\n      const error = ref()\r\n      const delayed = ref(!!delay)\r\n\r\n      if (delay) {\r\n        setTimeout(() => {\r\n          delayed.value = false\r\n        }, delay)\r\n      }\r\n\r\n      if (timeout != null) {\r\n        setTimeout(() => {\r\n          if (!loaded.value && !error.value) {\r\n            const err = new Error(\r\n              `Async component timed out after ${timeout}ms.`,\r\n            )\r\n            onError(err)\r\n            error.value = err\r\n          }\r\n        }, timeout)\r\n      }\r\n\r\n      load()\r\n        .then(() => {\r\n          loaded.value = true\r\n          if (instance.parent && isKeepAlive(instance.parent.vnode)) {\r\n            // parent is keep-alive, force update so the loaded component's\r\n            // name is taken into account\r\n            instance.parent.effect.dirty = true\r\n            queueJob(instance.parent.update)\r\n          }\r\n        })\r\n        .catch(err => {\r\n          onError(err)\r\n          error.value = err\r\n        })\r\n\r\n      return () => {\r\n        if (loaded.value && resolvedComp) {\r\n          return createInnerComp(resolvedComp, instance)\r\n        } else if (error.value && errorComponent) {\r\n          return createVNode(errorComponent, {\r\n            error: error.value,\r\n          })\r\n        } else if (loadingComponent && !delayed.value) {\r\n          return createVNode(loadingComponent)\r\n        }\r\n      }\r\n    },\r\n  }) as T\r\n}\r\n\r\nfunction createInnerComp(\r\n  comp: ConcreteComponent,\r\n  parent: ComponentInternalInstance,\r\n) {\r\n  const { ref, props, children, ce } = parent.vnode\r\n  const vnode = createVNode(comp, props, children)\r\n  // ensure inner component inherits the async wrapper's ref owner\r\n  vnode.ref = ref\r\n  // pass the custom element callback on to the inner comp\r\n  // and remove it from the async wrapper\r\n  vnode.ce = ce\r\n  delete parent.vnode.ce\r\n\r\n  return vnode\r\n}\r\n","import {\r\n  type ComponentInternalInstance,\r\n  type ComponentOptions,\r\n  type ConcreteComponent,\r\n  type SetupContext,\r\n  currentInstance,\r\n  getComponentName,\r\n  getCurrentInstance,\r\n} from '../component'\r\nimport {\r\n  type VNode,\r\n  type VNodeProps,\r\n  cloneVNode,\r\n  invokeVNodeHook,\r\n  isSameVNodeType,\r\n  isVNode,\r\n} from '../vnode'\r\nimport { warn } from '../warning'\r\nimport {\r\n  injectHook,\r\n  onBeforeUnmount,\r\n  onMounted,\r\n  onUnmounted,\r\n  onUpdated,\r\n} from '../apiLifecycle'\r\nimport {\r\n  ShapeFlags,\r\n  invokeArrayFns,\r\n  isArray,\r\n  isRegExp,\r\n  isString,\r\n  remove,\r\n} from '@vue/shared'\r\nimport { watch } from '../apiWatch'\r\nimport {\r\n  type ElementNamespace,\r\n  MoveType,\r\n  type RendererElement,\r\n  type RendererInternals,\r\n  type RendererNode,\r\n  queuePostRenderEffect,\r\n} from '../renderer'\r\nimport { setTransitionHooks } from './BaseTransition'\r\nimport type { ComponentRenderContext } from '../componentPublicInstance'\r\nimport { devtoolsComponentAdded } from '../devtools'\r\nimport { isAsyncWrapper } from '../apiAsyncComponent'\r\nimport { isSuspense } from './Suspense'\r\nimport { LifecycleHooks } from '../enums'\r\n\r\ntype MatchPattern = string | RegExp | (string | RegExp)[]\r\n\r\nexport interface KeepAliveProps {\r\n  include?: MatchPattern\r\n  exclude?: MatchPattern\r\n  max?: number | string\r\n}\r\n\r\ntype CacheKey = string | number | symbol | ConcreteComponent\r\ntype Cache = Map<CacheKey, VNode>\r\ntype Keys = Set<CacheKey>\r\n\r\nexport interface KeepAliveContext extends ComponentRenderContext {\r\n  renderer: RendererInternals\r\n  activate: (\r\n    vnode: VNode,\r\n    container: RendererElement,\r\n    anchor: RendererNode | null,\r\n    namespace: ElementNamespace,\r\n    optimized: boolean,\r\n  ) => void\r\n  deactivate: (vnode: VNode) => void\r\n}\r\n\r\nexport const isKeepAlive = (vnode: VNode): boolean =>\r\n  (vnode.type as any).__isKeepAlive\r\n\r\nconst KeepAliveImpl: ComponentOptions = {\r\n  name: `KeepAlive`,\r\n\r\n  // Marker for special handling inside the renderer. We are not using a ===\r\n  // check directly on KeepAlive in the renderer, because importing it directly\r\n  // would prevent it from being tree-shaken.\r\n  __isKeepAlive: true,\r\n\r\n  props: {\r\n    include: [String, RegExp, Array],\r\n    exclude: [String, RegExp, Array],\r\n    max: [String, Number],\r\n  },\r\n\r\n  setup(props: KeepAliveProps, { slots }: SetupContext) {\r\n    const instance = getCurrentInstance()!\r\n    // KeepAlive communicates with the instantiated renderer via the\r\n    // ctx where the renderer passes in its internals,\r\n    // and the KeepAlive instance exposes activate/deactivate implementations.\r\n    // The whole point of this is to avoid importing KeepAlive directly in the\r\n    // renderer to facilitate tree-shaking.\r\n    const sharedContext = instance.ctx as KeepAliveContext\r\n\r\n    // if the internal renderer is not registered, it indicates that this is server-side rendering,\r\n    // for KeepAlive, we just need to render its children\r\n    if (__SSR__ && !sharedContext.renderer) {\r\n      return () => {\r\n        const children = slots.default && slots.default()\r\n        return children && children.length === 1 ? children[0] : children\r\n      }\r\n    }\r\n\r\n    const cache: Cache = new Map()\r\n    const keys: Keys = new Set()\r\n    let current: VNode | null = null\r\n\r\n    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n      ;(instance as any).__v_cache = cache\r\n    }\r\n\r\n    const parentSuspense = instance.suspense\r\n\r\n    const {\r\n      renderer: {\r\n        p: patch,\r\n        m: move,\r\n        um: _unmount,\r\n        o: { createElement },\r\n      },\r\n    } = sharedContext\r\n    const storageContainer = createElement('div')\r\n\r\n    sharedContext.activate = (\r\n      vnode,\r\n      container,\r\n      anchor,\r\n      namespace,\r\n      optimized,\r\n    ) => {\r\n      const instance = vnode.component!\r\n      move(vnode, container, anchor, MoveType.ENTER, parentSuspense)\r\n      // in case props have changed\r\n      patch(\r\n        instance.vnode,\r\n        vnode,\r\n        container,\r\n        anchor,\r\n        instance,\r\n        parentSuspense,\r\n        namespace,\r\n        vnode.slotScopeIds,\r\n        optimized,\r\n      )\r\n      queuePostRenderEffect(() => {\r\n        instance.isDeactivated = false\r\n        if (instance.a) {\r\n          invokeArrayFns(instance.a)\r\n        }\r\n        const vnodeHook = vnode.props && vnode.props.onVnodeMounted\r\n        if (vnodeHook) {\r\n          invokeVNodeHook(vnodeHook, instance.parent, vnode)\r\n        }\r\n      }, parentSuspense)\r\n\r\n      if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n        // Update components tree\r\n        devtoolsComponentAdded(instance)\r\n      }\r\n    }\r\n\r\n    sharedContext.deactivate = (vnode: VNode) => {\r\n      const instance = vnode.component!\r\n      move(vnode, storageContainer, null, MoveType.LEAVE, parentSuspense)\r\n      queuePostRenderEffect(() => {\r\n        if (instance.da) {\r\n          invokeArrayFns(instance.da)\r\n        }\r\n        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted\r\n        if (vnodeHook) {\r\n          invokeVNodeHook(vnodeHook, instance.parent, vnode)\r\n        }\r\n        instance.isDeactivated = true\r\n      }, parentSuspense)\r\n\r\n      if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n        // Update components tree\r\n        devtoolsComponentAdded(instance)\r\n      }\r\n    }\r\n\r\n    function unmount(vnode: VNode) {\r\n      // reset the shapeFlag so it can be properly unmounted\r\n      resetShapeFlag(vnode)\r\n      _unmount(vnode, instance, parentSuspense, true)\r\n    }\r\n\r\n    function pruneCache(filter?: (name: string) => boolean) {\r\n      cache.forEach((vnode, key) => {\r\n        const name = getComponentName(vnode.type as ConcreteComponent)\r\n        if (name && (!filter || !filter(name))) {\r\n          pruneCacheEntry(key)\r\n        }\r\n      })\r\n    }\r\n\r\n    function pruneCacheEntry(key: CacheKey) {\r\n      const cached = cache.get(key) as VNode\r\n      if (!current || !isSameVNodeType(cached, current)) {\r\n        unmount(cached)\r\n      } else if (current) {\r\n        // current active instance should no longer be kept-alive.\r\n        // we can't unmount it now but it might be later, so reset its flag now.\r\n        resetShapeFlag(current)\r\n      }\r\n      cache.delete(key)\r\n      keys.delete(key)\r\n    }\r\n\r\n    // prune cache on include/exclude prop change\r\n    watch(\r\n      () => [props.include, props.exclude],\r\n      ([include, exclude]) => {\r\n        include && pruneCache(name => matches(include, name))\r\n        exclude && pruneCache(name => !matches(exclude, name))\r\n      },\r\n      // prune post-render after `current` has been updated\r\n      { flush: 'post', deep: true },\r\n    )\r\n\r\n    // cache sub tree after render\r\n    let pendingCacheKey: CacheKey | null = null\r\n    const cacheSubtree = () => {\r\n      // fix #1621, the pendingCacheKey could be 0\r\n      if (pendingCacheKey != null) {\r\n        cache.set(pendingCacheKey, getInnerChild(instance.subTree))\r\n      }\r\n    }\r\n    onMounted(cacheSubtree)\r\n    onUpdated(cacheSubtree)\r\n\r\n    onBeforeUnmount(() => {\r\n      cache.forEach(cached => {\r\n        const { subTree, suspense } = instance\r\n        const vnode = getInnerChild(subTree)\r\n        if (cached.type === vnode.type && cached.key === vnode.key) {\r\n          // current instance will be unmounted as part of keep-alive's unmount\r\n          resetShapeFlag(vnode)\r\n          // but invoke its deactivated hook here\r\n          const da = vnode.component!.da\r\n          da && queuePostRenderEffect(da, suspense)\r\n          return\r\n        }\r\n        unmount(cached)\r\n      })\r\n    })\r\n\r\n    return () => {\r\n      pendingCacheKey = null\r\n\r\n      if (!slots.default) {\r\n        return null\r\n      }\r\n\r\n      const children = slots.default()\r\n      const rawVNode = children[0]\r\n      if (children.length > 1) {\r\n        if (__DEV__) {\r\n          warn(`KeepAlive should contain exactly one component child.`)\r\n        }\r\n        current = null\r\n        return children\r\n      } else if (\r\n        !isVNode(rawVNode) ||\r\n        (!(rawVNode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT) &&\r\n          !(rawVNode.shapeFlag & ShapeFlags.SUSPENSE))\r\n      ) {\r\n        current = null\r\n        return rawVNode\r\n      }\r\n\r\n      let vnode = getInnerChild(rawVNode)\r\n      const comp = vnode.type as ConcreteComponent\r\n\r\n      // for async components, name check should be based in its loaded\r\n      // inner component if available\r\n      const name = getComponentName(\r\n        isAsyncWrapper(vnode)\r\n          ? (vnode.type as ComponentOptions).__asyncResolved || {}\r\n          : comp,\r\n      )\r\n\r\n      const { include, exclude, max } = props\r\n\r\n      if (\r\n        (include && (!name || !matches(include, name))) ||\r\n        (exclude && name && matches(exclude, name))\r\n      ) {\r\n        current = vnode\r\n        return rawVNode\r\n      }\r\n\r\n      const key = vnode.key == null ? comp : vnode.key\r\n      const cachedVNode = cache.get(key)\r\n\r\n      // clone vnode if it's reused because we are going to mutate it\r\n      if (vnode.el) {\r\n        vnode = cloneVNode(vnode)\r\n        if (rawVNode.shapeFlag & ShapeFlags.SUSPENSE) {\r\n          rawVNode.ssContent = vnode\r\n        }\r\n      }\r\n      // #1513 it's possible for the returned vnode to be cloned due to attr\r\n      // fallthrough or scopeId, so the vnode here may not be the final vnode\r\n      // that is mounted. Instead of caching it directly, we store the pending\r\n      // key and cache `instance.subTree` (the normalized vnode) in\r\n      // beforeMount/beforeUpdate hooks.\r\n      pendingCacheKey = key\r\n\r\n      if (cachedVNode) {\r\n        // copy over mounted state\r\n        vnode.el = cachedVNode.el\r\n        vnode.component = cachedVNode.component\r\n        if (vnode.transition) {\r\n          // recursively update transition hooks on subTree\r\n          setTransitionHooks(vnode, vnode.transition!)\r\n        }\r\n        // avoid vnode being mounted as fresh\r\n        vnode.shapeFlag |= ShapeFlags.COMPONENT_KEPT_ALIVE\r\n        // make this key the freshest\r\n        keys.delete(key)\r\n        keys.add(key)\r\n      } else {\r\n        keys.add(key)\r\n        // prune oldest entry\r\n        if (max && keys.size > parseInt(max as string, 10)) {\r\n          pruneCacheEntry(keys.values().next().value)\r\n        }\r\n      }\r\n      // avoid vnode being unmounted\r\n      vnode.shapeFlag |= ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE\r\n\r\n      current = vnode\r\n      return isSuspense(rawVNode.type) ? rawVNode : vnode\r\n    }\r\n  },\r\n}\r\n\r\nif (__COMPAT__) {\r\n  KeepAliveImpl.__isBuildIn = true\r\n}\r\n\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\nexport const KeepAlive = KeepAliveImpl as any as {\r\n  __isKeepAlive: true\r\n  new (): {\r\n    $props: VNodeProps & KeepAliveProps\r\n    $slots: {\r\n      default(): VNode[]\r\n    }\r\n  }\r\n}\r\n\r\nfunction matches(pattern: MatchPattern, name: string): boolean {\r\n  if (isArray(pattern)) {\r\n    return pattern.some((p: string | RegExp) => matches(p, name))\r\n  } else if (isString(pattern)) {\r\n    return pattern.split(',').includes(name)\r\n  } else if (isRegExp(pattern)) {\r\n    return pattern.test(name)\r\n  }\r\n  /* istanbul ignore next */\r\n  return false\r\n}\r\n\r\nexport function onActivated(\r\n  hook: Function,\r\n  target?: ComponentInternalInstance | null,\r\n) {\r\n  registerKeepAliveHook(hook, LifecycleHooks.ACTIVATED, target)\r\n}\r\n\r\nexport function onDeactivated(\r\n  hook: Function,\r\n  target?: ComponentInternalInstance | null,\r\n) {\r\n  registerKeepAliveHook(hook, LifecycleHooks.DEACTIVATED, target)\r\n}\r\n\r\nfunction registerKeepAliveHook(\r\n  hook: Function & { __wdc?: Function },\r\n  type: LifecycleHooks,\r\n  target: ComponentInternalInstance | null = currentInstance,\r\n) {\r\n  // cache the deactivate branch check wrapper for injected hooks so the same\r\n  // hook can be properly deduped by the scheduler. \"__wdc\" stands for \"with\r\n  // deactivation check\".\r\n  const wrappedHook =\r\n    hook.__wdc ||\r\n    (hook.__wdc = () => {\r\n      // only fire the hook if the target instance is NOT in a deactivated branch.\r\n      let current: ComponentInternalInstance | null = target\r\n      while (current) {\r\n        if (current.isDeactivated) {\r\n          return\r\n        }\r\n        current = current.parent\r\n      }\r\n      return hook()\r\n    })\r\n  injectHook(type, wrappedHook, target)\r\n  // In addition to registering it on the target instance, we walk up the parent\r\n  // chain and register it on all ancestor instances that are keep-alive roots.\r\n  // This avoids the need to walk the entire component tree when invoking these\r\n  // hooks, and more importantly, avoids the need to track child components in\r\n  // arrays.\r\n  if (target) {\r\n    let current = target.parent\r\n    while (current && current.parent) {\r\n      if (isKeepAlive(current.parent.vnode)) {\r\n        injectToKeepAliveRoot(wrappedHook, type, target, current)\r\n      }\r\n      current = current.parent\r\n    }\r\n  }\r\n}\r\n\r\nfunction injectToKeepAliveRoot(\r\n  hook: Function & { __weh?: Function },\r\n  type: LifecycleHooks,\r\n  target: ComponentInternalInstance,\r\n  keepAliveRoot: ComponentInternalInstance,\r\n) {\r\n  // injectHook wraps the original for error handling, so make sure to remove\r\n  // the wrapped version.\r\n  const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */)\r\n  onUnmounted(() => {\r\n    remove(keepAliveRoot[type]!, injected)\r\n  }, target)\r\n}\r\n\r\nfunction resetShapeFlag(vnode: VNode) {\r\n  // bitwise operations to remove keep alive flags\r\n  vnode.shapeFlag &= ~ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE\r\n  vnode.shapeFlag &= ~ShapeFlags.COMPONENT_KEPT_ALIVE\r\n}\r\n\r\nfunction getInnerChild(vnode: VNode) {\r\n  return vnode.shapeFlag & ShapeFlags.SUSPENSE ? vnode.ssContent! : vnode\r\n}\r\n","import {\r\n  type ComponentInternalInstance,\r\n  currentInstance,\r\n  isInSSRComponentSetup,\r\n  setCurrentInstance,\r\n} from './component'\r\nimport type { ComponentPublicInstance } from './componentPublicInstance'\r\nimport { ErrorTypeStrings, callWithAsyncErrorHandling } from './errorHandling'\r\nimport { warn } from './warning'\r\nimport { toHandlerKey } from '@vue/shared'\r\nimport {\r\n  type DebuggerEvent,\r\n  pauseTracking,\r\n  resetTracking,\r\n} from '@vue/reactivity'\r\nimport { LifecycleHooks } from './enums'\r\n\r\nexport { onActivated, onDeactivated } from './components/KeepAlive'\r\n\r\nexport function injectHook(\r\n  type: LifecycleHooks,\r\n  hook: Function & { __weh?: Function },\r\n  target: ComponentInternalInstance | null = currentInstance,\r\n  prepend: boolean = false,\r\n): Function | undefined {\r\n  if (target) {\r\n    const hooks = target[type] || (target[type] = [])\r\n    // cache the error handling wrapper for injected hooks so the same hook\r\n    // can be properly deduped by the scheduler. \"__weh\" stands for \"with error\r\n    // handling\".\r\n    const wrappedHook =\r\n      hook.__weh ||\r\n      (hook.__weh = (...args: unknown[]) => {\r\n        if (target.isUnmounted) {\r\n          return\r\n        }\r\n        // disable tracking inside all lifecycle hooks\r\n        // since they can potentially be called inside effects.\r\n        pauseTracking()\r\n        // Set currentInstance during hook invocation.\r\n        // This assumes the hook does not synchronously trigger other hooks, which\r\n        // can only be false when the user does something really funky.\r\n        const reset = setCurrentInstance(target)\r\n        const res = callWithAsyncErrorHandling(hook, target, type, args)\r\n        reset()\r\n        resetTracking()\r\n        return res\r\n      })\r\n    if (prepend) {\r\n      hooks.unshift(wrappedHook)\r\n    } else {\r\n      hooks.push(wrappedHook)\r\n    }\r\n    return wrappedHook\r\n  } else if (__DEV__) {\r\n    const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ''))\r\n    warn(\r\n      `${apiName} is called when there is no active component instance to be ` +\r\n        `associated with. ` +\r\n        `Lifecycle injection APIs can only be used during execution of setup().` +\r\n        (__FEATURE_SUSPENSE__\r\n          ? ` If you are using async setup(), make sure to register lifecycle ` +\r\n            `hooks before the first await statement.`\r\n          : ``),\r\n    )\r\n  }\r\n}\r\n\r\nexport const createHook =\r\n  <T extends Function = () => any>(lifecycle: LifecycleHooks) =>\r\n  (hook: T, target: ComponentInternalInstance | null = currentInstance) =>\r\n    // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)\r\n    (!isInSSRComponentSetup || lifecycle === LifecycleHooks.SERVER_PREFETCH) &&\r\n    injectHook(lifecycle, (...args: unknown[]) => hook(...args), target)\r\n\r\nexport const onBeforeMount = createHook(LifecycleHooks.BEFORE_MOUNT)\r\nexport const onMounted = createHook(LifecycleHooks.MOUNTED)\r\nexport const onBeforeUpdate = createHook(LifecycleHooks.BEFORE_UPDATE)\r\nexport const onUpdated = createHook(LifecycleHooks.UPDATED)\r\nexport const onBeforeUnmount = createHook(LifecycleHooks.BEFORE_UNMOUNT)\r\nexport const onUnmounted = createHook(LifecycleHooks.UNMOUNTED)\r\nexport const onServerPrefetch = createHook(LifecycleHooks.SERVER_PREFETCH)\r\n\r\nexport type DebuggerHook = (e: DebuggerEvent) => void\r\nexport const onRenderTriggered = createHook<DebuggerHook>(\r\n  LifecycleHooks.RENDER_TRIGGERED,\r\n)\r\nexport const onRenderTracked = createHook<DebuggerHook>(\r\n  LifecycleHooks.RENDER_TRACKED,\r\n)\r\n\r\nexport type ErrorCapturedHook<TError = unknown> = (\r\n  err: TError,\r\n  instance: ComponentPublicInstance | null,\r\n  info: string,\r\n) => boolean | void\r\n\r\nexport function onErrorCaptured<TError = Error>(\r\n  hook: ErrorCapturedHook<TError>,\r\n  target: ComponentInternalInstance | null = currentInstance,\r\n) {\r\n  injectHook(LifecycleHooks.ERROR_CAPTURED, hook, target)\r\n}\r\n","import {\r\n  type ComponentInternalInstance,\r\n  type Data,\r\n  getExposeProxy,\r\n  isStatefulComponent,\r\n} from './component'\r\nimport { nextTick, queueJob } from './scheduler'\r\nimport {\r\n  type WatchOptions,\r\n  type WatchStopHandle,\r\n  instanceWatch,\r\n} from './apiWatch'\r\nimport {\r\n  EMPTY_OBJ,\r\n  type IfAny,\r\n  NOOP,\r\n  type Prettify,\r\n  type UnionToIntersection,\r\n  extend,\r\n  hasOwn,\r\n  isFunction,\r\n  isGloballyAllowed,\r\n  isString,\r\n} from '@vue/shared'\r\nimport {\r\n  type ShallowUnwrapRef,\r\n  TrackOpTypes,\r\n  type UnwrapNestedRefs,\r\n  shallowReadonly,\r\n  toRaw,\r\n  track,\r\n} from '@vue/reactivity'\r\nimport {\r\n  type ComponentInjectOptions,\r\n  type ComponentOptionsBase,\r\n  type ComponentOptionsMixin,\r\n  type ComputedOptions,\r\n  type ExtractComputedReturns,\r\n  type InjectToObject,\r\n  type MergedComponentOptionsOverride,\r\n  type MethodOptions,\r\n  type OptionTypesKeys,\r\n  type OptionTypesType,\r\n  resolveMergedOptions,\r\n  shouldCacheAccess,\r\n} from './componentOptions'\r\nimport type { EmitFn, EmitsOptions } from './componentEmits'\r\nimport type { SlotsType, UnwrapSlotsType } from './componentSlots'\r\nimport { markAttrsAccessed } from './componentRenderUtils'\r\nimport { currentRenderingInstance } from './componentRenderContext'\r\nimport { warn } from './warning'\r\nimport { installCompatInstanceProperties } from './compat/instance'\r\n\r\n/**\r\n * Custom properties added to component instances in any way and can be accessed through `this`\r\n *\r\n * @example\r\n * Here is an example of adding a property `$router` to every component instance:\r\n * ```ts\r\n * import { createApp } from 'vue'\r\n * import { Router, createRouter } from 'vue-router'\r\n *\r\n * declare module '@vue/runtime-core' {\r\n *   interface ComponentCustomProperties {\r\n *     $router: Router\r\n *   }\r\n * }\r\n *\r\n * // effectively adding the router to every component instance\r\n * const app = createApp({})\r\n * const router = createRouter()\r\n * app.config.globalProperties.$router = router\r\n *\r\n * const vm = app.mount('#app')\r\n * // we can access the router from the instance\r\n * vm.$router.push('/')\r\n * ```\r\n */\r\nexport interface ComponentCustomProperties {}\r\n\r\ntype IsDefaultMixinComponent<T> = T extends ComponentOptionsMixin\r\n  ? ComponentOptionsMixin extends T\r\n    ? true\r\n    : false\r\n  : false\r\n\r\ntype MixinToOptionTypes<T> =\r\n  T extends ComponentOptionsBase<\r\n    infer P,\r\n    infer B,\r\n    infer D,\r\n    infer C,\r\n    infer M,\r\n    infer Mixin,\r\n    infer Extends,\r\n    any,\r\n    any,\r\n    infer Defaults,\r\n    any,\r\n    any,\r\n    any\r\n  >\r\n    ? OptionTypesType<P & {}, B & {}, D & {}, C & {}, M & {}, Defaults & {}> &\r\n        IntersectionMixin<Mixin> &\r\n        IntersectionMixin<Extends>\r\n    : never\r\n\r\n// ExtractMixin(map type) is used to resolve circularly references\r\ntype ExtractMixin<T> = {\r\n  Mixin: MixinToOptionTypes<T>\r\n}[T extends ComponentOptionsMixin ? 'Mixin' : never]\r\n\r\nexport type IntersectionMixin<T> =\r\n  IsDefaultMixinComponent<T> extends true\r\n    ? OptionTypesType\r\n    : UnionToIntersection<ExtractMixin<T>>\r\n\r\nexport type UnwrapMixinsType<\r\n  T,\r\n  Type extends OptionTypesKeys,\r\n> = T extends OptionTypesType ? T[Type] : never\r\n\r\ntype EnsureNonVoid<T> = T extends void ? {} : T\r\n\r\nexport type ComponentPublicInstanceConstructor<\r\n  T extends ComponentPublicInstance<\r\n    Props,\r\n    RawBindings,\r\n    D,\r\n    C,\r\n    M\r\n  > = ComponentPublicInstance<any>,\r\n  Props = any,\r\n  RawBindings = any,\r\n  D = any,\r\n  C extends ComputedOptions = ComputedOptions,\r\n  M extends MethodOptions = MethodOptions,\r\n> = {\r\n  __isFragment?: never\r\n  __isTeleport?: never\r\n  __isSuspense?: never\r\n  new (...args: any[]): T\r\n}\r\n\r\nexport type CreateComponentPublicInstance<\r\n  P = {},\r\n  B = {},\r\n  D = {},\r\n  C extends ComputedOptions = {},\r\n  M extends MethodOptions = {},\r\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  E extends EmitsOptions = {},\r\n  PublicProps = P,\r\n  Defaults = {},\r\n  MakeDefaultsOptional extends boolean = false,\r\n  I extends ComponentInjectOptions = {},\r\n  S extends SlotsType = {},\r\n  PublicMixin = IntersectionMixin<Mixin> & IntersectionMixin<Extends>,\r\n  PublicP = UnwrapMixinsType<PublicMixin, 'P'> & EnsureNonVoid<P>,\r\n  PublicB = UnwrapMixinsType<PublicMixin, 'B'> & EnsureNonVoid<B>,\r\n  PublicD = UnwrapMixinsType<PublicMixin, 'D'> & EnsureNonVoid<D>,\r\n  PublicC extends ComputedOptions = UnwrapMixinsType<PublicMixin, 'C'> &\r\n    EnsureNonVoid<C>,\r\n  PublicM extends MethodOptions = UnwrapMixinsType<PublicMixin, 'M'> &\r\n    EnsureNonVoid<M>,\r\n  PublicDefaults = UnwrapMixinsType<PublicMixin, 'Defaults'> &\r\n    EnsureNonVoid<Defaults>,\r\n> = ComponentPublicInstance<\r\n  PublicP,\r\n  PublicB,\r\n  PublicD,\r\n  PublicC,\r\n  PublicM,\r\n  E,\r\n  PublicProps,\r\n  PublicDefaults,\r\n  MakeDefaultsOptional,\r\n  ComponentOptionsBase<\r\n    P,\r\n    B,\r\n    D,\r\n    C,\r\n    M,\r\n    Mixin,\r\n    Extends,\r\n    E,\r\n    string,\r\n    Defaults,\r\n    {},\r\n    string,\r\n    S\r\n  >,\r\n  I,\r\n  S\r\n>\r\n// public properties exposed on the proxy, which is used as the render context\r\n// in templates (as `this` in the render option)\r\nexport type ComponentPublicInstance<\r\n  P = {}, // props type extracted from props option\r\n  B = {}, // raw bindings returned from setup()\r\n  D = {}, // return from data()\r\n  C extends ComputedOptions = {},\r\n  M extends MethodOptions = {},\r\n  E extends EmitsOptions = {},\r\n  PublicProps = P,\r\n  Defaults = {},\r\n  MakeDefaultsOptional extends boolean = false,\r\n  Options = ComponentOptionsBase<any, any, any, any, any, any, any, any, any>,\r\n  I extends ComponentInjectOptions = {},\r\n  S extends SlotsType = {},\r\n> = {\r\n  $: ComponentInternalInstance\r\n  $data: D\r\n  $props: MakeDefaultsOptional extends true\r\n    ? Partial<Defaults> & Omit<Prettify<P> & PublicProps, keyof Defaults>\r\n    : Prettify<P> & PublicProps\r\n  $attrs: Data\r\n  $refs: Data\r\n  $slots: UnwrapSlotsType<S>\r\n  $root: ComponentPublicInstance | null\r\n  $parent: ComponentPublicInstance | null\r\n  $emit: EmitFn<E>\r\n  $el: any\r\n  $options: Options & MergedComponentOptionsOverride\r\n  $forceUpdate: () => void\r\n  $nextTick: typeof nextTick\r\n  $watch<T extends string | ((...args: any) => any)>(\r\n    source: T,\r\n    cb: T extends (...args: any) => infer R\r\n      ? (...args: [R, R]) => any\r\n      : (...args: any) => any,\r\n    options?: WatchOptions,\r\n  ): WatchStopHandle\r\n} & IfAny<P, P, Omit<P, keyof ShallowUnwrapRef<B>>> &\r\n  ShallowUnwrapRef<B> &\r\n  UnwrapNestedRefs<D> &\r\n  ExtractComputedReturns<C> &\r\n  M &\r\n  ComponentCustomProperties &\r\n  InjectToObject<I>\r\n\r\nexport type PublicPropertiesMap = Record<\r\n  string,\r\n  (i: ComponentInternalInstance) => any\r\n>\r\n\r\n/**\r\n * #2437 In Vue 3, functional components do not have a public instance proxy but\r\n * they exist in the internal parent chain. For code that relies on traversing\r\n * public $parent chains, skip functional ones and go to the parent instead.\r\n */\r\nconst getPublicInstance = (\r\n  i: ComponentInternalInstance | null,\r\n): ComponentPublicInstance | ComponentInternalInstance['exposed'] | null => {\r\n  if (!i) return null\r\n  if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy\r\n  return getPublicInstance(i.parent)\r\n}\r\n\r\nexport const publicPropertiesMap: PublicPropertiesMap =\r\n  // Move PURE marker to new line to workaround compiler discarding it\r\n  // due to type annotation\r\n  /*#__PURE__*/ extend(Object.create(null), {\r\n    $: i => i,\r\n    $el: i => i.vnode.el,\r\n    $data: i => i.data,\r\n    $props: i => (__DEV__ ? shallowReadonly(i.props) : i.props),\r\n    $attrs: i => (__DEV__ ? shallowReadonly(i.attrs) : i.attrs),\r\n    $slots: i => (__DEV__ ? shallowReadonly(i.slots) : i.slots),\r\n    $refs: i => (__DEV__ ? shallowReadonly(i.refs) : i.refs),\r\n    $parent: i => getPublicInstance(i.parent),\r\n    $root: i => getPublicInstance(i.root),\r\n    $emit: i => i.emit,\r\n    $options: i => (__FEATURE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),\r\n    $forceUpdate: i =>\r\n      i.f ||\r\n      (i.f = () => {\r\n        i.effect.dirty = true\r\n        queueJob(i.update)\r\n      }),\r\n    $nextTick: i => i.n || (i.n = nextTick.bind(i.proxy!)),\r\n    $watch: i => (__FEATURE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP),\r\n  } as PublicPropertiesMap)\r\n\r\nif (__COMPAT__) {\r\n  installCompatInstanceProperties(publicPropertiesMap)\r\n}\r\n\r\nenum AccessTypes {\r\n  OTHER,\r\n  SETUP,\r\n  DATA,\r\n  PROPS,\r\n  CONTEXT,\r\n}\r\n\r\nexport interface ComponentRenderContext {\r\n  [key: string]: any\r\n  _: ComponentInternalInstance\r\n}\r\n\r\nexport const isReservedPrefix = (key: string) => key === '_' || key === '$'\r\n\r\nconst hasSetupBinding = (state: Data, key: string) =>\r\n  state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key)\r\n\r\n  // 这块代码待解析\r\nexport const PublicInstanceProxyHandlers: ProxyHandler<any> = {\r\n  get({ _: instance }: ComponentRenderContext, key: string) {\r\n    const { ctx, setupState, data, props, accessCache, type, appContext } =\r\n      instance\r\n\r\n    // for internal formatters to know that this is a Vue instance\r\n    if (__DEV__ && key === '__isVue') {\r\n      return true\r\n    }\r\n\r\n    // data / props / ctx\r\n    // This getter gets called for every property access on the render context\r\n    // during render and is a major hotspot. The most expensive part of this\r\n    // is the multiple hasOwn() calls. It's much faster to do a simple property\r\n    // access on a plain object, so we use an accessCache object (with null\r\n    // prototype) to memoize what access type a key corresponds to.\r\n    let normalizedProps\r\n    if (key[0] !== '$') {\r\n      const n = accessCache![key]\r\n      if (n !== undefined) {\r\n        switch (n) {\r\n          case AccessTypes.SETUP:\r\n            return setupState[key]\r\n          case AccessTypes.DATA:\r\n            return data[key]\r\n          case AccessTypes.CONTEXT:\r\n            return ctx[key]\r\n          case AccessTypes.PROPS:\r\n            return props![key]\r\n          // default: just fallthrough\r\n        }\r\n      } else if (hasSetupBinding(setupState, key)) {\r\n        accessCache![key] = AccessTypes.SETUP\r\n        return setupState[key]\r\n      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n        accessCache![key] = AccessTypes.DATA\r\n        return data[key]\r\n      } else if (\r\n        // only cache other properties when instance has declared (thus stable)\r\n        // props\r\n        (normalizedProps = instance.propsOptions[0]) &&\r\n        hasOwn(normalizedProps, key)\r\n      ) {\r\n        accessCache![key] = AccessTypes.PROPS\r\n        return props![key]\r\n      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n        accessCache![key] = AccessTypes.CONTEXT\r\n        return ctx[key]\r\n      } else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) {\r\n        accessCache![key] = AccessTypes.OTHER\r\n      }\r\n    }\r\n\r\n    const publicGetter = publicPropertiesMap[key]\r\n    let cssModule, globalProperties\r\n    // public $xxx properties\r\n    if (publicGetter) {\r\n      if (key === '$attrs') {\r\n        track(instance, TrackOpTypes.GET, key)\r\n        __DEV__ && markAttrsAccessed()\r\n      } else if (__DEV__ && key === '$slots') {\r\n        track(instance, TrackOpTypes.GET, key)\r\n      }\r\n      return publicGetter(instance)\r\n    } else if (\r\n      // css module (injected by vue-loader)\r\n      (cssModule = type.__cssModules) &&\r\n      (cssModule = cssModule[key])\r\n    ) {\r\n      return cssModule\r\n    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n      // user may set custom properties to `this` that start with `$`\r\n      accessCache![key] = AccessTypes.CONTEXT\r\n      return ctx[key]\r\n    } else if (\r\n      // global properties\r\n      ((globalProperties = appContext.config.globalProperties),\r\n      hasOwn(globalProperties, key))\r\n    ) {\r\n      if (__COMPAT__) {\r\n        const desc = Object.getOwnPropertyDescriptor(globalProperties, key)!\r\n        if (desc.get) {\r\n          return desc.get.call(instance.proxy)\r\n        } else {\r\n          const val = globalProperties[key]\r\n          return isFunction(val)\r\n            ? Object.assign(val.bind(instance.proxy), val)\r\n            : val\r\n        }\r\n      } else {\r\n        return globalProperties[key]\r\n      }\r\n    } else if (\r\n      __DEV__ &&\r\n      currentRenderingInstance &&\r\n      (!isString(key) ||\r\n        // #1091 avoid internal isRef/isVNode checks on component instance leading\r\n        // to infinite warning loop\r\n        key.indexOf('__v') !== 0)\r\n    ) {\r\n      if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {\r\n        warn(\r\n          `Property ${JSON.stringify(\r\n            key,\r\n          )} must be accessed via $data because it starts with a reserved ` +\r\n            `character (\"$\" or \"_\") and is not proxied on the render context.`,\r\n        )\r\n      } else if (instance === currentRenderingInstance) {\r\n        warn(\r\n          `Property ${JSON.stringify(key)} was accessed during render ` +\r\n            `but is not defined on instance.`,\r\n        )\r\n      }\r\n    }\r\n  },\r\n\r\n  set(\r\n    { _: instance }: ComponentRenderContext,\r\n    key: string,\r\n    value: any,\r\n  ): boolean {\r\n    const { data, setupState, ctx } = instance\r\n    if (hasSetupBinding(setupState, key)) {\r\n      setupState[key] = value\r\n      return true\r\n    } else if (\r\n      __DEV__ &&\r\n      setupState.__isScriptSetup &&\r\n      hasOwn(setupState, key)\r\n    ) {\r\n      warn(`Cannot mutate <script setup> binding \"${key}\" from Options API.`)\r\n      return false\r\n    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n      data[key] = value\r\n      return true\r\n    } else if (hasOwn(instance.props, key)) {\r\n      __DEV__ && warn(`Attempting to mutate prop \"${key}\". Props are readonly.`)\r\n      return false\r\n    }\r\n    if (key[0] === '$' && key.slice(1) in instance) {\r\n      __DEV__ &&\r\n        warn(\r\n          `Attempting to mutate public property \"${key}\". ` +\r\n            `Properties starting with $ are reserved and readonly.`,\r\n        )\r\n      return false\r\n    } else {\r\n      if (__DEV__ && key in instance.appContext.config.globalProperties) {\r\n        Object.defineProperty(ctx, key, {\r\n          enumerable: true,\r\n          configurable: true,\r\n          value,\r\n        })\r\n      } else {\r\n        ctx[key] = value\r\n      }\r\n    }\r\n    return true\r\n  },\r\n\r\n  has(\r\n    {\r\n      _: { data, setupState, accessCache, ctx, appContext, propsOptions },\r\n    }: ComponentRenderContext,\r\n    key: string,\r\n  ) {\r\n    let normalizedProps\r\n    return (\r\n      !!accessCache![key] ||\r\n      (data !== EMPTY_OBJ && hasOwn(data, key)) ||\r\n      hasSetupBinding(setupState, key) ||\r\n      ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||\r\n      hasOwn(ctx, key) ||\r\n      hasOwn(publicPropertiesMap, key) ||\r\n      hasOwn(appContext.config.globalProperties, key)\r\n    )\r\n  },\r\n\r\n  defineProperty(\r\n    target: ComponentRenderContext,\r\n    key: string,\r\n    descriptor: PropertyDescriptor,\r\n  ) {\r\n    if (descriptor.get != null) {\r\n      // invalidate key cache of a getter based property #5417\r\n      target._.accessCache![key] = 0\r\n    } else if (hasOwn(descriptor, 'value')) {\r\n      this.set!(target, key, descriptor.value, null)\r\n    }\r\n    return Reflect.defineProperty(target, key, descriptor)\r\n  },\r\n}\r\n\r\nif (__DEV__ && !__TEST__) {\r\n  PublicInstanceProxyHandlers.ownKeys = (target: ComponentRenderContext) => {\r\n    warn(\r\n      `Avoid app logic that relies on enumerating keys on a component instance. ` +\r\n        `The keys will be empty in production mode to avoid performance overhead.`,\r\n    )\r\n    return Reflect.ownKeys(target)\r\n  }\r\n}\r\n\r\nexport const RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/ extend(\r\n  {},\r\n  PublicInstanceProxyHandlers,\r\n  {\r\n    get(target: ComponentRenderContext, key: string) {\r\n      // fast path for unscopables when using `with` block\r\n      if ((key as any) === Symbol.unscopables) {\r\n        return\r\n      }\r\n      return PublicInstanceProxyHandlers.get!(target, key, target)\r\n    },\r\n    has(_: ComponentRenderContext, key: string) {\r\n      const has = key[0] !== '_' && !isGloballyAllowed(key)\r\n      if (__DEV__ && !has && PublicInstanceProxyHandlers.has!(_, key)) {\r\n        warn(\r\n          `Property ${JSON.stringify(\r\n            key,\r\n          )} should not start with _ which is a reserved prefix for Vue internals.`,\r\n        )\r\n      }\r\n      return has\r\n    },\r\n  },\r\n)\r\n\r\n// dev only\r\n// In dev mode, the proxy target exposes the same properties as seen on `this`\r\n// for easier console inspection. In prod mode it will be an empty object so\r\n// these properties definitions can be skipped.\r\nexport function createDevRenderContext(instance: ComponentInternalInstance) {\r\n  const target: Record<string, any> = {}\r\n\r\n  // expose internal instance for proxy handlers\r\n  Object.defineProperty(target, `_`, {\r\n    configurable: true,\r\n    enumerable: false,\r\n    get: () => instance,\r\n  })\r\n\r\n  // expose public properties\r\n  Object.keys(publicPropertiesMap).forEach(key => {\r\n    Object.defineProperty(target, key, {\r\n      configurable: true,\r\n      enumerable: false,\r\n      get: () => publicPropertiesMap[key](instance),\r\n      // intercepted by the proxy so no need for implementation,\r\n      // but needed to prevent set errors\r\n      set: NOOP,\r\n    })\r\n  })\r\n\r\n  return target as ComponentRenderContext\r\n}\r\n\r\n// dev only\r\nexport function exposePropsOnRenderContext(\r\n  instance: ComponentInternalInstance,\r\n) {\r\n  const {\r\n    ctx,\r\n    propsOptions: [propsOptions],\r\n  } = instance\r\n  if (propsOptions) {\r\n    Object.keys(propsOptions).forEach(key => {\r\n      Object.defineProperty(ctx, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: () => instance.props[key],\r\n        set: NOOP,\r\n      })\r\n    })\r\n  }\r\n}\r\n\r\n// dev only\r\nexport function exposeSetupStateOnRenderContext(\r\n  instance: ComponentInternalInstance,\r\n) {\r\n  const { ctx, setupState } = instance\r\n  Object.keys(toRaw(setupState)).forEach(key => {\r\n    if (!setupState.__isScriptSetup) {\r\n      if (isReservedPrefix(key[0])) {\r\n        warn(\r\n          `setup() return property ${JSON.stringify(\r\n            key,\r\n          )} should not start with \"$\" or \"_\" ` +\r\n            `which are reserved prefixes for Vue internals.`,\r\n        )\r\n        return\r\n      }\r\n      Object.defineProperty(ctx, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: () => setupState[key],\r\n        set: NOOP,\r\n      })\r\n    }\r\n  })\r\n}\r\n","import {\r\n  type LooseRequired,\r\n  type Prettify,\r\n  type UnionToIntersection,\r\n  extend,\r\n  isArray,\r\n  isFunction,\r\n  isPromise,\r\n} from '@vue/shared'\r\nimport {\r\n  type SetupContext,\r\n  createSetupContext,\r\n  getCurrentInstance,\r\n  setCurrentInstance,\r\n  unsetCurrentInstance,\r\n} from './component'\r\nimport type { EmitFn, EmitsOptions, ObjectEmitsOptions } from './componentEmits'\r\nimport type {\r\n  ComponentOptionsMixin,\r\n  ComponentOptionsWithoutProps,\r\n  ComputedOptions,\r\n  MethodOptions,\r\n} from './componentOptions'\r\nimport type {\r\n  ComponentObjectPropsOptions,\r\n  ComponentPropsOptions,\r\n  ExtractPropTypes,\r\n  PropOptions,\r\n} from './componentProps'\r\nimport { warn } from './warning'\r\nimport type { SlotsType, StrictUnwrapSlotsType } from './componentSlots'\r\nimport type { Ref } from '@vue/reactivity'\r\n\r\n// dev only\r\nconst warnRuntimeUsage = (method: string) =>\r\n  warn(\r\n    `${method}() is a compiler-hint helper that is only usable inside ` +\r\n      `<script setup> of a single file component. Its arguments should be ` +\r\n      `compiled away and passing it at runtime has no effect.`,\r\n  )\r\n\r\n/**\r\n * Vue `<script setup>` compiler macro for declaring component props. The\r\n * expected argument is the same as the component `props` option.\r\n *\r\n * Example runtime declaration:\r\n * ```js\r\n * // using Array syntax\r\n * const props = defineProps(['foo', 'bar'])\r\n * // using Object syntax\r\n * const props = defineProps({\r\n *   foo: String,\r\n *   bar: {\r\n *     type: Number,\r\n *     required: true\r\n *   }\r\n * })\r\n * ```\r\n *\r\n * Equivalent type-based declaration:\r\n * ```ts\r\n * // will be compiled into equivalent runtime declarations\r\n * const props = defineProps<{\r\n *   foo?: string\r\n *   bar: number\r\n * }>()\r\n * ```\r\n *\r\n * @see {@link https://vuejs.org/api/sfc-script-setup.html#defineprops-defineemits}\r\n *\r\n * This is only usable inside `<script setup>`, is compiled away in the\r\n * output and should **not** be actually called at runtime.\r\n */\r\n// overload 1: runtime props w/ array\r\nexport function defineProps<PropNames extends string = string>(\r\n  props: PropNames[],\r\n): Prettify<Readonly<{ [key in PropNames]?: any }>>\r\n// overload 2: runtime props w/ object\r\nexport function defineProps<\r\n  PP extends ComponentObjectPropsOptions = ComponentObjectPropsOptions,\r\n>(props: PP): Prettify<Readonly<ExtractPropTypes<PP>>>\r\n// overload 3: typed-based declaration\r\nexport function defineProps<TypeProps>(): DefineProps<\r\n  LooseRequired<TypeProps>,\r\n  BooleanKey<TypeProps>\r\n>\r\n// implementation\r\nexport function defineProps() {\r\n  if (__DEV__) {\r\n    warnRuntimeUsage(`defineProps`)\r\n  }\r\n  return null as any\r\n}\r\n\r\nexport type DefineProps<T, BKeys extends keyof T> = Readonly<T> & {\r\n  readonly [K in BKeys]-?: boolean\r\n}\r\n\r\ntype BooleanKey<T, K extends keyof T = keyof T> = K extends any\r\n  ? [T[K]] extends [boolean | undefined]\r\n    ? K\r\n    : never\r\n  : never\r\n\r\n/**\r\n * Vue `<script setup>` compiler macro for declaring a component's emitted\r\n * events. The expected argument is the same as the component `emits` option.\r\n *\r\n * Example runtime declaration:\r\n * ```js\r\n * const emit = defineEmits(['change', 'update'])\r\n * ```\r\n *\r\n * Example type-based declaration:\r\n * ```ts\r\n * const emit = defineEmits<{\r\n *   // <eventName>: <expected arguments>\r\n *   change: []\r\n *   update: [value: string] // named tuple syntax\r\n * }>()\r\n *\r\n * emit('change')\r\n * emit('update', 1)\r\n * ```\r\n *\r\n * This is only usable inside `<script setup>`, is compiled away in the\r\n * output and should **not** be actually called at runtime.\r\n *\r\n * @see {@link https://vuejs.org/api/sfc-script-setup.html#defineprops-defineemits}\r\n */\r\n// overload 1: runtime emits w/ array\r\nexport function defineEmits<EE extends string = string>(\r\n  emitOptions: EE[],\r\n): EmitFn<EE[]>\r\nexport function defineEmits<E extends EmitsOptions = EmitsOptions>(\r\n  emitOptions: E,\r\n): EmitFn<E>\r\nexport function defineEmits<\r\n  T extends ((...args: any[]) => any) | Record<string, any[]>,\r\n>(): T extends (...args: any[]) => any ? T : ShortEmits<T>\r\n// implementation\r\nexport function defineEmits() {\r\n  if (__DEV__) {\r\n    warnRuntimeUsage(`defineEmits`)\r\n  }\r\n  return null as any\r\n}\r\n\r\ntype RecordToUnion<T extends Record<string, any>> = T[keyof T]\r\n\r\ntype ShortEmits<T extends Record<string, any>> = UnionToIntersection<\r\n  RecordToUnion<{\r\n    [K in keyof T]: (evt: K, ...args: T[K]) => void\r\n  }>\r\n>\r\n\r\n/**\r\n * Vue `<script setup>` compiler macro for declaring a component's exposed\r\n * instance properties when it is accessed by a parent component via template\r\n * refs.\r\n *\r\n * `<script setup>` components are closed by default - i.e. variables inside\r\n * the `<script setup>` scope is not exposed to parent unless explicitly exposed\r\n * via `defineExpose`.\r\n *\r\n * This is only usable inside `<script setup>`, is compiled away in the\r\n * output and should **not** be actually called at runtime.\r\n *\r\n * @see {@link https://vuejs.org/api/sfc-script-setup.html#defineexpose}\r\n */\r\nexport function defineExpose<\r\n  Exposed extends Record<string, any> = Record<string, any>,\r\n>(exposed?: Exposed) {\r\n  if (__DEV__) {\r\n    warnRuntimeUsage(`defineExpose`)\r\n  }\r\n}\r\n\r\n/**\r\n * Vue `<script setup>` compiler macro for declaring a component's additional\r\n * options. This should be used only for options that cannot be expressed via\r\n * Composition API - e.g. `inheritAttrs`.\r\n *\r\n * @see {@link https://vuejs.org/api/sfc-script-setup.html#defineoptions}\r\n */\r\nexport function defineOptions<\r\n  RawBindings = {},\r\n  D = {},\r\n  C extends ComputedOptions = {},\r\n  M extends MethodOptions = {},\r\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n>(\r\n  options?: ComponentOptionsWithoutProps<\r\n    {},\r\n    RawBindings,\r\n    D,\r\n    C,\r\n    M,\r\n    Mixin,\r\n    Extends\r\n  > & { emits?: undefined; expose?: undefined; slots?: undefined },\r\n): void {\r\n  if (__DEV__) {\r\n    warnRuntimeUsage(`defineOptions`)\r\n  }\r\n}\r\n\r\nexport function defineSlots<\r\n  S extends Record<string, any> = Record<string, any>,\r\n>(): StrictUnwrapSlotsType<SlotsType<S>> {\r\n  if (__DEV__) {\r\n    warnRuntimeUsage(`defineSlots`)\r\n  }\r\n  return null as any\r\n}\r\n\r\nexport type ModelRef<T, M extends string | number | symbol = string> = Ref<T> &\r\n  [ModelRef<T, M>, Record<M, true | undefined>]\r\n\r\nexport type DefineModelOptions<T = any> = {\r\n  get?: (v: T) => any\r\n  set?: (v: T) => any\r\n}\r\n\r\n/**\r\n * Vue `<script setup>` compiler macro for declaring a\r\n * two-way binding prop that can be consumed via `v-model` from the parent\r\n * component. This will declare a prop with the same name and a corresponding\r\n * `update:propName` event.\r\n *\r\n * If the first argument is a string, it will be used as the prop name;\r\n * Otherwise the prop name will default to \"modelValue\". In both cases, you\r\n * can also pass an additional object which will be used as the prop's options.\r\n *\r\n * The the returned ref behaves differently depending on whether the parent\r\n * provided the corresponding v-model props or not:\r\n * - If yes, the returned ref's value will always be in sync with the parent\r\n *   prop.\r\n * - If not, the returned ref will behave like a normal local ref.\r\n *\r\n * @example\r\n * ```ts\r\n * // default model (consumed via `v-model`)\r\n * const modelValue = defineModel<string>()\r\n * modelValue.value = \"hello\"\r\n *\r\n * // default model with options\r\n * const modelValue = defineModel<string>({ required: true })\r\n *\r\n * // with specified name (consumed via `v-model:count`)\r\n * const count = defineModel<number>('count')\r\n * count.value++\r\n *\r\n * // with specified name and default value\r\n * const count = defineModel<number>('count', { default: 0 })\r\n * ```\r\n */\r\nexport function defineModel<T, M extends string | number | symbol = string>(\r\n  options: { required: true } & PropOptions<T> & DefineModelOptions<T>,\r\n): ModelRef<T, M>\r\nexport function defineModel<T, M extends string | number | symbol = string>(\r\n  options: { default: any } & PropOptions<T> & DefineModelOptions<T>,\r\n): ModelRef<T, M>\r\nexport function defineModel<T, M extends string | number | symbol = string>(\r\n  options?: PropOptions<T> & DefineModelOptions<T>,\r\n): ModelRef<T | undefined, M>\r\nexport function defineModel<T, M extends string | number | symbol = string>(\r\n  name: string,\r\n  options: { required: true } & PropOptions<T> & DefineModelOptions<T>,\r\n): ModelRef<T, M>\r\nexport function defineModel<T, M extends string | number | symbol = string>(\r\n  name: string,\r\n  options: { default: any } & PropOptions<T> & DefineModelOptions<T>,\r\n): ModelRef<T, M>\r\nexport function defineModel<T, M extends string | number | symbol = string>(\r\n  name: string,\r\n  options?: PropOptions<T> & DefineModelOptions<T>,\r\n): ModelRef<T | undefined, M>\r\nexport function defineModel(): any {\r\n  if (__DEV__) {\r\n    warnRuntimeUsage('defineModel')\r\n  }\r\n}\r\n\r\ntype NotUndefined<T> = T extends undefined ? never : T\r\n\r\ntype InferDefaults<T> = {\r\n  [K in keyof T]?: InferDefault<T, T[K]>\r\n}\r\n\r\ntype NativeType = null | number | string | boolean | symbol | Function\r\n\r\ntype InferDefault<P, T> =\r\n  | ((props: P) => T & {})\r\n  | (T extends NativeType ? T : never)\r\n\r\ntype PropsWithDefaults<\r\n  T,\r\n  Defaults extends InferDefaults<T>,\r\n  BKeys extends keyof T,\r\n> = Readonly<Omit<T, keyof Defaults>> & {\r\n  readonly [K in keyof Defaults]-?: K extends keyof T\r\n    ? Defaults[K] extends undefined\r\n      ? T[K]\r\n      : NotUndefined<T[K]>\r\n    : never\r\n} & {\r\n  readonly [K in BKeys]-?: K extends keyof Defaults\r\n    ? Defaults[K] extends undefined\r\n      ? boolean | undefined\r\n      : boolean\r\n    : boolean\r\n}\r\n\r\n/**\r\n * Vue `<script setup>` compiler macro for providing props default values when\r\n * using type-based `defineProps` declaration.\r\n *\r\n * Example usage:\r\n * ```ts\r\n * withDefaults(defineProps<{\r\n *   size?: number\r\n *   labels?: string[]\r\n * }>(), {\r\n *   size: 3,\r\n *   labels: () => ['default label']\r\n * })\r\n * ```\r\n *\r\n * This is only usable inside `<script setup>`, is compiled away in the output\r\n * and should **not** be actually called at runtime.\r\n *\r\n * @see {@link https://vuejs.org/guide/typescript/composition-api.html#typing-component-props}\r\n */\r\nexport function withDefaults<\r\n  T,\r\n  BKeys extends keyof T,\r\n  Defaults extends InferDefaults<T>,\r\n>(\r\n  props: DefineProps<T, BKeys>,\r\n  defaults: Defaults,\r\n): PropsWithDefaults<T, Defaults, BKeys> {\r\n  if (__DEV__) {\r\n    warnRuntimeUsage(`withDefaults`)\r\n  }\r\n  return null as any\r\n}\r\n\r\nexport function useSlots(): SetupContext['slots'] {\r\n  return getContext().slots\r\n}\r\n\r\nexport function useAttrs(): SetupContext['attrs'] {\r\n  return getContext().attrs\r\n}\r\n\r\nfunction getContext(): SetupContext {\r\n  const i = getCurrentInstance()!\r\n  if (__DEV__ && !i) {\r\n    warn(`useContext() called without active instance.`)\r\n  }\r\n  return i.setupContext || (i.setupContext = createSetupContext(i))\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function normalizePropsOrEmits(\r\n  props: ComponentPropsOptions | EmitsOptions,\r\n) {\r\n  return isArray(props)\r\n    ? props.reduce(\r\n        (normalized, p) => ((normalized[p] = null), normalized),\r\n        {} as ComponentObjectPropsOptions | ObjectEmitsOptions,\r\n      )\r\n    : props\r\n}\r\n\r\n/**\r\n * Runtime helper for merging default declarations. Imported by compiled code\r\n * only.\r\n * @internal\r\n */\r\nexport function mergeDefaults(\r\n  raw: ComponentPropsOptions,\r\n  defaults: Record<string, any>,\r\n): ComponentObjectPropsOptions {\r\n  const props = normalizePropsOrEmits(raw)\r\n  for (const key in defaults) {\r\n    if (key.startsWith('__skip')) continue\r\n    let opt = props[key]\r\n    if (opt) {\r\n      if (isArray(opt) || isFunction(opt)) {\r\n        opt = props[key] = { type: opt, default: defaults[key] }\r\n      } else {\r\n        opt.default = defaults[key]\r\n      }\r\n    } else if (opt === null) {\r\n      opt = props[key] = { default: defaults[key] }\r\n    } else if (__DEV__) {\r\n      warn(`props default key \"${key}\" has no corresponding declaration.`)\r\n    }\r\n    if (opt && defaults[`__skip_${key}`]) {\r\n      opt.skipFactory = true\r\n    }\r\n  }\r\n  return props\r\n}\r\n\r\n/**\r\n * Runtime helper for merging model declarations.\r\n * Imported by compiled code only.\r\n * @internal\r\n */\r\nexport function mergeModels(\r\n  a: ComponentPropsOptions | EmitsOptions,\r\n  b: ComponentPropsOptions | EmitsOptions,\r\n) {\r\n  if (!a || !b) return a || b\r\n  if (isArray(a) && isArray(b)) return a.concat(b)\r\n  return extend({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b))\r\n}\r\n\r\n/**\r\n * Used to create a proxy for the rest element when destructuring props with\r\n * defineProps().\r\n * @internal\r\n */\r\nexport function createPropsRestProxy(\r\n  props: any,\r\n  excludedKeys: string[],\r\n): Record<string, any> {\r\n  const ret: Record<string, any> = {}\r\n  for (const key in props) {\r\n    if (!excludedKeys.includes(key)) {\r\n      Object.defineProperty(ret, key, {\r\n        enumerable: true,\r\n        get: () => props[key],\r\n      })\r\n    }\r\n  }\r\n  return ret\r\n}\r\n\r\n/**\r\n * `<script setup>` helper for persisting the current instance context over\r\n * async/await flows.\r\n *\r\n * `@vue/compiler-sfc` converts the following:\r\n *\r\n * ```ts\r\n * const x = await foo()\r\n * ```\r\n *\r\n * into:\r\n *\r\n * ```ts\r\n * let __temp, __restore\r\n * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)\r\n * ```\r\n * @internal\r\n */\r\nexport function withAsyncContext(getAwaitable: () => any) {\r\n  const ctx = getCurrentInstance()!\r\n  if (__DEV__ && !ctx) {\r\n    warn(\r\n      `withAsyncContext called without active current instance. ` +\r\n        `This is likely a bug.`,\r\n    )\r\n  }\r\n  let awaitable = getAwaitable()\r\n  unsetCurrentInstance()\r\n  if (isPromise(awaitable)) {\r\n    awaitable = awaitable.catch(e => {\r\n      setCurrentInstance(ctx)\r\n      throw e\r\n    })\r\n  }\r\n  return [awaitable, () => setCurrentInstance(ctx)]\r\n}\r\n","import type {\r\n  Component,\r\n  ComponentInternalInstance,\r\n  ComponentInternalOptions,\r\n  ConcreteComponent,\r\n  Data,\r\n  InternalRenderFunction,\r\n  SetupContext,\r\n} from './component'\r\nimport {\r\n  type LooseRequired,\r\n  NOOP,\r\n  type Prettify,\r\n  extend,\r\n  isArray,\r\n  isFunction,\r\n  isObject,\r\n  isPromise,\r\n  isString,\r\n} from '@vue/shared'\r\nimport { type Ref, isRef } from '@vue/reactivity'\r\nimport { computed } from './apiComputed'\r\nimport {\r\n  type WatchCallback,\r\n  type WatchOptions,\r\n  createPathGetter,\r\n  watch,\r\n} from './apiWatch'\r\nimport { inject, provide } from './apiInject'\r\nimport {\r\n  type DebuggerHook,\r\n  type ErrorCapturedHook,\r\n  onActivated,\r\n  onBeforeMount,\r\n  onBeforeUnmount,\r\n  onBeforeUpdate,\r\n  onDeactivated,\r\n  onErrorCaptured,\r\n  onMounted,\r\n  onRenderTracked,\r\n  onRenderTriggered,\r\n  onServerPrefetch,\r\n  onUnmounted,\r\n  onUpdated,\r\n} from './apiLifecycle'\r\nimport {\r\n  type ComputedGetter,\r\n  type WritableComputedOptions,\r\n  reactive,\r\n} from '@vue/reactivity'\r\nimport type {\r\n  ComponentObjectPropsOptions,\r\n  ComponentPropsOptions,\r\n  ExtractDefaultPropTypes,\r\n  ExtractPropTypes,\r\n} from './componentProps'\r\nimport type { EmitsOptions, EmitsToProps } from './componentEmits'\r\nimport type { Directive } from './directives'\r\nimport {\r\n  type ComponentPublicInstance,\r\n  type CreateComponentPublicInstance,\r\n  type IntersectionMixin,\r\n  type UnwrapMixinsType,\r\n  isReservedPrefix,\r\n} from './componentPublicInstance'\r\nimport { warn } from './warning'\r\nimport type { VNodeChild } from './vnode'\r\nimport { callWithAsyncErrorHandling } from './errorHandling'\r\nimport { deepMergeData } from './compat/data'\r\nimport { DeprecationTypes } from './compat/compatConfig'\r\nimport {\r\n  type CompatConfig,\r\n  isCompatEnabled,\r\n  softAssertCompatEnabled,\r\n} from './compat/compatConfig'\r\nimport type { OptionMergeFunction } from './apiCreateApp'\r\nimport { LifecycleHooks } from './enums'\r\nimport type { SlotsType } from './componentSlots'\r\nimport { normalizePropsOrEmits } from './apiSetupHelpers'\r\n\r\n/**\r\n * Interface for declaring custom options.\r\n *\r\n * @example\r\n * ```ts\r\n * declare module '@vue/runtime-core' {\r\n *   interface ComponentCustomOptions {\r\n *     beforeRouteUpdate?(\r\n *       to: Route,\r\n *       from: Route,\r\n *       next: () => void\r\n *     ): void\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport interface ComponentCustomOptions {}\r\n\r\nexport type RenderFunction = () => VNodeChild\r\n\r\nexport interface ComponentOptionsBase<\r\n  Props,\r\n  RawBindings,\r\n  D,\r\n  C extends ComputedOptions,\r\n  M extends MethodOptions,\r\n  Mixin extends ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin,\r\n  E extends EmitsOptions,\r\n  EE extends string = string,\r\n  Defaults = {},\r\n  I extends ComponentInjectOptions = {},\r\n  II extends string = string,\r\n  S extends SlotsType = {},\r\n> extends LegacyOptions<Props, D, C, M, Mixin, Extends, I, II>,\r\n    ComponentInternalOptions,\r\n    ComponentCustomOptions {\r\n  setup?: (\r\n    this: void,\r\n    props: LooseRequired<\r\n      Props &\r\n        Prettify<\r\n          UnwrapMixinsType<\r\n            IntersectionMixin<Mixin> & IntersectionMixin<Extends>,\r\n            'P'\r\n          >\r\n        >\r\n    >,\r\n    ctx: SetupContext<E, S>,\r\n  ) => Promise<RawBindings> | RawBindings | RenderFunction | void\r\n  name?: string\r\n  template?: string | object // can be a direct DOM node\r\n  // Note: we are intentionally using the signature-less `Function` type here\r\n  // since any type with signature will cause the whole inference to fail when\r\n  // the return expression contains reference to `this`.\r\n  // Luckily `render()` doesn't need any arguments nor does it care about return\r\n  // type.\r\n  render?: Function\r\n  components?: Record<string, Component>\r\n  directives?: Record<string, Directive>\r\n  inheritAttrs?: boolean\r\n  emits?: (E | EE[]) & ThisType<void>\r\n  slots?: S\r\n  // TODO infer public instance type based on exposed keys\r\n  expose?: string[]\r\n  serverPrefetch?(): void | Promise<any>\r\n\r\n  // Runtime compiler only -----------------------------------------------------\r\n  compilerOptions?: RuntimeCompilerOptions\r\n\r\n  // Internal ------------------------------------------------------------------\r\n\r\n  /**\r\n   * SSR only. This is produced by compiler-ssr and attached in compiler-sfc\r\n   * not user facing, so the typing is lax and for test only.\r\n   * @internal\r\n   */\r\n  ssrRender?: (\r\n    ctx: any,\r\n    push: (item: any) => void,\r\n    parentInstance: ComponentInternalInstance,\r\n    attrs: Data | undefined,\r\n    // for compiler-optimized bindings\r\n    $props: ComponentInternalInstance['props'],\r\n    $setup: ComponentInternalInstance['setupState'],\r\n    $data: ComponentInternalInstance['data'],\r\n    $options: ComponentInternalInstance['ctx'],\r\n  ) => void\r\n\r\n  /**\r\n   * Only generated by compiler-sfc to mark a ssr render function inlined and\r\n   * returned from setup()\r\n   * @internal\r\n   */\r\n  __ssrInlineRender?: boolean\r\n\r\n  /**\r\n   * marker for AsyncComponentWrapper\r\n   * @internal\r\n   */\r\n  __asyncLoader?: () => Promise<ConcreteComponent>\r\n  /**\r\n   * the inner component resolved by the AsyncComponentWrapper\r\n   * @internal\r\n   */\r\n  __asyncResolved?: ConcreteComponent\r\n\r\n  // Type differentiators ------------------------------------------------------\r\n\r\n  // Note these are internal but need to be exposed in d.ts for type inference\r\n  // to work!\r\n\r\n  // type-only differentiator to separate OptionWithoutProps from a constructor\r\n  // type returned by defineComponent() or FunctionalComponent\r\n  call?: (this: unknown, ...args: unknown[]) => never\r\n  // type-only differentiators for built-in Vnode types\r\n  __isFragment?: never\r\n  __isTeleport?: never\r\n  __isSuspense?: never\r\n\r\n  __defaults?: Defaults\r\n}\r\n\r\n/**\r\n * Subset of compiler options that makes sense for the runtime.\r\n */\r\nexport interface RuntimeCompilerOptions {\r\n  isCustomElement?: (tag: string) => boolean\r\n  whitespace?: 'preserve' | 'condense'\r\n  comments?: boolean\r\n  delimiters?: [string, string]\r\n}\r\n\r\nexport type ComponentOptionsWithoutProps<\r\n  Props = {},\r\n  RawBindings = {},\r\n  D = {},\r\n  C extends ComputedOptions = {},\r\n  M extends MethodOptions = {},\r\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  E extends EmitsOptions = EmitsOptions,\r\n  EE extends string = string,\r\n  I extends ComponentInjectOptions = {},\r\n  II extends string = string,\r\n  S extends SlotsType = {},\r\n  PE = Props & EmitsToProps<E>,\r\n> = ComponentOptionsBase<\r\n  PE,\r\n  RawBindings,\r\n  D,\r\n  C,\r\n  M,\r\n  Mixin,\r\n  Extends,\r\n  E,\r\n  EE,\r\n  {},\r\n  I,\r\n  II,\r\n  S\r\n> & {\r\n  props?: undefined\r\n} & ThisType<\r\n    CreateComponentPublicInstance<\r\n      PE,\r\n      RawBindings,\r\n      D,\r\n      C,\r\n      M,\r\n      Mixin,\r\n      Extends,\r\n      E,\r\n      PE,\r\n      {},\r\n      false,\r\n      I,\r\n      S\r\n    >\r\n  >\r\n\r\nexport type ComponentOptionsWithArrayProps<\r\n  PropNames extends string = string,\r\n  RawBindings = {},\r\n  D = {},\r\n  C extends ComputedOptions = {},\r\n  M extends MethodOptions = {},\r\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  E extends EmitsOptions = EmitsOptions,\r\n  EE extends string = string,\r\n  I extends ComponentInjectOptions = {},\r\n  II extends string = string,\r\n  S extends SlotsType = {},\r\n  Props = Prettify<Readonly<{ [key in PropNames]?: any } & EmitsToProps<E>>>,\r\n> = ComponentOptionsBase<\r\n  Props,\r\n  RawBindings,\r\n  D,\r\n  C,\r\n  M,\r\n  Mixin,\r\n  Extends,\r\n  E,\r\n  EE,\r\n  {},\r\n  I,\r\n  II,\r\n  S\r\n> & {\r\n  props: PropNames[]\r\n} & ThisType<\r\n    CreateComponentPublicInstance<\r\n      Props,\r\n      RawBindings,\r\n      D,\r\n      C,\r\n      M,\r\n      Mixin,\r\n      Extends,\r\n      E,\r\n      Props,\r\n      {},\r\n      false,\r\n      I,\r\n      S\r\n    >\r\n  >\r\n\r\nexport type ComponentOptionsWithObjectProps<\r\n  PropsOptions = ComponentObjectPropsOptions,\r\n  RawBindings = {},\r\n  D = {},\r\n  C extends ComputedOptions = {},\r\n  M extends MethodOptions = {},\r\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  E extends EmitsOptions = EmitsOptions,\r\n  EE extends string = string,\r\n  I extends ComponentInjectOptions = {},\r\n  II extends string = string,\r\n  S extends SlotsType = {},\r\n  Props = Prettify<Readonly<ExtractPropTypes<PropsOptions> & EmitsToProps<E>>>,\r\n  Defaults = ExtractDefaultPropTypes<PropsOptions>,\r\n> = ComponentOptionsBase<\r\n  Props,\r\n  RawBindings,\r\n  D,\r\n  C,\r\n  M,\r\n  Mixin,\r\n  Extends,\r\n  E,\r\n  EE,\r\n  Defaults,\r\n  I,\r\n  II,\r\n  S\r\n> & {\r\n  props: PropsOptions & ThisType<void>\r\n} & ThisType<\r\n    CreateComponentPublicInstance<\r\n      Props,\r\n      RawBindings,\r\n      D,\r\n      C,\r\n      M,\r\n      Mixin,\r\n      Extends,\r\n      E,\r\n      Props,\r\n      Defaults,\r\n      false,\r\n      I,\r\n      S\r\n    >\r\n  >\r\n\r\nexport type ComponentOptions<\r\n  Props = {},\r\n  RawBindings = any,\r\n  D = any,\r\n  C extends ComputedOptions = any,\r\n  M extends MethodOptions = any,\r\n  Mixin extends ComponentOptionsMixin = any,\r\n  Extends extends ComponentOptionsMixin = any,\r\n  E extends EmitsOptions = any,\r\n  S extends SlotsType = any,\r\n> = ComponentOptionsBase<\r\n  Props,\r\n  RawBindings,\r\n  D,\r\n  C,\r\n  M,\r\n  Mixin,\r\n  Extends,\r\n  E,\r\n  string,\r\n  S\r\n> &\r\n  ThisType<\r\n    CreateComponentPublicInstance<\r\n      {},\r\n      RawBindings,\r\n      D,\r\n      C,\r\n      M,\r\n      Mixin,\r\n      Extends,\r\n      E,\r\n      Readonly<Props>\r\n    >\r\n  >\r\n\r\nexport type ComponentOptionsMixin = ComponentOptionsBase<\r\n  any,\r\n  any,\r\n  any,\r\n  any,\r\n  any,\r\n  any,\r\n  any,\r\n  any,\r\n  any,\r\n  any,\r\n  any\r\n>\r\n\r\nexport type ComputedOptions = Record<\r\n  string,\r\n  ComputedGetter<any> | WritableComputedOptions<any>\r\n>\r\n\r\nexport interface MethodOptions {\r\n  [key: string]: Function\r\n}\r\n\r\nexport type ExtractComputedReturns<T extends any> = {\r\n  [key in keyof T]: T[key] extends { get: (...args: any[]) => infer TReturn }\r\n    ? TReturn\r\n    : T[key] extends (...args: any[]) => infer TReturn\r\n      ? TReturn\r\n      : never\r\n}\r\n\r\nexport type ObjectWatchOptionItem = {\r\n  handler: WatchCallback | string\r\n} & WatchOptions\r\n\r\ntype WatchOptionItem = string | WatchCallback | ObjectWatchOptionItem\r\n\r\ntype ComponentWatchOptionItem = WatchOptionItem | WatchOptionItem[]\r\n\r\ntype ComponentWatchOptions = Record<string, ComponentWatchOptionItem>\r\n\r\nexport type ComponentProvideOptions = ObjectProvideOptions | Function\r\n\r\ntype ObjectProvideOptions = Record<string | symbol, unknown>\r\n\r\nexport type ComponentInjectOptions = string[] | ObjectInjectOptions\r\n\r\ntype ObjectInjectOptions = Record<\r\n  string | symbol,\r\n  string | symbol | { from?: string | symbol; default?: unknown }\r\n>\r\n\r\nexport type InjectToObject<T extends ComponentInjectOptions> =\r\n  T extends string[]\r\n    ? {\r\n        [K in T[number]]?: unknown\r\n      }\r\n    : T extends ObjectInjectOptions\r\n      ? {\r\n          [K in keyof T]?: unknown\r\n        }\r\n      : never\r\n\r\ninterface LegacyOptions<\r\n  Props,\r\n  D,\r\n  C extends ComputedOptions,\r\n  M extends MethodOptions,\r\n  Mixin extends ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin,\r\n  I extends ComponentInjectOptions,\r\n  II extends string,\r\n> {\r\n  compatConfig?: CompatConfig\r\n\r\n  // allow any custom options\r\n  [key: string]: any\r\n\r\n  // state\r\n  // Limitation: we cannot expose RawBindings on the `this` context for data\r\n  // since that leads to some sort of circular inference and breaks ThisType\r\n  // for the entire component.\r\n  data?: (\r\n    this: CreateComponentPublicInstance<\r\n      Props,\r\n      {},\r\n      {},\r\n      {},\r\n      MethodOptions,\r\n      Mixin,\r\n      Extends\r\n    >,\r\n    vm: CreateComponentPublicInstance<\r\n      Props,\r\n      {},\r\n      {},\r\n      {},\r\n      MethodOptions,\r\n      Mixin,\r\n      Extends\r\n    >,\r\n  ) => D\r\n  computed?: C\r\n  methods?: M\r\n  watch?: ComponentWatchOptions\r\n  provide?: ComponentProvideOptions\r\n  inject?: I | II[]\r\n\r\n  // assets\r\n  filters?: Record<string, Function>\r\n\r\n  // composition\r\n  mixins?: Mixin[]\r\n  extends?: Extends\r\n\r\n  // lifecycle\r\n  beforeCreate?(): void\r\n  created?(): void\r\n  beforeMount?(): void\r\n  mounted?(): void\r\n  beforeUpdate?(): void\r\n  updated?(): void\r\n  activated?(): void\r\n  deactivated?(): void\r\n  /** @deprecated use `beforeUnmount` instead */\r\n  beforeDestroy?(): void\r\n  beforeUnmount?(): void\r\n  /** @deprecated use `unmounted` instead */\r\n  destroyed?(): void\r\n  unmounted?(): void\r\n  renderTracked?: DebuggerHook\r\n  renderTriggered?: DebuggerHook\r\n  errorCaptured?: ErrorCapturedHook\r\n\r\n  /**\r\n   * runtime compile only\r\n   * @deprecated use `compilerOptions.delimiters` instead.\r\n   */\r\n  delimiters?: [string, string]\r\n\r\n  /**\r\n   * #3468\r\n   *\r\n   * type-only, used to assist Mixin's type inference,\r\n   * typescript will try to simplify the inferred `Mixin` type,\r\n   * with the `__differentiator`, typescript won't be able to combine different mixins,\r\n   * because the `__differentiator` will be different\r\n   */\r\n  __differentiator?: keyof D | keyof C | keyof M\r\n}\r\n\r\ntype MergedHook<T = () => void> = T | T[]\r\n\r\nexport type MergedComponentOptions = ComponentOptions &\r\n  MergedComponentOptionsOverride\r\n\r\nexport type MergedComponentOptionsOverride = {\r\n  beforeCreate?: MergedHook\r\n  created?: MergedHook\r\n  beforeMount?: MergedHook\r\n  mounted?: MergedHook\r\n  beforeUpdate?: MergedHook\r\n  updated?: MergedHook\r\n  activated?: MergedHook\r\n  deactivated?: MergedHook\r\n  /** @deprecated use `beforeUnmount` instead */\r\n  beforeDestroy?: MergedHook\r\n  beforeUnmount?: MergedHook\r\n  /** @deprecated use `unmounted` instead */\r\n  destroyed?: MergedHook\r\n  unmounted?: MergedHook\r\n  renderTracked?: MergedHook<DebuggerHook>\r\n  renderTriggered?: MergedHook<DebuggerHook>\r\n  errorCaptured?: MergedHook<ErrorCapturedHook>\r\n}\r\n\r\nexport type OptionTypesKeys = 'P' | 'B' | 'D' | 'C' | 'M' | 'Defaults'\r\n\r\nexport type OptionTypesType<\r\n  P = {},\r\n  B = {},\r\n  D = {},\r\n  C extends ComputedOptions = {},\r\n  M extends MethodOptions = {},\r\n  Defaults = {},\r\n> = {\r\n  P: P\r\n  B: B\r\n  D: D\r\n  C: C\r\n  M: M\r\n  Defaults: Defaults\r\n}\r\n\r\nenum OptionTypes {\r\n  PROPS = 'Props',\r\n  DATA = 'Data',\r\n  COMPUTED = 'Computed',\r\n  METHODS = 'Methods',\r\n  INJECT = 'Inject',\r\n}\r\n\r\nfunction createDuplicateChecker() {\r\n  const cache = Object.create(null)\r\n  return (type: OptionTypes, key: string) => {\r\n    if (cache[key]) {\r\n      warn(`${type} property \"${key}\" is already defined in ${cache[key]}.`)\r\n    } else {\r\n      cache[key] = type\r\n    }\r\n  }\r\n}\r\n\r\nexport let shouldCacheAccess = true\r\n\r\nexport function applyOptions(instance: ComponentInternalInstance) {\r\n  const options = resolveMergedOptions(instance)\r\n  const publicThis = instance.proxy! as any\r\n  const ctx = instance.ctx\r\n\r\n  // do not cache property access on public proxy during state initialization\r\n  shouldCacheAccess = false\r\n\r\n  // call beforeCreate first before accessing other options since\r\n  // the hook may mutate resolved options (#2791)\r\n  if (options.beforeCreate) {\r\n    callHook(options.beforeCreate, instance, LifecycleHooks.BEFORE_CREATE)\r\n  }\r\n\r\n  const {\r\n    // state\r\n    data: dataOptions,\r\n    computed: computedOptions,\r\n    methods,\r\n    watch: watchOptions,\r\n    provide: provideOptions,\r\n    inject: injectOptions,\r\n    // lifecycle\r\n    created,\r\n    beforeMount,\r\n    mounted,\r\n    beforeUpdate,\r\n    updated,\r\n    activated,\r\n    deactivated,\r\n    beforeDestroy,\r\n    beforeUnmount,\r\n    destroyed,\r\n    unmounted,\r\n    render,\r\n    renderTracked,\r\n    renderTriggered,\r\n    errorCaptured,\r\n    serverPrefetch,\r\n    // public API\r\n    expose,\r\n    inheritAttrs,\r\n    // assets\r\n    components,\r\n    directives,\r\n    filters,\r\n  } = options\r\n\r\n  const checkDuplicateProperties = __DEV__ ? createDuplicateChecker() : null\r\n\r\n  if (__DEV__) {\r\n    const [propsOptions] = instance.propsOptions\r\n    if (propsOptions) {\r\n      for (const key in propsOptions) {\r\n        checkDuplicateProperties!(OptionTypes.PROPS, key)\r\n      }\r\n    }\r\n  }\r\n\r\n  // options initialization order (to be consistent with Vue 2):\r\n  // - props (already done outside of this function)\r\n  // - inject\r\n  // - methods\r\n  // - data (deferred since it relies on `this` access)\r\n  // - computed\r\n  // - watch (deferred since it relies on `this` access)\r\n\r\n  if (injectOptions) {\r\n    resolveInjections(injectOptions, ctx, checkDuplicateProperties)\r\n  }\r\n\r\n  if (methods) {\r\n    for (const key in methods) {\r\n      const methodHandler = (methods as MethodOptions)[key]\r\n      if (isFunction(methodHandler)) {\r\n        // In dev mode, we use the `createRenderContext` function to define\r\n        // methods to the proxy target, and those are read-only but\r\n        // reconfigurable, so it needs to be redefined here\r\n        if (__DEV__) {\r\n          Object.defineProperty(ctx, key, {\r\n            value: methodHandler.bind(publicThis),\r\n            configurable: true,\r\n            enumerable: true,\r\n            writable: true,\r\n          })\r\n        } else {\r\n          ctx[key] = methodHandler.bind(publicThis)\r\n        }\r\n        if (__DEV__) {\r\n          checkDuplicateProperties!(OptionTypes.METHODS, key)\r\n        }\r\n      } else if (__DEV__) {\r\n        warn(\r\n          `Method \"${key}\" has type \"${typeof methodHandler}\" in the component definition. ` +\r\n            `Did you reference the function correctly?`,\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  if (dataOptions) {\r\n    if (__DEV__ && !isFunction(dataOptions)) {\r\n      warn(\r\n        `The data option must be a function. ` +\r\n          `Plain object usage is no longer supported.`,\r\n      )\r\n    }\r\n    const data = dataOptions.call(publicThis, publicThis)\r\n    if (__DEV__ && isPromise(data)) {\r\n      warn(\r\n        `data() returned a Promise - note data() cannot be async; If you ` +\r\n          `intend to perform data fetching before component renders, use ` +\r\n          `async setup() + <Suspense>.`,\r\n      )\r\n    }\r\n    if (!isObject(data)) {\r\n      __DEV__ && warn(`data() should return an object.`)\r\n    } else {\r\n      instance.data = reactive(data)\r\n      if (__DEV__) {\r\n        for (const key in data) {\r\n          checkDuplicateProperties!(OptionTypes.DATA, key)\r\n          // expose data on ctx during dev\r\n          if (!isReservedPrefix(key[0])) {\r\n            Object.defineProperty(ctx, key, {\r\n              configurable: true,\r\n              enumerable: true,\r\n              get: () => data[key],\r\n              set: NOOP,\r\n            })\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // state initialization complete at this point - start caching access\r\n  shouldCacheAccess = true\r\n\r\n  if (computedOptions) {\r\n    for (const key in computedOptions) {\r\n      const opt = (computedOptions as ComputedOptions)[key]\r\n      const get = isFunction(opt)\r\n        ? opt.bind(publicThis, publicThis)\r\n        : isFunction(opt.get)\r\n          ? opt.get.bind(publicThis, publicThis)\r\n          : NOOP\r\n      if (__DEV__ && get === NOOP) {\r\n        warn(`Computed property \"${key}\" has no getter.`)\r\n      }\r\n      const set =\r\n        !isFunction(opt) && isFunction(opt.set)\r\n          ? opt.set.bind(publicThis)\r\n          : __DEV__\r\n            ? () => {\r\n                warn(\r\n                  `Write operation failed: computed property \"${key}\" is readonly.`,\r\n                )\r\n              }\r\n            : NOOP\r\n      const c = computed({\r\n        get,\r\n        set,\r\n      })\r\n      Object.defineProperty(ctx, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: () => c.value,\r\n        set: v => (c.value = v),\r\n      })\r\n      if (__DEV__) {\r\n        checkDuplicateProperties!(OptionTypes.COMPUTED, key)\r\n      }\r\n    }\r\n  }\r\n\r\n  if (watchOptions) {\r\n    for (const key in watchOptions) {\r\n      createWatcher(watchOptions[key], ctx, publicThis, key)\r\n    }\r\n  }\r\n\r\n  if (provideOptions) {\r\n    const provides = isFunction(provideOptions)\r\n      ? provideOptions.call(publicThis)\r\n      : provideOptions\r\n    Reflect.ownKeys(provides).forEach(key => {\r\n      provide(key, provides[key])\r\n    })\r\n  }\r\n\r\n  if (created) {\r\n    callHook(created, instance, LifecycleHooks.CREATED)\r\n  }\r\n\r\n  function registerLifecycleHook(\r\n    register: Function,\r\n    hook?: Function | Function[],\r\n  ) {\r\n    if (isArray(hook)) {\r\n      hook.forEach(_hook => register(_hook.bind(publicThis)))\r\n    } else if (hook) {\r\n      register(hook.bind(publicThis))\r\n    }\r\n  }\r\n\r\n  registerLifecycleHook(onBeforeMount, beforeMount)\r\n  registerLifecycleHook(onMounted, mounted)\r\n  registerLifecycleHook(onBeforeUpdate, beforeUpdate)\r\n  registerLifecycleHook(onUpdated, updated)\r\n  registerLifecycleHook(onActivated, activated)\r\n  registerLifecycleHook(onDeactivated, deactivated)\r\n  registerLifecycleHook(onErrorCaptured, errorCaptured)\r\n  registerLifecycleHook(onRenderTracked, renderTracked)\r\n  registerLifecycleHook(onRenderTriggered, renderTriggered)\r\n  registerLifecycleHook(onBeforeUnmount, beforeUnmount)\r\n  registerLifecycleHook(onUnmounted, unmounted)\r\n  registerLifecycleHook(onServerPrefetch, serverPrefetch)\r\n\r\n  if (__COMPAT__) {\r\n    if (\r\n      beforeDestroy &&\r\n      softAssertCompatEnabled(DeprecationTypes.OPTIONS_BEFORE_DESTROY, instance)\r\n    ) {\r\n      registerLifecycleHook(onBeforeUnmount, beforeDestroy)\r\n    }\r\n    if (\r\n      destroyed &&\r\n      softAssertCompatEnabled(DeprecationTypes.OPTIONS_DESTROYED, instance)\r\n    ) {\r\n      registerLifecycleHook(onUnmounted, destroyed)\r\n    }\r\n  }\r\n\r\n  if (isArray(expose)) {\r\n    if (expose.length) {\r\n      const exposed = instance.exposed || (instance.exposed = {})\r\n      expose.forEach(key => {\r\n        Object.defineProperty(exposed, key, {\r\n          get: () => publicThis[key],\r\n          set: val => (publicThis[key] = val),\r\n        })\r\n      })\r\n    } else if (!instance.exposed) {\r\n      instance.exposed = {}\r\n    }\r\n  }\r\n\r\n  // options that are handled when creating the instance but also need to be\r\n  // applied from mixins\r\n  if (render && instance.render === NOOP) {\r\n    instance.render = render as InternalRenderFunction\r\n  }\r\n  if (inheritAttrs != null) {\r\n    instance.inheritAttrs = inheritAttrs\r\n  }\r\n\r\n  // asset options.\r\n  if (components) instance.components = components as any\r\n  if (directives) instance.directives = directives\r\n  if (\r\n    __COMPAT__ &&\r\n    filters &&\r\n    isCompatEnabled(DeprecationTypes.FILTERS, instance)\r\n  ) {\r\n    instance.filters = filters\r\n  }\r\n}\r\n\r\nexport function resolveInjections(\r\n  injectOptions: ComponentInjectOptions,\r\n  ctx: any,\r\n  checkDuplicateProperties = NOOP as any,\r\n) {\r\n  if (isArray(injectOptions)) {\r\n    injectOptions = normalizeInject(injectOptions)!\r\n  }\r\n  for (const key in injectOptions) {\r\n    const opt = injectOptions[key]\r\n    let injected: unknown\r\n    if (isObject(opt)) {\r\n      if ('default' in opt) {\r\n        injected = inject(\r\n          opt.from || key,\r\n          opt.default,\r\n          true /* treat default function as factory */,\r\n        )\r\n      } else {\r\n        injected = inject(opt.from || key)\r\n      }\r\n    } else {\r\n      injected = inject(opt)\r\n    }\r\n    if (isRef(injected)) {\r\n      // unwrap injected refs (ref #4196)\r\n      Object.defineProperty(ctx, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: () => (injected as Ref).value,\r\n        set: v => ((injected as Ref).value = v),\r\n      })\r\n    } else {\r\n      ctx[key] = injected\r\n    }\r\n    if (__DEV__) {\r\n      checkDuplicateProperties!(OptionTypes.INJECT, key)\r\n    }\r\n  }\r\n}\r\n\r\nfunction callHook(\r\n  hook: Function,\r\n  instance: ComponentInternalInstance,\r\n  type: LifecycleHooks,\r\n) {\r\n  callWithAsyncErrorHandling(\r\n    isArray(hook)\r\n      ? hook.map(h => h.bind(instance.proxy!))\r\n      : hook.bind(instance.proxy!),\r\n    instance,\r\n    type,\r\n  )\r\n}\r\n\r\nexport function createWatcher(\r\n  raw: ComponentWatchOptionItem,\r\n  ctx: Data,\r\n  publicThis: ComponentPublicInstance,\r\n  key: string,\r\n) {\r\n  const getter = key.includes('.')\r\n    ? createPathGetter(publicThis, key)\r\n    : () => (publicThis as any)[key]\r\n  if (isString(raw)) {\r\n    const handler = ctx[raw]\r\n    if (isFunction(handler)) {\r\n      watch(getter, handler as WatchCallback)\r\n    } else if (__DEV__) {\r\n      warn(`Invalid watch handler specified by key \"${raw}\"`, handler)\r\n    }\r\n  } else if (isFunction(raw)) {\r\n    watch(getter, raw.bind(publicThis))\r\n  } else if (isObject(raw)) {\r\n    if (isArray(raw)) {\r\n      raw.forEach(r => createWatcher(r, ctx, publicThis, key))\r\n    } else {\r\n      const handler = isFunction(raw.handler)\r\n        ? raw.handler.bind(publicThis)\r\n        : (ctx[raw.handler] as WatchCallback)\r\n      if (isFunction(handler)) {\r\n        watch(getter, handler, raw)\r\n      } else if (__DEV__) {\r\n        warn(`Invalid watch handler specified by key \"${raw.handler}\"`, handler)\r\n      }\r\n    }\r\n  } else if (__DEV__) {\r\n    warn(`Invalid watch option: \"${key}\"`, raw)\r\n  }\r\n}\r\n\r\n/**\r\n * Resolve merged options and cache it on the component.\r\n * This is done only once per-component since the merging does not involve\r\n * instances.\r\n */\r\nexport function resolveMergedOptions(\r\n  instance: ComponentInternalInstance,\r\n): MergedComponentOptions {\r\n  const base = instance.type as ComponentOptions\r\n  const { mixins, extends: extendsOptions } = base\r\n  const {\r\n    mixins: globalMixins,\r\n    optionsCache: cache,\r\n    config: { optionMergeStrategies },\r\n  } = instance.appContext\r\n  const cached = cache.get(base)\r\n\r\n  let resolved: MergedComponentOptions\r\n\r\n  if (cached) {\r\n    resolved = cached\r\n  } else if (!globalMixins.length && !mixins && !extendsOptions) {\r\n    if (\r\n      __COMPAT__ &&\r\n      isCompatEnabled(DeprecationTypes.PRIVATE_APIS, instance)\r\n    ) {\r\n      resolved = extend({}, base) as MergedComponentOptions\r\n      resolved.parent = instance.parent && instance.parent.proxy\r\n      resolved.propsData = instance.vnode.props\r\n    } else {\r\n      resolved = base as MergedComponentOptions\r\n    }\r\n  } else {\r\n    resolved = {}\r\n    if (globalMixins.length) {\r\n      globalMixins.forEach(m =>\r\n        mergeOptions(resolved, m, optionMergeStrategies, true),\r\n      )\r\n    }\r\n    mergeOptions(resolved, base, optionMergeStrategies)\r\n  }\r\n  if (isObject(base)) {\r\n    cache.set(base, resolved)\r\n  }\r\n  return resolved\r\n}\r\n\r\nexport function mergeOptions(\r\n  to: any,\r\n  from: any,\r\n  strats: Record<string, OptionMergeFunction>,\r\n  asMixin = false,\r\n) {\r\n  if (__COMPAT__ && isFunction(from)) {\r\n    from = from.options\r\n  }\r\n\r\n  const { mixins, extends: extendsOptions } = from\r\n\r\n  if (extendsOptions) {\r\n    mergeOptions(to, extendsOptions, strats, true)\r\n  }\r\n  if (mixins) {\r\n    mixins.forEach((m: ComponentOptionsMixin) =>\r\n      mergeOptions(to, m, strats, true),\r\n    )\r\n  }\r\n\r\n  for (const key in from) {\r\n    if (asMixin && key === 'expose') {\r\n      __DEV__ &&\r\n        warn(\r\n          `\"expose\" option is ignored when declared in mixins or extends. ` +\r\n            `It should only be declared in the base component itself.`,\r\n        )\r\n    } else {\r\n      const strat = internalOptionMergeStrats[key] || (strats && strats[key])\r\n      to[key] = strat ? strat(to[key], from[key]) : from[key]\r\n    }\r\n  }\r\n  return to\r\n}\r\n\r\nexport const internalOptionMergeStrats: Record<string, Function> = {\r\n  data: mergeDataFn,\r\n  props: mergeEmitsOrPropsOptions,\r\n  emits: mergeEmitsOrPropsOptions,\r\n  // objects\r\n  methods: mergeObjectOptions,\r\n  computed: mergeObjectOptions,\r\n  // lifecycle\r\n  beforeCreate: mergeAsArray,\r\n  created: mergeAsArray,\r\n  beforeMount: mergeAsArray,\r\n  mounted: mergeAsArray,\r\n  beforeUpdate: mergeAsArray,\r\n  updated: mergeAsArray,\r\n  beforeDestroy: mergeAsArray,\r\n  beforeUnmount: mergeAsArray,\r\n  destroyed: mergeAsArray,\r\n  unmounted: mergeAsArray,\r\n  activated: mergeAsArray,\r\n  deactivated: mergeAsArray,\r\n  errorCaptured: mergeAsArray,\r\n  serverPrefetch: mergeAsArray,\r\n  // assets\r\n  components: mergeObjectOptions,\r\n  directives: mergeObjectOptions,\r\n  // watch\r\n  watch: mergeWatchOptions,\r\n  // provide / inject\r\n  provide: mergeDataFn,\r\n  inject: mergeInject,\r\n}\r\n\r\nif (__COMPAT__) {\r\n  internalOptionMergeStrats.filters = mergeObjectOptions\r\n}\r\n\r\nfunction mergeDataFn(to: any, from: any) {\r\n  if (!from) {\r\n    return to\r\n  }\r\n  if (!to) {\r\n    return from\r\n  }\r\n  return function mergedDataFn(this: ComponentPublicInstance) {\r\n    return (\r\n      __COMPAT__ && isCompatEnabled(DeprecationTypes.OPTIONS_DATA_MERGE, null)\r\n        ? deepMergeData\r\n        : extend\r\n    )(\r\n      isFunction(to) ? to.call(this, this) : to,\r\n      isFunction(from) ? from.call(this, this) : from,\r\n    )\r\n  }\r\n}\r\n\r\nfunction mergeInject(\r\n  to: ComponentInjectOptions | undefined,\r\n  from: ComponentInjectOptions,\r\n) {\r\n  return mergeObjectOptions(normalizeInject(to), normalizeInject(from))\r\n}\r\n\r\nfunction normalizeInject(\r\n  raw: ComponentInjectOptions | undefined,\r\n): ObjectInjectOptions | undefined {\r\n  if (isArray(raw)) {\r\n    const res: ObjectInjectOptions = {}\r\n    for (let i = 0; i < raw.length; i++) {\r\n      res[raw[i]] = raw[i]\r\n    }\r\n    return res\r\n  }\r\n  return raw\r\n}\r\n\r\nfunction mergeAsArray<T = Function>(to: T[] | T | undefined, from: T | T[]) {\r\n  return to ? [...new Set([].concat(to as any, from as any))] : from\r\n}\r\n\r\nfunction mergeObjectOptions(to: Object | undefined, from: Object | undefined) {\r\n  return to ? extend(Object.create(null), to, from) : from\r\n}\r\n\r\nfunction mergeEmitsOrPropsOptions(\r\n  to: EmitsOptions | undefined,\r\n  from: EmitsOptions | undefined,\r\n): EmitsOptions | undefined\r\nfunction mergeEmitsOrPropsOptions(\r\n  to: ComponentPropsOptions | undefined,\r\n  from: ComponentPropsOptions | undefined,\r\n): ComponentPropsOptions | undefined\r\nfunction mergeEmitsOrPropsOptions(\r\n  to: ComponentPropsOptions | EmitsOptions | undefined,\r\n  from: ComponentPropsOptions | EmitsOptions | undefined,\r\n) {\r\n  if (to) {\r\n    if (isArray(to) && isArray(from)) {\r\n      return [...new Set([...to, ...from])]\r\n    }\r\n    return extend(\r\n      Object.create(null),\r\n      normalizePropsOrEmits(to),\r\n      normalizePropsOrEmits(from ?? {}),\r\n    )\r\n  } else {\r\n    return from\r\n  }\r\n}\r\n\r\nfunction mergeWatchOptions(\r\n  to: ComponentWatchOptions | undefined,\r\n  from: ComponentWatchOptions | undefined,\r\n) {\r\n  if (!to) return from\r\n  if (!from) return to\r\n  const merged = extend(Object.create(null), to)\r\n  for (const key in from) {\r\n    merged[key] = mergeAsArray(to[key], from[key])\r\n  }\r\n  return merged\r\n}\r\n","import { isFunction } from '@vue/shared'\r\nimport { currentInstance } from './component'\r\nimport { currentRenderingInstance } from './componentRenderContext'\r\nimport { currentApp } from './apiCreateApp'\r\nimport { warn } from './warning'\r\n\r\nexport interface InjectionKey<T> extends Symbol {}\r\n\r\nexport function provide<T, K = InjectionKey<T> | string | number>(\r\n  key: K,\r\n  value: K extends InjectionKey<infer V> ? V : T,\r\n) {\r\n  if (!currentInstance) {\r\n    if (__DEV__) {\r\n      warn(`provide() can only be used inside setup().`)\r\n    }\r\n  } else {\r\n    let provides = currentInstance.provides\r\n    // by default an instance inherits its parent's provides object\r\n    // but when it needs to provide values of its own, it creates its\r\n    // own provides object using parent provides object as prototype.\r\n    // this way in `inject` we can simply look up injections from direct\r\n    // parent and let the prototype chain do the work.\r\n    const parentProvides =\r\n      currentInstance.parent && currentInstance.parent.provides\r\n    if (parentProvides === provides) {\r\n      provides = currentInstance.provides = Object.create(parentProvides)\r\n    }\r\n    // TS doesn't allow symbol as index type\r\n    provides[key as string] = value\r\n  }\r\n}\r\n\r\nexport function inject<T>(key: InjectionKey<T> | string): T | undefined\r\nexport function inject<T>(\r\n  key: InjectionKey<T> | string,\r\n  defaultValue: T,\r\n  treatDefaultAsFactory?: false,\r\n): T\r\nexport function inject<T>(\r\n  key: InjectionKey<T> | string,\r\n  defaultValue: T | (() => T),\r\n  treatDefaultAsFactory: true,\r\n): T\r\nexport function inject(\r\n  key: InjectionKey<any> | string,\r\n  defaultValue?: unknown,\r\n  treatDefaultAsFactory = false,\r\n) {\r\n  // fallback to `currentRenderingInstance` so that this can be called in\r\n  // a functional component\r\n  const instance = currentInstance || currentRenderingInstance\r\n\r\n  // also support looking up from app-level provides w/ `app.runWithContext()`\r\n  if (instance || currentApp) {\r\n    // #2400\r\n    // to support `app.use` plugins,\r\n    // fallback to appContext's `provides` if the instance is at root\r\n    const provides = instance\r\n      ? instance.parent == null\r\n        ? instance.vnode.appContext && instance.vnode.appContext.provides\r\n        : instance.parent.provides\r\n      : currentApp!._context.provides\r\n\r\n    if (provides && (key as string | symbol) in provides) {\r\n      // TS doesn't allow symbol as index type\r\n      return provides[key as string]\r\n    } else if (arguments.length > 1) {\r\n      return treatDefaultAsFactory && isFunction(defaultValue)\r\n        ? defaultValue.call(instance && instance.proxy)\r\n        : defaultValue\r\n    } else if (__DEV__) {\r\n      warn(`injection \"${String(key)}\" not found.`)\r\n    }\r\n  } else if (__DEV__) {\r\n    warn(`inject() can only be used inside setup() or functional components.`)\r\n  }\r\n}\r\n\r\n/**\r\n * Returns true if `inject()` can be used without warning about being called in the wrong place (e.g. outside of\r\n * setup()). This is used by libraries that want to use `inject()` internally without triggering a warning to the end\r\n * user. One example is `useRoute()` in `vue-router`.\r\n */\r\nexport function hasInjectionContext(): boolean {\r\n  return !!(currentInstance || currentRenderingInstance || currentApp)\r\n}\r\n","import {\r\n  type Component,\r\n  type ComponentInternalInstance,\r\n  type ConcreteComponent,\r\n  type Data,\r\n  getExposeProxy,\r\n  validateComponentName,\r\n} from './component'\r\nimport type {\r\n  ComponentOptions,\r\n  MergedComponentOptions,\r\n  RuntimeCompilerOptions,\r\n} from './componentOptions'\r\nimport type {\r\n  ComponentCustomProperties,\r\n  ComponentPublicInstance,\r\n} from './componentPublicInstance'\r\nimport { type Directive, validateDirectiveName } from './directives'\r\nimport type { ElementNamespace, RootRenderFunction } from './renderer'\r\nimport type { InjectionKey } from './apiInject'\r\nimport { warn } from './warning'\r\nimport { type VNode, cloneVNode, createVNode } from './vnode'\r\nimport type { RootHydrateFunction } from './hydration'\r\nimport { devtoolsInitApp, devtoolsUnmountApp } from './devtools'\r\nimport { NO, extend, isFunction, isObject } from '@vue/shared'\r\nimport { version } from '.'\r\nimport { installAppCompatProperties } from './compat/global'\r\nimport type { NormalizedPropsOptions } from './componentProps'\r\nimport type { ObjectEmitsOptions } from './componentEmits'\r\nimport type { DefineComponent } from './apiDefineComponent'\r\n\r\nexport interface App<HostElement = any> {\r\n  version: string\r\n  config: AppConfig\r\n\r\n  use<Options extends unknown[]>(\r\n    plugin: Plugin<Options>,\r\n    ...options: Options\r\n  ): this\r\n  use<Options>(plugin: Plugin<Options>, options: Options): this\r\n\r\n  mixin(mixin: ComponentOptions): this\r\n  component(name: string): Component | undefined\r\n  component(name: string, component: Component | DefineComponent): this\r\n  directive<T = any, V = any>(name: string): Directive<T, V> | undefined\r\n  directive<T = any, V = any>(name: string, directive: Directive<T, V>): this\r\n  mount(\r\n    rootContainer: HostElement | string,\r\n    isHydrate?: boolean,\r\n    namespace?: boolean | ElementNamespace,\r\n  ): ComponentPublicInstance\r\n  unmount(): void\r\n  provide<T>(key: InjectionKey<T> | string, value: T): this\r\n\r\n  /**\r\n   * Runs a function with the app as active instance. This allows using of `inject()` within the function to get access\r\n   * to variables provided via `app.provide()`.\r\n   *\r\n   * @param fn - function to run with the app as active instance\r\n   */\r\n  runWithContext<T>(fn: () => T): T\r\n\r\n  // internal, but we need to expose these for the server-renderer and devtools\r\n  _uid: number\r\n  _component: ConcreteComponent\r\n  _props: Data | null\r\n  _container: HostElement | null\r\n  _context: AppContext\r\n  _instance: ComponentInternalInstance | null\r\n\r\n  /**\r\n   * v2 compat only\r\n   */\r\n  filter?(name: string): Function | undefined\r\n  filter?(name: string, filter: Function): this\r\n\r\n  /**\r\n   * @internal v3 compat only\r\n   */\r\n  _createRoot?(options: ComponentOptions): ComponentPublicInstance\r\n}\r\n\r\nexport type OptionMergeFunction = (to: unknown, from: unknown) => any\r\n\r\nexport interface AppConfig {\r\n  // @private\r\n  readonly isNativeTag?: (tag: string) => boolean\r\n\r\n  performance: boolean\r\n  optionMergeStrategies: Record<string, OptionMergeFunction>\r\n  globalProperties: ComponentCustomProperties & Record<string, any>\r\n  errorHandler?: (\r\n    err: unknown,\r\n    instance: ComponentPublicInstance | null,\r\n    info: string,\r\n  ) => void\r\n  warnHandler?: (\r\n    msg: string,\r\n    instance: ComponentPublicInstance | null,\r\n    trace: string,\r\n  ) => void\r\n\r\n  /**\r\n   * Options to pass to `@vue/compiler-dom`.\r\n   * Only supported in runtime compiler build.\r\n   */\r\n  compilerOptions: RuntimeCompilerOptions\r\n\r\n  /**\r\n   * @deprecated use config.compilerOptions.isCustomElement\r\n   */\r\n  isCustomElement?: (tag: string) => boolean\r\n}\r\n\r\nexport interface AppContext {\r\n  app: App // for devtools\r\n  config: AppConfig\r\n  mixins: ComponentOptions[]\r\n  components: Record<string, Component>\r\n  directives: Record<string, Directive>\r\n  provides: Record<string | symbol, any>\r\n\r\n  /**\r\n   * Cache for merged/normalized component options\r\n   * Each app instance has its own cache because app-level global mixins and\r\n   * optionMergeStrategies can affect merge behavior.\r\n   * @internal\r\n   */\r\n  optionsCache: WeakMap<ComponentOptions, MergedComponentOptions>\r\n  /**\r\n   * Cache for normalized props options\r\n   * @internal\r\n   */\r\n  propsCache: WeakMap<ConcreteComponent, NormalizedPropsOptions>\r\n  /**\r\n   * Cache for normalized emits options\r\n   * @internal\r\n   */\r\n  emitsCache: WeakMap<ConcreteComponent, ObjectEmitsOptions | null>\r\n  /**\r\n   * HMR only\r\n   * @internal\r\n   */\r\n  reload?: () => void\r\n  /**\r\n   * v2 compat only\r\n   * @internal\r\n   */\r\n  filters?: Record<string, Function>\r\n}\r\n\r\ntype PluginInstallFunction<Options = any[]> = Options extends unknown[]\r\n  ? (app: App, ...options: Options) => any\r\n  : (app: App, options: Options) => any\r\n\r\nexport type ObjectPlugin<Options = any[]> = {\r\n  install: PluginInstallFunction<Options>\r\n}\r\nexport type FunctionPlugin<Options = any[]> = PluginInstallFunction<Options> &\r\n  Partial<ObjectPlugin<Options>>\r\n\r\nexport type Plugin<Options = any[]> =\r\n  | FunctionPlugin<Options>\r\n  | ObjectPlugin<Options>\r\n\r\nexport function createAppContext(): AppContext {\r\n  return {\r\n    app: null as any,\r\n    config: {\r\n      isNativeTag: NO,\r\n      performance: false,\r\n      globalProperties: {},\r\n      optionMergeStrategies: {},\r\n      errorHandler: undefined,\r\n      warnHandler: undefined,\r\n      compilerOptions: {},\r\n    },\r\n    mixins: [],\r\n    components: {},\r\n    directives: {},\r\n    provides: Object.create(null),\r\n    optionsCache: new WeakMap(),\r\n    propsCache: new WeakMap(),\r\n    emitsCache: new WeakMap(),\r\n  }\r\n}\r\n\r\nexport type CreateAppFunction<HostElement> = (\r\n  rootComponent: Component,\r\n  rootProps?: Data | null,\r\n) => App<HostElement>\r\n\r\nlet uid = 0\r\n\r\nexport function createAppAPI<HostElement>(\r\n  render: RootRenderFunction<HostElement>,\r\n  hydrate?: RootHydrateFunction,\r\n): CreateAppFunction<HostElement> {\r\n  return function createApp(rootComponent, rootProps = null) {\r\n    if (!isFunction(rootComponent)) {\r\n      rootComponent = extend({}, rootComponent)\r\n    }\r\n\r\n    if (rootProps != null && !isObject(rootProps)) {\r\n      __DEV__ && warn(`root props passed to app.mount() must be an object.`)\r\n      rootProps = null\r\n    }\r\n    // 创建全局的context\r\n    const context = createAppContext()\r\n    const installedPlugins = new WeakSet()\r\n\r\n    let isMounted = false\r\n    /**\r\n     * 创建App对象并范围，app对象中_context指向全局的context，\r\n     * 全局的context中保存app字段，这样在任何组件中都可以获取context，进而获取app\r\n     */\r\n    const app: App = (context.app = {\r\n      _uid: uid++,\r\n      _component: rootComponent as ConcreteComponent,\r\n      _props: rootProps,\r\n      _container: null,\r\n      _context: context,\r\n      _instance: null,\r\n\r\n      version,\r\n\r\n      get config() {\r\n        return context.config\r\n      },\r\n\r\n      set config(v) {\r\n        if (__DEV__) {\r\n          warn(\r\n            `app.config cannot be replaced. Modify individual options instead.`,\r\n          )\r\n        }\r\n      },\r\n\r\n      use(plugin: Plugin, ...options: any[]) {\r\n        if (installedPlugins.has(plugin)) {\r\n          __DEV__ && warn(`Plugin has already been applied to target app.`)\r\n        } else if (plugin && isFunction(plugin.install)) {\r\n          installedPlugins.add(plugin)\r\n          plugin.install(app, ...options)\r\n        } else if (isFunction(plugin)) {\r\n          installedPlugins.add(plugin)\r\n          plugin(app, ...options)\r\n        } else if (__DEV__) {\r\n          warn(\r\n            `A plugin must either be a function or an object with an \"install\" ` +\r\n              `function.`,\r\n          )\r\n        }\r\n        return app\r\n      },\r\n\r\n      mixin(mixin: ComponentOptions) {\r\n        if (__FEATURE_OPTIONS_API__) {\r\n          if (!context.mixins.includes(mixin)) {\r\n            context.mixins.push(mixin)\r\n          } else if (__DEV__) {\r\n            warn(\r\n              'Mixin has already been applied to target app' +\r\n                (mixin.name ? `: ${mixin.name}` : ''),\r\n            )\r\n          }\r\n        } else if (__DEV__) {\r\n          warn('Mixins are only available in builds supporting Options API')\r\n        }\r\n        return app\r\n      },\r\n\r\n      component(name: string, component?: Component): any {\r\n        if (__DEV__) {\r\n          validateComponentName(name, context.config)\r\n        }\r\n        if (!component) {\r\n          return context.components[name]\r\n        }\r\n        if (__DEV__ && context.components[name]) {\r\n          warn(`Component \"${name}\" has already been registered in target app.`)\r\n        }\r\n        context.components[name] = component\r\n        return app\r\n      },\r\n\r\n      directive(name: string, directive?: Directive) {\r\n        if (__DEV__) {\r\n          validateDirectiveName(name)\r\n        }\r\n\r\n        if (!directive) {\r\n          return context.directives[name] as any\r\n        }\r\n        if (__DEV__ && context.directives[name]) {\r\n          warn(`Directive \"${name}\" has already been registered in target app.`)\r\n        }\r\n        context.directives[name] = directive\r\n        return app\r\n      },\r\n\r\n      mount(\r\n        rootContainer: HostElement, // 容器\r\n        isHydrate?: boolean,\r\n        namespace?: boolean | ElementNamespace,\r\n      ): any {\r\n        // 一个app对象只会挂载一次\r\n        if (!isMounted) {\r\n          // #5571\r\n          // 容器只会被挂载一次\r\n          if (__DEV__ && (rootContainer as any).__vue_app__) {\r\n            warn(\r\n              `There is already an app instance mounted on the host container.\\n` +\r\n                ` If you want to mount another app on the same host container,` +\r\n                ` you need to unmount the previous app by calling \\`app.unmount()\\` first.`,\r\n            )\r\n          }\r\n          // 为根组件创建虚拟VNode\r\n          const vnode = createVNode(rootComponent, rootProps)\r\n          // store app context on the root VNode.\r\n          // this will be set on the root instance on initial mount.\r\n          // 给节点赋值全局变量context\r\n          vnode.appContext = context\r\n\r\n          if (namespace === true) {\r\n            namespace = 'svg'\r\n          } else if (namespace === false) {\r\n            namespace = undefined\r\n          }\r\n\r\n          // HMR root reload\r\n          if (__DEV__) {\r\n            context.reload = () => {\r\n              // casting to ElementNamespace because TS doesn't guarantee type narrowing\r\n              // over function boundaries\r\n              render(\r\n                cloneVNode(vnode),\r\n                rootContainer,\r\n                namespace as ElementNamespace,\r\n              )\r\n            }\r\n          }\r\n          /**hydrate是水合函数\r\n           * 在 Vue 3 中，水合函数用于将服务器端渲染（SSR）生成的 HTML 字符串重新变成可交互的、具有响应式特性的 Vue 组件。水合函数的作用是根据服务器端渲染生成的 HTML 字符串来创建对应的虚拟 DOM 树，并与客户端渲染的虚拟 DOM 树进行比较和合并，从而实现客户端的静态内容复用和动态内容更新。\r\n           */\r\n          if (isHydrate && hydrate) {\r\n            hydrate(vnode as VNode<Node, Element>, rootContainer as any)\r\n          } else {\r\n            render(vnode, rootContainer, namespace)\r\n          }\r\n          isMounted = true\r\n          app._container = rootContainer\r\n          // for devtools and telemetry\r\n          ;(rootContainer as any).__vue_app__ = app\r\n\r\n          if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n            app._instance = vnode.component\r\n            devtoolsInitApp(app, version)\r\n          }\r\n\r\n          return getExposeProxy(vnode.component!) || vnode.component!.proxy\r\n        } else if (__DEV__) {\r\n          warn(\r\n            `App has already been mounted.\\n` +\r\n              `If you want to remount the same app, move your app creation logic ` +\r\n              `into a factory function and create fresh app instances for each ` +\r\n              `mount - e.g. \\`const createMyApp = () => createApp(App)\\``,\r\n          )\r\n        }\r\n      },\r\n\r\n      unmount() {\r\n        if (isMounted) {\r\n          render(null, app._container)\r\n          if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n            app._instance = null\r\n            devtoolsUnmountApp(app)\r\n          }\r\n          delete app._container.__vue_app__\r\n        } else if (__DEV__) {\r\n          warn(`Cannot unmount an app that is not mounted.`)\r\n        }\r\n      },\r\n\r\n      provide(key, value) {\r\n        if (__DEV__ && (key as string | symbol) in context.provides) {\r\n          warn(\r\n            `App already provides property with key \"${String(key)}\". ` +\r\n              `It will be overwritten with the new value.`,\r\n          )\r\n        }\r\n\r\n        context.provides[key as string | symbol] = value\r\n\r\n        return app\r\n      },\r\n\r\n      runWithContext(fn) {\r\n        currentApp = app\r\n        try {\r\n          return fn()\r\n        } finally {\r\n          currentApp = null\r\n        }\r\n      },\r\n    })\r\n\r\n    if (__COMPAT__) {\r\n      installAppCompatProperties(app, context, render)\r\n    }\r\n\r\n    return app\r\n  }\r\n}\r\n\r\n/**\r\n * @internal Used to identify the current app when using `inject()` within\r\n * `app.runWithContext()`.\r\n */\r\nexport let currentApp: App<unknown> | null = null\r\n","import {\r\n  TriggerOpTypes,\r\n  shallowReactive,\r\n  shallowReadonly,\r\n  toRaw,\r\n  trigger,\r\n} from '@vue/reactivity'\r\nimport {\r\n  EMPTY_ARR,\r\n  EMPTY_OBJ,\r\n  type IfAny,\r\n  PatchFlags,\r\n  camelize,\r\n  capitalize,\r\n  def,\r\n  extend,\r\n  hasOwn,\r\n  hyphenate,\r\n  isArray,\r\n  isFunction,\r\n  isObject,\r\n  isOn,\r\n  isReservedProp,\r\n  isString,\r\n  makeMap,\r\n  toRawType,\r\n} from '@vue/shared'\r\nimport { warn } from './warning'\r\nimport {\r\n  type ComponentInternalInstance,\r\n  type ComponentOptions,\r\n  type ConcreteComponent,\r\n  type Data,\r\n  setCurrentInstance,\r\n} from './component'\r\nimport { isEmitListener } from './componentEmits'\r\nimport { InternalObjectKey } from './vnode'\r\nimport type { AppContext } from './apiCreateApp'\r\nimport { createPropsDefaultThis } from './compat/props'\r\nimport { isCompatEnabled, softAssertCompatEnabled } from './compat/compatConfig'\r\nimport { DeprecationTypes } from './compat/compatConfig'\r\nimport { shouldSkipAttr } from './compat/attrsFallthrough'\r\n\r\nexport type ComponentPropsOptions<P = Data> =\r\n  | ComponentObjectPropsOptions<P>\r\n  | string[]\r\n\r\nexport type ComponentObjectPropsOptions<P = Data> = {\r\n  [K in keyof P]: Prop<P[K]> | null\r\n}\r\n\r\nexport type Prop<T, D = T> = PropOptions<T, D> | PropType<T>\r\n\r\ntype DefaultFactory<T> = (props: Data) => T | null | undefined\r\n\r\nexport interface PropOptions<T = any, D = T> {\r\n  type?: PropType<T> | true | null\r\n  required?: boolean\r\n  default?: D | DefaultFactory<D> | null | undefined | object\r\n  validator?(value: unknown, props: Data): boolean\r\n  /**\r\n   * @internal\r\n   */\r\n  skipCheck?: boolean\r\n  /**\r\n   * @internal\r\n   */\r\n  skipFactory?: boolean\r\n}\r\n\r\nexport type PropType<T> = PropConstructor<T> | PropConstructor<T>[]\r\n\r\ntype PropConstructor<T = any> =\r\n  | { new (...args: any[]): T & {} }\r\n  | { (): T }\r\n  | PropMethod<T>\r\n\r\ntype PropMethod<T, TConstructor = any> = [T] extends [\r\n  ((...args: any) => any) | undefined,\r\n] // if is function with args, allowing non-required functions\r\n  ? { new (): TConstructor; (): T; readonly prototype: TConstructor } // Create Function like constructor\r\n  : never\r\n\r\ntype RequiredKeys<T> = {\r\n  [K in keyof T]: T[K] extends\r\n    | { required: true }\r\n    | { default: any }\r\n    // don't mark Boolean props as undefined\r\n    | BooleanConstructor\r\n    | { type: BooleanConstructor }\r\n    ? T[K] extends { default: undefined | (() => undefined) }\r\n      ? never\r\n      : K\r\n    : never\r\n}[keyof T]\r\n\r\ntype OptionalKeys<T> = Exclude<keyof T, RequiredKeys<T>>\r\n\r\ntype DefaultKeys<T> = {\r\n  [K in keyof T]: T[K] extends\r\n    | { default: any }\r\n    // Boolean implicitly defaults to false\r\n    | BooleanConstructor\r\n    | { type: BooleanConstructor }\r\n    ? T[K] extends { type: BooleanConstructor; required: true } // not default if Boolean is marked as required\r\n      ? never\r\n      : K\r\n    : never\r\n}[keyof T]\r\n\r\ntype InferPropType<T> = [T] extends [null]\r\n  ? any // null & true would fail to infer\r\n  : [T] extends [{ type: null | true }]\r\n    ? any // As TS issue https://github.com/Microsoft/TypeScript/issues/14829 // somehow `ObjectConstructor` when inferred from { (): T } becomes `any` // `BooleanConstructor` when inferred from PropConstructor(with PropMethod) becomes `Boolean`\r\n    : [T] extends [ObjectConstructor | { type: ObjectConstructor }]\r\n      ? Record<string, any>\r\n      : [T] extends [BooleanConstructor | { type: BooleanConstructor }]\r\n        ? boolean\r\n        : [T] extends [DateConstructor | { type: DateConstructor }]\r\n          ? Date\r\n          : [T] extends [(infer U)[] | { type: (infer U)[] }]\r\n            ? U extends DateConstructor\r\n              ? Date | InferPropType<U>\r\n              : InferPropType<U>\r\n            : [T] extends [Prop<infer V, infer D>]\r\n              ? unknown extends V\r\n                ? IfAny<V, V, D>\r\n                : V\r\n              : T\r\n\r\n/**\r\n * Extract prop types from a runtime props options object.\r\n * The extracted types are **internal** - i.e. the resolved props received by\r\n * the component.\r\n * - Boolean props are always present\r\n * - Props with default values are always present\r\n *\r\n * To extract accepted props from the parent, use {@link ExtractPublicPropTypes}.\r\n */\r\nexport type ExtractPropTypes<O> = {\r\n  // use `keyof Pick<O, RequiredKeys<O>>` instead of `RequiredKeys<O>` to\r\n  // support IDE features\r\n  [K in keyof Pick<O, RequiredKeys<O>>]: InferPropType<O[K]>\r\n} & {\r\n  // use `keyof Pick<O, OptionalKeys<O>>` instead of `OptionalKeys<O>` to\r\n  // support IDE features\r\n  [K in keyof Pick<O, OptionalKeys<O>>]?: InferPropType<O[K]>\r\n}\r\n\r\ntype PublicRequiredKeys<T> = {\r\n  [K in keyof T]: T[K] extends { required: true } ? K : never\r\n}[keyof T]\r\n\r\ntype PublicOptionalKeys<T> = Exclude<keyof T, PublicRequiredKeys<T>>\r\n\r\n/**\r\n * Extract prop types from a runtime props options object.\r\n * The extracted types are **public** - i.e. the expected props that can be\r\n * passed to component.\r\n */\r\nexport type ExtractPublicPropTypes<O> = {\r\n  [K in keyof Pick<O, PublicRequiredKeys<O>>]: InferPropType<O[K]>\r\n} & {\r\n  [K in keyof Pick<O, PublicOptionalKeys<O>>]?: InferPropType<O[K]>\r\n}\r\n\r\nenum BooleanFlags {\r\n  shouldCast,\r\n  shouldCastTrue,\r\n}\r\n\r\n// extract props which defined with default from prop options\r\nexport type ExtractDefaultPropTypes<O> = O extends object\r\n  ? // use `keyof Pick<O, DefaultKeys<O>>` instead of `DefaultKeys<O>` to support IDE features\r\n    { [K in keyof Pick<O, DefaultKeys<O>>]: InferPropType<O[K]> }\r\n  : {}\r\n\r\ntype NormalizedProp =\r\n  | null\r\n  | (PropOptions & {\r\n      [BooleanFlags.shouldCast]?: boolean\r\n      [BooleanFlags.shouldCastTrue]?: boolean\r\n    })\r\n\r\n// normalized value is a tuple of the actual normalized options\r\n// and an array of prop keys that need value casting (booleans and defaults)\r\nexport type NormalizedProps = Record<string, NormalizedProp>\r\nexport type NormalizedPropsOptions = [NormalizedProps, string[]] | []\r\n\r\nexport function initProps(\r\n  instance: ComponentInternalInstance,\r\n  rawProps: Data | null,\r\n  isStateful: number, // result of bitwise flag comparison\r\n  isSSR = false,\r\n) {\r\n  const props: Data = {}\r\n  const attrs: Data = {}\r\n  def(attrs, InternalObjectKey, 1)\r\n\r\n  instance.propsDefaults = Object.create(null)\r\n\r\n  setFullProps(instance, rawProps, props, attrs)\r\n\r\n  // ensure all declared prop keys are present\r\n  for (const key in instance.propsOptions[0]) {\r\n    if (!(key in props)) {\r\n      props[key] = undefined\r\n    }\r\n  }\r\n\r\n  // validation\r\n  if (__DEV__) {\r\n    validateProps(rawProps || {}, props, instance)\r\n  }\r\n\r\n  if (isStateful) {\r\n    // stateful\r\n    instance.props = isSSR ? props : shallowReactive(props)\r\n  } else {\r\n    if (!instance.type.props) {\r\n      // functional w/ optional props, props === attrs\r\n      instance.props = attrs\r\n    } else {\r\n      // functional w/ declared props\r\n      instance.props = props\r\n    }\r\n  }\r\n  instance.attrs = attrs\r\n}\r\n\r\nfunction isInHmrContext(instance: ComponentInternalInstance | null) {\r\n  while (instance) {\r\n    if (instance.type.__hmrId) return true\r\n    instance = instance.parent\r\n  }\r\n}\r\n\r\nexport function updateProps(\r\n  instance: ComponentInternalInstance,\r\n  rawProps: Data | null,\r\n  rawPrevProps: Data | null,\r\n  optimized: boolean,\r\n) {\r\n  const {\r\n    props,\r\n    attrs,\r\n    vnode: { patchFlag },\r\n  } = instance\r\n  const rawCurrentProps = toRaw(props)\r\n  const [options] = instance.propsOptions\r\n  let hasAttrsChanged = false\r\n\r\n  if (\r\n    // always force full diff in dev\r\n    // - #1942 if hmr is enabled with sfc component\r\n    // - vite#872 non-sfc component used by sfc component\r\n    !(__DEV__ && isInHmrContext(instance)) &&\r\n    (optimized || patchFlag > 0) &&\r\n    !(patchFlag & PatchFlags.FULL_PROPS)\r\n  ) {\r\n    if (patchFlag & PatchFlags.PROPS) {\r\n      // Compiler-generated props & no keys change, just set the updated\r\n      // the props.\r\n      const propsToUpdate = instance.vnode.dynamicProps!\r\n      for (let i = 0; i < propsToUpdate.length; i++) {\r\n        let key = propsToUpdate[i]\r\n        // skip if the prop key is a declared emit event listener\r\n        if (isEmitListener(instance.emitsOptions, key)) {\r\n          continue\r\n        }\r\n        // PROPS flag guarantees rawProps to be non-null\r\n        const value = rawProps![key]\r\n        if (options) {\r\n          // attr / props separation was done on init and will be consistent\r\n          // in this code path, so just check if attrs have it.\r\n          if (hasOwn(attrs, key)) {\r\n            if (value !== attrs[key]) {\r\n              attrs[key] = value\r\n              hasAttrsChanged = true\r\n            }\r\n          } else {\r\n            const camelizedKey = camelize(key)\r\n            props[camelizedKey] = resolvePropValue(\r\n              options,\r\n              rawCurrentProps,\r\n              camelizedKey,\r\n              value,\r\n              instance,\r\n              false /* isAbsent */,\r\n            )\r\n          }\r\n        } else {\r\n          if (__COMPAT__) {\r\n            if (isOn(key) && key.endsWith('Native')) {\r\n              key = key.slice(0, -6) // remove Native postfix\r\n            } else if (shouldSkipAttr(key, instance)) {\r\n              continue\r\n            }\r\n          }\r\n          if (value !== attrs[key]) {\r\n            attrs[key] = value\r\n            hasAttrsChanged = true\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    // full props update.\r\n    if (setFullProps(instance, rawProps, props, attrs)) {\r\n      hasAttrsChanged = true\r\n    }\r\n    // in case of dynamic props, check if we need to delete keys from\r\n    // the props object\r\n    let kebabKey: string\r\n    for (const key in rawCurrentProps) {\r\n      if (\r\n        !rawProps ||\r\n        // for camelCase\r\n        (!hasOwn(rawProps, key) &&\r\n          // it's possible the original props was passed in as kebab-case\r\n          // and converted to camelCase (#955)\r\n          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey)))\r\n      ) {\r\n        if (options) {\r\n          if (\r\n            rawPrevProps &&\r\n            // for camelCase\r\n            (rawPrevProps[key] !== undefined ||\r\n              // for kebab-case\r\n              rawPrevProps[kebabKey!] !== undefined)\r\n          ) {\r\n            props[key] = resolvePropValue(\r\n              options,\r\n              rawCurrentProps,\r\n              key,\r\n              undefined,\r\n              instance,\r\n              true /* isAbsent */,\r\n            )\r\n          }\r\n        } else {\r\n          delete props[key]\r\n        }\r\n      }\r\n    }\r\n    // in the case of functional component w/o props declaration, props and\r\n    // attrs point to the same object so it should already have been updated.\r\n    if (attrs !== rawCurrentProps) {\r\n      for (const key in attrs) {\r\n        if (\r\n          !rawProps ||\r\n          (!hasOwn(rawProps, key) &&\r\n            (!__COMPAT__ || !hasOwn(rawProps, key + 'Native')))\r\n        ) {\r\n          delete attrs[key]\r\n          hasAttrsChanged = true\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // trigger updates for $attrs in case it's used in component slots\r\n  if (hasAttrsChanged) {\r\n    trigger(instance, TriggerOpTypes.SET, '$attrs')\r\n  }\r\n\r\n  if (__DEV__) {\r\n    validateProps(rawProps || {}, props, instance)\r\n  }\r\n}\r\n\r\nfunction setFullProps(\r\n  instance: ComponentInternalInstance,\r\n  rawProps: Data | null,\r\n  props: Data,\r\n  attrs: Data,\r\n) {\r\n  const [options, needCastKeys] = instance.propsOptions\r\n  let hasAttrsChanged = false\r\n  let rawCastValues: Data | undefined\r\n  if (rawProps) {\r\n    for (let key in rawProps) {\r\n      // key, ref are reserved and never passed down\r\n      if (isReservedProp(key)) {\r\n        continue\r\n      }\r\n\r\n      if (__COMPAT__) {\r\n        if (key.startsWith('onHook:')) {\r\n          softAssertCompatEnabled(\r\n            DeprecationTypes.INSTANCE_EVENT_HOOKS,\r\n            instance,\r\n            key.slice(2).toLowerCase(),\r\n          )\r\n        }\r\n        if (key === 'inline-template') {\r\n          continue\r\n        }\r\n      }\r\n\r\n      const value = rawProps[key]\r\n      // prop option names are camelized during normalization, so to support\r\n      // kebab -> camel conversion here we need to camelize the key.\r\n      let camelKey\r\n      if (options && hasOwn(options, (camelKey = camelize(key)))) {\r\n        if (!needCastKeys || !needCastKeys.includes(camelKey)) {\r\n          props[camelKey] = value\r\n        } else {\r\n          ;(rawCastValues || (rawCastValues = {}))[camelKey] = value\r\n        }\r\n      } else if (!isEmitListener(instance.emitsOptions, key)) {\r\n        // Any non-declared (either as a prop or an emitted event) props are put\r\n        // into a separate `attrs` object for spreading. Make sure to preserve\r\n        // original key casing\r\n        if (__COMPAT__) {\r\n          if (isOn(key) && key.endsWith('Native')) {\r\n            key = key.slice(0, -6) // remove Native postfix\r\n          } else if (shouldSkipAttr(key, instance)) {\r\n            continue\r\n          }\r\n        }\r\n        if (!(key in attrs) || value !== attrs[key]) {\r\n          attrs[key] = value\r\n          hasAttrsChanged = true\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (needCastKeys) {\r\n    const rawCurrentProps = toRaw(props)\r\n    const castValues = rawCastValues || EMPTY_OBJ\r\n    for (let i = 0; i < needCastKeys.length; i++) {\r\n      const key = needCastKeys[i]\r\n      props[key] = resolvePropValue(\r\n        options!,\r\n        rawCurrentProps,\r\n        key,\r\n        castValues[key],\r\n        instance,\r\n        !hasOwn(castValues, key),\r\n      )\r\n    }\r\n  }\r\n\r\n  return hasAttrsChanged\r\n}\r\n\r\nfunction resolvePropValue(\r\n  options: NormalizedProps,\r\n  props: Data,\r\n  key: string,\r\n  value: unknown,\r\n  instance: ComponentInternalInstance,\r\n  isAbsent: boolean,\r\n) {\r\n  const opt = options[key]\r\n  if (opt != null) {\r\n    const hasDefault = hasOwn(opt, 'default')\r\n    // default values\r\n    if (hasDefault && value === undefined) {\r\n      const defaultValue = opt.default\r\n      if (\r\n        opt.type !== Function &&\r\n        !opt.skipFactory &&\r\n        isFunction(defaultValue)\r\n      ) {\r\n        const { propsDefaults } = instance\r\n        if (key in propsDefaults) {\r\n          value = propsDefaults[key]\r\n        } else {\r\n          const reset = setCurrentInstance(instance)\r\n          value = propsDefaults[key] = defaultValue.call(\r\n            __COMPAT__ &&\r\n              isCompatEnabled(DeprecationTypes.PROPS_DEFAULT_THIS, instance)\r\n              ? createPropsDefaultThis(instance, props, key)\r\n              : null,\r\n            props,\r\n          )\r\n          reset()\r\n        }\r\n      } else {\r\n        value = defaultValue\r\n      }\r\n    }\r\n    // boolean casting\r\n    if (opt[BooleanFlags.shouldCast]) {\r\n      if (isAbsent && !hasDefault) {\r\n        value = false\r\n      } else if (\r\n        opt[BooleanFlags.shouldCastTrue] &&\r\n        (value === '' || value === hyphenate(key))\r\n      ) {\r\n        value = true\r\n      }\r\n    }\r\n  }\r\n  return value\r\n}\r\n\r\nexport function normalizePropsOptions(\r\n  comp: ConcreteComponent,\r\n  appContext: AppContext,\r\n  asMixin = false,\r\n): NormalizedPropsOptions {\r\n  const cache = appContext.propsCache\r\n  const cached = cache.get(comp)\r\n  if (cached) {\r\n    return cached\r\n  }\r\n\r\n  const raw = comp.props\r\n  const normalized: NormalizedPropsOptions[0] = {}\r\n  const needCastKeys: NormalizedPropsOptions[1] = []\r\n\r\n  // apply mixin/extends props\r\n  let hasExtends = false\r\n  if (__FEATURE_OPTIONS_API__ && !isFunction(comp)) {\r\n    const extendProps = (raw: ComponentOptions) => {\r\n      if (__COMPAT__ && isFunction(raw)) {\r\n        raw = raw.options\r\n      }\r\n      hasExtends = true\r\n      const [props, keys] = normalizePropsOptions(raw, appContext, true)\r\n      extend(normalized, props)\r\n      if (keys) needCastKeys.push(...keys)\r\n    }\r\n    if (!asMixin && appContext.mixins.length) {\r\n      appContext.mixins.forEach(extendProps)\r\n    }\r\n    if (comp.extends) {\r\n      extendProps(comp.extends)\r\n    }\r\n    if (comp.mixins) {\r\n      comp.mixins.forEach(extendProps)\r\n    }\r\n  }\r\n\r\n  if (!raw && !hasExtends) {\r\n    if (isObject(comp)) {\r\n      cache.set(comp, EMPTY_ARR as any)\r\n    }\r\n    return EMPTY_ARR as any\r\n  }\r\n\r\n  if (isArray(raw)) {\r\n    for (let i = 0; i < raw.length; i++) {\r\n      if (__DEV__ && !isString(raw[i])) {\r\n        warn(`props must be strings when using array syntax.`, raw[i])\r\n      }\r\n      const normalizedKey = camelize(raw[i])\r\n      if (validatePropName(normalizedKey)) {\r\n        normalized[normalizedKey] = EMPTY_OBJ\r\n      }\r\n    }\r\n  } else if (raw) {\r\n    if (__DEV__ && !isObject(raw)) {\r\n      warn(`invalid props options`, raw)\r\n    }\r\n    for (const key in raw) {\r\n      const normalizedKey = camelize(key)\r\n      if (validatePropName(normalizedKey)) {\r\n        const opt = raw[key]\r\n        const prop: NormalizedProp = (normalized[normalizedKey] =\r\n          isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt))\r\n        if (prop) {\r\n          const booleanIndex = getTypeIndex(Boolean, prop.type)\r\n          const stringIndex = getTypeIndex(String, prop.type)\r\n          prop[BooleanFlags.shouldCast] = booleanIndex > -1\r\n          prop[BooleanFlags.shouldCastTrue] =\r\n            stringIndex < 0 || booleanIndex < stringIndex\r\n          // if the prop needs boolean casting or default value\r\n          if (booleanIndex > -1 || hasOwn(prop, 'default')) {\r\n            needCastKeys.push(normalizedKey)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const res: NormalizedPropsOptions = [normalized, needCastKeys]\r\n  if (isObject(comp)) {\r\n    cache.set(comp, res)\r\n  }\r\n  return res\r\n}\r\n\r\nfunction validatePropName(key: string) {\r\n  if (key[0] !== '$') {\r\n    return true\r\n  } else if (__DEV__) {\r\n    warn(`Invalid prop name: \"${key}\" is a reserved property.`)\r\n  }\r\n  return false\r\n}\r\n\r\n// use function string name to check type constructors\r\n// so that it works across vms / iframes.\r\nfunction getType(ctor: Prop<any>): string {\r\n  const match = ctor && ctor.toString().match(/^\\s*(function|class) (\\w+)/)\r\n  return match ? match[2] : ctor === null ? 'null' : ''\r\n}\r\n\r\nfunction isSameType(a: Prop<any>, b: Prop<any>): boolean {\r\n  return getType(a) === getType(b)\r\n}\r\n\r\nfunction getTypeIndex(\r\n  type: Prop<any>,\r\n  expectedTypes: PropType<any> | void | null | true,\r\n): number {\r\n  if (isArray(expectedTypes)) {\r\n    return expectedTypes.findIndex(t => isSameType(t, type))\r\n  } else if (isFunction(expectedTypes)) {\r\n    return isSameType(expectedTypes, type) ? 0 : -1\r\n  }\r\n  return -1\r\n}\r\n\r\n/**\r\n * dev only\r\n */\r\nfunction validateProps(\r\n  rawProps: Data,\r\n  props: Data,\r\n  instance: ComponentInternalInstance,\r\n) {\r\n  const resolvedValues = toRaw(props)\r\n  const options = instance.propsOptions[0]\r\n  for (const key in options) {\r\n    let opt = options[key]\r\n    if (opt == null) continue\r\n    validateProp(\r\n      key,\r\n      resolvedValues[key],\r\n      opt,\r\n      __DEV__ ? shallowReadonly(resolvedValues) : resolvedValues,\r\n      !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key)),\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * dev only\r\n */\r\nfunction validateProp(\r\n  name: string,\r\n  value: unknown,\r\n  prop: PropOptions,\r\n  props: Data,\r\n  isAbsent: boolean,\r\n) {\r\n  const { type, required, validator, skipCheck } = prop\r\n  // required!\r\n  if (required && isAbsent) {\r\n    warn('Missing required prop: \"' + name + '\"')\r\n    return\r\n  }\r\n  // missing but optional\r\n  if (value == null && !required) {\r\n    return\r\n  }\r\n  // type check\r\n  if (type != null && type !== true && !skipCheck) {\r\n    let isValid = false\r\n    const types = isArray(type) ? type : [type]\r\n    const expectedTypes = []\r\n    // value is valid as long as one of the specified types match\r\n    for (let i = 0; i < types.length && !isValid; i++) {\r\n      const { valid, expectedType } = assertType(value, types[i])\r\n      expectedTypes.push(expectedType || '')\r\n      isValid = valid\r\n    }\r\n    if (!isValid) {\r\n      warn(getInvalidTypeMessage(name, value, expectedTypes))\r\n      return\r\n    }\r\n  }\r\n  // custom validator\r\n  if (validator && !validator(value, props)) {\r\n    warn('Invalid prop: custom validator check failed for prop \"' + name + '\".')\r\n  }\r\n}\r\n\r\nconst isSimpleType = /*#__PURE__*/ makeMap(\r\n  'String,Number,Boolean,Function,Symbol,BigInt',\r\n)\r\n\r\ntype AssertionResult = {\r\n  valid: boolean\r\n  expectedType: string\r\n}\r\n\r\n/**\r\n * dev only\r\n */\r\nfunction assertType(value: unknown, type: PropConstructor): AssertionResult {\r\n  let valid\r\n  const expectedType = getType(type)\r\n  if (isSimpleType(expectedType)) {\r\n    const t = typeof value\r\n    valid = t === expectedType.toLowerCase()\r\n    // for primitive wrapper objects\r\n    if (!valid && t === 'object') {\r\n      valid = value instanceof type\r\n    }\r\n  } else if (expectedType === 'Object') {\r\n    valid = isObject(value)\r\n  } else if (expectedType === 'Array') {\r\n    valid = isArray(value)\r\n  } else if (expectedType === 'null') {\r\n    valid = value === null\r\n  } else {\r\n    valid = value instanceof type\r\n  }\r\n  return {\r\n    valid,\r\n    expectedType,\r\n  }\r\n}\r\n\r\n/**\r\n * dev only\r\n */\r\nfunction getInvalidTypeMessage(\r\n  name: string,\r\n  value: unknown,\r\n  expectedTypes: string[],\r\n): string {\r\n  if (expectedTypes.length === 0) {\r\n    return (\r\n      `Prop type [] for prop \"${name}\" won't match anything.` +\r\n      ` Did you mean to use type Array instead?`\r\n    )\r\n  }\r\n  let message =\r\n    `Invalid prop: type check failed for prop \"${name}\".` +\r\n    ` Expected ${expectedTypes.map(capitalize).join(' | ')}`\r\n  const expectedType = expectedTypes[0]\r\n  const receivedType = toRawType(value)\r\n  const expectedValue = styleValue(value, expectedType)\r\n  const receivedValue = styleValue(value, receivedType)\r\n  // check if we need to specify expected value\r\n  if (\r\n    expectedTypes.length === 1 &&\r\n    isExplicable(expectedType) &&\r\n    !isBoolean(expectedType, receivedType)\r\n  ) {\r\n    message += ` with value ${expectedValue}`\r\n  }\r\n  message += `, got ${receivedType} `\r\n  // check if we need to specify received value\r\n  if (isExplicable(receivedType)) {\r\n    message += `with value ${receivedValue}.`\r\n  }\r\n  return message\r\n}\r\n\r\n/**\r\n * dev only\r\n */\r\nfunction styleValue(value: unknown, type: string): string {\r\n  if (type === 'String') {\r\n    return `\"${value}\"`\r\n  } else if (type === 'Number') {\r\n    return `${Number(value)}`\r\n  } else {\r\n    return `${value}`\r\n  }\r\n}\r\n\r\n/**\r\n * dev only\r\n */\r\nfunction isExplicable(type: string): boolean {\r\n  const explicitTypes = ['string', 'number', 'boolean']\r\n  return explicitTypes.some(elem => type.toLowerCase() === elem)\r\n}\r\n\r\n/**\r\n * dev only\r\n */\r\nfunction isBoolean(...args: string[]): boolean {\r\n  return args.some(elem => elem.toLowerCase() === 'boolean')\r\n}\r\n","import { type ComponentInternalInstance, currentInstance } from './component'\r\nimport {\r\n  InternalObjectKey,\r\n  type VNode,\r\n  type VNodeChild,\r\n  type VNodeNormalizedChildren,\r\n  normalizeVNode,\r\n} from './vnode'\r\nimport {\r\n  EMPTY_OBJ,\r\n  type IfAny,\r\n  type Prettify,\r\n  ShapeFlags,\r\n  SlotFlags,\r\n  def,\r\n  extend,\r\n  isArray,\r\n  isFunction,\r\n} from '@vue/shared'\r\nimport { warn } from './warning'\r\nimport { isKeepAlive } from './components/KeepAlive'\r\nimport { type ContextualRenderFn, withCtx } from './componentRenderContext'\r\nimport { isHmrUpdating } from './hmr'\r\nimport { DeprecationTypes, isCompatEnabled } from './compat/compatConfig'\r\nimport { toRaw } from '@vue/reactivity'\r\nimport { trigger } from '@vue/reactivity'\r\nimport { TriggerOpTypes } from '@vue/reactivity'\r\n\r\nexport type Slot<T extends any = any> = (\r\n  ...args: IfAny<T, any[], [T] | (T extends undefined ? [] : never)>\r\n) => VNode[]\r\n\r\nexport type InternalSlots = {\r\n  [name: string]: Slot | undefined\r\n}\r\n\r\nexport type Slots = Readonly<InternalSlots>\r\n\r\ndeclare const SlotSymbol: unique symbol\r\nexport type SlotsType<T extends Record<string, any> = Record<string, any>> = {\r\n  [SlotSymbol]?: T\r\n}\r\n\r\nexport type StrictUnwrapSlotsType<\r\n  S extends SlotsType,\r\n  T = NonNullable<S[typeof SlotSymbol]>,\r\n> = [keyof S] extends [never] ? Slots : Readonly<T> & T\r\n\r\nexport type UnwrapSlotsType<\r\n  S extends SlotsType,\r\n  T = NonNullable<S[typeof SlotSymbol]>,\r\n> = [keyof S] extends [never]\r\n  ? Slots\r\n  : Readonly<\r\n      Prettify<{\r\n        [K in keyof T]: NonNullable<T[K]> extends (...args: any[]) => any\r\n          ? T[K]\r\n          : Slot<T[K]>\r\n      }>\r\n    >\r\n\r\nexport type RawSlots = {\r\n  [name: string]: unknown\r\n  // manual render fn hint to skip forced children updates\r\n  $stable?: boolean\r\n  /**\r\n   * for tracking slot owner instance. This is attached during\r\n   * normalizeChildren when the component vnode is created.\r\n   * @internal\r\n   */\r\n  _ctx?: ComponentInternalInstance | null\r\n  /**\r\n   * indicates compiler generated slots\r\n   * we use a reserved property instead of a vnode patchFlag because the slots\r\n   * object may be directly passed down to a child component in a manual\r\n   * render function, and the optimization hint need to be on the slot object\r\n   * itself to be preserved.\r\n   * @internal\r\n   */\r\n  _?: SlotFlags\r\n}\r\n\r\nconst isInternalKey = (key: string) => key[0] === '_' || key === '$stable'\r\n\r\nconst normalizeSlotValue = (value: unknown): VNode[] =>\r\n  isArray(value)\r\n    ? value.map(normalizeVNode)\r\n    : [normalizeVNode(value as VNodeChild)]\r\n\r\nconst normalizeSlot = (\r\n  key: string,\r\n  rawSlot: Function,\r\n  ctx: ComponentInternalInstance | null | undefined,\r\n): Slot => {\r\n  if ((rawSlot as any)._n) {\r\n    // already normalized - #5353\r\n    return rawSlot as Slot\r\n  }\r\n  const normalized = withCtx((...args: any[]) => {\r\n    if (\r\n      __DEV__ &&\r\n      currentInstance &&\r\n      (!ctx || ctx.root === currentInstance.root)\r\n    ) {\r\n      warn(\r\n        `Slot \"${key}\" invoked outside of the render function: ` +\r\n          `this will not track dependencies used in the slot. ` +\r\n          `Invoke the slot function inside the render function instead.`,\r\n      )\r\n    }\r\n    return normalizeSlotValue(rawSlot(...args))\r\n  }, ctx) as Slot\r\n  // NOT a compiled slot\r\n  ;(normalized as ContextualRenderFn)._c = false\r\n  return normalized\r\n}\r\n\r\nconst normalizeObjectSlots = (\r\n  rawSlots: RawSlots,\r\n  slots: InternalSlots,\r\n  instance: ComponentInternalInstance,\r\n) => {\r\n  const ctx = rawSlots._ctx\r\n  for (const key in rawSlots) {\r\n    if (isInternalKey(key)) continue\r\n    const value = rawSlots[key]\r\n    if (isFunction(value)) {\r\n      slots[key] = normalizeSlot(key, value, ctx)\r\n    } else if (value != null) {\r\n      if (\r\n        __DEV__ &&\r\n        !(\r\n          __COMPAT__ &&\r\n          isCompatEnabled(DeprecationTypes.RENDER_FUNCTION, instance)\r\n        )\r\n      ) {\r\n        warn(\r\n          `Non-function value encountered for slot \"${key}\". ` +\r\n            `Prefer function slots for better performance.`,\r\n        )\r\n      }\r\n      const normalized = normalizeSlotValue(value)\r\n      slots[key] = () => normalized\r\n    }\r\n  }\r\n}\r\n\r\nconst normalizeVNodeSlots = (\r\n  instance: ComponentInternalInstance,\r\n  children: VNodeNormalizedChildren,\r\n) => {\r\n  if (\r\n    __DEV__ &&\r\n    !isKeepAlive(instance.vnode) &&\r\n    !(__COMPAT__ && isCompatEnabled(DeprecationTypes.RENDER_FUNCTION, instance))\r\n  ) {\r\n    warn(\r\n      `Non-function value encountered for default slot. ` +\r\n        `Prefer function slots for better performance.`,\r\n    )\r\n  }\r\n  const normalized = normalizeSlotValue(children)\r\n  instance.slots.default = () => normalized\r\n}\r\n\r\nexport const initSlots = (\r\n  instance: ComponentInternalInstance,\r\n  children: VNodeNormalizedChildren,\r\n) => {\r\n  if (instance.vnode.shapeFlag & ShapeFlags.SLOTS_CHILDREN) {\r\n    const type = (children as RawSlots)._\r\n    if (type) {\r\n      // users can get the shallow readonly version of the slots object through `this.$slots`,\r\n      // we should avoid the proxy object polluting the slots of the internal instance\r\n      instance.slots = toRaw(children as InternalSlots)\r\n      // make compiler marker non-enumerable\r\n      def(children as InternalSlots, '_', type)\r\n    } else {\r\n      normalizeObjectSlots(\r\n        children as RawSlots,\r\n        (instance.slots = {}),\r\n        instance,\r\n      )\r\n    }\r\n  } else {\r\n    instance.slots = {}\r\n    if (children) {\r\n      normalizeVNodeSlots(instance, children)\r\n    }\r\n  }\r\n  def(instance.slots, InternalObjectKey, 1)\r\n}\r\n\r\nexport const updateSlots = (\r\n  instance: ComponentInternalInstance,\r\n  children: VNodeNormalizedChildren,\r\n  optimized: boolean,\r\n) => {\r\n  const { vnode, slots } = instance\r\n  let needDeletionCheck = true\r\n  let deletionComparisonTarget = EMPTY_OBJ\r\n  if (vnode.shapeFlag & ShapeFlags.SLOTS_CHILDREN) {\r\n    const type = (children as RawSlots)._\r\n    if (type) {\r\n      // compiled slots.\r\n      if (__DEV__ && isHmrUpdating) {\r\n        // Parent was HMR updated so slot content may have changed.\r\n        // force update slots and mark instance for hmr as well\r\n        extend(slots, children as Slots)\r\n        trigger(instance, TriggerOpTypes.SET, '$slots')\r\n      } else if (optimized && type === SlotFlags.STABLE) {\r\n        // compiled AND stable.\r\n        // no need to update, and skip stale slots removal.\r\n        needDeletionCheck = false\r\n      } else {\r\n        // compiled but dynamic (v-if/v-for on slots) - update slots, but skip\r\n        // normalization.\r\n        extend(slots, children as Slots)\r\n        // #2893\r\n        // when rendering the optimized slots by manually written render function,\r\n        // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,\r\n        // i.e. let the `renderSlot` create the bailed Fragment\r\n        if (!optimized && type === SlotFlags.STABLE) {\r\n          delete slots._\r\n        }\r\n      }\r\n    } else {\r\n      needDeletionCheck = !(children as RawSlots).$stable\r\n      normalizeObjectSlots(children as RawSlots, slots, instance)\r\n    }\r\n    deletionComparisonTarget = children as RawSlots\r\n  } else if (children) {\r\n    // non slot object children (direct value) passed to a component\r\n    normalizeVNodeSlots(instance, children)\r\n    deletionComparisonTarget = { default: 1 }\r\n  }\r\n\r\n  // delete stale slots\r\n  if (needDeletionCheck) {\r\n    for (const key in slots) {\r\n      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {\r\n        delete slots[key]\r\n      }\r\n    }\r\n  }\r\n}\r\n","import type { SuspenseBoundary } from './components/Suspense'\r\nimport type { VNode, VNodeNormalizedRef, VNodeNormalizedRefAtom } from './vnode'\r\nimport {\r\n  EMPTY_OBJ,\r\n  ShapeFlags,\r\n  hasOwn,\r\n  isArray,\r\n  isFunction,\r\n  isString,\r\n  remove,\r\n} from '@vue/shared'\r\nimport { isAsyncWrapper } from './apiAsyncComponent'\r\nimport { getExposeProxy } from './component'\r\nimport { warn } from './warning'\r\nimport { isRef } from '@vue/reactivity'\r\nimport { ErrorCodes, callWithErrorHandling } from './errorHandling'\r\nimport type { SchedulerJob } from './scheduler'\r\nimport { queuePostRenderEffect } from './renderer'\r\n\r\n/**\r\n * Function for handling a template ref\r\n */\r\nexport function setRef(\r\n  rawRef: VNodeNormalizedRef,\r\n  oldRawRef: VNodeNormalizedRef | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  vnode: VNode,\r\n  isUnmount = false,\r\n) {\r\n  if (isArray(rawRef)) {\r\n    rawRef.forEach((r, i) =>\r\n      setRef(\r\n        r,\r\n        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),\r\n        parentSuspense,\r\n        vnode,\r\n        isUnmount,\r\n      ),\r\n    )\r\n    return\r\n  }\r\n\r\n  if (isAsyncWrapper(vnode) && !isUnmount) {\r\n    // when mounting async components, nothing needs to be done,\r\n    // because the template ref is forwarded to inner component\r\n    return\r\n  }\r\n\r\n  const refValue =\r\n    vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT\r\n      ? getExposeProxy(vnode.component!) || vnode.component!.proxy\r\n      : vnode.el\r\n  const value = isUnmount ? null : refValue\r\n\r\n  const { i: owner, r: ref } = rawRef\r\n  if (__DEV__ && !owner) {\r\n    warn(\r\n      `Missing ref owner context. ref cannot be used on hoisted vnodes. ` +\r\n        `A vnode with ref must be created inside the render function.`,\r\n    )\r\n    return\r\n  }\r\n  const oldRef = oldRawRef && (oldRawRef as VNodeNormalizedRefAtom).r\r\n  const refs = owner.refs === EMPTY_OBJ ? (owner.refs = {}) : owner.refs\r\n  const setupState = owner.setupState\r\n\r\n  // dynamic ref changed. unset old ref\r\n  if (oldRef != null && oldRef !== ref) {\r\n    if (isString(oldRef)) {\r\n      refs[oldRef] = null\r\n      if (hasOwn(setupState, oldRef)) {\r\n        setupState[oldRef] = null\r\n      }\r\n    } else if (isRef(oldRef)) {\r\n      oldRef.value = null\r\n    }\r\n  }\r\n\r\n  if (isFunction(ref)) {\r\n    callWithErrorHandling(ref, owner, ErrorCodes.FUNCTION_REF, [value, refs])\r\n  } else {\r\n    const _isString = isString(ref)\r\n    const _isRef = isRef(ref)\r\n    const isVFor = rawRef.f\r\n    if (_isString || _isRef) {\r\n      const doSet = () => {\r\n        if (isVFor) {\r\n          const existing = _isString\r\n            ? hasOwn(setupState, ref)\r\n              ? setupState[ref]\r\n              : refs[ref]\r\n            : ref.value\r\n          if (isUnmount) {\r\n            isArray(existing) && remove(existing, refValue)\r\n          } else {\r\n            if (!isArray(existing)) {\r\n              if (_isString) {\r\n                refs[ref] = [refValue]\r\n                if (hasOwn(setupState, ref)) {\r\n                  setupState[ref] = refs[ref]\r\n                }\r\n              } else {\r\n                ref.value = [refValue]\r\n                if (rawRef.k) refs[rawRef.k] = ref.value\r\n              }\r\n            } else if (!existing.includes(refValue)) {\r\n              existing.push(refValue)\r\n            }\r\n          }\r\n        } else if (_isString) {\r\n          refs[ref] = value\r\n          if (hasOwn(setupState, ref)) {\r\n            setupState[ref] = value\r\n          }\r\n        } else if (_isRef) {\r\n          ref.value = value\r\n          if (rawRef.k) refs[rawRef.k] = value\r\n        } else if (__DEV__) {\r\n          warn('Invalid template ref type:', ref, `(${typeof ref})`)\r\n        }\r\n      }\r\n      // #9908 ref on v-for mutates the same array for both mount and unmount\r\n      // and should be done together\r\n      if (isUnmount || isVFor) {\r\n        doSet()\r\n      } else {\r\n        // #1789: set new refs in a post job so that they don't get overwritten\r\n        // by unmounting ones.\r\n        ;(doSet as SchedulerJob).id = -1\r\n        queuePostRenderEffect(doSet, parentSuspense)\r\n      }\r\n    } else if (__DEV__) {\r\n      warn('Invalid template ref type:', ref, `(${typeof ref})`)\r\n    }\r\n  }\r\n}\r\n","import {\r\n  Comment,\r\n  Fragment,\r\n  Static,\r\n  Text,\r\n  type VNode,\r\n  type VNodeArrayChildren,\r\n  type VNodeHook,\r\n  type VNodeProps,\r\n  cloneIfMounted,\r\n  createVNode,\r\n  invokeVNodeHook,\r\n  isSameVNodeType,\r\n  normalizeVNode,\r\n} from './vnode'\r\nimport {\r\n  type ComponentInternalInstance,\r\n  type ComponentOptions,\r\n  type Data,\r\n  createComponentInstance,\r\n  setupComponent,\r\n} from './component'\r\nimport {\r\n  filterSingleRoot,\r\n  renderComponentRoot,\r\n  shouldUpdateComponent,\r\n  updateHOCHostEl,\r\n} from './componentRenderUtils'\r\nimport {\r\n  EMPTY_ARR,\r\n  EMPTY_OBJ,\r\n  NOOP,\r\n  PatchFlags,\r\n  ShapeFlags,\r\n  getGlobalThis,\r\n  invokeArrayFns,\r\n  isArray,\r\n  isReservedProp,\r\n} from '@vue/shared'\r\nimport {\r\n  type SchedulerJob,\r\n  flushPostFlushCbs,\r\n  flushPreFlushCbs,\r\n  invalidateJob,\r\n  queueJob,\r\n  queuePostFlushCb,\r\n} from './scheduler'\r\nimport { ReactiveEffect, pauseTracking, resetTracking } from '@vue/reactivity'\r\nimport { updateProps } from './componentProps'\r\nimport { updateSlots } from './componentSlots'\r\nimport { popWarningContext, pushWarningContext, warn } from './warning'\r\nimport { type CreateAppFunction, createAppAPI } from './apiCreateApp'\r\nimport { setRef } from './rendererTemplateRef'\r\nimport {\r\n  type SuspenseBoundary,\r\n  type SuspenseImpl,\r\n  queueEffectWithSuspense,\r\n} from './components/Suspense'\r\nimport type { TeleportImpl, TeleportVNode } from './components/Teleport'\r\nimport { type KeepAliveContext, isKeepAlive } from './components/KeepAlive'\r\nimport { isHmrUpdating, registerHMR, unregisterHMR } from './hmr'\r\nimport { type RootHydrateFunction, createHydrationFunctions } from './hydration'\r\nimport { invokeDirectiveHook } from './directives'\r\nimport { endMeasure, startMeasure } from './profiling'\r\nimport {\r\n  devtoolsComponentAdded,\r\n  devtoolsComponentRemoved,\r\n  devtoolsComponentUpdated,\r\n  setDevtoolsHook,\r\n} from './devtools'\r\nimport { initFeatureFlags } from './featureFlags'\r\nimport { isAsyncWrapper } from './apiAsyncComponent'\r\nimport { isCompatEnabled } from './compat/compatConfig'\r\nimport { DeprecationTypes } from './compat/compatConfig'\r\nimport type { TransitionHooks } from './components/BaseTransition'\r\n\r\nexport interface Renderer<HostElement = RendererElement> {\r\n  render: RootRenderFunction<HostElement>\r\n  createApp: CreateAppFunction<HostElement>\r\n}\r\n\r\nexport interface HydrationRenderer extends Renderer<Element | ShadowRoot> {\r\n  hydrate: RootHydrateFunction\r\n}\r\n\r\nexport type ElementNamespace = 'svg' | 'mathml' | undefined\r\n\r\nexport type RootRenderFunction<HostElement = RendererElement> = (\r\n  vnode: VNode | null,\r\n  container: HostElement,\r\n  namespace?: ElementNamespace,\r\n) => void\r\n\r\nexport interface RendererOptions<\r\n  HostNode = RendererNode,\r\n  HostElement = RendererElement,\r\n> {\r\n  patchProp(\r\n    el: HostElement,\r\n    key: string,\r\n    prevValue: any,\r\n    nextValue: any,\r\n    namespace?: ElementNamespace,\r\n    prevChildren?: VNode<HostNode, HostElement>[],\r\n    parentComponent?: ComponentInternalInstance | null,\r\n    parentSuspense?: SuspenseBoundary | null,\r\n    unmountChildren?: UnmountChildrenFn,\r\n  ): void\r\n  insert(el: HostNode, parent: HostElement, anchor?: HostNode | null): void\r\n  remove(el: HostNode): void\r\n  createElement(\r\n    type: string,\r\n    namespace?: ElementNamespace,\r\n    isCustomizedBuiltIn?: string,\r\n    vnodeProps?: (VNodeProps & { [key: string]: any }) | null,\r\n  ): HostElement\r\n  createText(text: string): HostNode\r\n  createComment(text: string): HostNode\r\n  setText(node: HostNode, text: string): void\r\n  setElementText(node: HostElement, text: string): void\r\n  parentNode(node: HostNode): HostElement | null\r\n  nextSibling(node: HostNode): HostNode | null\r\n  querySelector?(selector: string): HostElement | null\r\n  setScopeId?(el: HostElement, id: string): void\r\n  cloneNode?(node: HostNode): HostNode\r\n  insertStaticContent?(\r\n    content: string,\r\n    parent: HostElement,\r\n    anchor: HostNode | null,\r\n    namespace: ElementNamespace,\r\n    start?: HostNode | null,\r\n    end?: HostNode | null,\r\n  ): [HostNode, HostNode]\r\n}\r\n\r\n// Renderer Node can technically be any object in the context of core renderer\r\n// logic - they are never directly operated on and always passed to the node op\r\n// functions provided via options, so the internal constraint is really just\r\n// a generic object.\r\nexport interface RendererNode {\r\n  [key: string]: any\r\n}\r\n\r\nexport interface RendererElement extends RendererNode {}\r\n\r\n// An object exposing the internals of a renderer, passed to tree-shakeable\r\n// features so that they can be decoupled from this file. Keys are shortened\r\n// to optimize bundle size.\r\nexport interface RendererInternals<\r\n  HostNode = RendererNode,\r\n  HostElement = RendererElement,\r\n> {\r\n  p: PatchFn\r\n  um: UnmountFn\r\n  r: RemoveFn\r\n  m: MoveFn\r\n  mt: MountComponentFn\r\n  mc: MountChildrenFn\r\n  pc: PatchChildrenFn\r\n  pbc: PatchBlockChildrenFn\r\n  n: NextFn\r\n  o: RendererOptions<HostNode, HostElement>\r\n}\r\n\r\n// These functions are created inside a closure and therefore their types cannot\r\n// be directly exported. In order to avoid maintaining function signatures in\r\n// two places, we declare them once here and use them inside the closure.\r\ntype PatchFn = (\r\n  n1: VNode | null, // null means this is a mount\r\n  n2: VNode,\r\n  container: RendererElement,\r\n  anchor?: RendererNode | null,\r\n  parentComponent?: ComponentInternalInstance | null,\r\n  parentSuspense?: SuspenseBoundary | null,\r\n  namespace?: ElementNamespace,\r\n  slotScopeIds?: string[] | null,\r\n  optimized?: boolean,\r\n) => void\r\n\r\ntype MountChildrenFn = (\r\n  children: VNodeArrayChildren,\r\n  container: RendererElement,\r\n  anchor: RendererNode | null,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  namespace: ElementNamespace,\r\n  slotScopeIds: string[] | null,\r\n  optimized: boolean,\r\n  start?: number,\r\n) => void\r\n\r\ntype PatchChildrenFn = (\r\n  n1: VNode | null,\r\n  n2: VNode,\r\n  container: RendererElement,\r\n  anchor: RendererNode | null,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  namespace: ElementNamespace,\r\n  slotScopeIds: string[] | null,\r\n  optimized: boolean,\r\n) => void\r\n\r\ntype PatchBlockChildrenFn = (\r\n  oldChildren: VNode[],\r\n  newChildren: VNode[],\r\n  fallbackContainer: RendererElement,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  namespace: ElementNamespace,\r\n  slotScopeIds: string[] | null,\r\n) => void\r\n\r\ntype MoveFn = (\r\n  vnode: VNode,\r\n  container: RendererElement,\r\n  anchor: RendererNode | null,\r\n  type: MoveType,\r\n  parentSuspense?: SuspenseBoundary | null,\r\n) => void\r\n\r\ntype NextFn = (vnode: VNode) => RendererNode | null\r\n\r\ntype UnmountFn = (\r\n  vnode: VNode,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  doRemove?: boolean,\r\n  optimized?: boolean,\r\n) => void\r\n\r\ntype RemoveFn = (vnode: VNode) => void\r\n\r\ntype UnmountChildrenFn = (\r\n  children: VNode[],\r\n  parentComponent: ComponentInternalInstance | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  doRemove?: boolean,\r\n  optimized?: boolean,\r\n  start?: number,\r\n) => void\r\n\r\nexport type MountComponentFn = (\r\n  initialVNode: VNode,\r\n  container: RendererElement,\r\n  anchor: RendererNode | null,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  namespace: ElementNamespace,\r\n  optimized: boolean,\r\n) => void\r\n\r\ntype ProcessTextOrCommentFn = (\r\n  n1: VNode | null,\r\n  n2: VNode,\r\n  container: RendererElement,\r\n  anchor: RendererNode | null,\r\n) => void\r\n\r\nexport type SetupRenderEffectFn = (\r\n  instance: ComponentInternalInstance,\r\n  initialVNode: VNode,\r\n  container: RendererElement,\r\n  anchor: RendererNode | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  namespace: ElementNamespace,\r\n  optimized: boolean,\r\n) => void\r\n\r\nexport enum MoveType {\r\n  ENTER,\r\n  LEAVE,\r\n  REORDER, \r\n}\r\n\r\nexport const queuePostRenderEffect = __FEATURE_SUSPENSE__\r\n  ? __TEST__\r\n    ? // vitest can't seem to handle eager circular dependency\r\n      (fn: Function | Function[], suspense: SuspenseBoundary | null) =>\r\n        queueEffectWithSuspense(fn, suspense)\r\n    : queueEffectWithSuspense\r\n  : queuePostFlushCb\r\n\r\n/**\r\n * The createRenderer function accepts two generic arguments:\r\n * HostNode and HostElement, corresponding to Node and Element types in the\r\n * host environment. For example, for runtime-dom, HostNode would be the DOM\r\n * `Node` interface and HostElement would be the DOM `Element` interface.\r\n *\r\n * Custom renderers can pass in the platform specific types like this:\r\n *\r\n * ``` js\r\n * const { render, createApp } = createRenderer<Node, Element>({\r\n *   patchProp,\r\n *   ...nodeOps\r\n * })\r\n * ```\r\n */\r\nexport function createRenderer<\r\n  HostNode = RendererNode,\r\n  HostElement = RendererElement,\r\n>(options: RendererOptions<HostNode, HostElement>) {\r\n  return baseCreateRenderer<HostNode, HostElement>(options)\r\n}\r\n\r\n// Separate API for creating hydration-enabled renderer.\r\n// Hydration logic is only used when calling this function, making it\r\n// tree-shakable.\r\nexport function createHydrationRenderer(\r\n  options: RendererOptions<Node, Element>,\r\n) {\r\n  return baseCreateRenderer(options, createHydrationFunctions)\r\n}\r\n\r\n// overload 1: no hydration\r\nfunction baseCreateRenderer<\r\n  HostNode = RendererNode,\r\n  HostElement = RendererElement,\r\n>(options: RendererOptions<HostNode, HostElement>): Renderer<HostElement>\r\n\r\n// overload 2: with hydration\r\nfunction baseCreateRenderer(\r\n  options: RendererOptions<Node, Element>,\r\n  createHydrationFns: typeof createHydrationFunctions,\r\n): HydrationRenderer\r\n\r\n// implementation\r\nfunction baseCreateRenderer(\r\n  options: RendererOptions,\r\n  createHydrationFns?: typeof createHydrationFunctions,\r\n): any {\r\n  // compile-time feature flags check\r\n  if (__ESM_BUNDLER__ && !__TEST__) {\r\n    initFeatureFlags()\r\n  }\r\n\r\n  const target = getGlobalThis()\r\n  target.__VUE__ = true\r\n  if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target)\r\n  }\r\n\r\n  const {\r\n    insert: hostInsert,\r\n    remove: hostRemove,\r\n    patchProp: hostPatchProp,\r\n    createElement: hostCreateElement,\r\n    createText: hostCreateText,\r\n    createComment: hostCreateComment,\r\n    setText: hostSetText,\r\n    setElementText: hostSetElementText,\r\n    parentNode: hostParentNode,\r\n    nextSibling: hostNextSibling,\r\n    setScopeId: hostSetScopeId = NOOP,\r\n    insertStaticContent: hostInsertStaticContent,\r\n  } = options\r\n\r\n  // Note: functions inside this closure should use `const xxx = () => {}`\r\n  // style in order to prevent being inlined by minifiers.\r\n  const patch: PatchFn = (\r\n    n1,\r\n    n2,\r\n    container,\r\n    anchor = null,\r\n    parentComponent = null,\r\n    parentSuspense = null,\r\n    namespace = undefined,\r\n    slotScopeIds = null,\r\n    /**\r\n     * 在 Vue 3 的虚拟 DOM 中，一个 VNode 可以包含静态子节点和动态子节点。静态子节点在渲染过程中不会发生变化，而动态子节点可能会根据数据变化而更新\r\n     */\r\n    optimized = __DEV__ && isHmrUpdating ? false : !!n2.dynamicChildren,\r\n  ) => {\r\n    // 两个节点一样就返回\r\n    if (n1 === n2) {\r\n      return\r\n    }\r\n\r\n    // patching & not same type, unmount old tree\r\n    // old node存在且类型不一样，就卸载原来的节点\r\n    if (n1 && !isSameVNodeType(n1, n2)) {\r\n      anchor = getNextHostNode(n1)\r\n      unmount(n1, parentComponent, parentSuspense, true)\r\n      n1 = null\r\n    }\r\n\r\n    // 是否不需要优化\r\n    if (n2.patchFlag === PatchFlags.BAIL) {\r\n      optimized = false\r\n      n2.dynamicChildren = null\r\n    }\r\n\r\n    const { type, ref, shapeFlag } = n2\r\n    switch (type) {\r\n      case Text:\r\n        processText(n1, n2, container, anchor)\r\n        break\r\n      case Comment:\r\n        processCommentNode(n1, n2, container, anchor)\r\n        break\r\n      case Static:\r\n        if (n1 == null) {\r\n          mountStaticNode(n2, container, anchor, namespace)\r\n        } else if (__DEV__) {\r\n          patchStaticNode(n1, n2, container, namespace)\r\n        }\r\n        break\r\n      case Fragment:\r\n        processFragment(\r\n          n1,\r\n          n2,\r\n          container,\r\n          anchor,\r\n          parentComponent,\r\n          parentSuspense,\r\n          namespace,\r\n          slotScopeIds,\r\n          optimized,\r\n        )\r\n        break\r\n      default:\r\n        if (shapeFlag & ShapeFlags.ELEMENT) {\r\n          processElement(\r\n            n1,\r\n            n2,\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            parentSuspense,\r\n            namespace,\r\n            slotScopeIds,\r\n            optimized,\r\n          )\r\n        } else if (shapeFlag & ShapeFlags.COMPONENT) {\r\n          processComponent(\r\n            n1,\r\n            n2,\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            parentSuspense,\r\n            namespace,\r\n            slotScopeIds,\r\n            optimized,\r\n          )\r\n        } else if (shapeFlag & ShapeFlags.TELEPORT) {\r\n          ;(type as typeof TeleportImpl).process(\r\n            n1 as TeleportVNode,\r\n            n2 as TeleportVNode,\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            parentSuspense,\r\n            namespace,\r\n            slotScopeIds,\r\n            optimized,\r\n            internals,\r\n          )\r\n        } else if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {\r\n          ;(type as typeof SuspenseImpl).process(\r\n            n1,\r\n            n2,\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            parentSuspense,\r\n            namespace,\r\n            slotScopeIds,\r\n            optimized,\r\n            internals,\r\n          )\r\n        } else if (__DEV__) {\r\n          warn('Invalid VNode type:', type, `(${typeof type})`)\r\n        }\r\n    }\r\n\r\n    // set ref\r\n    if (ref != null && parentComponent) {\r\n      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2)\r\n    }\r\n  }\r\n\r\n  const processText: ProcessTextOrCommentFn = (n1, n2, container, anchor) => {\r\n    if (n1 == null) {\r\n      hostInsert(\r\n        (n2.el = hostCreateText(n2.children as string)),\r\n        container,\r\n        anchor,\r\n      )\r\n    } else {\r\n      const el = (n2.el = n1.el!)\r\n      if (n2.children !== n1.children) {\r\n        hostSetText(el, n2.children as string)\r\n      }\r\n    }\r\n  }\r\n\r\n  const processCommentNode: ProcessTextOrCommentFn = (\r\n    n1,\r\n    n2,\r\n    container,\r\n    anchor,\r\n  ) => {\r\n    if (n1 == null) {\r\n      hostInsert(\r\n        (n2.el = hostCreateComment((n2.children as string) || '')),\r\n        container,\r\n        anchor,\r\n      )\r\n    } else {\r\n      // there's no support for dynamic comments\r\n      n2.el = n1.el\r\n    }\r\n  }\r\n\r\n  const mountStaticNode = (\r\n    n2: VNode,\r\n    container: RendererElement,\r\n    anchor: RendererNode | null,\r\n    namespace: ElementNamespace,\r\n  ) => {\r\n    // static nodes are only present when used with compiler-dom/runtime-dom\r\n    // which guarantees presence of hostInsertStaticContent.\r\n    ;[n2.el, n2.anchor] = hostInsertStaticContent!(\r\n      n2.children as string,\r\n      container,\r\n      anchor,\r\n      namespace,\r\n      n2.el,\r\n      n2.anchor,\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Dev / HMR only\r\n   */\r\n  const patchStaticNode = (\r\n    n1: VNode,\r\n    n2: VNode,\r\n    container: RendererElement,\r\n    namespace: ElementNamespace,\r\n  ) => {\r\n    // static nodes are only patched during dev for HMR\r\n    if (n2.children !== n1.children) {\r\n      const anchor = hostNextSibling(n1.anchor!)\r\n      // remove existing\r\n      removeStaticNode(n1)\r\n      // insert new\r\n      ;[n2.el, n2.anchor] = hostInsertStaticContent!(\r\n        n2.children as string,\r\n        container,\r\n        anchor,\r\n        namespace,\r\n      )\r\n    } else {\r\n      n2.el = n1.el\r\n      n2.anchor = n1.anchor\r\n    }\r\n  }\r\n\r\n  const moveStaticNode = (\r\n    { el, anchor }: VNode,\r\n    container: RendererElement,\r\n    nextSibling: RendererNode | null,\r\n  ) => {\r\n    let next\r\n    while (el && el !== anchor) {\r\n      next = hostNextSibling(el)\r\n      hostInsert(el, container, nextSibling)\r\n      el = next\r\n    }\r\n    hostInsert(anchor!, container, nextSibling)\r\n  }\r\n\r\n  const removeStaticNode = ({ el, anchor }: VNode) => {\r\n    let next\r\n    while (el && el !== anchor) {\r\n      next = hostNextSibling(el)\r\n      hostRemove(el)\r\n      el = next\r\n    }\r\n    hostRemove(anchor!)\r\n  }\r\n\r\n  const processElement = (\r\n    n1: VNode | null,\r\n    n2: VNode,\r\n    container: RendererElement,\r\n    anchor: RendererNode | null,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    namespace: ElementNamespace,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean,\r\n  ) => {\r\n    if (n2.type === 'svg') {\r\n      namespace = 'svg'\r\n    } else if (n2.type === 'math') {\r\n      namespace = 'mathml'\r\n    }\r\n\r\n    if (n1 == null) {\r\n      mountElement(\r\n        n2,\r\n        container,\r\n        anchor,\r\n        parentComponent,\r\n        parentSuspense,\r\n        namespace,\r\n        slotScopeIds,\r\n        optimized,\r\n      )\r\n    } else {\r\n      patchElement(\r\n        n1,\r\n        n2,\r\n        parentComponent,\r\n        parentSuspense,\r\n        namespace,\r\n        slotScopeIds,\r\n        optimized,\r\n      )\r\n    }\r\n  }\r\n\r\n  const mountElement = (\r\n    vnode: VNode,\r\n    container: RendererElement,\r\n    anchor: RendererNode | null,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    namespace: ElementNamespace,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean,\r\n  ) => {\r\n    let el: RendererElement\r\n    let vnodeHook: VNodeHook | undefined | null\r\n    const { props, shapeFlag, transition, dirs } = vnode\r\n\r\n    el = vnode.el = hostCreateElement(\r\n      vnode.type as string,\r\n      namespace,\r\n      props && props.is,\r\n      props,\r\n    )\r\n\r\n    // mount children first, since some props may rely on child content\r\n    // being already rendered, e.g. `<select value>`\r\n    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n      hostSetElementText(el, vnode.children as string)\r\n    } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n      mountChildren(\r\n        vnode.children as VNodeArrayChildren,\r\n        el,\r\n        null,\r\n        parentComponent,\r\n        parentSuspense,\r\n        resolveChildrenNamespace(vnode, namespace),\r\n        slotScopeIds,\r\n        optimized,\r\n      )\r\n    }\r\n\r\n    if (dirs) {\r\n      invokeDirectiveHook(vnode, null, parentComponent, 'created')\r\n    }\r\n    // scopeId\r\n    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent)\r\n    // props\r\n    if (props) {\r\n      for (const key in props) {\r\n        if (key !== 'value' && !isReservedProp(key)) {\r\n          hostPatchProp(\r\n            el,\r\n            key,\r\n            null,\r\n            props[key],\r\n            namespace,\r\n            vnode.children as VNode[],\r\n            parentComponent,\r\n            parentSuspense,\r\n            unmountChildren,\r\n          )\r\n        }\r\n      }\r\n      /**\r\n       * Special case for setting value on DOM elements:\r\n       * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)\r\n       * - it needs to be forced (#1471)\r\n       * #2353 proposes adding another renderer option to configure this, but\r\n       * the properties affects are so finite it is worth special casing it\r\n       * here to reduce the complexity. (Special casing it also should not\r\n       * affect non-DOM renderers)\r\n       */\r\n      if ('value' in props) {\r\n        hostPatchProp(el, 'value', null, props.value, namespace)\r\n      }\r\n      if ((vnodeHook = props.onVnodeBeforeMount)) {\r\n        invokeVNodeHook(vnodeHook, parentComponent, vnode)\r\n      }\r\n    }\r\n\r\n    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n      Object.defineProperty(el, '__vnode', {\r\n        value: vnode,\r\n        enumerable: false,\r\n      })\r\n      Object.defineProperty(el, '__vueParentComponent', {\r\n        value: parentComponent,\r\n        enumerable: false,\r\n      })\r\n    }\r\n    if (dirs) {\r\n      invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount')\r\n    }\r\n    // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved\r\n    // #1689 For inside suspense + suspense resolved case, just call it\r\n    const needCallTransitionHooks = needTransition(parentSuspense, transition)\r\n    if (needCallTransitionHooks) {\r\n      transition!.beforeEnter(el)\r\n    }\r\n    hostInsert(el, container, anchor)\r\n    if (\r\n      (vnodeHook = props && props.onVnodeMounted) ||\r\n      needCallTransitionHooks ||\r\n      dirs\r\n    ) {\r\n      queuePostRenderEffect(() => {\r\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode)\r\n        needCallTransitionHooks && transition!.enter(el)\r\n        dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted')\r\n      }, parentSuspense)\r\n    }\r\n  }\r\n\r\n  const setScopeId = (\r\n    el: RendererElement,\r\n    vnode: VNode,\r\n    scopeId: string | null,\r\n    slotScopeIds: string[] | null,\r\n    parentComponent: ComponentInternalInstance | null,\r\n  ) => {\r\n    if (scopeId) {\r\n      hostSetScopeId(el, scopeId)\r\n    }\r\n    if (slotScopeIds) {\r\n      for (let i = 0; i < slotScopeIds.length; i++) {\r\n        hostSetScopeId(el, slotScopeIds[i])\r\n      }\r\n    }\r\n    if (parentComponent) {\r\n      let subTree = parentComponent.subTree\r\n      if (\r\n        __DEV__ &&\r\n        subTree.patchFlag > 0 &&\r\n        subTree.patchFlag & PatchFlags.DEV_ROOT_FRAGMENT\r\n      ) {\r\n        subTree =\r\n          filterSingleRoot(subTree.children as VNodeArrayChildren) || subTree\r\n      }\r\n      if (vnode === subTree) {\r\n        const parentVNode = parentComponent.vnode\r\n        setScopeId(\r\n          el,\r\n          parentVNode,\r\n          parentVNode.scopeId,\r\n          parentVNode.slotScopeIds,\r\n          parentComponent.parent,\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  const mountChildren: MountChildrenFn = (\r\n    children,\r\n    container,\r\n    anchor,\r\n    parentComponent,\r\n    parentSuspense,\r\n    namespace: ElementNamespace,\r\n    slotScopeIds,\r\n    optimized,\r\n    start = 0,\r\n  ) => {\r\n    for (let i = start; i < children.length; i++) {\r\n      const child = (children[i] = optimized\r\n        ? cloneIfMounted(children[i] as VNode)\r\n        : normalizeVNode(children[i]))\r\n      patch(\r\n        null,\r\n        child,\r\n        container,\r\n        anchor,\r\n        parentComponent,\r\n        parentSuspense,\r\n        namespace,\r\n        slotScopeIds,\r\n        optimized,\r\n      )\r\n    }\r\n  }\r\n\r\n  const patchElement = (\r\n    n1: VNode,\r\n    n2: VNode,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    namespace: ElementNamespace,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean,\r\n  ) => {\r\n    const el = (n2.el = n1.el!)\r\n    let { patchFlag, dynamicChildren, dirs } = n2\r\n    // #1426 take the old vnode's patch flag into account since user may clone a compiler-generated vnode, which de-opts to FULL_PROPS\r\n    /**\r\n     * 这段代码的主要目的是确保在某些特殊情况下（如用户克隆了一个编译器生成的 VNode），仍然能够正确处理属性的更新。具体来说，若旧的 VNode 是 FULL_PROPS，则新 VNode 也应该继承这个标志，从而避免性能优化的失效或更新行为的不一致性。\r\n    比如v-bind\r\n    */\r\n    patchFlag |= n1.patchFlag & PatchFlags.FULL_PROPS\r\n    const oldProps = n1.props || EMPTY_OBJ\r\n    const newProps = n2.props || EMPTY_OBJ\r\n    let vnodeHook: VNodeHook | undefined | null\r\n\r\n    // disable recurse in beforeUpdate hooks\r\n    /**\r\n     * 这段代码的主要作用是在组件更新前暂时禁用父组件的递归更新，确保更新过程不会出现递归循环问题。它同时还会触发 beforeUpdate 钩子函数和指令钩子函数，在更新发生前执行必要的操作。最后重新启用父组件的递归更新。\r\n     */\r\n    parentComponent && toggleRecurse(parentComponent, false)\r\n    if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {\r\n      invokeVNodeHook(vnodeHook, parentComponent, n2, n1)\r\n    }\r\n    if (dirs) {\r\n      invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate')\r\n    }\r\n    parentComponent && toggleRecurse(parentComponent, true)\r\n\r\n    if (__DEV__ && isHmrUpdating) {\r\n      // HMR updated, force full diff\r\n      patchFlag = 0\r\n      optimized = false\r\n      dynamicChildren = null\r\n    }\r\n\r\n    if (dynamicChildren) {\r\n      // \r\n      patchBlockChildren(\r\n        n1.dynamicChildren!,\r\n        dynamicChildren,\r\n        el,\r\n        parentComponent,\r\n        parentSuspense,\r\n        resolveChildrenNamespace(n2, namespace),\r\n        slotScopeIds,\r\n      )\r\n      if (__DEV__) {\r\n        // necessary for HMR\r\n        traverseStaticChildren(n1, n2)\r\n      }\r\n    } else if (!optimized) {\r\n      // full diff\r\n      patchChildren(\r\n        n1,\r\n        n2,\r\n        el,\r\n        null,\r\n        parentComponent,\r\n        parentSuspense,\r\n        resolveChildrenNamespace(n2, namespace),\r\n        slotScopeIds,\r\n        false,\r\n      )\r\n    }\r\n\r\n    if (patchFlag > 0) {\r\n      // the presence of a patchFlag means this element's render code was\r\n      // generated by the compiler and can take the fast path.\r\n      // in this path old node and new node are guaranteed to have the same shape\r\n      // (i.e. at the exact same position in the source template)\r\n      if (patchFlag & PatchFlags.FULL_PROPS) { // 全部props都更新\r\n        // element props contain dynamic keys, full diff needed\r\n        patchProps(\r\n          el,\r\n          n2,\r\n          oldProps,\r\n          newProps,\r\n          parentComponent,\r\n          parentSuspense,\r\n          namespace,\r\n        )\r\n      } else {\r\n        // class\r\n        // this flag is matched when the element has dynamic class bindings.\r\n        // 只更新class\r\n        if (patchFlag & PatchFlags.CLASS) {\r\n          if (oldProps.class !== newProps.class) {\r\n            hostPatchProp(el, 'class', null, newProps.class, namespace)\r\n          }\r\n        }\r\n\r\n        // style\r\n        // this flag is matched when the element has dynamic style bindings\r\n        // 只更新style\r\n        if (patchFlag & PatchFlags.STYLE) {\r\n          hostPatchProp(el, 'style', oldProps.style, newProps.style, namespace)\r\n        }\r\n\r\n        // props\r\n        // This flag is matched when the element has dynamic prop/attr bindings\r\n        // other than class and style. The keys of dynamic prop/attrs are saved for\r\n        // faster iteration.\r\n        // Note dynamic keys like :[foo]=\"bar\" will cause this optimization to\r\n        // bail out and go through a full diff because we need to unset the old key\r\n        // 只更新动态props\r\n        if (patchFlag & PatchFlags.PROPS) {\r\n          // if the flag is present then dynamicProps must be non-null\r\n          const propsToUpdate = n2.dynamicProps!\r\n          for (let i = 0; i < propsToUpdate.length; i++) {\r\n            const key = propsToUpdate[i]\r\n            const prev = oldProps[key]\r\n            const next = newProps[key]\r\n            // #1471 force patch value\r\n            if (next !== prev || key === 'value') {\r\n              hostPatchProp(\r\n                el,\r\n                key,\r\n                prev,\r\n                next,\r\n                namespace,\r\n                n1.children as VNode[],\r\n                parentComponent,\r\n                parentSuspense,\r\n                unmountChildren,\r\n              )\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // text\r\n      // This flag is matched when the element has only dynamic text children.\r\n      // 更新文本\r\n      if (patchFlag & PatchFlags.TEXT) {\r\n        if (n1.children !== n2.children) {\r\n          hostSetElementText(el, n2.children as string)\r\n        }\r\n      }\r\n    } else if (!optimized && dynamicChildren == null) {\r\n      // unoptimized, full diff\r\n      patchProps(\r\n        el,\r\n        n2,\r\n        oldProps,\r\n        newProps,\r\n        parentComponent,\r\n        parentSuspense,\r\n        namespace,\r\n      )\r\n    }\r\n\r\n    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\r\n      queuePostRenderEffect(() => {\r\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1)\r\n        dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated')\r\n      }, parentSuspense)\r\n    }\r\n  }\r\n\r\n  // The fast path for blocks.\r\n  const patchBlockChildren: PatchBlockChildrenFn = (\r\n    oldChildren,\r\n    newChildren,\r\n    fallbackContainer,\r\n    parentComponent,\r\n    parentSuspense,\r\n    namespace: ElementNamespace,\r\n    slotScopeIds,\r\n  ) => {\r\n    for (let i = 0; i < newChildren.length; i++) {\r\n      const oldVNode = oldChildren[i]\r\n      const newVNode = newChildren[i]\r\n      // Determine the container (parent element) for the patch.\r\n      const container =\r\n        // oldVNode may be an errored async setup() component inside Suspense\r\n        // which will not have a mounted element\r\n        oldVNode.el &&\r\n        // - In the case of a Fragment, we need to provide the actual parent\r\n        // of the Fragment itself so it can move its children.\r\n        (oldVNode.type === Fragment ||\r\n          // - In the case of different nodes, there is going to be a replacement\r\n          // which also requires the correct parent container\r\n          !isSameVNodeType(oldVNode, newVNode) ||\r\n          // - In the case of a component, it could contain anything.\r\n          oldVNode.shapeFlag & (ShapeFlags.COMPONENT | ShapeFlags.TELEPORT))\r\n          ? hostParentNode(oldVNode.el)!\r\n          : // In other cases, the parent container is not actually used so we\r\n            // just pass the block element here to avoid a DOM parentNode call.\r\n            fallbackContainer\r\n      patch(\r\n        oldVNode,\r\n        newVNode,\r\n        container,\r\n        null,\r\n        parentComponent,\r\n        parentSuspense,\r\n        namespace,\r\n        slotScopeIds,\r\n        true,\r\n      )\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 更新属性props\r\n   */\r\n  const patchProps = (\r\n    el: RendererElement,\r\n    vnode: VNode,\r\n    oldProps: Data,\r\n    newProps: Data,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    namespace: ElementNamespace,\r\n  ) => {\r\n    if (oldProps !== newProps) {\r\n      if (oldProps !== EMPTY_OBJ) {\r\n        for (const key in oldProps) {\r\n          if (!isReservedProp(key) && !(key in newProps)) {\r\n            // 在oldProps，不在newProps的卸载\r\n            hostPatchProp(\r\n              el,\r\n              key,\r\n              oldProps[key],\r\n              null,\r\n              namespace,\r\n              vnode.children as VNode[],\r\n              parentComponent,\r\n              parentSuspense,\r\n              unmountChildren,\r\n            )\r\n          }\r\n        }\r\n      }\r\n      // 在newProps的更新上去\r\n      for (const key in newProps) {\r\n        // empty string is not valid prop\r\n        if (isReservedProp(key)) continue\r\n        const next = newProps[key]\r\n        const prev = oldProps[key]\r\n        // defer patching value\r\n        if (next !== prev && key !== 'value') {\r\n          hostPatchProp(\r\n            el,\r\n            key,\r\n            prev,\r\n            next,\r\n            namespace,\r\n            vnode.children as VNode[],\r\n            parentComponent,\r\n            parentSuspense,\r\n            unmountChildren,\r\n          )\r\n        }\r\n      }\r\n      if ('value' in newProps) {\r\n        hostPatchProp(el, 'value', oldProps.value, newProps.value, namespace)\r\n      }\r\n    }\r\n  }\r\n\r\n  const processFragment = (\r\n    n1: VNode | null,\r\n    n2: VNode,\r\n    container: RendererElement,\r\n    anchor: RendererNode | null,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    namespace: ElementNamespace,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean,\r\n  ) => {\r\n    const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''))!\r\n    const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''))!\r\n\r\n    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2\r\n\r\n    if (\r\n      __DEV__ &&\r\n      // #5523 dev root fragment may inherit directives\r\n      (isHmrUpdating || patchFlag & PatchFlags.DEV_ROOT_FRAGMENT)\r\n    ) {\r\n      // HMR updated / Dev root fragment (w/ comments), force full diff\r\n      patchFlag = 0\r\n      optimized = false\r\n      dynamicChildren = null\r\n    }\r\n\r\n    // check if this is a slot fragment with :slotted scope ids\r\n    if (fragmentSlotScopeIds) {\r\n      slotScopeIds = slotScopeIds\r\n        ? slotScopeIds.concat(fragmentSlotScopeIds)\r\n        : fragmentSlotScopeIds\r\n    }\r\n\r\n    if (n1 == null) {\r\n      hostInsert(fragmentStartAnchor, container, anchor)\r\n      hostInsert(fragmentEndAnchor, container, anchor)\r\n      // a fragment can only have array children\r\n      // since they are either generated by the compiler, or implicitly created\r\n      // from arrays.\r\n      mountChildren(\r\n        // #10007\r\n        // such fragment like `<></>` will be compiled into\r\n        // a fragment which doesn't have a children.\r\n        // In this case fallback to an empty array\r\n        (n2.children || []) as VNodeArrayChildren,\r\n        container,\r\n        fragmentEndAnchor,\r\n        parentComponent,\r\n        parentSuspense,\r\n        namespace,\r\n        slotScopeIds,\r\n        optimized,\r\n      )\r\n    } else {\r\n      if (\r\n        patchFlag > 0 &&\r\n        patchFlag & PatchFlags.STABLE_FRAGMENT &&\r\n        dynamicChildren &&\r\n        // #2715 the previous fragment could've been a BAILed one as a result\r\n        // of renderSlot() with no valid children\r\n        n1.dynamicChildren\r\n      ) {\r\n        // a stable fragment (template root or <template v-for>) doesn't need to\r\n        // patch children order, but it may contain dynamicChildren.\r\n        patchBlockChildren(\r\n          n1.dynamicChildren,\r\n          dynamicChildren,\r\n          container,\r\n          parentComponent,\r\n          parentSuspense,\r\n          namespace,\r\n          slotScopeIds,\r\n        )\r\n        if (__DEV__) {\r\n          // necessary for HMR\r\n          traverseStaticChildren(n1, n2)\r\n        } else if (\r\n          // #2080 if the stable fragment has a key, it's a <template v-for> that may\r\n          //  get moved around. Make sure all root level vnodes inherit el.\r\n          // #2134 or if it's a component root, it may also get moved around\r\n          // as the component is being moved.\r\n          n2.key != null ||\r\n          (parentComponent && n2 === parentComponent.subTree)\r\n        ) {\r\n          traverseStaticChildren(n1, n2, true /* shallow */)\r\n        }\r\n      } else {\r\n        // keyed / unkeyed, or manual fragments.\r\n        // for keyed & unkeyed, since they are compiler generated from v-for,\r\n        // each child is guaranteed to be a block so the fragment will never\r\n        // have dynamicChildren.\r\n        patchChildren(\r\n          n1,\r\n          n2,\r\n          container,\r\n          fragmentEndAnchor,\r\n          parentComponent,\r\n          parentSuspense,\r\n          namespace,\r\n          slotScopeIds,\r\n          optimized,\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  const processComponent = (\r\n    n1: VNode | null,\r\n    n2: VNode,\r\n    container: RendererElement,\r\n    anchor: RendererNode | null,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    namespace: ElementNamespace,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean,\r\n  ) => {\r\n    n2.slotScopeIds = slotScopeIds\r\n    if (n1 == null) {\r\n      // 如果是keep-alive的模式，则是激活组件\r\n      if (n2.shapeFlag & ShapeFlags.COMPONENT_KEPT_ALIVE) {\r\n        ;(parentComponent!.ctx as KeepAliveContext).activate(\r\n          n2,\r\n          container,\r\n          anchor,\r\n          namespace,\r\n          optimized,\r\n        )\r\n      } else {\r\n        // n1不存在挂载节点\r\n        mountComponent(\r\n          n2,\r\n          container,\r\n          anchor,\r\n          parentComponent,\r\n          parentSuspense,\r\n          namespace,\r\n          optimized,\r\n        )\r\n      }\r\n    } else {\r\n      // 如果n1、n2都存在就是更新\r\n      updateComponent(n1, n2, optimized)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 执行\r\n   */\r\n  const mountComponent: MountComponentFn = (\r\n    initialVNode,\r\n    container,\r\n    anchor,\r\n    parentComponent,\r\n    parentSuspense,\r\n    namespace: ElementNamespace,\r\n    optimized,\r\n  ) => {\r\n    // 2.x compat may pre-create the component instance before actually\r\n    // mounting\r\n    const compatMountInstance =\r\n      __COMPAT__ && initialVNode.isCompatRoot && initialVNode.component\r\n    // 创建虚拟节点对应的组件实例对象\r\n    const instance: ComponentInternalInstance =\r\n      compatMountInstance ||\r\n      (initialVNode.component = createComponentInstance(\r\n        initialVNode,\r\n        parentComponent,\r\n        parentSuspense,\r\n      ))\r\n\r\n    if (__DEV__ && instance.type.__hmrId) {\r\n      registerHMR(instance)\r\n    }\r\n\r\n    if (__DEV__) {\r\n      pushWarningContext(initialVNode)\r\n      startMeasure(instance, `mount`)\r\n    }\r\n\r\n    // inject renderer internals for keepAlive\r\n    if (isKeepAlive(initialVNode)) {\r\n      ;(instance.ctx as KeepAliveContext).renderer = internals\r\n    }\r\n\r\n    // resolve props and slots for setup context\r\n    // 先记录setupComponent方法执行所使用的时间\r\n    if (!(__COMPAT__ && compatMountInstance)) {\r\n      if (__DEV__) {\r\n        startMeasure(instance, `init`)\r\n      }\r\n      //执行组件的setup方法，然后根据template模板（解析模板）组装render函数\r\n      setupComponent(instance)\r\n      if (__DEV__) {\r\n        endMeasure(instance, `init`)\r\n      }\r\n    }\r\n\r\n    // setup() is async. This component relies on async logic to be resolved\r\n    // before proceeding\r\n    if (__FEATURE_SUSPENSE__ && instance.asyncDep) {\r\n      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect)\r\n\r\n      // Give it a placeholder if this is not hydration\r\n      // TODO handle self-defined fallback\r\n      if (!initialVNode.el) {\r\n        const placeholder = (instance.subTree = createVNode(Comment))\r\n        processCommentNode(null, placeholder, container!, anchor)\r\n      }\r\n    } else {\r\n      // 执行render函数\r\n      setupRenderEffect(\r\n        instance,\r\n        initialVNode,\r\n        container,\r\n        anchor,\r\n        parentSuspense,\r\n        namespace,\r\n        optimized,\r\n      )\r\n    }\r\n\r\n    if (__DEV__) {\r\n      popWarningContext()\r\n      endMeasure(instance, `mount`)\r\n    }\r\n  }\r\n\r\n  const updateComponent = (n1: VNode, n2: VNode, optimized: boolean) => {\r\n    const instance = (n2.component = n1.component)!\r\n    if (shouldUpdateComponent(n1, n2, optimized)) {\r\n      if (\r\n        __FEATURE_SUSPENSE__ &&\r\n        instance.asyncDep &&\r\n        !instance.asyncResolved\r\n      ) {\r\n        // async & still pending - just update props and slots\r\n        // since the component's reactive effect for render isn't set-up yet\r\n        if (__DEV__) {\r\n          pushWarningContext(n2)\r\n        }\r\n        updateComponentPreRender(instance, n2, optimized)\r\n        if (__DEV__) {\r\n          popWarningContext()\r\n        }\r\n        return\r\n      } else {\r\n        // normal update\r\n        instance.next = n2\r\n        // in case the child component is also queued, remove it to avoid\r\n        // double updating the same child component in the same flush.\r\n        invalidateJob(instance.update)\r\n        // instance.update is the reactive effect.\r\n        instance.effect.dirty = true\r\n        instance.update()\r\n      }\r\n    } else {\r\n      // no update needed. just copy over properties\r\n      n2.el = n1.el\r\n      instance.vnode = n2\r\n    }\r\n  }\r\n\r\n  const setupRenderEffect: SetupRenderEffectFn = (\r\n    instance,\r\n    initialVNode,\r\n    container,\r\n    anchor,\r\n    parentSuspense,\r\n    namespace: ElementNamespace,\r\n    optimized,\r\n  ) => {\r\n    const componentUpdateFn = () => {\r\n      if (!instance.isMounted) {\r\n        let vnodeHook: VNodeHook | null | undefined\r\n        const { el, props } = initialVNode\r\n        const { bm, m, parent } = instance\r\n        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode)\r\n\r\n        toggleRecurse(instance, false)\r\n        // beforeMount hook\r\n        if (bm) {\r\n          invokeArrayFns(bm)\r\n        }\r\n        // onVnodeBeforeMount\r\n        if (\r\n          !isAsyncWrapperVNode &&\r\n          (vnodeHook = props && props.onVnodeBeforeMount)\r\n        ) {\r\n          invokeVNodeHook(vnodeHook, parent, initialVNode)\r\n        }\r\n        if (\r\n          __COMPAT__ &&\r\n          isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\r\n        ) {\r\n          instance.emit('hook:beforeMount')\r\n        }\r\n        toggleRecurse(instance, true)\r\n\r\n        if (el && hydrateNode) {\r\n          // vnode has adopted host node - perform hydration instead of mount.\r\n          const hydrateSubTree = () => {\r\n            if (__DEV__) {\r\n              startMeasure(instance, `render`)\r\n            }\r\n            instance.subTree = renderComponentRoot(instance)\r\n            if (__DEV__) {\r\n              endMeasure(instance, `render`)\r\n            }\r\n            if (__DEV__) {\r\n              startMeasure(instance, `hydrate`)\r\n            }\r\n            hydrateNode!(\r\n              el as Node,\r\n              instance.subTree,\r\n              instance,\r\n              parentSuspense,\r\n              null,\r\n            )\r\n            if (__DEV__) {\r\n              endMeasure(instance, `hydrate`)\r\n            }\r\n          }\r\n\r\n          if (isAsyncWrapperVNode) {\r\n            ;(initialVNode.type as ComponentOptions).__asyncLoader!().then(\r\n              // note: we are moving the render call into an async callback,\r\n              // which means it won't track dependencies - but it's ok because\r\n              // a server-rendered async wrapper is already in resolved state\r\n              // and it will never need to change.\r\n              () => !instance.isUnmounted && hydrateSubTree(),\r\n            )\r\n          } else {\r\n            hydrateSubTree()\r\n          }\r\n        } else {\r\n          if (__DEV__) {\r\n            startMeasure(instance, `render`)\r\n          }\r\n          const subTree = (instance.subTree = renderComponentRoot(instance))\r\n          if (__DEV__) {\r\n            endMeasure(instance, `render`)\r\n          }\r\n          if (__DEV__) {\r\n            startMeasure(instance, `patch`)\r\n          }\r\n          patch(\r\n            null,\r\n            subTree,\r\n            container,\r\n            anchor,\r\n            instance,\r\n            parentSuspense,\r\n            namespace,\r\n          )\r\n          if (__DEV__) {\r\n            endMeasure(instance, `patch`)\r\n          }\r\n          initialVNode.el = subTree.el\r\n        }\r\n        // mounted hook\r\n        if (m) {\r\n          queuePostRenderEffect(m, parentSuspense)\r\n        }\r\n        // onVnodeMounted\r\n        if (\r\n          !isAsyncWrapperVNode &&\r\n          (vnodeHook = props && props.onVnodeMounted)\r\n        ) {\r\n          const scopedInitialVNode = initialVNode\r\n          queuePostRenderEffect(\r\n            () => invokeVNodeHook(vnodeHook!, parent, scopedInitialVNode),\r\n            parentSuspense,\r\n          )\r\n        }\r\n        if (\r\n          __COMPAT__ &&\r\n          isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\r\n        ) {\r\n          queuePostRenderEffect(\r\n            () => instance.emit('hook:mounted'),\r\n            parentSuspense,\r\n          )\r\n        }\r\n\r\n        // activated hook for keep-alive roots.\r\n        // #1742 activated hook must be accessed after first render\r\n        // since the hook may be injected by a child keep-alive\r\n        if (\r\n          initialVNode.shapeFlag & ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE ||\r\n          (parent &&\r\n            isAsyncWrapper(parent.vnode) &&\r\n            parent.vnode.shapeFlag & ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE)\r\n        ) {\r\n          instance.a && queuePostRenderEffect(instance.a, parentSuspense)\r\n          if (\r\n            __COMPAT__ &&\r\n            isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\r\n          ) {\r\n            queuePostRenderEffect(\r\n              () => instance.emit('hook:activated'),\r\n              parentSuspense,\r\n            )\r\n          }\r\n        }\r\n        instance.isMounted = true\r\n\r\n        if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n          devtoolsComponentAdded(instance)\r\n        }\r\n\r\n        // #2458: deference mount-only object parameters to prevent memleaks\r\n        initialVNode = container = anchor = null as any\r\n      } else {\r\n        let { next, bu, u, parent, vnode } = instance\r\n\r\n        if (__FEATURE_SUSPENSE__) {\r\n          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance)\r\n          // we are trying to update some async comp before hydration\r\n          // this will cause crash because we don't know the root node yet\r\n          if (nonHydratedAsyncRoot) {\r\n            // only sync the properties and abort the rest of operations\r\n            if (next) {\r\n              next.el = vnode.el\r\n              updateComponentPreRender(instance, next, optimized)\r\n            }\r\n            // and continue the rest of operations once the deps are resolved\r\n            nonHydratedAsyncRoot.asyncDep!.then(() => {\r\n              // the instance may be destroyed during the time period\r\n              if (!instance.isUnmounted) {\r\n                componentUpdateFn()\r\n              }\r\n            })\r\n            return\r\n          }\r\n        }\r\n\r\n        // updateComponent\r\n        // This is triggered by mutation of component's own state (next: null)\r\n        // OR parent calling processComponent (next: VNode)\r\n        let originNext = next\r\n        let vnodeHook: VNodeHook | null | undefined\r\n        if (__DEV__) {\r\n          pushWarningContext(next || instance.vnode)\r\n        }\r\n\r\n        // Disallow component effect recursion during pre-lifecycle hooks.\r\n        toggleRecurse(instance, false)\r\n        if (next) {\r\n          next.el = vnode.el\r\n          updateComponentPreRender(instance, next, optimized)\r\n        } else {\r\n          next = vnode\r\n        }\r\n\r\n        // beforeUpdate hook\r\n        if (bu) {\r\n          invokeArrayFns(bu)\r\n        }\r\n        // onVnodeBeforeUpdate\r\n        if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {\r\n          invokeVNodeHook(vnodeHook, parent, next, vnode)\r\n        }\r\n        if (\r\n          __COMPAT__ &&\r\n          isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\r\n        ) {\r\n          instance.emit('hook:beforeUpdate')\r\n        }\r\n        toggleRecurse(instance, true)\r\n\r\n        // render\r\n        if (__DEV__) {\r\n          startMeasure(instance, `render`)\r\n        }\r\n        const nextTree = renderComponentRoot(instance)\r\n        if (__DEV__) {\r\n          endMeasure(instance, `render`)\r\n        }\r\n        const prevTree = instance.subTree\r\n        instance.subTree = nextTree\r\n\r\n        if (__DEV__) {\r\n          startMeasure(instance, `patch`)\r\n        }\r\n        patch(\r\n          prevTree,\r\n          nextTree,\r\n          // parent may have changed if it's in a teleport\r\n          hostParentNode(prevTree.el!)!,\r\n          // anchor may have changed if it's in a fragment\r\n          getNextHostNode(prevTree),\r\n          instance,\r\n          parentSuspense,\r\n          namespace,\r\n        )\r\n        if (__DEV__) {\r\n          endMeasure(instance, `patch`)\r\n        }\r\n        next.el = nextTree.el\r\n        if (originNext === null) {\r\n          // self-triggered update. In case of HOC, update parent component\r\n          // vnode el. HOC is indicated by parent instance's subTree pointing\r\n          // to child component's vnode\r\n          updateHOCHostEl(instance, nextTree.el)\r\n        }\r\n        // updated hook\r\n        if (u) {\r\n          queuePostRenderEffect(u, parentSuspense)\r\n        }\r\n        // onVnodeUpdated\r\n        if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {\r\n          queuePostRenderEffect(\r\n            () => invokeVNodeHook(vnodeHook!, parent, next!, vnode),\r\n            parentSuspense,\r\n          )\r\n        }\r\n        if (\r\n          __COMPAT__ &&\r\n          isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\r\n        ) {\r\n          queuePostRenderEffect(\r\n            () => instance.emit('hook:updated'),\r\n            parentSuspense,\r\n          )\r\n        }\r\n\r\n        if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n          devtoolsComponentUpdated(instance)\r\n        }\r\n\r\n        if (__DEV__) {\r\n          popWarningContext()\r\n        }\r\n      }\r\n    }\r\n\r\n    // create reactive effect for rendering\r\n    const effect = (instance.effect = new ReactiveEffect(\r\n      componentUpdateFn,\r\n      NOOP,\r\n      () => queueJob(update),\r\n      instance.scope, // track it in component's effect scope\r\n    ))\r\n\r\n    const update: SchedulerJob = (instance.update = () => {\r\n      if (effect.dirty) {\r\n        effect.run()\r\n      }\r\n    })\r\n    update.id = instance.uid\r\n    // allowRecurse\r\n    // #1801, #2043 component render effects should allow recursive updates\r\n    toggleRecurse(instance, true)\r\n\r\n    if (__DEV__) {\r\n      effect.onTrack = instance.rtc\r\n        ? e => invokeArrayFns(instance.rtc!, e)\r\n        : void 0\r\n      effect.onTrigger = instance.rtg\r\n        ? e => invokeArrayFns(instance.rtg!, e)\r\n        : void 0\r\n      update.ownerInstance = instance\r\n    }\r\n\r\n    update()\r\n  }\r\n\r\n  const updateComponentPreRender = (\r\n    instance: ComponentInternalInstance,\r\n    nextVNode: VNode,\r\n    optimized: boolean,\r\n  ) => {\r\n    nextVNode.component = instance\r\n    const prevProps = instance.vnode.props\r\n    instance.vnode = nextVNode\r\n    instance.next = null\r\n    updateProps(instance, nextVNode.props, prevProps, optimized)\r\n    updateSlots(instance, nextVNode.children, optimized)\r\n\r\n    pauseTracking()\r\n    // props update may have triggered pre-flush watchers.\r\n    // flush them before the render update.\r\n    flushPreFlushCbs(instance)\r\n    resetTracking()\r\n  }\r\n\r\n  const patchChildren: PatchChildrenFn = (\r\n    n1,\r\n    n2,\r\n    container,\r\n    anchor,\r\n    parentComponent,\r\n    parentSuspense,\r\n    namespace: ElementNamespace,\r\n    slotScopeIds,\r\n    optimized = false,\r\n  ) => {\r\n    const c1 = n1 && n1.children\r\n    const prevShapeFlag = n1 ? n1.shapeFlag : 0\r\n    const c2 = n2.children\r\n\r\n    const { patchFlag, shapeFlag } = n2\r\n    // fast path\r\n    if (patchFlag > 0) {\r\n      if (patchFlag & PatchFlags.KEYED_FRAGMENT) {\r\n        // this could be either fully-keyed or mixed (some keyed some not)\r\n        // presence of patchFlag means children are guaranteed to be arrays\r\n        patchKeyedChildren(\r\n          c1 as VNode[],\r\n          c2 as VNodeArrayChildren,\r\n          container,\r\n          anchor,\r\n          parentComponent,\r\n          parentSuspense,\r\n          namespace,\r\n          slotScopeIds,\r\n          optimized,\r\n        )\r\n        return\r\n      } else if (patchFlag & PatchFlags.UNKEYED_FRAGMENT) {\r\n        // unkeyed\r\n        patchUnkeyedChildren(\r\n          c1 as VNode[],\r\n          c2 as VNodeArrayChildren,\r\n          container,\r\n          anchor,\r\n          parentComponent,\r\n          parentSuspense,\r\n          namespace,\r\n          slotScopeIds,\r\n          optimized,\r\n        )\r\n        return\r\n      }\r\n    }\r\n\r\n    // children has 3 possibilities: text, array or no children.\r\n    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n      // text children fast path\r\n      if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n        unmountChildren(c1 as VNode[], parentComponent, parentSuspense)\r\n      }\r\n      if (c2 !== c1) {\r\n        hostSetElementText(container, c2 as string)\r\n      }\r\n    } else {\r\n      if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n        // prev children was array\r\n        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n          // two arrays, cannot assume anything, do full diff\r\n          patchKeyedChildren(\r\n            c1 as VNode[],\r\n            c2 as VNodeArrayChildren,\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            parentSuspense,\r\n            namespace,\r\n            slotScopeIds,\r\n            optimized,\r\n          )\r\n        } else {\r\n          // no new children, just unmount old\r\n          unmountChildren(c1 as VNode[], parentComponent, parentSuspense, true)\r\n        }\r\n      } else {\r\n        // prev children was text OR null\r\n        // new children is array OR null\r\n        if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n          hostSetElementText(container, '')\r\n        }\r\n        // mount new if array\r\n        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n          mountChildren(\r\n            c2 as VNodeArrayChildren,\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            parentSuspense,\r\n            namespace,\r\n            slotScopeIds,\r\n            optimized,\r\n          )\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 元素没有key的情况下，先获取共同长度的key，执行patch，多余的卸载，新添加的挂载\r\n   */\r\n  const patchUnkeyedChildren = (\r\n    c1: VNode[],\r\n    c2: VNodeArrayChildren,\r\n    container: RendererElement,\r\n    anchor: RendererNode | null,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    namespace: ElementNamespace,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean,\r\n  ) => {\r\n    c1 = c1 || EMPTY_ARR\r\n    c2 = c2 || EMPTY_ARR\r\n    const oldLength = c1.length\r\n    const newLength = c2.length\r\n    const commonLength = Math.min(oldLength, newLength)\r\n    let i\r\n    for (i = 0; i < commonLength; i++) {\r\n      /**\r\n       * 这行代码的作用是在子节点更新过程中，根据是否启用了优化模式来选择合适的处理方式。如果在优化模式下，使用 cloneIfMounted 来处理已经挂载的节点，以避免副作用。\r\n       * 如果不在优化模式下，则使用 normalizeVNode 确保输入子节点是标准的 VNode 对象\r\n       */\r\n      const nextChild = (c2[i] = optimized\r\n        ? cloneIfMounted(c2[i] as VNode)\r\n        : normalizeVNode(c2[i]))\r\n      patch(\r\n        c1[i],\r\n        nextChild,\r\n        container,\r\n        null,\r\n        parentComponent,\r\n        parentSuspense,\r\n        namespace,\r\n        slotScopeIds,\r\n        optimized,\r\n      )\r\n    }\r\n    if (oldLength > newLength) {\r\n      // remove old\r\n      unmountChildren(\r\n        c1,\r\n        parentComponent,\r\n        parentSuspense,\r\n        true,\r\n        false,\r\n        commonLength,\r\n      )\r\n    } else {\r\n      // mount new\r\n      mountChildren(\r\n        c2,\r\n        container,\r\n        anchor,\r\n        parentComponent,\r\n        parentSuspense,\r\n        namespace,\r\n        slotScopeIds,\r\n        optimized,\r\n        commonLength,\r\n      )\r\n    }\r\n  }\r\n\r\n  // can be all-keyed or mixed\r\n  const patchKeyedChildren = (\r\n    c1: VNode[],\r\n    c2: VNodeArrayChildren,\r\n    container: RendererElement,\r\n    parentAnchor: RendererNode | null,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    namespace: ElementNamespace,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean,\r\n  ) => {\r\n    let i = 0\r\n    const l2 = c2.length\r\n    let e1 = c1.length - 1 // prev ending index\r\n    let e2 = l2 - 1 // next ending index\r\n\r\n    // 1. sync from start\r\n    // (a b) c\r\n    // (a b) d e\r\n    // 快速diff算法\r\n    // step 1. 找到开头那些key相同的（相同的前置元素），对那些节点执行patch \r\n    while (i <= e1 && i <= e2) {\r\n      const n1 = c1[i]\r\n      const n2 = (c2[i] = optimized\r\n        ? cloneIfMounted(c2[i] as VNode)\r\n        : normalizeVNode(c2[i]))\r\n      if (isSameVNodeType(n1, n2)) {\r\n        patch(\r\n          n1,\r\n          n2,\r\n          container,\r\n          null,\r\n          parentComponent,\r\n          parentSuspense,\r\n          namespace,\r\n          slotScopeIds,\r\n          optimized,\r\n        )\r\n      } else {\r\n        break\r\n      }\r\n      i++\r\n    }\r\n\r\n    // 2. sync from end\r\n    // a (b c)\r\n    // d e (b c)\r\n    // step 2. 找到末尾那些key相同的（相同的后置元素），对那些节点执行patch\r\n    while (i <= e1 && i <= e2) {\r\n      const n1 = c1[e1]\r\n      const n2 = (c2[e2] = optimized\r\n        ? cloneIfMounted(c2[e2] as VNode)\r\n        : normalizeVNode(c2[e2]))\r\n      if (isSameVNodeType(n1, n2)) {\r\n        patch(\r\n          n1,\r\n          n2,\r\n          container,\r\n          null,\r\n          parentComponent,\r\n          parentSuspense,\r\n          namespace,\r\n          slotScopeIds,\r\n          optimized,\r\n        )\r\n      } else {\r\n        break\r\n      }\r\n      e1--\r\n      e2--\r\n    }\r\n\r\n    // 3. common sequence + mount\r\n    // (a b)\r\n    // (a b) c\r\n    // i = 2, e1 = 1, e2 = 2\r\n    // (a b)\r\n    // c (a b)\r\n    // i = 0, e1 = -1, e2 = 0\r\n    // 如果是新的节点多，那么多余的节点执行mount,\r\n    if (i > e1) {\r\n      if (i <= e2) {\r\n        const nextPos = e2 + 1\r\n        const anchor = nextPos < l2 ? (c2[nextPos] as VNode).el : parentAnchor\r\n        while (i <= e2) {\r\n          patch(\r\n            null,\r\n            (c2[i] = optimized\r\n              ? cloneIfMounted(c2[i] as VNode)\r\n              : normalizeVNode(c2[i])),\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            parentSuspense,\r\n            namespace,\r\n            slotScopeIds,\r\n            optimized,\r\n          )\r\n          i++\r\n        }\r\n      }\r\n    }\r\n\r\n    // 4. common sequence + unmount\r\n    // (a b) c\r\n    // (a b)\r\n    // i = 2, e1 = 2, e2 = 1\r\n    // a (b c)\r\n    // (b c)\r\n    // i = 0, e1 = 0, e2 = -1\r\n    // step 4. 如果是有多余的old node，执行卸载\r\n    else if (i > e2) {\r\n      while (i <= e1) {\r\n        unmount(c1[i], parentComponent, parentSuspense, true)\r\n        i++\r\n      }\r\n    }\r\n\r\n    // 5. unknown sequence\r\n    // [i ... e1 + 1]: a b [c d e] f g\r\n    // [i ... e2 + 1]: a b [e d c h] f g\r\n    // i = 2, e1 = 4, e2 = 5\r\n    else {\r\n      // 如果两个都有多余，寻找最长递增子序列\r\n      const s1 = i // prev starting index\r\n      const s2 = i // next starting index\r\n\r\n      // 5.1 build key:index map for newChildren  先获取 new nodes的key map集合\r\n      const keyToNewIndexMap: Map<string | number | symbol, number> = new Map()\r\n      for (i = s2; i <= e2; i++) {\r\n        const nextChild = (c2[i] = optimized\r\n          ? cloneIfMounted(c2[i] as VNode)\r\n          : normalizeVNode(c2[i]))\r\n        if (nextChild.key != null) {\r\n          if (__DEV__ && keyToNewIndexMap.has(nextChild.key)) {\r\n            warn(\r\n              `Duplicate keys found during update:`,\r\n              JSON.stringify(nextChild.key),\r\n              `Make sure keys are unique.`,\r\n            )\r\n          }\r\n          keyToNewIndexMap.set(nextChild.key, i)\r\n        }\r\n      }\r\n\r\n      // 5.2 loop through old children left to be patched and try to patch\r\n      // matching nodes & remove nodes that are no longer present\r\n      let j\r\n      let patched = 0\r\n      const toBePatched = e2 - s2 + 1 // 剩余new nodes 的长度\r\n      let moved = false // 判断是否需要移动，如果每一个新节点在old nodes的索引值大于当前最大的索引值，则不需要移动\r\n      // used to track whether any node has moved\r\n      let maxNewIndexSoFar = 0 // 当前遍历中最大的索引值（新节点在旧节点数组的索引值）\r\n      // works as Map<newIndex, oldIndex>\r\n      // Note that oldIndex is offset by +1\r\n      // and oldIndex = 0 is a special value indicating the new node has\r\n      // no corresponding old node.\r\n      // used for determining longest stable subsequence\r\n      // 创建一个与剩余new nodes长度相同的数组，初始值设置为0。  用来存储新的一组节点在旧的一组节点中的索引位置\r\n      const newIndexToOldIndexMap = new Array(toBePatched)\r\n      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0\r\n\r\n      // 遍历old nodes数组\r\n      for (i = s1; i <= e1; i++) {\r\n        const prevChild = c1[i]\r\n        // 判断已经匹配了的old node 数目，如果已经大于new nodes的数目，那么直接unmount\r\n        if (patched >= toBePatched) {\r\n          // all new children have been patched so this can only be a removal\r\n          unmount(prevChild, parentComponent, parentSuspense, true)\r\n          continue\r\n        }\r\n        let newIndex\r\n        // \r\n        if (prevChild.key != null) {\r\n          newIndex = keyToNewIndexMap.get(prevChild.key)\r\n        } else {\r\n          // key-less node, try to locate a key-less node of the same type\r\n          for (j = s2; j <= e2; j++) {\r\n            if (\r\n              newIndexToOldIndexMap[j - s2] === 0 &&\r\n              isSameVNodeType(prevChild, c2[j] as VNode)\r\n            ) {\r\n              newIndex = j\r\n              break\r\n            }\r\n          }\r\n        }\r\n        // 没有找到，说明是多余的节点，应该unmount\r\n        if (newIndex === undefined) {\r\n          unmount(prevChild, parentComponent, parentSuspense, true)\r\n        } else {\r\n          //否则记录这个新节点在旧节点的位置\r\n          newIndexToOldIndexMap[newIndex - s2] = i + 1\r\n          if (newIndex >= maxNewIndexSoFar) {\r\n            maxNewIndexSoFar = newIndex\r\n          } else {\r\n            moved = true\r\n          }\r\n          // 先对这个节点本身patch\r\n          patch(\r\n            prevChild,\r\n            c2[newIndex] as VNode,\r\n            container,\r\n            null,\r\n            parentComponent,\r\n            parentSuspense,\r\n            namespace,\r\n            slotScopeIds,\r\n            optimized,\r\n          )\r\n          patched++\r\n        }\r\n      }\r\n\r\n      // 5.3 move and mount\r\n      // generate longest stable subsequence only when nodes have moved\r\n      // 如果moved为true，说明需要移动，否则就不需要移动，找到source的最长递增子序列。。返回的是位置\r\n      const increasingNewIndexSequence = moved\r\n        ? getSequence(newIndexToOldIndexMap)\r\n        : EMPTY_ARR\r\n      j = increasingNewIndexSequence.length - 1\r\n      // looping backwards so that we can use last patched node as anchor\r\n      // 遍历source，从最后一个元素开始，\r\n      for (i = toBePatched - 1; i >= 0; i--) {\r\n        const nextIndex = s2 + i\r\n        const nextChild = c2[nextIndex] as VNode\r\n        const anchor =\r\n          nextIndex + 1 < l2 ? (c2[nextIndex + 1] as VNode).el : parentAnchor\r\n        if (newIndexToOldIndexMap[i] === 0) { // 如果是0 说明是mount\r\n          // mount new\r\n          patch(\r\n            null,\r\n            nextChild,\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            parentSuspense,\r\n            namespace,\r\n            slotScopeIds,\r\n            optimized,\r\n          )\r\n        } else if (moved) {\r\n          // move if:\r\n          // There is no stable subsequence (e.g. a reverse)\r\n          // OR current node is not among the stable sequence\r\n          if (j < 0 || i !== increasingNewIndexSequence[j]) {\r\n            // 以下个节点为描点，移动\r\n            move(nextChild, container, anchor, MoveType.REORDER)\r\n          } else {\r\n             // 如果是最长递增子序列中的，则不需要移动，只要patch node\r\n            j--\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const move: MoveFn = (\r\n    vnode,\r\n    container,\r\n    anchor,\r\n    moveType,\r\n    parentSuspense = null,\r\n  ) => {\r\n    const { el, type, transition, children, shapeFlag } = vnode\r\n    if (shapeFlag & ShapeFlags.COMPONENT) {\r\n      move(vnode.component!.subTree, container, anchor, moveType)\r\n      return\r\n    }\r\n\r\n    if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {\r\n      vnode.suspense!.move(container, anchor, moveType)\r\n      return\r\n    }\r\n\r\n    if (shapeFlag & ShapeFlags.TELEPORT) {\r\n      ;(type as typeof TeleportImpl).move(vnode, container, anchor, internals)\r\n      return\r\n    }\r\n\r\n    if (type === Fragment) {\r\n      hostInsert(el!, container, anchor)\r\n      for (let i = 0; i < (children as VNode[]).length; i++) {\r\n        move((children as VNode[])[i], container, anchor, moveType)\r\n      }\r\n      hostInsert(vnode.anchor!, container, anchor)\r\n      return\r\n    }\r\n\r\n    if (type === Static) {\r\n      moveStaticNode(vnode, container, anchor)\r\n      return\r\n    }\r\n\r\n    // single nodes\r\n    const needTransition =\r\n      moveType !== MoveType.REORDER &&\r\n      shapeFlag & ShapeFlags.ELEMENT &&\r\n      transition\r\n    if (needTransition) {\r\n      if (moveType === MoveType.ENTER) {\r\n        transition!.beforeEnter(el!)\r\n        hostInsert(el!, container, anchor)\r\n        queuePostRenderEffect(() => transition!.enter(el!), parentSuspense)\r\n      } else {\r\n        const { leave, delayLeave, afterLeave } = transition!\r\n        const remove = () => hostInsert(el!, container, anchor)\r\n        const performLeave = () => {\r\n          leave(el!, () => {\r\n            remove()\r\n            afterLeave && afterLeave()\r\n          })\r\n        }\r\n        if (delayLeave) {\r\n          delayLeave(el!, remove, performLeave)\r\n        } else {\r\n          performLeave()\r\n        }\r\n      }\r\n    } else {\r\n      hostInsert(el!, container, anchor)\r\n    }\r\n  }\r\n\r\n  const unmount: UnmountFn = (\r\n    vnode,\r\n    parentComponent,\r\n    parentSuspense,\r\n    doRemove = false,\r\n    optimized = false,\r\n  ) => {\r\n    const {\r\n      type,\r\n      props,\r\n      ref,\r\n      children,\r\n      dynamicChildren,\r\n      shapeFlag,\r\n      patchFlag,\r\n      dirs,\r\n    } = vnode\r\n    // unset ref\r\n    if (ref != null) {\r\n      setRef(ref, null, parentSuspense, vnode, true)\r\n    }\r\n\r\n    if (shapeFlag & ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) {\r\n      ;(parentComponent!.ctx as KeepAliveContext).deactivate(vnode)\r\n      return\r\n    }\r\n\r\n    const shouldInvokeDirs = shapeFlag & ShapeFlags.ELEMENT && dirs\r\n    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode)\r\n\r\n    let vnodeHook: VNodeHook | undefined | null\r\n    if (\r\n      shouldInvokeVnodeHook &&\r\n      (vnodeHook = props && props.onVnodeBeforeUnmount)\r\n    ) {\r\n      invokeVNodeHook(vnodeHook, parentComponent, vnode)\r\n    }\r\n\r\n    if (shapeFlag & ShapeFlags.COMPONENT) {\r\n      unmountComponent(vnode.component!, parentSuspense, doRemove)\r\n    } else {\r\n      if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {\r\n        vnode.suspense!.unmount(parentSuspense, doRemove)\r\n        return\r\n      }\r\n\r\n      if (shouldInvokeDirs) {\r\n        invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount')\r\n      }\r\n\r\n      if (shapeFlag & ShapeFlags.TELEPORT) {\r\n        ;(vnode.type as typeof TeleportImpl).remove(\r\n          vnode,\r\n          parentComponent,\r\n          parentSuspense,\r\n          optimized,\r\n          internals,\r\n          doRemove,\r\n        )\r\n      } else if (\r\n        dynamicChildren &&\r\n        // #1153: fast path should not be taken for non-stable (v-for) fragments\r\n        (type !== Fragment ||\r\n          (patchFlag > 0 && patchFlag & PatchFlags.STABLE_FRAGMENT))\r\n      ) {\r\n        // fast path for block nodes: only need to unmount dynamic children.\r\n        unmountChildren(\r\n          dynamicChildren,\r\n          parentComponent,\r\n          parentSuspense,\r\n          false,\r\n          true,\r\n        )\r\n      } else if (\r\n        (type === Fragment &&\r\n          patchFlag &\r\n            (PatchFlags.KEYED_FRAGMENT | PatchFlags.UNKEYED_FRAGMENT)) ||\r\n        (!optimized && shapeFlag & ShapeFlags.ARRAY_CHILDREN)\r\n      ) {\r\n        unmountChildren(children as VNode[], parentComponent, parentSuspense)\r\n      }\r\n\r\n      if (doRemove) {\r\n        remove(vnode)\r\n      }\r\n    }\r\n\r\n    if (\r\n      (shouldInvokeVnodeHook &&\r\n        (vnodeHook = props && props.onVnodeUnmounted)) ||\r\n      shouldInvokeDirs\r\n    ) {\r\n      queuePostRenderEffect(() => {\r\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode)\r\n        shouldInvokeDirs &&\r\n          invokeDirectiveHook(vnode, null, parentComponent, 'unmounted')\r\n      }, parentSuspense)\r\n    }\r\n  }\r\n\r\n  const remove: RemoveFn = vnode => {\r\n    const { type, el, anchor, transition } = vnode\r\n    if (type === Fragment) {\r\n      if (\r\n        __DEV__ &&\r\n        vnode.patchFlag > 0 &&\r\n        vnode.patchFlag & PatchFlags.DEV_ROOT_FRAGMENT &&\r\n        transition &&\r\n        !transition.persisted\r\n      ) {\r\n        ;(vnode.children as VNode[]).forEach(child => {\r\n          if (child.type === Comment) {\r\n            hostRemove(child.el!)\r\n          } else {\r\n            remove(child)\r\n          }\r\n        })\r\n      } else {\r\n        removeFragment(el!, anchor!)\r\n      }\r\n      return\r\n    }\r\n\r\n    if (type === Static) {\r\n      removeStaticNode(vnode)\r\n      return\r\n    }\r\n\r\n    const performRemove = () => {\r\n      hostRemove(el!)\r\n      if (transition && !transition.persisted && transition.afterLeave) {\r\n        transition.afterLeave()\r\n      }\r\n    }\r\n\r\n    if (\r\n      vnode.shapeFlag & ShapeFlags.ELEMENT &&\r\n      transition &&\r\n      !transition.persisted\r\n    ) {\r\n      const { leave, delayLeave } = transition\r\n      const performLeave = () => leave(el!, performRemove)\r\n      if (delayLeave) {\r\n        delayLeave(vnode.el!, performRemove, performLeave)\r\n      } else {\r\n        performLeave()\r\n      }\r\n    } else {\r\n      performRemove()\r\n    }\r\n  }\r\n\r\n  const removeFragment = (cur: RendererNode, end: RendererNode) => {\r\n    // For fragments, directly remove all contained DOM nodes.\r\n    // (fragment child nodes cannot have transition)\r\n    let next\r\n    while (cur !== end) {\r\n      next = hostNextSibling(cur)!\r\n      hostRemove(cur)\r\n      cur = next\r\n    }\r\n    hostRemove(end)\r\n  }\r\n\r\n  const unmountComponent = (\r\n    instance: ComponentInternalInstance,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    doRemove?: boolean,\r\n  ) => {\r\n    if (__DEV__ && instance.type.__hmrId) {\r\n      unregisterHMR(instance)\r\n    }\r\n\r\n    const { bum, scope, update, subTree, um } = instance\r\n\r\n    // beforeUnmount hook\r\n    if (bum) {\r\n      invokeArrayFns(bum)\r\n    }\r\n\r\n    if (\r\n      __COMPAT__ &&\r\n      isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\r\n    ) {\r\n      instance.emit('hook:beforeDestroy')\r\n    }\r\n\r\n    // stop effects in component scope\r\n    scope.stop()\r\n\r\n    // update may be null if a component is unmounted before its async\r\n    // setup has resolved.\r\n    if (update) {\r\n      // so that scheduler will no longer invoke it\r\n      update.active = false\r\n      unmount(subTree, instance, parentSuspense, doRemove)\r\n    }\r\n    // unmounted hook\r\n    if (um) {\r\n      queuePostRenderEffect(um, parentSuspense)\r\n    }\r\n    if (\r\n      __COMPAT__ &&\r\n      isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\r\n    ) {\r\n      queuePostRenderEffect(\r\n        () => instance.emit('hook:destroyed'),\r\n        parentSuspense,\r\n      )\r\n    }\r\n    queuePostRenderEffect(() => {\r\n      instance.isUnmounted = true\r\n    }, parentSuspense)\r\n\r\n    // A component with async dep inside a pending suspense is unmounted before\r\n    // its async dep resolves. This should remove the dep from the suspense, and\r\n    // cause the suspense to resolve immediately if that was the last dep.\r\n    if (\r\n      __FEATURE_SUSPENSE__ &&\r\n      parentSuspense &&\r\n      parentSuspense.pendingBranch &&\r\n      !parentSuspense.isUnmounted &&\r\n      instance.asyncDep &&\r\n      !instance.asyncResolved &&\r\n      instance.suspenseId === parentSuspense.pendingId\r\n    ) {\r\n      parentSuspense.deps--\r\n      if (parentSuspense.deps === 0) {\r\n        parentSuspense.resolve()\r\n      }\r\n    }\r\n\r\n    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n      devtoolsComponentRemoved(instance)\r\n    }\r\n  }\r\n\r\n  const unmountChildren: UnmountChildrenFn = (\r\n    children,\r\n    parentComponent,\r\n    parentSuspense,\r\n    doRemove = false,\r\n    optimized = false,\r\n    start = 0,\r\n  ) => {\r\n    for (let i = start; i < children.length; i++) {\r\n      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized)\r\n    }\r\n  }\r\n\r\n  const getNextHostNode: NextFn = vnode => {\r\n    if (vnode.shapeFlag & ShapeFlags.COMPONENT) {\r\n      return getNextHostNode(vnode.component!.subTree)\r\n    }\r\n    if (__FEATURE_SUSPENSE__ && vnode.shapeFlag & ShapeFlags.SUSPENSE) {\r\n      return vnode.suspense!.next()\r\n    }\r\n    return hostNextSibling((vnode.anchor || vnode.el)!)\r\n  }\r\n\r\n  let isFlushing = false\r\n  // render函数渲染\r\n  const render: RootRenderFunction = (vnode, container, namespace) => {\r\n    // vnode不存在，就卸载原来的\r\n    if (vnode == null) {\r\n      if (container._vnode) {\r\n        unmount(container._vnode, null, null, true)\r\n      }\r\n    } else {\r\n      patch(\r\n        container._vnode || null,\r\n        vnode,\r\n        container,\r\n        null,\r\n        null,\r\n        null,\r\n        namespace,\r\n      )\r\n    }\r\n    if (!isFlushing) {\r\n      isFlushing = true\r\n      flushPreFlushCbs()\r\n      flushPostFlushCbs()\r\n      isFlushing = false\r\n    }\r\n    container._vnode = vnode\r\n  }\r\n\r\n  const internals: RendererInternals = {\r\n    p: patch,\r\n    um: unmount,\r\n    m: move,\r\n    r: remove,\r\n    mt: mountComponent,\r\n    mc: mountChildren,\r\n    pc: patchChildren,\r\n    pbc: patchBlockChildren,\r\n    n: getNextHostNode,\r\n    o: options,\r\n  }\r\n\r\n  let hydrate: ReturnType<typeof createHydrationFunctions>[0] | undefined\r\n  let hydrateNode: ReturnType<typeof createHydrationFunctions>[1] | undefined\r\n  if (createHydrationFns) {\r\n    ;[hydrate, hydrateNode] = createHydrationFns(\r\n      internals as RendererInternals<Node, Element>,\r\n    )\r\n  }\r\n\r\n  return {\r\n    render,\r\n    hydrate,\r\n    createApp: createAppAPI(render, hydrate),\r\n  }\r\n}\r\n\r\nfunction resolveChildrenNamespace(\r\n  { type, props }: VNode,\r\n  currentNamespace: ElementNamespace,\r\n): ElementNamespace {\r\n  return (currentNamespace === 'svg' && type === 'foreignObject') ||\r\n    (currentNamespace === 'mathml' &&\r\n      type === 'annotation-xml' &&\r\n      props &&\r\n      props.encoding &&\r\n      props.encoding.includes('html'))\r\n    ? undefined\r\n    : currentNamespace\r\n}\r\n\r\nfunction toggleRecurse(\r\n  { effect, update }: ComponentInternalInstance,\r\n  allowed: boolean,\r\n) {\r\n  effect.allowRecurse = update.allowRecurse = allowed\r\n}\r\n\r\nexport function needTransition(\r\n  parentSuspense: SuspenseBoundary | null,\r\n  transition: TransitionHooks | null,\r\n) {\r\n  return (\r\n    (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&\r\n    transition &&\r\n    !transition.persisted\r\n  )\r\n}\r\n\r\n/**\r\n * #1156\r\n * When a component is HMR-enabled, we need to make sure that all static nodes\r\n * inside a block also inherit the DOM element from the previous tree so that\r\n * HMR updates (which are full updates) can retrieve the element for patching.\r\n *\r\n * #2080\r\n * Inside keyed `template` fragment static children, if a fragment is moved,\r\n * the children will always be moved. Therefore, in order to ensure correct move\r\n * position, el should be inherited from previous nodes.\r\n */\r\nexport function traverseStaticChildren(n1: VNode, n2: VNode, shallow = false) {\r\n  const ch1 = n1.children\r\n  const ch2 = n2.children\r\n  if (isArray(ch1) && isArray(ch2)) {\r\n    for (let i = 0; i < ch1.length; i++) {\r\n      // this is only called in the optimized path so array children are\r\n      // guaranteed to be vnodes\r\n      const c1 = ch1[i] as VNode\r\n      let c2 = ch2[i] as VNode\r\n      if (c2.shapeFlag & ShapeFlags.ELEMENT && !c2.dynamicChildren) {\r\n        if (c2.patchFlag <= 0 || c2.patchFlag === PatchFlags.NEED_HYDRATION) {\r\n          c2 = ch2[i] = cloneIfMounted(ch2[i] as VNode)\r\n          c2.el = c1.el\r\n        }\r\n        if (!shallow) traverseStaticChildren(c1, c2)\r\n      }\r\n      // #6852 also inherit for text nodes\r\n      if (c2.type === Text) {\r\n        c2.el = c1.el\r\n      }\r\n      // also inherit for comment nodes, but not placeholders (e.g. v-if which\r\n      // would have received .el during block patch)\r\n      if (__DEV__ && c2.type === Comment && !c2.el) {\r\n        c2.el = c1.el\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\r\n// 贪心+二分法实现\r\nfunction getSequence(arr: number[]): number[] {\r\n  const p = arr.slice()\r\n  const result = [0]\r\n  let i, j, u, v, c\r\n  const len = arr.length\r\n  for (i = 0; i < len; i++) {\r\n    const arrI = arr[i]\r\n    if (arrI !== 0) { // 为0 是默认初始值，说明是新增的节点\r\n      j = result[result.length - 1]\r\n      if (arr[j] < arrI) {\r\n        p[i] = j //p用来记录这个元素加入前最长子序列最后一个元素的位置 []\r\n        result.push(i)\r\n        continue\r\n      }\r\n      u = 0\r\n      v = result.length - 1\r\n      while (u < v) {\r\n        c = (u + v) >> 1\r\n        if (arr[result[c]] < arrI) {\r\n          u = c + 1\r\n        } else {\r\n          v = c\r\n        }\r\n      }\r\n      if (arrI < arr[result[u]]) {\r\n        if (u > 0) {\r\n          p[i] = result[u - 1]\r\n        }\r\n        result[u] = i\r\n      }\r\n    }\r\n  }\r\n  u = result.length\r\n  v = result[u - 1]\r\n  while (u-- > 0) { // 结果result最长递增子序列元素个数是没有问题，但是位置可能有误（最后一个元素不会有错），重新纠正\r\n    result[u] = v\r\n    v = p[v]\r\n  }\r\n  return result\r\n}\r\n\r\nfunction locateNonHydratedAsyncRoot(\r\n  instance: ComponentInternalInstance,\r\n): ComponentInternalInstance | undefined {\r\n  const subComponent = instance.subTree.component\r\n  if (subComponent) {\r\n    if (subComponent.asyncDep && !subComponent.asyncResolved) {\r\n      return subComponent\r\n    } else {\r\n      return locateNonHydratedAsyncRoot(subComponent)\r\n    }\r\n  }\r\n}\r\n","import {\r\n  Comment,\r\n  type VNode,\r\n  type VNodeProps,\r\n  closeBlock,\r\n  createVNode,\r\n  currentBlock,\r\n  isBlockTreeEnabled,\r\n  isSameVNodeType,\r\n  normalizeVNode,\r\n  openBlock,\r\n} from '../vnode'\r\nimport { ShapeFlags, isArray, isFunction, toNumber } from '@vue/shared'\r\nimport { type ComponentInternalInstance, handleSetupResult } from '../component'\r\nimport type { Slots } from '../componentSlots'\r\nimport {\r\n  type ElementNamespace,\r\n  MoveType,\r\n  type RendererElement,\r\n  type RendererInternals,\r\n  type RendererNode,\r\n  type SetupRenderEffectFn,\r\n} from '../renderer'\r\nimport { queuePostFlushCb } from '../scheduler'\r\nimport { filterSingleRoot, updateHOCHostEl } from '../componentRenderUtils'\r\nimport {\r\n  assertNumber,\r\n  popWarningContext,\r\n  pushWarningContext,\r\n  warn,\r\n} from '../warning'\r\nimport { ErrorCodes, handleError } from '../errorHandling'\r\nimport { NULL_DYNAMIC_COMPONENT } from '../helpers/resolveAssets'\r\n\r\nexport interface SuspenseProps {\r\n  onResolve?: () => void\r\n  onPending?: () => void\r\n  onFallback?: () => void\r\n  timeout?: string | number\r\n  /**\r\n   * Allow suspense to be captured by parent suspense\r\n   *\r\n   * @default false\r\n   */\r\n  suspensible?: boolean\r\n}\r\n\r\nexport const isSuspense = (type: any): boolean => type.__isSuspense\r\n\r\n// incrementing unique id for every pending branch\r\nlet suspenseId = 0\r\n\r\n/**\r\n * For testing only\r\n */\r\nexport const resetSuspenseId = () => (suspenseId = 0)\r\n\r\n// Suspense exposes a component-like API, and is treated like a component\r\n// in the compiler, but internally it's a special built-in type that hooks\r\n// directly into the renderer.\r\nexport const SuspenseImpl = {\r\n  name: 'Suspense',\r\n  // In order to make Suspense tree-shakable, we need to avoid importing it\r\n  // directly in the renderer. The renderer checks for the __isSuspense flag\r\n  // on a vnode's type and calls the `process` method, passing in renderer\r\n  // internals.\r\n  __isSuspense: true,\r\n  process(\r\n    n1: VNode | null,\r\n    n2: VNode,\r\n    container: RendererElement,\r\n    anchor: RendererNode | null,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    namespace: ElementNamespace,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean,\r\n    // platform-specific impl passed from renderer\r\n    rendererInternals: RendererInternals,\r\n  ) {\r\n    if (n1 == null) {\r\n      mountSuspense(\r\n        n2,\r\n        container,\r\n        anchor,\r\n        parentComponent,\r\n        parentSuspense,\r\n        namespace,\r\n        slotScopeIds,\r\n        optimized,\r\n        rendererInternals,\r\n      )\r\n    } else {\r\n      // #8678 if the current suspense needs to be patched and parentSuspense has\r\n      // not been resolved. this means that both the current suspense and parentSuspense\r\n      // need to be patched. because parentSuspense's pendingBranch includes the\r\n      // current suspense, it will be processed twice:\r\n      //  1. current patch\r\n      //  2. mounting along with the pendingBranch of parentSuspense\r\n      // it is necessary to skip the current patch to avoid multiple mounts\r\n      // of inner components.\r\n      if (parentSuspense && parentSuspense.deps > 0) {\r\n        n2.suspense = n1.suspense\r\n        return\r\n      }\r\n      patchSuspense(\r\n        n1,\r\n        n2,\r\n        container,\r\n        anchor,\r\n        parentComponent,\r\n        namespace,\r\n        slotScopeIds,\r\n        optimized,\r\n        rendererInternals,\r\n      )\r\n    }\r\n  },\r\n  hydrate: hydrateSuspense,\r\n  create: createSuspenseBoundary,\r\n  normalize: normalizeSuspenseChildren,\r\n}\r\n\r\n// Force-casted public typing for h and TSX props inference\r\nexport const Suspense = (__FEATURE_SUSPENSE__\r\n  ? SuspenseImpl\r\n  : null) as unknown as {\r\n  __isSuspense: true\r\n  new (): {\r\n    $props: VNodeProps & SuspenseProps\r\n    $slots: {\r\n      default(): VNode[]\r\n      fallback(): VNode[]\r\n    }\r\n  }\r\n}\r\n\r\nfunction triggerEvent(\r\n  vnode: VNode,\r\n  name: 'onResolve' | 'onPending' | 'onFallback',\r\n) {\r\n  const eventListener = vnode.props && vnode.props[name]\r\n  if (isFunction(eventListener)) {\r\n    eventListener()\r\n  }\r\n}\r\n\r\nfunction mountSuspense(\r\n  vnode: VNode,\r\n  container: RendererElement,\r\n  anchor: RendererNode | null,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  namespace: ElementNamespace,\r\n  slotScopeIds: string[] | null,\r\n  optimized: boolean,\r\n  rendererInternals: RendererInternals,\r\n) {\r\n  const {\r\n    p: patch,\r\n    o: { createElement },\r\n  } = rendererInternals\r\n  const hiddenContainer = createElement('div')\r\n  const suspense = (vnode.suspense = createSuspenseBoundary(\r\n    vnode,\r\n    parentSuspense,\r\n    parentComponent,\r\n    container,\r\n    hiddenContainer,\r\n    anchor,\r\n    namespace,\r\n    slotScopeIds,\r\n    optimized,\r\n    rendererInternals,\r\n  ))\r\n\r\n  // start mounting the content subtree in an off-dom container\r\n  patch(\r\n    null,\r\n    (suspense.pendingBranch = vnode.ssContent!),\r\n    hiddenContainer,\r\n    null,\r\n    parentComponent,\r\n    suspense,\r\n    namespace,\r\n    slotScopeIds,\r\n  )\r\n  // now check if we have encountered any async deps\r\n  if (suspense.deps > 0) {\r\n    // has async\r\n    // invoke @fallback event\r\n    triggerEvent(vnode, 'onPending')\r\n    triggerEvent(vnode, 'onFallback')\r\n\r\n    // mount the fallback tree\r\n    patch(\r\n      null,\r\n      vnode.ssFallback!,\r\n      container,\r\n      anchor,\r\n      parentComponent,\r\n      null, // fallback tree will not have suspense context\r\n      namespace,\r\n      slotScopeIds,\r\n    )\r\n    setActiveBranch(suspense, vnode.ssFallback!)\r\n  } else {\r\n    // Suspense has no async deps. Just resolve.\r\n    suspense.resolve(false, true)\r\n  }\r\n}\r\n\r\nfunction patchSuspense(\r\n  n1: VNode,\r\n  n2: VNode,\r\n  container: RendererElement,\r\n  anchor: RendererNode | null,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  namespace: ElementNamespace,\r\n  slotScopeIds: string[] | null,\r\n  optimized: boolean,\r\n  { p: patch, um: unmount, o: { createElement } }: RendererInternals,\r\n) {\r\n  const suspense = (n2.suspense = n1.suspense)!\r\n  suspense.vnode = n2\r\n  n2.el = n1.el\r\n  const newBranch = n2.ssContent!\r\n  const newFallback = n2.ssFallback!\r\n\r\n  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense\r\n  if (pendingBranch) {\r\n    suspense.pendingBranch = newBranch\r\n    if (isSameVNodeType(newBranch, pendingBranch)) {\r\n      // same root type but content may have changed.\r\n      patch(\r\n        pendingBranch,\r\n        newBranch,\r\n        suspense.hiddenContainer,\r\n        null,\r\n        parentComponent,\r\n        suspense,\r\n        namespace,\r\n        slotScopeIds,\r\n        optimized,\r\n      )\r\n      if (suspense.deps <= 0) {\r\n        suspense.resolve()\r\n      } else if (isInFallback) {\r\n        // It's possible that the app is in hydrating state when patching the\r\n        // suspense instance. If someone updates the dependency during component\r\n        // setup in children of suspense boundary, that would be problemtic\r\n        // because we aren't actually showing a fallback content when\r\n        // patchSuspense is called. In such case, patch of fallback content\r\n        // should be no op\r\n        if (!isHydrating) {\r\n          patch(\r\n            activeBranch,\r\n            newFallback,\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            null, // fallback tree will not have suspense context\r\n            namespace,\r\n            slotScopeIds,\r\n            optimized,\r\n          )\r\n          setActiveBranch(suspense, newFallback)\r\n        }\r\n      }\r\n    } else {\r\n      // toggled before pending tree is resolved\r\n      // increment pending ID. this is used to invalidate async callbacks\r\n      suspense.pendingId = suspenseId++\r\n      if (isHydrating) {\r\n        // if toggled before hydration is finished, the current DOM tree is\r\n        // no longer valid. set it as the active branch so it will be unmounted\r\n        // when resolved\r\n        suspense.isHydrating = false\r\n        suspense.activeBranch = pendingBranch\r\n      } else {\r\n        unmount(pendingBranch, parentComponent, suspense)\r\n      }\r\n      // reset suspense state\r\n      suspense.deps = 0\r\n      // discard effects from pending branch\r\n      suspense.effects.length = 0\r\n      // discard previous container\r\n      suspense.hiddenContainer = createElement('div')\r\n\r\n      if (isInFallback) {\r\n        // already in fallback state\r\n        patch(\r\n          null,\r\n          newBranch,\r\n          suspense.hiddenContainer,\r\n          null,\r\n          parentComponent,\r\n          suspense,\r\n          namespace,\r\n          slotScopeIds,\r\n          optimized,\r\n        )\r\n        if (suspense.deps <= 0) {\r\n          suspense.resolve()\r\n        } else {\r\n          patch(\r\n            activeBranch,\r\n            newFallback,\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            null, // fallback tree will not have suspense context\r\n            namespace,\r\n            slotScopeIds,\r\n            optimized,\r\n          )\r\n          setActiveBranch(suspense, newFallback)\r\n        }\r\n      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\r\n        // toggled \"back\" to current active branch\r\n        patch(\r\n          activeBranch,\r\n          newBranch,\r\n          container,\r\n          anchor,\r\n          parentComponent,\r\n          suspense,\r\n          namespace,\r\n          slotScopeIds,\r\n          optimized,\r\n        )\r\n        // force resolve\r\n        suspense.resolve(true)\r\n      } else {\r\n        // switched to a 3rd branch\r\n        patch(\r\n          null,\r\n          newBranch,\r\n          suspense.hiddenContainer,\r\n          null,\r\n          parentComponent,\r\n          suspense,\r\n          namespace,\r\n          slotScopeIds,\r\n          optimized,\r\n        )\r\n        if (suspense.deps <= 0) {\r\n          suspense.resolve()\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\r\n      // root did not change, just normal patch\r\n      patch(\r\n        activeBranch,\r\n        newBranch,\r\n        container,\r\n        anchor,\r\n        parentComponent,\r\n        suspense,\r\n        namespace,\r\n        slotScopeIds,\r\n        optimized,\r\n      )\r\n      setActiveBranch(suspense, newBranch)\r\n    } else {\r\n      // root node toggled\r\n      // invoke @pending event\r\n      triggerEvent(n2, 'onPending')\r\n      // mount pending branch in off-dom container\r\n      suspense.pendingBranch = newBranch\r\n      if (newBranch.shapeFlag & ShapeFlags.COMPONENT_KEPT_ALIVE) {\r\n        suspense.pendingId = newBranch.component!.suspenseId!\r\n      } else {\r\n        suspense.pendingId = suspenseId++\r\n      }\r\n      patch(\r\n        null,\r\n        newBranch,\r\n        suspense.hiddenContainer,\r\n        null,\r\n        parentComponent,\r\n        suspense,\r\n        namespace,\r\n        slotScopeIds,\r\n        optimized,\r\n      )\r\n      if (suspense.deps <= 0) {\r\n        // incoming branch has no async deps, resolve now.\r\n        suspense.resolve()\r\n      } else {\r\n        const { timeout, pendingId } = suspense\r\n        if (timeout > 0) {\r\n          setTimeout(() => {\r\n            if (suspense.pendingId === pendingId) {\r\n              suspense.fallback(newFallback)\r\n            }\r\n          }, timeout)\r\n        } else if (timeout === 0) {\r\n          suspense.fallback(newFallback)\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport interface SuspenseBoundary {\r\n  vnode: VNode<RendererNode, RendererElement, SuspenseProps>\r\n  parent: SuspenseBoundary | null\r\n  parentComponent: ComponentInternalInstance | null\r\n  namespace: ElementNamespace\r\n  container: RendererElement\r\n  hiddenContainer: RendererElement\r\n  activeBranch: VNode | null\r\n  pendingBranch: VNode | null\r\n  deps: number\r\n  pendingId: number\r\n  timeout: number\r\n  isInFallback: boolean\r\n  isHydrating: boolean\r\n  isUnmounted: boolean\r\n  effects: Function[]\r\n  resolve(force?: boolean, sync?: boolean): void\r\n  fallback(fallbackVNode: VNode): void\r\n  move(\r\n    container: RendererElement,\r\n    anchor: RendererNode | null,\r\n    type: MoveType,\r\n  ): void\r\n  next(): RendererNode | null\r\n  registerDep(\r\n    instance: ComponentInternalInstance,\r\n    setupRenderEffect: SetupRenderEffectFn,\r\n  ): void\r\n  unmount(parentSuspense: SuspenseBoundary | null, doRemove?: boolean): void\r\n}\r\n\r\nlet hasWarned = false\r\n\r\nfunction createSuspenseBoundary(\r\n  vnode: VNode,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  container: RendererElement,\r\n  hiddenContainer: RendererElement,\r\n  anchor: RendererNode | null,\r\n  namespace: ElementNamespace,\r\n  slotScopeIds: string[] | null,\r\n  optimized: boolean,\r\n  rendererInternals: RendererInternals,\r\n  isHydrating = false,\r\n): SuspenseBoundary {\r\n  /* istanbul ignore if */\r\n  if (__DEV__ && !__TEST__ && !hasWarned) {\r\n    hasWarned = true\r\n    // @ts-expect-error `console.info` cannot be null error\r\n    // eslint-disable-next-line no-console\r\n    console[console.info ? 'info' : 'log'](\r\n      `<Suspense> is an experimental feature and its API will likely change.`,\r\n    )\r\n  }\r\n\r\n  const {\r\n    p: patch,\r\n    m: move,\r\n    um: unmount,\r\n    n: next,\r\n    o: { parentNode, remove },\r\n  } = rendererInternals\r\n\r\n  // if set `suspensible: true`, set the current suspense as a dep of parent suspense\r\n  let parentSuspenseId: number | undefined\r\n  const isSuspensible = isVNodeSuspensible(vnode)\r\n  if (isSuspensible) {\r\n    if (parentSuspense?.pendingBranch) {\r\n      parentSuspenseId = parentSuspense.pendingId\r\n      parentSuspense.deps++\r\n    }\r\n  }\r\n\r\n  const timeout = vnode.props ? toNumber(vnode.props.timeout) : undefined\r\n  if (__DEV__) {\r\n    assertNumber(timeout, `Suspense timeout`)\r\n  }\r\n\r\n  const initialAnchor = anchor\r\n  const suspense: SuspenseBoundary = {\r\n    vnode,\r\n    parent: parentSuspense,\r\n    parentComponent,\r\n    namespace,\r\n    container,\r\n    hiddenContainer,\r\n    deps: 0,\r\n    pendingId: suspenseId++,\r\n    timeout: typeof timeout === 'number' ? timeout : -1,\r\n    activeBranch: null,\r\n    pendingBranch: null,\r\n    isInFallback: !isHydrating,\r\n    isHydrating,\r\n    isUnmounted: false,\r\n    effects: [],\r\n\r\n    resolve(resume = false, sync = false) {\r\n      if (__DEV__) {\r\n        if (!resume && !suspense.pendingBranch) {\r\n          throw new Error(\r\n            `suspense.resolve() is called without a pending branch.`,\r\n          )\r\n        }\r\n        if (suspense.isUnmounted) {\r\n          throw new Error(\r\n            `suspense.resolve() is called on an already unmounted suspense boundary.`,\r\n          )\r\n        }\r\n      }\r\n      const {\r\n        vnode,\r\n        activeBranch,\r\n        pendingBranch,\r\n        pendingId,\r\n        effects,\r\n        parentComponent,\r\n        container,\r\n      } = suspense\r\n\r\n      // if there's a transition happening we need to wait it to finish.\r\n      let delayEnter: boolean | null = false\r\n      if (suspense.isHydrating) {\r\n        suspense.isHydrating = false\r\n      } else if (!resume) {\r\n        delayEnter =\r\n          activeBranch &&\r\n          pendingBranch!.transition &&\r\n          pendingBranch!.transition.mode === 'out-in'\r\n        if (delayEnter) {\r\n          activeBranch!.transition!.afterLeave = () => {\r\n            if (pendingId === suspense.pendingId) {\r\n              move(\r\n                pendingBranch!,\r\n                container,\r\n                anchor === initialAnchor ? next(activeBranch!) : anchor,\r\n                MoveType.ENTER,\r\n              )\r\n              queuePostFlushCb(effects)\r\n            }\r\n          }\r\n        }\r\n        // unmount current active tree\r\n        if (activeBranch) {\r\n          // if the fallback tree was mounted, it may have been moved\r\n          // as part of a parent suspense. get the latest anchor for insertion\r\n          // #8105 if `delayEnter` is true, it means that the mounting of\r\n          // `activeBranch` will be delayed. if the branch switches before\r\n          // transition completes, both `activeBranch` and `pendingBranch` may\r\n          // coexist in the `hiddenContainer`. This could result in\r\n          // `next(activeBranch!)` obtaining an incorrect anchor\r\n          // (got `pendingBranch.el`).\r\n          // Therefore, after the mounting of activeBranch is completed,\r\n          // it is necessary to get the latest anchor.\r\n          if (parentNode(activeBranch.el!) !== suspense.hiddenContainer) {\r\n            anchor = next(activeBranch)\r\n          }\r\n          unmount(activeBranch, parentComponent, suspense, true)\r\n        }\r\n        if (!delayEnter) {\r\n          // move content from off-dom container to actual container\r\n          move(pendingBranch!, container, anchor, MoveType.ENTER)\r\n        }\r\n      }\r\n\r\n      setActiveBranch(suspense, pendingBranch!)\r\n      suspense.pendingBranch = null\r\n      suspense.isInFallback = false\r\n\r\n      // flush buffered effects\r\n      // check if there is a pending parent suspense\r\n      let parent = suspense.parent\r\n      let hasUnresolvedAncestor = false\r\n      while (parent) {\r\n        if (parent.pendingBranch) {\r\n          // found a pending parent suspense, merge buffered post jobs\r\n          // into that parent\r\n          parent.effects.push(...effects)\r\n          hasUnresolvedAncestor = true\r\n          break\r\n        }\r\n        parent = parent.parent\r\n      }\r\n      // no pending parent suspense nor transition, flush all jobs\r\n      if (!hasUnresolvedAncestor && !delayEnter) {\r\n        queuePostFlushCb(effects)\r\n      }\r\n      suspense.effects = []\r\n\r\n      // resolve parent suspense if all async deps are resolved\r\n      if (isSuspensible) {\r\n        if (\r\n          parentSuspense &&\r\n          parentSuspense.pendingBranch &&\r\n          parentSuspenseId === parentSuspense.pendingId\r\n        ) {\r\n          parentSuspense.deps--\r\n          if (parentSuspense.deps === 0 && !sync) {\r\n            parentSuspense.resolve()\r\n          }\r\n        }\r\n      }\r\n\r\n      // invoke @resolve event\r\n      triggerEvent(vnode, 'onResolve')\r\n    },\r\n\r\n    fallback(fallbackVNode) {\r\n      if (!suspense.pendingBranch) {\r\n        return\r\n      }\r\n\r\n      const { vnode, activeBranch, parentComponent, container, namespace } =\r\n        suspense\r\n\r\n      // invoke @fallback event\r\n      triggerEvent(vnode, 'onFallback')\r\n\r\n      const anchor = next(activeBranch!)\r\n      const mountFallback = () => {\r\n        if (!suspense.isInFallback) {\r\n          return\r\n        }\r\n        // mount the fallback tree\r\n        patch(\r\n          null,\r\n          fallbackVNode,\r\n          container,\r\n          anchor,\r\n          parentComponent,\r\n          null, // fallback tree will not have suspense context\r\n          namespace,\r\n          slotScopeIds,\r\n          optimized,\r\n        )\r\n        setActiveBranch(suspense, fallbackVNode)\r\n      }\r\n\r\n      const delayEnter =\r\n        fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in'\r\n      if (delayEnter) {\r\n        activeBranch!.transition!.afterLeave = mountFallback\r\n      }\r\n      suspense.isInFallback = true\r\n\r\n      // unmount current active branch\r\n      unmount(\r\n        activeBranch!,\r\n        parentComponent,\r\n        null, // no suspense so unmount hooks fire now\r\n        true, // shouldRemove\r\n      )\r\n\r\n      if (!delayEnter) {\r\n        mountFallback()\r\n      }\r\n    },\r\n\r\n    move(container, anchor, type) {\r\n      suspense.activeBranch &&\r\n        move(suspense.activeBranch, container, anchor, type)\r\n      suspense.container = container\r\n    },\r\n\r\n    next() {\r\n      return suspense.activeBranch && next(suspense.activeBranch)\r\n    },\r\n\r\n    registerDep(instance, setupRenderEffect) {\r\n      const isInPendingSuspense = !!suspense.pendingBranch\r\n      if (isInPendingSuspense) {\r\n        suspense.deps++\r\n      }\r\n      const hydratedEl = instance.vnode.el\r\n      instance\r\n        .asyncDep!.catch(err => {\r\n          handleError(err, instance, ErrorCodes.SETUP_FUNCTION)\r\n        })\r\n        .then(asyncSetupResult => {\r\n          // retry when the setup() promise resolves.\r\n          // component may have been unmounted before resolve.\r\n          if (\r\n            instance.isUnmounted ||\r\n            suspense.isUnmounted ||\r\n            suspense.pendingId !== instance.suspenseId\r\n          ) {\r\n            return\r\n          }\r\n          // retry from this component\r\n          instance.asyncResolved = true\r\n          const { vnode } = instance\r\n          if (__DEV__) {\r\n            pushWarningContext(vnode)\r\n          }\r\n          handleSetupResult(instance, asyncSetupResult, false)\r\n          if (hydratedEl) {\r\n            // vnode may have been replaced if an update happened before the\r\n            // async dep is resolved.\r\n            vnode.el = hydratedEl\r\n          }\r\n          const placeholder = !hydratedEl && instance.subTree.el\r\n          setupRenderEffect(\r\n            instance,\r\n            vnode,\r\n            // component may have been moved before resolve.\r\n            // if this is not a hydration, instance.subTree will be the comment\r\n            // placeholder.\r\n            parentNode(hydratedEl || instance.subTree.el!)!,\r\n            // anchor will not be used if this is hydration, so only need to\r\n            // consider the comment placeholder case.\r\n            hydratedEl ? null : next(instance.subTree),\r\n            suspense,\r\n            namespace,\r\n            optimized,\r\n          )\r\n          if (placeholder) {\r\n            remove(placeholder)\r\n          }\r\n          updateHOCHostEl(instance, vnode.el)\r\n          if (__DEV__) {\r\n            popWarningContext()\r\n          }\r\n          // only decrease deps count if suspense is not already resolved\r\n          if (isInPendingSuspense && --suspense.deps === 0) {\r\n            suspense.resolve()\r\n          }\r\n        })\r\n    },\r\n\r\n    unmount(parentSuspense, doRemove) {\r\n      suspense.isUnmounted = true\r\n      if (suspense.activeBranch) {\r\n        unmount(\r\n          suspense.activeBranch,\r\n          parentComponent,\r\n          parentSuspense,\r\n          doRemove,\r\n        )\r\n      }\r\n      if (suspense.pendingBranch) {\r\n        unmount(\r\n          suspense.pendingBranch,\r\n          parentComponent,\r\n          parentSuspense,\r\n          doRemove,\r\n        )\r\n      }\r\n    },\r\n  }\r\n\r\n  return suspense\r\n}\r\n\r\nfunction hydrateSuspense(\r\n  node: Node,\r\n  vnode: VNode,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  namespace: ElementNamespace,\r\n  slotScopeIds: string[] | null,\r\n  optimized: boolean,\r\n  rendererInternals: RendererInternals,\r\n  hydrateNode: (\r\n    node: Node,\r\n    vnode: VNode,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean,\r\n  ) => Node | null,\r\n): Node | null {\r\n  const suspense = (vnode.suspense = createSuspenseBoundary(\r\n    vnode,\r\n    parentSuspense,\r\n    parentComponent,\r\n    node.parentNode!,\r\n    // eslint-disable-next-line no-restricted-globals\r\n    document.createElement('div'),\r\n    null,\r\n    namespace,\r\n    slotScopeIds,\r\n    optimized,\r\n    rendererInternals,\r\n    true /* hydrating */,\r\n  ))\r\n  // there are two possible scenarios for server-rendered suspense:\r\n  // - success: ssr content should be fully resolved\r\n  // - failure: ssr content should be the fallback branch.\r\n  // however, on the client we don't really know if it has failed or not\r\n  // attempt to hydrate the DOM assuming it has succeeded, but we still\r\n  // need to construct a suspense boundary first\r\n  const result = hydrateNode(\r\n    node,\r\n    (suspense.pendingBranch = vnode.ssContent!),\r\n    parentComponent,\r\n    suspense,\r\n    slotScopeIds,\r\n    optimized,\r\n  )\r\n  if (suspense.deps === 0) {\r\n    suspense.resolve(false, true)\r\n  }\r\n  return result\r\n  /* eslint-enable no-restricted-globals */\r\n}\r\n\r\nfunction normalizeSuspenseChildren(vnode: VNode) {\r\n  const { shapeFlag, children } = vnode\r\n  const isSlotChildren = shapeFlag & ShapeFlags.SLOTS_CHILDREN\r\n  vnode.ssContent = normalizeSuspenseSlot(\r\n    isSlotChildren ? (children as Slots).default : children,\r\n  )\r\n  vnode.ssFallback = isSlotChildren\r\n    ? normalizeSuspenseSlot((children as Slots).fallback)\r\n    : createVNode(Comment)\r\n}\r\n\r\nfunction normalizeSuspenseSlot(s: any) {\r\n  let block: VNode[] | null | undefined\r\n  if (isFunction(s)) {\r\n    const trackBlock = isBlockTreeEnabled && s._c\r\n    if (trackBlock) {\r\n      // disableTracking: false\r\n      // allow block tracking for compiled slots\r\n      // (see ./componentRenderContext.ts)\r\n      s._d = false\r\n      openBlock()\r\n    }\r\n    s = s()\r\n    if (trackBlock) {\r\n      s._d = true\r\n      block = currentBlock\r\n      closeBlock()\r\n    }\r\n  }\r\n  if (isArray(s)) {\r\n    const singleChild = filterSingleRoot(s)\r\n    if (\r\n      __DEV__ &&\r\n      !singleChild &&\r\n      s.filter(child => child !== NULL_DYNAMIC_COMPONENT).length > 0\r\n    ) {\r\n      warn(`<Suspense> slots expect a single root node.`)\r\n    }\r\n    s = singleChild\r\n  }\r\n  s = normalizeVNode(s)\r\n  if (block && !s.dynamicChildren) {\r\n    s.dynamicChildren = block.filter(c => c !== s)\r\n  }\r\n  return s\r\n}\r\n\r\nexport function queueEffectWithSuspense(\r\n  fn: Function | Function[],\r\n  suspense: SuspenseBoundary | null,\r\n): void {\r\n  if (suspense && suspense.pendingBranch) {\r\n    if (isArray(fn)) {\r\n      suspense.effects.push(...fn)\r\n    } else {\r\n      suspense.effects.push(fn)\r\n    }\r\n  } else {\r\n    queuePostFlushCb(fn)\r\n  }\r\n}\r\n\r\nfunction setActiveBranch(suspense: SuspenseBoundary, branch: VNode) {\r\n  suspense.activeBranch = branch\r\n  const { vnode, parentComponent } = suspense\r\n  let el = branch.el\r\n  // if branch has no el after patch, it's a HOC wrapping async components\r\n  // drill and locate the placeholder comment node\r\n  while (!el && branch.component) {\r\n    branch = branch.component.subTree\r\n    el = branch.el\r\n  }\r\n  vnode.el = el\r\n  // in case suspense is the root node of a component,\r\n  // recursively update the HOC el\r\n  if (parentComponent && parentComponent.subTree === vnode) {\r\n    parentComponent.vnode.el = el\r\n    updateHOCHostEl(parentComponent, el)\r\n  }\r\n}\r\n\r\nfunction isVNodeSuspensible(vnode: VNode) {\r\n  return vnode.props?.suspensible != null && vnode.props.suspensible !== false\r\n}\r\n","import type { ComponentInternalInstance } from '../component'\r\nimport type { SuspenseBoundary } from './Suspense'\r\nimport {\r\n  type ElementNamespace,\r\n  MoveType,\r\n  type RendererElement,\r\n  type RendererInternals,\r\n  type RendererNode,\r\n  type RendererOptions,\r\n  traverseStaticChildren,\r\n} from '../renderer'\r\nimport type { VNode, VNodeArrayChildren, VNodeProps } from '../vnode'\r\nimport { ShapeFlags, isString } from '@vue/shared'\r\nimport { warn } from '../warning'\r\nimport { isHmrUpdating } from '../hmr'\r\n\r\nexport type TeleportVNode = VNode<RendererNode, RendererElement, TeleportProps>\r\n\r\nexport interface TeleportProps {\r\n  to: string | RendererElement | null | undefined\r\n  disabled?: boolean\r\n}\r\n\r\nexport const isTeleport = (type: any): boolean => type.__isTeleport\r\n\r\nconst isTeleportDisabled = (props: VNode['props']): boolean =>\r\n  props && (props.disabled || props.disabled === '')\r\n\r\nconst isTargetSVG = (target: RendererElement): boolean =>\r\n  typeof SVGElement !== 'undefined' && target instanceof SVGElement\r\n\r\nconst isTargetMathML = (target: RendererElement): boolean =>\r\n  typeof MathMLElement === 'function' && target instanceof MathMLElement\r\n\r\nconst resolveTarget = <T = RendererElement>(\r\n  props: TeleportProps | null,\r\n  select: RendererOptions['querySelector'],\r\n): T | null => {\r\n  const targetSelector = props && props.to\r\n  if (isString(targetSelector)) {\r\n    if (!select) {\r\n      __DEV__ &&\r\n        warn(\r\n          `Current renderer does not support string target for Teleports. ` +\r\n            `(missing querySelector renderer option)`,\r\n        )\r\n      return null\r\n    } else {\r\n      const target = select(targetSelector)\r\n      if (!target) {\r\n        __DEV__ &&\r\n          warn(\r\n            `Failed to locate Teleport target with selector \"${targetSelector}\". ` +\r\n              `Note the target element must exist before the component is mounted - ` +\r\n              `i.e. the target cannot be rendered by the component itself, and ` +\r\n              `ideally should be outside of the entire Vue component tree.`,\r\n          )\r\n      }\r\n      return target as T\r\n    }\r\n  } else {\r\n    if (__DEV__ && !targetSelector && !isTeleportDisabled(props)) {\r\n      warn(`Invalid Teleport target: ${targetSelector}`)\r\n    }\r\n    return targetSelector as T\r\n  }\r\n}\r\n\r\nexport const TeleportImpl = {\r\n  name: 'Teleport',\r\n  __isTeleport: true,\r\n  process(\r\n    n1: TeleportVNode | null,\r\n    n2: TeleportVNode,\r\n    container: RendererElement,\r\n    anchor: RendererNode | null,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    namespace: ElementNamespace,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean,\r\n    internals: RendererInternals,\r\n  ) {\r\n    const {\r\n      mc: mountChildren,\r\n      pc: patchChildren,\r\n      pbc: patchBlockChildren,\r\n      o: { insert, querySelector, createText, createComment },\r\n    } = internals\r\n\r\n    const disabled = isTeleportDisabled(n2.props)\r\n    let { shapeFlag, children, dynamicChildren } = n2\r\n\r\n    // #3302\r\n    // HMR updated, force full diff\r\n    if (__DEV__ && isHmrUpdating) {\r\n      optimized = false\r\n      dynamicChildren = null\r\n    }\r\n\r\n    if (n1 == null) {\r\n      // insert anchors in the main view\r\n      const placeholder = (n2.el = __DEV__\r\n        ? createComment('teleport start')\r\n        : createText(''))\r\n      const mainAnchor = (n2.anchor = __DEV__\r\n        ? createComment('teleport end')\r\n        : createText(''))\r\n      insert(placeholder, container, anchor)\r\n      insert(mainAnchor, container, anchor)\r\n      const target = (n2.target = resolveTarget(n2.props, querySelector))\r\n      const targetAnchor = (n2.targetAnchor = createText(''))\r\n      if (target) {\r\n        insert(targetAnchor, target)\r\n        // #2652 we could be teleporting from a non-SVG tree into an SVG tree\r\n        if (namespace === 'svg' || isTargetSVG(target)) {\r\n          namespace = 'svg'\r\n        } else if (namespace === 'mathml' || isTargetMathML(target)) {\r\n          namespace = 'mathml'\r\n        }\r\n      } else if (__DEV__ && !disabled) {\r\n        warn('Invalid Teleport target on mount:', target, `(${typeof target})`)\r\n      }\r\n\r\n      const mount = (container: RendererElement, anchor: RendererNode) => {\r\n        // Teleport *always* has Array children. This is enforced in both the\r\n        // compiler and vnode children normalization.\r\n        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n          mountChildren(\r\n            children as VNodeArrayChildren,\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            parentSuspense,\r\n            namespace,\r\n            slotScopeIds,\r\n            optimized,\r\n          )\r\n        }\r\n      }\r\n\r\n      if (disabled) {\r\n        mount(container, mainAnchor)\r\n      } else if (target) {\r\n        mount(target, targetAnchor)\r\n      }\r\n    } else {\r\n      // update content\r\n      n2.el = n1.el\r\n      const mainAnchor = (n2.anchor = n1.anchor)!\r\n      const target = (n2.target = n1.target)!\r\n      const targetAnchor = (n2.targetAnchor = n1.targetAnchor)!\r\n      const wasDisabled = isTeleportDisabled(n1.props)\r\n      const currentContainer = wasDisabled ? container : target\r\n      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor\r\n\r\n      if (namespace === 'svg' || isTargetSVG(target)) {\r\n        namespace = 'svg'\r\n      } else if (namespace === 'mathml' || isTargetMathML(target)) {\r\n        namespace = 'mathml'\r\n      }\r\n\r\n      if (dynamicChildren) {\r\n        // fast path when the teleport happens to be a block root\r\n        patchBlockChildren(\r\n          n1.dynamicChildren!,\r\n          dynamicChildren,\r\n          currentContainer,\r\n          parentComponent,\r\n          parentSuspense,\r\n          namespace,\r\n          slotScopeIds,\r\n        )\r\n        // even in block tree mode we need to make sure all root-level nodes\r\n        // in the teleport inherit previous DOM references so that they can\r\n        // be moved in future patches.\r\n        traverseStaticChildren(n1, n2, true)\r\n      } else if (!optimized) {\r\n        patchChildren(\r\n          n1,\r\n          n2,\r\n          currentContainer,\r\n          currentAnchor,\r\n          parentComponent,\r\n          parentSuspense,\r\n          namespace,\r\n          slotScopeIds,\r\n          false,\r\n        )\r\n      }\r\n\r\n      if (disabled) {\r\n        if (!wasDisabled) {\r\n          // enabled -> disabled\r\n          // move into main container\r\n          moveTeleport(\r\n            n2,\r\n            container,\r\n            mainAnchor,\r\n            internals,\r\n            TeleportMoveTypes.TOGGLE,\r\n          )\r\n        } else {\r\n          // #7835\r\n          // When `teleport` is disabled, `to` may change, making it always old,\r\n          // to ensure the correct `to` when enabled\r\n          if (n2.props && n1.props && n2.props.to !== n1.props.to) {\r\n            n2.props.to = n1.props.to\r\n          }\r\n        }\r\n      } else {\r\n        // target changed\r\n        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\r\n          const nextTarget = (n2.target = resolveTarget(\r\n            n2.props,\r\n            querySelector,\r\n          ))\r\n          if (nextTarget) {\r\n            moveTeleport(\r\n              n2,\r\n              nextTarget,\r\n              null,\r\n              internals,\r\n              TeleportMoveTypes.TARGET_CHANGE,\r\n            )\r\n          } else if (__DEV__) {\r\n            warn(\r\n              'Invalid Teleport target on update:',\r\n              target,\r\n              `(${typeof target})`,\r\n            )\r\n          }\r\n        } else if (wasDisabled) {\r\n          // disabled -> enabled\r\n          // move into teleport target\r\n          moveTeleport(\r\n            n2,\r\n            target,\r\n            targetAnchor,\r\n            internals,\r\n            TeleportMoveTypes.TOGGLE,\r\n          )\r\n        }\r\n      }\r\n    }\r\n\r\n    updateCssVars(n2)\r\n  },\r\n\r\n  remove(\r\n    vnode: VNode,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    optimized: boolean,\r\n    { um: unmount, o: { remove: hostRemove } }: RendererInternals,\r\n    doRemove: boolean,\r\n  ) {\r\n    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode\r\n\r\n    if (target) {\r\n      hostRemove(targetAnchor!)\r\n    }\r\n\r\n    // an unmounted teleport should always unmount its children whether it's disabled or not\r\n    doRemove && hostRemove(anchor!)\r\n    if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n      const shouldRemove = doRemove || !isTeleportDisabled(props)\r\n      for (let i = 0; i < (children as VNode[]).length; i++) {\r\n        const child = (children as VNode[])[i]\r\n        unmount(\r\n          child,\r\n          parentComponent,\r\n          parentSuspense,\r\n          shouldRemove,\r\n          !!child.dynamicChildren,\r\n        )\r\n      }\r\n    }\r\n  },\r\n\r\n  move: moveTeleport,\r\n  hydrate: hydrateTeleport,\r\n}\r\n\r\nexport enum TeleportMoveTypes {\r\n  TARGET_CHANGE,\r\n  TOGGLE, // enable / disable\r\n  REORDER, // moved in the main view\r\n}\r\n\r\nfunction moveTeleport(\r\n  vnode: VNode,\r\n  container: RendererElement,\r\n  parentAnchor: RendererNode | null,\r\n  { o: { insert }, m: move }: RendererInternals,\r\n  moveType: TeleportMoveTypes = TeleportMoveTypes.REORDER,\r\n) {\r\n  // move target anchor if this is a target change.\r\n  if (moveType === TeleportMoveTypes.TARGET_CHANGE) {\r\n    insert(vnode.targetAnchor!, container, parentAnchor)\r\n  }\r\n  const { el, anchor, shapeFlag, children, props } = vnode\r\n  const isReorder = moveType === TeleportMoveTypes.REORDER\r\n  // move main view anchor if this is a re-order.\r\n  if (isReorder) {\r\n    insert(el!, container, parentAnchor)\r\n  }\r\n  // if this is a re-order and teleport is enabled (content is in target)\r\n  // do not move children. So the opposite is: only move children if this\r\n  // is not a reorder, or the teleport is disabled\r\n  if (!isReorder || isTeleportDisabled(props)) {\r\n    // Teleport has either Array children or no children.\r\n    if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n      for (let i = 0; i < (children as VNode[]).length; i++) {\r\n        move(\r\n          (children as VNode[])[i],\r\n          container,\r\n          parentAnchor,\r\n          MoveType.REORDER,\r\n        )\r\n      }\r\n    }\r\n  }\r\n  // move main view anchor if this is a re-order.\r\n  if (isReorder) {\r\n    insert(anchor!, container, parentAnchor)\r\n  }\r\n}\r\n\r\ninterface TeleportTargetElement extends Element {\r\n  // last teleport target\r\n  _lpa?: Node | null\r\n}\r\n\r\nfunction hydrateTeleport(\r\n  node: Node,\r\n  vnode: TeleportVNode,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  slotScopeIds: string[] | null,\r\n  optimized: boolean,\r\n  {\r\n    o: { nextSibling, parentNode, querySelector },\r\n  }: RendererInternals<Node, Element>,\r\n  hydrateChildren: (\r\n    node: Node | null,\r\n    vnode: VNode,\r\n    container: Element,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean,\r\n  ) => Node | null,\r\n): Node | null {\r\n  const target = (vnode.target = resolveTarget<Element>(\r\n    vnode.props,\r\n    querySelector,\r\n  ))\r\n  if (target) {\r\n    // if multiple teleports rendered to the same target element, we need to\r\n    // pick up from where the last teleport finished instead of the first node\r\n    const targetNode =\r\n      (target as TeleportTargetElement)._lpa || target.firstChild\r\n    if (vnode.shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n      if (isTeleportDisabled(vnode.props)) {\r\n        vnode.anchor = hydrateChildren(\r\n          nextSibling(node),\r\n          vnode,\r\n          parentNode(node)!,\r\n          parentComponent,\r\n          parentSuspense,\r\n          slotScopeIds,\r\n          optimized,\r\n        )\r\n        vnode.targetAnchor = targetNode\r\n      } else {\r\n        vnode.anchor = nextSibling(node)\r\n\r\n        // lookahead until we find the target anchor\r\n        // we cannot rely on return value of hydrateChildren() because there\r\n        // could be nested teleports\r\n        let targetAnchor = targetNode\r\n        while (targetAnchor) {\r\n          targetAnchor = nextSibling(targetAnchor)\r\n          if (\r\n            targetAnchor &&\r\n            targetAnchor.nodeType === 8 &&\r\n            (targetAnchor as Comment).data === 'teleport anchor'\r\n          ) {\r\n            vnode.targetAnchor = targetAnchor\r\n            ;(target as TeleportTargetElement)._lpa =\r\n              vnode.targetAnchor && nextSibling(vnode.targetAnchor as Node)\r\n            break\r\n          }\r\n        }\r\n\r\n        hydrateChildren(\r\n          targetNode,\r\n          vnode,\r\n          target,\r\n          parentComponent,\r\n          parentSuspense,\r\n          slotScopeIds,\r\n          optimized,\r\n        )\r\n      }\r\n    }\r\n    updateCssVars(vnode)\r\n  }\r\n  return vnode.anchor && nextSibling(vnode.anchor as Node)\r\n}\r\n\r\n// Force-casted public typing for h and TSX props inference\r\nexport const Teleport = TeleportImpl as unknown as {\r\n  __isTeleport: true\r\n  new (): {\r\n    $props: VNodeProps & TeleportProps\r\n    $slots: {\r\n      default(): VNode[]\r\n    }\r\n  }\r\n}\r\n\r\nfunction updateCssVars(vnode: VNode) {\r\n  // presence of .ut method indicates owner component uses css vars.\r\n  // code path here can assume browser environment.\r\n  const ctx = vnode.ctx\r\n  if (ctx && ctx.ut) {\r\n    let node = (vnode.children as VNode[])[0].el!\r\n    while (node && node !== vnode.targetAnchor) {\r\n      if (node.nodeType === 1) node.setAttribute('data-v-owner', ctx.uid)\r\n      node = node.nextSibling\r\n    }\r\n    ctx.ut()\r\n  }\r\n}\r\n","import {\r\n  EMPTY_ARR,\r\n  PatchFlags,\r\n  ShapeFlags,\r\n  SlotFlags,\r\n  extend,\r\n  isArray,\r\n  isFunction,\r\n  isObject,\r\n  isOn,\r\n  isString,\r\n  normalizeClass,\r\n  normalizeStyle,\r\n} from '@vue/shared'\r\nimport {\r\n  type ClassComponent,\r\n  type Component,\r\n  type ComponentInternalInstance,\r\n  type ConcreteComponent,\r\n  type Data,\r\n  isClassComponent,\r\n} from './component'\r\nimport type { RawSlots } from './componentSlots'\r\nimport {\r\n  type ReactiveFlags,\r\n  type Ref,\r\n  isProxy,\r\n  isRef,\r\n  toRaw,\r\n} from '@vue/reactivity'\r\nimport type { AppContext } from './apiCreateApp'\r\nimport {\r\n  type Suspense,\r\n  type SuspenseBoundary,\r\n  type SuspenseImpl,\r\n  isSuspense,\r\n} from './components/Suspense'\r\nimport type { DirectiveBinding } from './directives'\r\nimport type { TransitionHooks } from './components/BaseTransition'\r\nimport { warn } from './warning'\r\nimport {\r\n  type Teleport,\r\n  type TeleportImpl,\r\n  isTeleport,\r\n} from './components/Teleport'\r\nimport {\r\n  currentRenderingInstance,\r\n  currentScopeId,\r\n} from './componentRenderContext'\r\nimport type { RendererElement, RendererNode } from './renderer'\r\nimport { NULL_DYNAMIC_COMPONENT } from './helpers/resolveAssets'\r\nimport { hmrDirtyComponents } from './hmr'\r\nimport { convertLegacyComponent } from './compat/component'\r\nimport { convertLegacyVModelProps } from './compat/componentVModel'\r\nimport { defineLegacyVNodeProperties } from './compat/renderFn'\r\nimport { ErrorCodes, callWithAsyncErrorHandling } from './errorHandling'\r\nimport type { ComponentPublicInstance } from './componentPublicInstance'\r\n\r\nexport const Fragment = Symbol.for('v-fgt') as any as {\r\n  __isFragment: true\r\n  new (): {\r\n    $props: VNodeProps\r\n  }\r\n}\r\nexport const Text = Symbol.for('v-txt')\r\nexport const Comment = Symbol.for('v-cmt')\r\nexport const Static = Symbol.for('v-stc')\r\n\r\nexport type VNodeTypes =\r\n  | string\r\n  | VNode\r\n  | Component\r\n  | typeof Text\r\n  | typeof Static\r\n  | typeof Comment\r\n  | typeof Fragment\r\n  | typeof Teleport\r\n  | typeof TeleportImpl\r\n  | typeof Suspense\r\n  | typeof SuspenseImpl\r\n\r\nexport type VNodeRef =\r\n  | string\r\n  | Ref\r\n  | ((\r\n      ref: Element | ComponentPublicInstance | null,\r\n      refs: Record<string, any>,\r\n    ) => void)\r\n\r\nexport type VNodeNormalizedRefAtom = {\r\n  i: ComponentInternalInstance\r\n  r: VNodeRef\r\n  k?: string // setup ref key\r\n  f?: boolean // refInFor marker\r\n}\r\n\r\nexport type VNodeNormalizedRef =\r\n  | VNodeNormalizedRefAtom\r\n  | VNodeNormalizedRefAtom[]\r\n\r\ntype VNodeMountHook = (vnode: VNode) => void\r\ntype VNodeUpdateHook = (vnode: VNode, oldVNode: VNode) => void\r\nexport type VNodeHook =\r\n  | VNodeMountHook\r\n  | VNodeUpdateHook\r\n  | VNodeMountHook[]\r\n  | VNodeUpdateHook[]\r\n\r\n// https://github.com/microsoft/TypeScript/issues/33099\r\nexport type VNodeProps = {\r\n  key?: string | number | symbol\r\n  ref?: VNodeRef\r\n  ref_for?: boolean\r\n  ref_key?: string\r\n\r\n  // vnode hooks\r\n  onVnodeBeforeMount?: VNodeMountHook | VNodeMountHook[]\r\n  onVnodeMounted?: VNodeMountHook | VNodeMountHook[]\r\n  onVnodeBeforeUpdate?: VNodeUpdateHook | VNodeUpdateHook[]\r\n  onVnodeUpdated?: VNodeUpdateHook | VNodeUpdateHook[]\r\n  onVnodeBeforeUnmount?: VNodeMountHook | VNodeMountHook[]\r\n  onVnodeUnmounted?: VNodeMountHook | VNodeMountHook[]\r\n}\r\n\r\ntype VNodeChildAtom =\r\n  | VNode\r\n  | string\r\n  | number\r\n  | boolean\r\n  | null\r\n  | undefined\r\n  | void\r\n\r\nexport type VNodeArrayChildren = Array<VNodeArrayChildren | VNodeChildAtom>\r\n\r\nexport type VNodeChild = VNodeChildAtom | VNodeArrayChildren\r\n\r\nexport type VNodeNormalizedChildren =\r\n  | string\r\n  | VNodeArrayChildren\r\n  | RawSlots\r\n  | null\r\n\r\nexport interface VNode<\r\n  HostNode = RendererNode,\r\n  HostElement = RendererElement,\r\n  ExtraProps = { [key: string]: any },\r\n> {\r\n  /**\r\n   * @internal\r\n   */\r\n  __v_isVNode: true\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  [ReactiveFlags.SKIP]: true\r\n  // 表示 VNode 的类型，可以是组件类型、原生 HTML 标签类型、注释节点、文本节点等; 区分不同类型的 VNode，在后续渲染或更新时采用不同的处理逻辑。\r\n  type: VNodeTypes\r\n  // 表示与该 VNode 相关的属性或特性，类似于 HTML 元素的属性； 包含传递给组件或元素的各种属性（例如 class、style、自定义属性等），这些属性会在渲染时应用到真实 DOM 或组件实例上。\r\n  props: (VNodeProps & ExtraProps) | null\r\n  // 表示 VNode 的唯一标识，用于优化 diff 算法。 在 VNode 的更新过程中，key 用于判断哪些节点需要被更新、移动或删除。拥有 key 的 VNode 可以更高效地进行节点复用。\r\n  key: string | number | symbol | null\r\n  ref: VNodeNormalizedRef | null\r\n  /**\r\n   * SFC only. This is assigned on vnode creation using currentScopeId\r\n   * which is set alongside currentRenderingInstance.\r\n   */\r\n  // 表示与 VNode 关联的作用域 ID。 在使用 `scoped` 样式时，这个 ID 会被附加到元素上，以确保样式作用范围正确。\r\n  scopeId: string | null\r\n  /**\r\n   * SFC only. This is assigned to:\r\n   * - Slot fragment vnodes with :slotted SFC styles.\r\n   * - Component vnodes (during patch/hydration) so that its root node can\r\n   *   inherit the component's slotScopeIds\r\n   * @internal\r\n   */\r\n  /**\r\n   * 当使用 scoped slots（作用域插槽）时，父组件会将数据传递给子组件的插槽。slotScopeIds 用于跟踪这些插槽的作用域 ID，以便在渲染时正确地处理这些插槽。Vue 通过这些 ID 来确保作用域插槽能够正确地绑定到合适的上下文。\r\n   */\r\n  slotScopeIds: string[] | null\r\n  // 表示当前 VNode 的子节点，可以是数组、文本或 null。   描述子元素的 VNode，如果有子元素，这个字段会包含这些子元素的 VNode 列表，文本节点则直接以字符串形式表示。\r\n  children: VNodeNormalizedChildren\r\n  // 表示如果 VNode 是一个组件，该字段会存储组件实例。  用于管理组件的生命周期和状态，例如在 VNode 更新时，可能会通过这个字段访问组件实例并进行相应的更新操作。 \r\n  component: ComponentInternalInstance | null\r\n  // 存储与 VNode 关联的指令列表   当 VNode 被挂载或更新时，这些指令会被调用来执行相应的逻辑\r\n  dirs: DirectiveBinding[] | null\r\n  // 与 VNode 关联的过渡效果信息。  如果 VNode 包含过渡效果，这个字段会存储相关的配置和状态，用于在元素进入或离开时执行动画。\r\n  transition: TransitionHooks<HostElement> | null\r\n\r\n  // 表示与 VNode 对应的真实 DOM 元素。  在 VNode 被挂载后，此字段会指向对应的真实 DOM 元素，用于后续的更新或操作。\r\n  el: HostNode | null\r\n  anchor: HostNode | null // fragment anchor\r\n  target: HostElement | null // teleport target\r\n  targetAnchor: HostNode | null // teleport target anchor\r\n  /**\r\n   * number of elements contained in a static vnode\r\n   * @internal\r\n   */\r\n  staticCount: number\r\n\r\n  // suspense\r\n  suspense: SuspenseBoundary | null\r\n  /**\r\n   * @internal\r\n   */\r\n  ssContent: VNode | null\r\n  /**\r\n   * @internal\r\n   */\r\n  ssFallback: VNode | null\r\n\r\n  // optimization only\r\n  //表示 VNode 的类型标志（flag），通过位运算标记 VNode 是元素、组件、文本等不同类型。  在 VNode 的处理过程中，用来快速判断和区分不同类型的 VNode，以决定如何处理该节点。\r\n  shapeFlag: number\r\n  // 表示 VNode 的优化标志，用于指示哪些部分在更新时可能会发生变化。  通过该标志，Vue 可以在更新时跳过不必要的 diff 计算，直接更新有变化的部分，从而提升性能。\r\n  patchFlag: number\r\n  /**\r\n   * @internal\r\n   * 在 Vue 3 中，VNode 中的属性可以是静态的或动态的。静态属性是不会在后续渲染中发生变化的，而动态属性则可能随数据变化而变化。dynamicProps 用于标记那些在后续更新中可能会发生变化的属性，这样 Vue 就可以有选择性地更新这些属性，而不是整个 VNode，从而提高渲染性能\r\n   */\r\n  dynamicProps: string[] | null\r\n  /**\r\n   * @internal\r\n   * dynamicChildren 用于标记那些包含动态内容的子节点。与 dynamicProps 类似，dynamicChildren 帮助 Vue 优化更新流程。Vue 会优先更新这些动态子节点，而不是整个子节点树，这样可以减少不必要的 DOM 操作，提高渲染效率。\r\n   */\r\n  dynamicChildren: VNode[] | null\r\n\r\n  // application root node only\r\n  appContext: AppContext | null\r\n\r\n  /**\r\n   * @internal lexical scope owner instance\r\n   */\r\n  // 存储与 VNode 相关的上下文对象。  通常用于存储渲染上下文，如当前的组件实例等。\r\n  ctx: ComponentInternalInstance | null\r\n\r\n  /**\r\n   * @internal attached by v-memo\r\n   * memo 属性是 Vue 3 中的一种优化手段，通过缓存和复用 VNode，避免不必要的重新渲染，以提升性能。它主要与 v-memo 指令配合使用，用于指示 Vue 仅在特定条件变化时更新节点。\r\n   */\r\n  memo?: any[]\r\n  /**\r\n   * @internal __COMPAT__ only\r\n   */\r\n  isCompatRoot?: true\r\n  /**\r\n   * @internal custom element interception hook\r\n   */\r\n  ce?: (instance: ComponentInternalInstance) => void\r\n}\r\n\r\n// Since v-if and v-for are the two possible ways node structure can dynamically\r\n// change, once we consider v-if branches and each v-for fragment a block, we\r\n// can divide a template into nested blocks, and within each block the node\r\n// structure would be stable. This allows us to skip most children diffing\r\n// and only worry about the dynamic nodes (indicated by patch flags).\r\nexport const blockStack: (VNode[] | null)[] = []\r\nexport let currentBlock: VNode[] | null = null\r\n\r\n/**\r\n * Open a block.\r\n * This must be called before `createBlock`. It cannot be part of `createBlock`\r\n * because the children of the block are evaluated before `createBlock` itself\r\n * is called. The generated code typically looks like this:\r\n *\r\n * ```js\r\n * function render() {\r\n *   return (openBlock(),createBlock('div', null, [...]))\r\n * }\r\n * ```\r\n * disableTracking is true when creating a v-for fragment block, since a v-for\r\n * fragment always diffs its children.\r\n *\r\n * @private\r\n */\r\nexport function openBlock(disableTracking = false) {\r\n  blockStack.push((currentBlock = disableTracking ? null : []))\r\n}\r\n\r\nexport function closeBlock() {\r\n  blockStack.pop()\r\n  currentBlock = blockStack[blockStack.length - 1] || null\r\n}\r\n\r\n// Whether we should be tracking dynamic child nodes inside a block.\r\n// Only tracks when this value is > 0\r\n// We are not using a simple boolean because this value may need to be\r\n// incremented/decremented by nested usage of v-once (see below)\r\nexport let isBlockTreeEnabled = 1\r\n\r\n/**\r\n * Block tracking sometimes needs to be disabled, for example during the\r\n * creation of a tree that needs to be cached by v-once. The compiler generates\r\n * code like this:\r\n *\r\n * ``` js\r\n * _cache[1] || (\r\n *   setBlockTracking(-1),\r\n *   _cache[1] = createVNode(...),\r\n *   setBlockTracking(1),\r\n *   _cache[1]\r\n * )\r\n * ```\r\n *\r\n * @private\r\n */\r\nexport function setBlockTracking(value: number) {\r\n  isBlockTreeEnabled += value\r\n}\r\n\r\nfunction setupBlock(vnode: VNode) {\r\n  // save current block children on the block vnode\r\n  vnode.dynamicChildren =\r\n    isBlockTreeEnabled > 0 ? currentBlock || (EMPTY_ARR as any) : null\r\n  // close block\r\n  closeBlock()\r\n  // a block is always going to be patched, so track it as a child of its\r\n  // parent block\r\n  if (isBlockTreeEnabled > 0 && currentBlock) {\r\n    currentBlock.push(vnode)\r\n  }\r\n  return vnode\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function createElementBlock(\r\n  type: string | typeof Fragment,\r\n  props?: Record<string, any> | null,\r\n  children?: any,\r\n  patchFlag?: number,\r\n  dynamicProps?: string[],\r\n  shapeFlag?: number,\r\n) {\r\n  return setupBlock(\r\n    createBaseVNode(\r\n      type,\r\n      props,\r\n      children,\r\n      patchFlag,\r\n      dynamicProps,\r\n      shapeFlag,\r\n      true /* isBlock */,\r\n    ),\r\n  )\r\n}\r\n\r\n/**\r\n * Create a block root vnode. Takes the same exact arguments as `createVNode`.\r\n * A block root keeps track of dynamic nodes within the block in the\r\n * `dynamicChildren` array.\r\n *\r\n * @private\r\n */\r\nexport function createBlock(\r\n  type: VNodeTypes | ClassComponent,\r\n  props?: Record<string, any> | null,\r\n  children?: any,\r\n  patchFlag?: number,\r\n  dynamicProps?: string[],\r\n): VNode {\r\n  return setupBlock(\r\n    createVNode(\r\n      type,\r\n      props,\r\n      children,\r\n      patchFlag,\r\n      dynamicProps,\r\n      true /* isBlock: prevent a block from tracking itself */,\r\n    ),\r\n  )\r\n}\r\n\r\nexport function isVNode(value: any): value is VNode {\r\n  return value ? value.__v_isVNode === true : false\r\n}\r\n\r\nexport function isSameVNodeType(n1: VNode, n2: VNode): boolean {\r\n  if (\r\n    __DEV__ &&\r\n    n2.shapeFlag & ShapeFlags.COMPONENT &&\r\n    hmrDirtyComponents.has(n2.type as ConcreteComponent)\r\n  ) {\r\n    // #7042, ensure the vnode being unmounted during HMR\r\n    // bitwise operations to remove keep alive flags\r\n    n1.shapeFlag &= ~ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE\r\n    n2.shapeFlag &= ~ShapeFlags.COMPONENT_KEPT_ALIVE\r\n    // HMR only: if the component has been hot-updated, force a reload.\r\n    return false\r\n  }\r\n  return n1.type === n2.type && n1.key === n2.key\r\n}\r\n\r\nlet vnodeArgsTransformer:\r\n  | ((\r\n      args: Parameters<typeof _createVNode>,\r\n      instance: ComponentInternalInstance | null,\r\n    ) => Parameters<typeof _createVNode>)\r\n  | undefined\r\n\r\n/**\r\n * Internal API for registering an arguments transform for createVNode\r\n * used for creating stubs in the test-utils\r\n * It is *internal* but needs to be exposed for test-utils to pick up proper\r\n * typings\r\n */\r\nexport function transformVNodeArgs(transformer?: typeof vnodeArgsTransformer) {\r\n  vnodeArgsTransformer = transformer\r\n}\r\n\r\nconst createVNodeWithArgsTransform = (\r\n  ...args: Parameters<typeof _createVNode>\r\n): VNode => {\r\n  return _createVNode(\r\n    ...(vnodeArgsTransformer\r\n      ? vnodeArgsTransformer(args, currentRenderingInstance)\r\n      : args),\r\n  )\r\n}\r\n\r\nexport const InternalObjectKey = `__vInternal`\r\n\r\nconst normalizeKey = ({ key }: VNodeProps): VNode['key'] =>\r\n  key != null ? key : null\r\n\r\nconst normalizeRef = ({\r\n  ref,\r\n  ref_key,\r\n  ref_for,\r\n}: VNodeProps): VNodeNormalizedRefAtom | null => {\r\n  if (typeof ref === 'number') {\r\n    ref = '' + ref\r\n  }\r\n  return (\r\n    ref != null\r\n      ? isString(ref) || isRef(ref) || isFunction(ref)\r\n        ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for }\r\n        : ref\r\n      : null\r\n  ) as any\r\n}\r\n\r\nfunction createBaseVNode(\r\n  type: VNodeTypes | ClassComponent | typeof NULL_DYNAMIC_COMPONENT,\r\n  props: (Data & VNodeProps) | null = null,\r\n  children: unknown = null,\r\n  patchFlag = 0,\r\n  dynamicProps: string[] | null = null,\r\n  shapeFlag = type === Fragment ? 0 : ShapeFlags.ELEMENT,\r\n  isBlockNode = false,\r\n  needFullChildrenNormalization = false,\r\n) {\r\n  const vnode = {\r\n    __v_isVNode: true, // 标识是一个VNode\r\n    __v_skip: true, // 标识在渲染过程中是否跳过该VNode，用于优化过程\r\n    type,\r\n    props, // 标识节点的各种属性\r\n    key: props && normalizeKey(props), // 节点的唯一标识，用于优化DOM更新\r\n    ref: props && normalizeRef(props), // 节点的引用，可以是字符串或者函数\r\n    scopeId: currentScopeId, // 表示节点的作用域ID，用于样式隔离\r\n    slotScopeIds: null, // 表示节点的插槽作用域ID\r\n    children, // 表示节点的子节点，可以是字符串、VNode对象或者VNode数组\r\n    component: null, // 表示节点对应的组件实例\r\n    suspense: null,\r\n    ssContent: null,\r\n    ssFallback: null,\r\n    dirs: null,\r\n    transition: null,\r\n    el: null,\r\n    anchor: null,\r\n    target: null,\r\n    targetAnchor: null,\r\n    staticCount: 0,\r\n    shapeFlag,\r\n    patchFlag,\r\n    dynamicProps,\r\n    dynamicChildren: null,\r\n    appContext: null,\r\n    ctx: currentRenderingInstance,\r\n  } as VNode\r\n\r\n  if (needFullChildrenNormalization) {\r\n    normalizeChildren(vnode, children)\r\n    // normalize suspense children\r\n    if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {\r\n      ;(type as typeof SuspenseImpl).normalize(vnode)\r\n    }\r\n  } else if (children) {\r\n    // compiled element vnode - if children is passed, only possible types are\r\n    // string or Array.\r\n    vnode.shapeFlag |= isString(children)\r\n      ? ShapeFlags.TEXT_CHILDREN\r\n      : ShapeFlags.ARRAY_CHILDREN\r\n  }\r\n\r\n  // validate key\r\n  if (__DEV__ && vnode.key !== vnode.key) {\r\n    warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type)\r\n  }\r\n\r\n  // track vnode for block tree\r\n  if (\r\n    isBlockTreeEnabled > 0 &&\r\n    // avoid a block node from tracking itself\r\n    !isBlockNode &&\r\n    // has current parent block\r\n    currentBlock &&\r\n    // presence of a patch flag indicates this node needs patching on updates.\r\n    // component nodes also should always be patched, because even if the\r\n    // component doesn't need to update, it needs to persist the instance on to\r\n    // the next vnode so that it can be properly unmounted later.\r\n    (vnode.patchFlag > 0 || shapeFlag & ShapeFlags.COMPONENT) &&\r\n    // the EVENTS flag is only for hydration and if it is the only flag, the\r\n    // vnode should not be considered dynamic due to handler caching.\r\n    vnode.patchFlag !== PatchFlags.NEED_HYDRATION\r\n  ) {\r\n    currentBlock.push(vnode)\r\n  }\r\n\r\n  if (__COMPAT__) {\r\n    convertLegacyVModelProps(vnode)\r\n    defineLegacyVNodeProperties(vnode)\r\n  }\r\n\r\n  return vnode\r\n}\r\n\r\nexport { createBaseVNode as createElementVNode }\r\n\r\nexport const createVNode = (\r\n  __DEV__ ? createVNodeWithArgsTransform : _createVNode // 提供了扩展的接口，可以给用户自己定义转换创建虚拟dom节点\r\n) as typeof _createVNode\r\n\r\nfunction _createVNode(\r\n  type: VNodeTypes | ClassComponent | typeof NULL_DYNAMIC_COMPONENT,\r\n  props: (Data & VNodeProps) | null = null,\r\n  children: unknown = null,\r\n  patchFlag: number = 0,\r\n  dynamicProps: string[] | null = null,\r\n  isBlockNode = false,\r\n): VNode {\r\n  /**\r\n   * NULL_DYNAMIC_COMPONENT表示动态组件的空值\r\n   */\r\n  if (!type || type === NULL_DYNAMIC_COMPONENT) {\r\n    if (__DEV__ && !type) {\r\n      warn(`Invalid vnode type when creating vnode: ${type}.`)\r\n    }\r\n    type = Comment\r\n  }\r\n\r\n  if (isVNode(type)) {\r\n    // createVNode receiving an existing vnode. This happens in cases like\r\n    // <component :is=\"vnode\"/>\r\n    // #2078 make sure to merge refs during the clone instead of overwriting it\r\n    const cloned = cloneVNode(type, props, true /* mergeRef: true */)\r\n    if (children) {\r\n      normalizeChildren(cloned, children)\r\n    }\r\n    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {\r\n      if (cloned.shapeFlag & ShapeFlags.COMPONENT) {\r\n        currentBlock[currentBlock.indexOf(type)] = cloned\r\n      } else {\r\n        currentBlock.push(cloned)\r\n      }\r\n    }\r\n    cloned.patchFlag |= PatchFlags.BAIL\r\n    return cloned\r\n  }\r\n\r\n  // class component normalization.\r\n  if (isClassComponent(type)) {\r\n    type = type.__vccOpts\r\n  }\r\n\r\n  // 2.x async/functional component compat\r\n  if (__COMPAT__) {\r\n    type = convertLegacyComponent(type, currentRenderingInstance)\r\n  }\r\n\r\n  // class & style normalization.\r\n  if (props) {\r\n    // for reactive or proxy objects, we need to clone it to enable mutation.\r\n    /**\r\n     * 这个函数的目的是确保在组件内部使用 props 对象时不会直接修改原始的属性，以确保数据的稳定性和可预测性\r\n     */\r\n    props = guardReactiveProps(props)!\r\n    let { class: klass, style } = props\r\n    if (klass && !isString(klass)) {\r\n      /**\r\n       * class可以是如下形式\r\n       * 'text-center, search'\r\n       * {search: true, 'text-center': true }\r\n       * ['text-center', 'search', {'filename': true }]\r\n       */\r\n      props.class = normalizeClass(klass)\r\n    }\r\n    if (isObject(style)) {\r\n      // reactive state objects need to be cloned since they are likely to be\r\n      // mutated\r\n      if (isProxy(style) && !isArray(style)) {\r\n        style = extend({}, style)\r\n      }\r\n      props.style = normalizeStyle(style)\r\n    }\r\n  }\r\n\r\n  // encode the vnode type information into a bitmap\r\n  // 获取组件的类型\r\n  const shapeFlag = isString(type)\r\n    ? ShapeFlags.ELEMENT\r\n    : __FEATURE_SUSPENSE__ && isSuspense(type)\r\n      ? ShapeFlags.SUSPENSE\r\n      : isTeleport(type)\r\n        ? ShapeFlags.TELEPORT\r\n        : isObject(type)\r\n          ? ShapeFlags.STATEFUL_COMPONENT\r\n          : isFunction(type)\r\n            ? ShapeFlags.FUNCTIONAL_COMPONENT\r\n            : 0\r\n\r\n  if (__DEV__ && shapeFlag & ShapeFlags.STATEFUL_COMPONENT && isProxy(type)) {\r\n    type = toRaw(type)\r\n    warn(\r\n      `Vue received a Component that was made a reactive object. This can ` +\r\n        `lead to unnecessary performance overhead and should be avoided by ` +\r\n        `marking the component with \\`markRaw\\` or using \\`shallowRef\\` ` +\r\n        `instead of \\`ref\\`.`,\r\n      `\\nComponent that was made reactive: `,\r\n      type,\r\n    )\r\n  }\r\n\r\n  return createBaseVNode(\r\n    type,\r\n    props,\r\n    children,\r\n    patchFlag,\r\n    dynamicProps,\r\n    shapeFlag,\r\n    isBlockNode,\r\n    true,\r\n  )\r\n}\r\n\r\nexport function guardReactiveProps(props: (Data & VNodeProps) | null) {\r\n  if (!props) return null\r\n  return isProxy(props) || InternalObjectKey in props\r\n    ? extend({}, props)\r\n    : props\r\n}\r\n\r\nexport function cloneVNode<T, U>(\r\n  vnode: VNode<T, U>,\r\n  extraProps?: (Data & VNodeProps) | null,\r\n  mergeRef = false,\r\n): VNode<T, U> {\r\n  // This is intentionally NOT using spread or extend to avoid the runtime\r\n  // key enumeration cost.\r\n  const { props, ref, patchFlag, children } = vnode\r\n  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props\r\n  const cloned: VNode<T, U> = {\r\n    __v_isVNode: true,\r\n    __v_skip: true,\r\n    type: vnode.type,\r\n    props: mergedProps,\r\n    key: mergedProps && normalizeKey(mergedProps),\r\n    ref:\r\n      extraProps && extraProps.ref\r\n        ? // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\r\n          // if the vnode itself already has a ref, cloneVNode will need to merge\r\n          // the refs so the single vnode can be set on multiple refs\r\n          mergeRef && ref\r\n          ? isArray(ref)\r\n            ? ref.concat(normalizeRef(extraProps)!)\r\n            : [ref, normalizeRef(extraProps)!]\r\n          : normalizeRef(extraProps)\r\n        : ref,\r\n    scopeId: vnode.scopeId,\r\n    slotScopeIds: vnode.slotScopeIds,\r\n    children:\r\n      __DEV__ && patchFlag === PatchFlags.HOISTED && isArray(children)\r\n        ? (children as VNode[]).map(deepCloneVNode)\r\n        : children,\r\n    target: vnode.target,\r\n    targetAnchor: vnode.targetAnchor,\r\n    staticCount: vnode.staticCount,\r\n    shapeFlag: vnode.shapeFlag,\r\n    // if the vnode is cloned with extra props, we can no longer assume its\r\n    // existing patch flag to be reliable and need to add the FULL_PROPS flag.\r\n    // note: preserve flag for fragments since they use the flag for children\r\n    // fast paths only.\r\n    patchFlag:\r\n      extraProps && vnode.type !== Fragment\r\n        ? patchFlag === PatchFlags.HOISTED // hoisted node\r\n          ? PatchFlags.FULL_PROPS\r\n          : patchFlag | PatchFlags.FULL_PROPS\r\n        : patchFlag,\r\n    dynamicProps: vnode.dynamicProps,\r\n    dynamicChildren: vnode.dynamicChildren,\r\n    appContext: vnode.appContext,\r\n    dirs: vnode.dirs,\r\n    transition: vnode.transition,\r\n\r\n    // These should technically only be non-null on mounted VNodes. However,\r\n    // they *should* be copied for kept-alive vnodes. So we just always copy\r\n    // them since them being non-null during a mount doesn't affect the logic as\r\n    // they will simply be overwritten.\r\n    component: vnode.component,\r\n    suspense: vnode.suspense,\r\n    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\r\n    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\r\n    el: vnode.el,\r\n    anchor: vnode.anchor,\r\n    ctx: vnode.ctx,\r\n    ce: vnode.ce,\r\n  }\r\n  if (__COMPAT__) {\r\n    defineLegacyVNodeProperties(cloned as VNode)\r\n  }\r\n  return cloned\r\n}\r\n\r\n/**\r\n * Dev only, for HMR of hoisted vnodes reused in v-for\r\n * https://github.com/vitejs/vite/issues/2022\r\n */\r\nfunction deepCloneVNode(vnode: VNode): VNode {\r\n  const cloned = cloneVNode(vnode)\r\n  if (isArray(vnode.children)) {\r\n    cloned.children = (vnode.children as VNode[]).map(deepCloneVNode)\r\n  }\r\n  return cloned\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function createTextVNode(text: string = ' ', flag: number = 0): VNode {\r\n  return createVNode(Text, null, text, flag)\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function createStaticVNode(\r\n  content: string,\r\n  numberOfNodes: number,\r\n): VNode {\r\n  // A static vnode can contain multiple stringified elements, and the number\r\n  // of elements is necessary for hydration.\r\n  const vnode = createVNode(Static, null, content)\r\n  vnode.staticCount = numberOfNodes\r\n  return vnode\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function createCommentVNode(\r\n  text: string = '',\r\n  // when used as the v-else branch, the comment node must be created as a\r\n  // block to ensure correct updates.\r\n  asBlock: boolean = false,\r\n): VNode {\r\n  return asBlock\r\n    ? (openBlock(), createBlock(Comment, null, text))\r\n    : createVNode(Comment, null, text)\r\n}\r\n\r\nexport function normalizeVNode(child: VNodeChild): VNode {\r\n  if (child == null || typeof child === 'boolean') {\r\n    // empty placeholder\r\n    return createVNode(Comment)\r\n  } else if (isArray(child)) {\r\n    // fragment\r\n    return createVNode(\r\n      Fragment,\r\n      null,\r\n      // #3666, avoid reference pollution when reusing vnode\r\n      child.slice(),\r\n    )\r\n  } else if (typeof child === 'object') {\r\n    // already vnode, this should be the most common since compiled templates\r\n    // always produce all-vnode children arrays\r\n    return cloneIfMounted(child)\r\n  } else {\r\n    // strings and numbers\r\n    return createVNode(Text, null, String(child))\r\n  }\r\n}\r\n\r\n// optimized normalization for template-compiled render fns\r\nexport function cloneIfMounted(child: VNode): VNode {\r\n  return (child.el === null && child.patchFlag !== PatchFlags.HOISTED) ||\r\n    child.memo\r\n    ? child\r\n    : cloneVNode(child)\r\n}\r\n\r\nexport function normalizeChildren(vnode: VNode, children: unknown) {\r\n  let type = 0\r\n  const { shapeFlag } = vnode\r\n  if (children == null) {\r\n    children = null\r\n  } else if (isArray(children)) {\r\n    type = ShapeFlags.ARRAY_CHILDREN\r\n  } else if (typeof children === 'object') {\r\n    if (shapeFlag & (ShapeFlags.ELEMENT | ShapeFlags.TELEPORT)) {\r\n      // Normalize slot to plain children for plain element and Teleport\r\n      const slot = (children as any).default\r\n      if (slot) {\r\n        // _c marker is added by withCtx() indicating this is a compiled slot\r\n        slot._c && (slot._d = false)\r\n        normalizeChildren(vnode, slot())\r\n        slot._c && (slot._d = true)\r\n      }\r\n      return\r\n    } else {\r\n      type = ShapeFlags.SLOTS_CHILDREN\r\n      const slotFlag = (children as RawSlots)._\r\n      if (!slotFlag && !(InternalObjectKey in children!)) {\r\n        // if slots are not normalized, attach context instance\r\n        // (compiled / normalized slots already have context)\r\n        ;(children as RawSlots)._ctx = currentRenderingInstance\r\n      } else if (slotFlag === SlotFlags.FORWARDED && currentRenderingInstance) {\r\n        // a child component receives forwarded slots from the parent.\r\n        // its slot type is determined by its parent's slot type.\r\n        if (\r\n          (currentRenderingInstance.slots as RawSlots)._ === SlotFlags.STABLE\r\n        ) {\r\n          ;(children as RawSlots)._ = SlotFlags.STABLE\r\n        } else {\r\n          ;(children as RawSlots)._ = SlotFlags.DYNAMIC\r\n          vnode.patchFlag |= PatchFlags.DYNAMIC_SLOTS\r\n        }\r\n      }\r\n    }\r\n  } else if (isFunction(children)) {\r\n    children = { default: children, _ctx: currentRenderingInstance }\r\n    type = ShapeFlags.SLOTS_CHILDREN\r\n  } else {\r\n    children = String(children)\r\n    // force teleport children to array so it can be moved around\r\n    if (shapeFlag & ShapeFlags.TELEPORT) {\r\n      type = ShapeFlags.ARRAY_CHILDREN\r\n      children = [createTextVNode(children as string)]\r\n    } else {\r\n      type = ShapeFlags.TEXT_CHILDREN\r\n    }\r\n  }\r\n  vnode.children = children as VNodeNormalizedChildren\r\n  vnode.shapeFlag |= type\r\n}\r\n\r\nexport function mergeProps(...args: (Data & VNodeProps)[]) {\r\n  const ret: Data = {}\r\n  for (let i = 0; i < args.length; i++) {\r\n    const toMerge = args[i]\r\n    for (const key in toMerge) {\r\n      if (key === 'class') {\r\n        if (ret.class !== toMerge.class) {\r\n          ret.class = normalizeClass([ret.class, toMerge.class])\r\n        }\r\n      } else if (key === 'style') {\r\n        ret.style = normalizeStyle([ret.style, toMerge.style])\r\n      } else if (isOn(key)) {\r\n        const existing = ret[key]\r\n        const incoming = toMerge[key]\r\n        if (\r\n          incoming &&\r\n          existing !== incoming &&\r\n          !(isArray(existing) && existing.includes(incoming))\r\n        ) {\r\n          ret[key] = existing\r\n            ? [].concat(existing as any, incoming as any)\r\n            : incoming\r\n        }\r\n      } else if (key !== '') {\r\n        ret[key] = toMerge[key]\r\n      }\r\n    }\r\n  }\r\n  return ret\r\n}\r\n\r\nexport function invokeVNodeHook(\r\n  hook: VNodeHook,\r\n  instance: ComponentInternalInstance | null,\r\n  vnode: VNode,\r\n  prevVNode: VNode | null = null,\r\n) {\r\n  callWithAsyncErrorHandling(hook, instance, ErrorCodes.VNODE_HOOK, [\r\n    vnode,\r\n    prevVNode,\r\n  ])\r\n}\r\n","import { type VNode, type VNodeChild, isVNode } from './vnode'\r\nimport {\r\n  EffectScope,\r\n  type ReactiveEffect,\r\n  TrackOpTypes,\r\n  isRef,\r\n  markRaw,\r\n  pauseTracking,\r\n  proxyRefs,\r\n  resetTracking,\r\n  shallowReadonly,\r\n  track,\r\n} from '@vue/reactivity'\r\nimport {\r\n  type ComponentPublicInstance,\r\n  type ComponentPublicInstanceConstructor,\r\n  PublicInstanceProxyHandlers,\r\n  RuntimeCompiledPublicInstanceProxyHandlers,\r\n  createDevRenderContext,\r\n  exposePropsOnRenderContext,\r\n  exposeSetupStateOnRenderContext,\r\n  publicPropertiesMap,\r\n} from './componentPublicInstance'\r\nimport {\r\n  type ComponentPropsOptions,\r\n  type NormalizedPropsOptions,\r\n  initProps,\r\n  normalizePropsOptions,\r\n} from './componentProps'\r\nimport {\r\n  type InternalSlots,\r\n  type Slots,\r\n  type SlotsType,\r\n  type UnwrapSlotsType,\r\n  initSlots,\r\n} from './componentSlots'\r\nimport { warn } from './warning'\r\nimport { ErrorCodes, callWithErrorHandling, handleError } from './errorHandling'\r\nimport {\r\n  type AppConfig,\r\n  type AppContext,\r\n  createAppContext,\r\n} from './apiCreateApp'\r\nimport { type Directive, validateDirectiveName } from './directives'\r\nimport {\r\n  type ComponentOptions,\r\n  type ComputedOptions,\r\n  type MethodOptions,\r\n  applyOptions,\r\n  resolveMergedOptions,\r\n} from './componentOptions'\r\nimport {\r\n  type EmitFn,\r\n  type EmitsOptions,\r\n  type EmitsToProps,\r\n  type ObjectEmitsOptions,\r\n  type ShortEmitsToObject,\r\n  emit,\r\n  normalizeEmitsOptions,\r\n} from './componentEmits'\r\nimport {\r\n  EMPTY_OBJ,\r\n  type IfAny,\r\n  NO,\r\n  NOOP,\r\n  ShapeFlags,\r\n  extend,\r\n  getGlobalThis,\r\n  isArray,\r\n  isFunction,\r\n  isObject,\r\n  isPromise,\r\n  makeMap,\r\n} from '@vue/shared'\r\nimport type { SuspenseBoundary } from './components/Suspense'\r\nimport type { CompilerOptions } from '@vue/compiler-core'\r\nimport { markAttrsAccessed } from './componentRenderUtils'\r\nimport { currentRenderingInstance } from './componentRenderContext'\r\nimport { endMeasure, startMeasure } from './profiling'\r\nimport { convertLegacyRenderFn } from './compat/renderFn'\r\nimport {\r\n  type CompatConfig,\r\n  globalCompatConfig,\r\n  validateCompatConfig,\r\n} from './compat/compatConfig'\r\nimport type { SchedulerJob } from './scheduler'\r\nimport type { LifecycleHooks } from './enums'\r\n\r\nexport type Data = Record<string, unknown>\r\n\r\n/**\r\n * Public utility type for extracting the instance type of a component.\r\n * Works with all valid component definition types. This is intended to replace\r\n * the usage of `InstanceType<typeof Comp>` which only works for\r\n * constructor-based component definition types.\r\n *\r\n * Exmaple:\r\n * ```ts\r\n * const MyComp = { ... }\r\n * declare const instance: ComponentInstance<typeof MyComp>\r\n * ```\r\n */\r\nexport type ComponentInstance<T> = T extends { new (): ComponentPublicInstance }\r\n  ? InstanceType<T>\r\n  : T extends FunctionalComponent<infer Props, infer Emits>\r\n    ? ComponentPublicInstance<Props, {}, {}, {}, {}, ShortEmitsToObject<Emits>>\r\n    : T extends Component<\r\n          infer Props,\r\n          infer RawBindings,\r\n          infer D,\r\n          infer C,\r\n          infer M\r\n        >\r\n      ? // NOTE we override Props/RawBindings/D to make sure is not `unknown`\r\n        ComponentPublicInstance<\r\n          unknown extends Props ? {} : Props,\r\n          unknown extends RawBindings ? {} : RawBindings,\r\n          unknown extends D ? {} : D,\r\n          C,\r\n          M\r\n        >\r\n      : never // not a vue Component\r\n\r\n/**\r\n * For extending allowed non-declared props on components in TSX\r\n */\r\nexport interface ComponentCustomProps {}\r\n\r\n/**\r\n * Default allowed non-declared props on component in TSX\r\n */\r\nexport interface AllowedComponentProps {\r\n  class?: unknown\r\n  style?: unknown\r\n}\r\n\r\n// Note: can't mark this whole interface internal because some public interfaces\r\n// extend it.\r\nexport interface ComponentInternalOptions {\r\n  /**\r\n   * @internal\r\n   */\r\n  __scopeId?: string\r\n  /**\r\n   * @internal\r\n   */\r\n  __cssModules?: Data\r\n  /**\r\n   * @internal\r\n   */\r\n  __hmrId?: string\r\n  /**\r\n   * Compat build only, for bailing out of certain compatibility behavior\r\n   */\r\n  __isBuiltIn?: boolean\r\n  /**\r\n   * This one should be exposed so that devtools can make use of it\r\n   */\r\n  __file?: string\r\n  /**\r\n   * name inferred from filename\r\n   */\r\n  __name?: string\r\n}\r\n\r\nexport interface FunctionalComponent<\r\n  P = {},\r\n  E extends EmitsOptions | Record<string, any[]> = {},\r\n  S extends Record<string, any> = any,\r\n  EE extends EmitsOptions = ShortEmitsToObject<E>,\r\n> extends ComponentInternalOptions {\r\n  // use of any here is intentional so it can be a valid JSX Element constructor\r\n  (\r\n    props: P & EmitsToProps<EE>,\r\n    ctx: Omit<SetupContext<EE, IfAny<S, {}, SlotsType<S>>>, 'expose'>,\r\n  ): any\r\n  props?: ComponentPropsOptions<P>\r\n  emits?: EE | (keyof EE)[]\r\n  slots?: IfAny<S, Slots, SlotsType<S>>\r\n  inheritAttrs?: boolean\r\n  displayName?: string\r\n  compatConfig?: CompatConfig\r\n}\r\n\r\nexport interface ClassComponent {\r\n  new (...args: any[]): ComponentPublicInstance<any, any, any, any, any>\r\n  __vccOpts: ComponentOptions\r\n}\r\n\r\n/**\r\n * Concrete component type matches its actual value: it's either an options\r\n * object, or a function. Use this where the code expects to work with actual\r\n * values, e.g. checking if its a function or not. This is mostly for internal\r\n * implementation code.\r\n */\r\nexport type ConcreteComponent<\r\n  Props = {},\r\n  RawBindings = any,\r\n  D = any,\r\n  C extends ComputedOptions = ComputedOptions,\r\n  M extends MethodOptions = MethodOptions,\r\n  E extends EmitsOptions | Record<string, any[]> = {},\r\n  S extends Record<string, any> = any,\r\n> =\r\n  | ComponentOptions<Props, RawBindings, D, C, M>\r\n  | FunctionalComponent<Props, E, S>\r\n\r\n/**\r\n * A type used in public APIs where a component type is expected.\r\n * The constructor type is an artificial type returned by defineComponent().\r\n */\r\nexport type Component<\r\n  Props = any,\r\n  RawBindings = any,\r\n  D = any,\r\n  C extends ComputedOptions = ComputedOptions,\r\n  M extends MethodOptions = MethodOptions,\r\n  E extends EmitsOptions | Record<string, any[]> = {},\r\n  S extends Record<string, any> = any,\r\n> =\r\n  | ConcreteComponent<Props, RawBindings, D, C, M, E, S>\r\n  | ComponentPublicInstanceConstructor<Props>\r\n\r\nexport type { ComponentOptions }\r\n\r\ntype LifecycleHook<TFn = Function> = TFn[] | null\r\n\r\n// use `E extends any` to force evaluating type to fix #2362\r\nexport type SetupContext<\r\n  E = EmitsOptions,\r\n  S extends SlotsType = {},\r\n> = E extends any\r\n  ? {\r\n      attrs: Data\r\n      slots: UnwrapSlotsType<S>\r\n      emit: EmitFn<E>\r\n      expose: (exposed?: Record<string, any>) => void\r\n    }\r\n  : never\r\n\r\n/**\r\n * @internal\r\n */\r\nexport type InternalRenderFunction = {\r\n  (\r\n    ctx: ComponentPublicInstance,\r\n    cache: ComponentInternalInstance['renderCache'],\r\n    // for compiler-optimized bindings\r\n    $props: ComponentInternalInstance['props'],\r\n    $setup: ComponentInternalInstance['setupState'],\r\n    $data: ComponentInternalInstance['data'],\r\n    $options: ComponentInternalInstance['ctx'],\r\n  ): VNodeChild\r\n  _rc?: boolean // isRuntimeCompiled\r\n\r\n  // __COMPAT__ only\r\n  _compatChecked?: boolean // v3 and already checked for v2 compat\r\n  _compatWrapped?: boolean // is wrapped for v2 compat\r\n}\r\n\r\n/**\r\n * We expose a subset of properties on the internal instance as they are\r\n * useful for advanced external libraries and tools.\r\n */\r\nexport interface ComponentInternalInstance {\r\n  uid: number\r\n  type: ConcreteComponent\r\n  parent: ComponentInternalInstance | null\r\n  root: ComponentInternalInstance\r\n  appContext: AppContext\r\n  /**\r\n   * Vnode representing this component in its parent's vdom tree\r\n   */\r\n  vnode: VNode\r\n  /**\r\n   * The pending new vnode from parent updates\r\n   * @internal\r\n   */\r\n  next: VNode | null\r\n  /**\r\n   * Root vnode of this component's own vdom tree\r\n   */\r\n  subTree: VNode\r\n  /**\r\n   * Render effect instance\r\n   */\r\n  effect: ReactiveEffect\r\n  /**\r\n   * Bound effect runner to be passed to schedulers\r\n   */\r\n  update: SchedulerJob\r\n  /**\r\n   * The render function that returns vdom tree.\r\n   * @internal\r\n   */\r\n  render: InternalRenderFunction | null\r\n  /**\r\n   * SSR render function\r\n   * @internal\r\n   */\r\n  ssrRender?: Function | null\r\n  /**\r\n   * Object containing values this component provides for its descendants\r\n   * @internal\r\n   */\r\n  provides: Data\r\n  /**\r\n   * Tracking reactive effects (e.g. watchers) associated with this component\r\n   * so that they can be automatically stopped on component unmount\r\n   * @internal\r\n   */\r\n  scope: EffectScope\r\n  /**\r\n   * cache for proxy access type to avoid hasOwnProperty calls\r\n   * @internal\r\n   */\r\n  accessCache: Data | null\r\n  /**\r\n   * cache for render function values that rely on _ctx but won't need updates\r\n   * after initialized (e.g. inline handlers)\r\n   * @internal\r\n   */\r\n  renderCache: (Function | VNode)[]\r\n\r\n  /**\r\n   * Resolved component registry, only for components with mixins or extends\r\n   * @internal\r\n   */\r\n  components: Record<string, ConcreteComponent> | null\r\n  /**\r\n   * Resolved directive registry, only for components with mixins or extends\r\n   * @internal\r\n   */\r\n  directives: Record<string, Directive> | null\r\n  /**\r\n   * Resolved filters registry, v2 compat only\r\n   * @internal\r\n   */\r\n  filters?: Record<string, Function>\r\n  /**\r\n   * resolved props options\r\n   * @internal\r\n   */\r\n  propsOptions: NormalizedPropsOptions\r\n  /**\r\n   * resolved emits options\r\n   * @internal\r\n   */\r\n  emitsOptions: ObjectEmitsOptions | null\r\n  /**\r\n   * resolved inheritAttrs options\r\n   * @internal\r\n   */\r\n  inheritAttrs?: boolean\r\n  /**\r\n   * is custom element?\r\n   * @internal\r\n   */\r\n  isCE?: boolean\r\n  /**\r\n   * custom element specific HMR method\r\n   * @internal\r\n   */\r\n  ceReload?: (newStyles?: string[]) => void\r\n\r\n  // the rest are only for stateful components ---------------------------------\r\n\r\n  // main proxy that serves as the public instance (`this`)\r\n  proxy: ComponentPublicInstance | null\r\n\r\n  // exposed properties via expose()\r\n  exposed: Record<string, any> | null\r\n  exposeProxy: Record<string, any> | null\r\n\r\n  /**\r\n   * alternative proxy used only for runtime-compiled render functions using\r\n   * `with` block\r\n   * @internal\r\n   */\r\n  withProxy: ComponentPublicInstance | null\r\n  /**\r\n   * This is the target for the public instance proxy. It also holds properties\r\n   * injected by user options (computed, methods etc.) and user-attached\r\n   * custom properties (via `this.x = ...`)\r\n   * @internal\r\n   */\r\n  ctx: Data\r\n\r\n  // state\r\n  data: Data\r\n  props: Data\r\n  attrs: Data\r\n  slots: InternalSlots\r\n  refs: Data\r\n  emit: EmitFn\r\n\r\n  attrsProxy: Data | null\r\n  slotsProxy: Slots | null\r\n\r\n  /**\r\n   * used for keeping track of .once event handlers on components\r\n   * @internal\r\n   */\r\n  emitted: Record<string, boolean> | null\r\n  /**\r\n   * used for caching the value returned from props default factory functions to\r\n   * avoid unnecessary watcher trigger\r\n   * @internal\r\n   */\r\n  propsDefaults: Data\r\n  /**\r\n   * setup related\r\n   * @internal\r\n   */\r\n  setupState: Data\r\n  /**\r\n   * devtools access to additional info\r\n   * @internal\r\n   */\r\n  devtoolsRawSetupState?: any\r\n  /**\r\n   * @internal\r\n   */\r\n  setupContext: SetupContext | null\r\n\r\n  /**\r\n   * suspense related\r\n   * @internal\r\n   */\r\n  suspense: SuspenseBoundary | null\r\n  /**\r\n   * suspense pending batch id\r\n   * @internal\r\n   */\r\n  suspenseId: number\r\n  /**\r\n   * @internal\r\n   */\r\n  asyncDep: Promise<any> | null\r\n  /**\r\n   * @internal\r\n   */\r\n  asyncResolved: boolean\r\n\r\n  // lifecycle\r\n  isMounted: boolean\r\n  isUnmounted: boolean\r\n  isDeactivated: boolean\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.BEFORE_CREATE]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.CREATED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.BEFORE_MOUNT]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.MOUNTED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.BEFORE_UPDATE]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.UPDATED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.BEFORE_UNMOUNT]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.UNMOUNTED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.RENDER_TRACKED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.RENDER_TRIGGERED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.ACTIVATED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.DEACTIVATED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.ERROR_CAPTURED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.SERVER_PREFETCH]: LifecycleHook<() => Promise<unknown>>\r\n\r\n  /**\r\n   * For caching bound $forceUpdate on public proxy access\r\n   * @internal\r\n   */\r\n  f?: () => void\r\n  /**\r\n   * For caching bound $nextTick on public proxy access\r\n   * @internal\r\n   */\r\n  n?: () => Promise<void>\r\n  /**\r\n   * `updateTeleportCssVars`\r\n   * For updating css vars on contained teleports\r\n   * @internal\r\n   */\r\n  ut?: (vars?: Record<string, string>) => void\r\n}\r\n\r\nconst emptyAppContext = createAppContext()\r\n\r\nlet uid = 0\r\n\r\nexport function createComponentInstance(\r\n  vnode: VNode,\r\n  parent: ComponentInternalInstance | null,\r\n  suspense: SuspenseBoundary | null,\r\n) {\r\n  const type = vnode.type as ConcreteComponent\r\n  // inherit parent app context - or - if root, adopt from root vnode\r\n  const appContext =\r\n    (parent ? parent.appContext : vnode.appContext) || emptyAppContext\r\n\r\n  // 定义的组件（ConcreteComponent）--> 创建虚拟Dom（VNode，包含了context） --> 创建组件实例（包含type/vnode）\r\n  const instance: ComponentInternalInstance = {\r\n    uid: uid++, // 组件的唯一标识\r\n    vnode, // 虚拟dom\r\n    type, // 用户定义的组件\r\n    parent,\r\n    appContext,//全局的context上下文\r\n    root: null!, // to be immediately set\r\n    next: null,\r\n    subTree: null!, // will be set synchronously right after creation\r\n    effect: null!,\r\n    update: null!, // will be set synchronously right after creation\r\n    scope: new EffectScope(true /* detached */),\r\n    render: null,\r\n    proxy: null,\r\n    exposed: null,\r\n    exposeProxy: null,\r\n    withProxy: null,\r\n    provides: parent ? parent.provides : Object.create(appContext.provides),\r\n    accessCache: null!,\r\n    renderCache: [],\r\n\r\n    // local resolved assets\r\n    components: null,\r\n    directives: null,\r\n\r\n    // resolved props and emits options\r\n    propsOptions: normalizePropsOptions(type, appContext),\r\n    emitsOptions: normalizeEmitsOptions(type, appContext),\r\n\r\n    // emit\r\n    emit: null!, // to be set immediately\r\n    emitted: null,\r\n\r\n    // props default value\r\n    propsDefaults: EMPTY_OBJ,\r\n\r\n    // inheritAttrs\r\n    inheritAttrs: type.inheritAttrs,\r\n\r\n    // state\r\n    ctx: EMPTY_OBJ,\r\n    data: EMPTY_OBJ,\r\n    props: EMPTY_OBJ,\r\n    attrs: EMPTY_OBJ,\r\n    slots: EMPTY_OBJ,\r\n    refs: EMPTY_OBJ,\r\n    setupState: EMPTY_OBJ,\r\n    setupContext: null,\r\n\r\n    attrsProxy: null,\r\n    slotsProxy: null,\r\n\r\n    // suspense related\r\n    suspense,\r\n    suspenseId: suspense ? suspense.pendingId : 0,\r\n    asyncDep: null,\r\n    asyncResolved: false,\r\n\r\n    // lifecycle hooks\r\n    // not using enums here because it results in computed properties\r\n    isMounted: false,\r\n    isUnmounted: false,\r\n    isDeactivated: false,\r\n    bc: null,\r\n    c: null,\r\n    bm: null,\r\n    m: null,\r\n    bu: null,\r\n    u: null,\r\n    um: null,\r\n    bum: null,\r\n    da: null,\r\n    a: null,\r\n    rtg: null,\r\n    rtc: null,\r\n    ec: null,\r\n    sp: null,\r\n  }\r\n  // 将组件实例本身作为ctx字段的值存储起来\r\n  if (__DEV__) {\r\n    instance.ctx = createDevRenderContext(instance)\r\n  } else {\r\n    instance.ctx = { _: instance }\r\n  }\r\n  instance.root = parent ? parent.root : instance\r\n  instance.emit = emit.bind(null, instance)\r\n\r\n  // apply custom element special handling\r\n  if (vnode.ce) {\r\n    vnode.ce(instance)\r\n  }\r\n\r\n  return instance\r\n}\r\n\r\nexport let currentInstance: ComponentInternalInstance | null = null\r\n\r\nexport const getCurrentInstance: () => ComponentInternalInstance | null = () =>\r\n  currentInstance || currentRenderingInstance\r\n\r\nlet internalSetCurrentInstance: (\r\n  instance: ComponentInternalInstance | null,\r\n) => void\r\nlet setInSSRSetupState: (state: boolean) => void\r\n\r\n/**\r\n * The following makes getCurrentInstance() usage across multiple copies of Vue\r\n * work. Some cases of how this can happen are summarized in #7590. In principle\r\n * the duplication should be avoided, but in practice there are often cases\r\n * where the user is unable to resolve on their own, especially in complicated\r\n * SSR setups.\r\n *\r\n * Note this fix is technically incomplete, as we still rely on other singletons\r\n * for effectScope and global reactive dependency maps. However, it does make\r\n * some of the most common cases work. It also warns if the duplication is\r\n * found during browser execution.\r\n */\r\nif (__SSR__) {\r\n  type Setter = (v: any) => void\r\n  const g = getGlobalThis()\r\n  const registerGlobalSetter = (key: string, setter: Setter) => {\r\n    let setters: Setter[]\r\n    if (!(setters = g[key])) setters = g[key] = []\r\n    setters.push(setter)\r\n    return (v: any) => {\r\n      if (setters.length > 1) setters.forEach(set => set(v))\r\n      else setters[0](v)\r\n    }\r\n  }\r\n  internalSetCurrentInstance = registerGlobalSetter(\r\n    `__VUE_INSTANCE_SETTERS__`,\r\n    v => (currentInstance = v),\r\n  )\r\n  // also make `isInSSRComponentSetup` sharable across copies of Vue.\r\n  // this is needed in the SFC playground when SSRing async components, since\r\n  // we have to load both the runtime and the server-renderer from CDNs, they\r\n  // contain duplicated copies of Vue runtime code.\r\n  setInSSRSetupState = registerGlobalSetter(\r\n    `__VUE_SSR_SETTERS__`,\r\n    v => (isInSSRComponentSetup = v),\r\n  )\r\n} else {\r\n  internalSetCurrentInstance = i => {\r\n    currentInstance = i\r\n  }\r\n  setInSSRSetupState = v => {\r\n    isInSSRComponentSetup = v\r\n  }\r\n}\r\n\r\nexport const setCurrentInstance = (instance: ComponentInternalInstance) => {\r\n  const prev = currentInstance\r\n  internalSetCurrentInstance(instance)\r\n  instance.scope.on()\r\n  return () => {\r\n    instance.scope.off()\r\n    internalSetCurrentInstance(prev)\r\n  }\r\n}\r\n\r\nexport const unsetCurrentInstance = () => {\r\n  currentInstance && currentInstance.scope.off()\r\n  internalSetCurrentInstance(null)\r\n}\r\n\r\nconst isBuiltInTag = /*#__PURE__*/ makeMap('slot,component')\r\n\r\nexport function validateComponentName(name: string, config: AppConfig) {\r\n  const appIsNativeTag = config.isNativeTag || NO\r\n  if (isBuiltInTag(name) || appIsNativeTag(name)) {\r\n    warn(\r\n      'Do not use built-in or reserved HTML elements as component id: ' + name,\r\n    )\r\n  }\r\n}\r\n\r\nexport function isStatefulComponent(instance: ComponentInternalInstance) {\r\n  return instance.vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT\r\n}\r\n\r\nexport let isInSSRComponentSetup = false\r\n\r\nexport function setupComponent(\r\n  instance: ComponentInternalInstance,\r\n  isSSR = false,\r\n) {\r\n  isSSR && setInSSRSetupState(isSSR)\r\n\r\n  const { props, children } = instance.vnode\r\n  // 是否是一个有状态的组件\r\n  const isStateful = isStatefulComponent(instance)\r\n  initProps(instance, props, isStateful, isSSR)\r\n  initSlots(instance, children)\r\n\r\n  const setupResult = isStateful\r\n    ? setupStatefulComponent(instance, isSSR)\r\n    : undefined\r\n\r\n  isSSR && setInSSRSetupState(false)\r\n  return setupResult\r\n}\r\n\r\nfunction setupStatefulComponent(\r\n  instance: ComponentInternalInstance,\r\n  isSSR: boolean,\r\n) {\r\n  const Component = instance.type as ComponentOptions\r\n\r\n  if (__DEV__) {\r\n    if (Component.name) {\r\n      validateComponentName(Component.name, instance.appContext.config)\r\n    }\r\n    if (Component.components) {\r\n      const names = Object.keys(Component.components)\r\n      for (let i = 0; i < names.length; i++) {\r\n        validateComponentName(names[i], instance.appContext.config)\r\n      }\r\n    }\r\n    if (Component.directives) {\r\n      const names = Object.keys(Component.directives)\r\n      for (let i = 0; i < names.length; i++) {\r\n        validateDirectiveName(names[i])\r\n      }\r\n    }\r\n    if (Component.compilerOptions && isRuntimeOnly()) {\r\n      warn(\r\n        `\"compilerOptions\" is only supported when using a build of Vue that ` +\r\n          `includes the runtime compiler. Since you are using a runtime-only ` +\r\n          `build, the options should be passed via your build tool config instead.`,\r\n      )\r\n    }\r\n  }\r\n  // 0. create render proxy property access cache\r\n  // 组件的属性访问缓存\r\n  instance.accessCache = Object.create(null)\r\n  // 1. create public instance / render proxy\r\n  // also mark it raw so it's never observed\r\n  /**\r\n   * 给ctx创建一个代理对象，并标识为非响应式，赋值给proxy字段\r\n   * 代理的处理对象为PublicInstanceProxyHandlers\r\n   */\r\n  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers))\r\n  if (__DEV__) {\r\n    exposePropsOnRenderContext(instance)\r\n  }\r\n  // 2. call setup()\r\n  const { setup } = Component\r\n  // 如果存在setup函数就调用setup函数\r\n  if (setup) {\r\n    const setupContext = (instance.setupContext =\r\n      setup.length > 1 ? createSetupContext(instance) : null)\r\n\r\n    const reset = setCurrentInstance(instance)\r\n    pauseTracking()\r\n    const setupResult = callWithErrorHandling(\r\n      setup,\r\n      instance,\r\n      ErrorCodes.SETUP_FUNCTION,\r\n      [\r\n        __DEV__ ? shallowReadonly(instance.props) : instance.props,\r\n        setupContext,\r\n      ],\r\n    )\r\n    resetTracking()\r\n    reset()\r\n\r\n    if (isPromise(setupResult)) {\r\n      setupResult.then(unsetCurrentInstance, unsetCurrentInstance)\r\n      if (isSSR) {\r\n        // return the promise so server-renderer can wait on it\r\n        return setupResult\r\n          .then((resolvedResult: unknown) => {\r\n            handleSetupResult(instance, resolvedResult, isSSR)\r\n          })\r\n          .catch(e => {\r\n            handleError(e, instance, ErrorCodes.SETUP_FUNCTION)\r\n          })\r\n      } else if (__FEATURE_SUSPENSE__) {\r\n        // async setup returned Promise.\r\n        // bail here and wait for re-entry.\r\n        instance.asyncDep = setupResult\r\n        if (__DEV__ && !instance.suspense) {\r\n          const name = Component.name ?? 'Anonymous'\r\n          warn(\r\n            `Component <${name}>: setup function returned a promise, but no ` +\r\n              `<Suspense> boundary was found in the parent component tree. ` +\r\n              `A component with async setup() must be nested in a <Suspense> ` +\r\n              `in order to be rendered.`,\r\n          )\r\n        }\r\n      } else if (__DEV__) {\r\n        warn(\r\n          `setup() returned a Promise, but the version of Vue you are using ` +\r\n            `does not support it yet.`,\r\n        )\r\n      }\r\n    } else {\r\n      handleSetupResult(instance, setupResult, isSSR)\r\n    }\r\n  } else {\r\n    finishComponentSetup(instance, isSSR)\r\n  }\r\n}\r\n\r\nexport function handleSetupResult(\r\n  instance: ComponentInternalInstance,\r\n  setupResult: unknown,\r\n  isSSR: boolean,\r\n) {\r\n  if (isFunction(setupResult)) {\r\n    // setup returned an inline render function\r\n    if (__SSR__ && (instance.type as ComponentOptions).__ssrInlineRender) {\r\n      // when the function's name is `ssrRender` (compiled by SFC inline mode),\r\n      // set it as ssrRender instead.\r\n      instance.ssrRender = setupResult\r\n    } else {\r\n      instance.render = setupResult as InternalRenderFunction\r\n    }\r\n  } else if (isObject(setupResult)) {\r\n    if (__DEV__ && isVNode(setupResult)) {\r\n      warn(\r\n        `setup() should not return VNodes directly - ` +\r\n          `return a render function instead.`,\r\n      )\r\n    }\r\n    // setup returned bindings.\r\n    // assuming a render function compiled from template is present.\r\n    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n      instance.devtoolsRawSetupState = setupResult\r\n    }\r\n    instance.setupState = proxyRefs(setupResult)\r\n    if (__DEV__) {\r\n      exposeSetupStateOnRenderContext(instance)\r\n    }\r\n  } else if (__DEV__ && setupResult !== undefined) {\r\n    warn(\r\n      `setup() should return an object. Received: ${\r\n        setupResult === null ? 'null' : typeof setupResult\r\n      }`,\r\n    )\r\n  }\r\n  finishComponentSetup(instance, isSSR)\r\n}\r\n\r\ntype CompileFunction = (\r\n  template: string | object,\r\n  options?: CompilerOptions,\r\n) => InternalRenderFunction\r\n\r\nlet compile: CompileFunction | undefined\r\nlet installWithProxy: (i: ComponentInternalInstance) => void\r\n\r\n/**\r\n * For runtime-dom to register the compiler.\r\n * Note the exported method uses any to avoid d.ts relying on the compiler types.\r\n */\r\nexport function registerRuntimeCompiler(_compile: any) {\r\n  compile = _compile\r\n  installWithProxy = i => {\r\n    if (i.render!._rc) {\r\n      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers)\r\n    }\r\n  }\r\n}\r\n\r\n// dev only\r\nexport const isRuntimeOnly = () => !compile\r\n\r\n/**\r\n * 先执行组件的setup方法，然后判断组件是否有render函数，如果没有render函数，通过template构建render函数\r\n * \r\n */\r\nexport function finishComponentSetup(\r\n  instance: ComponentInternalInstance,\r\n  isSSR: boolean,\r\n  skipOptions?: boolean,\r\n) {\r\n  const Component = instance.type as ComponentOptions\r\n\r\n  if (__COMPAT__) {\r\n    convertLegacyRenderFn(instance)\r\n\r\n    if (__DEV__ && Component.compatConfig) {\r\n      validateCompatConfig(Component.compatConfig)\r\n    }\r\n  }\r\n\r\n  // template / render function normalization\r\n  // could be already set when returned from setup()\r\n  if (!instance.render) {\r\n    // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation\r\n    // is done by server-renderer\r\n    if (!isSSR && compile && !Component.render) {\r\n      const template =\r\n        (__COMPAT__ &&\r\n          instance.vnode.props &&\r\n          instance.vnode.props['inline-template']) ||\r\n        Component.template ||\r\n        resolveMergedOptions(instance).template\r\n      if (template) {\r\n        if (__DEV__) {\r\n          startMeasure(instance, `compile`)\r\n        }\r\n        const { isCustomElement, compilerOptions } = instance.appContext.config\r\n        const { delimiters, compilerOptions: componentCompilerOptions } =\r\n          Component\r\n        const finalCompilerOptions: CompilerOptions = extend(\r\n          extend(\r\n            {\r\n              isCustomElement,\r\n              delimiters,\r\n            },\r\n            compilerOptions,\r\n          ),\r\n          componentCompilerOptions,\r\n        )\r\n        if (__COMPAT__) {\r\n          // pass runtime compat config into the compiler\r\n          finalCompilerOptions.compatConfig = Object.create(globalCompatConfig)\r\n          if (Component.compatConfig) {\r\n            // @ts-expect-error types are not compatible\r\n            extend(finalCompilerOptions.compatConfig, Component.compatConfig)\r\n          }\r\n        }\r\n        /**\r\n         * 生成render渲染函数\r\n         * 如果template是dom元素，就取dom元素的innerHtml\r\n         * 如果是dom元素的id，就取该dom元素的innerHtml\r\n         * 最后生成render函数\r\n         */\r\n        Component.render = compile(template, finalCompilerOptions)\r\n        if (__DEV__) {\r\n          endMeasure(instance, `compile`)\r\n        }\r\n      }\r\n    }\r\n\r\n    instance.render = (Component.render || NOOP) as InternalRenderFunction\r\n\r\n    // for runtime-compiled render functions using `with` blocks, the render\r\n    // proxy used needs a different `has` handler which is more performant and\r\n    // also only allows a whitelist of globals to fallthrough.\r\n    if (installWithProxy) {\r\n      installWithProxy(instance)\r\n    }\r\n  }\r\n\r\n  // support for 2.x options\r\n  if (__FEATURE_OPTIONS_API__ && !(__COMPAT__ && skipOptions)) {\r\n    const reset = setCurrentInstance(instance)\r\n    pauseTracking()\r\n    try {\r\n      applyOptions(instance)\r\n    } finally {\r\n      resetTracking()\r\n      reset()\r\n    }\r\n  }\r\n\r\n  // warn missing template/render\r\n  // the runtime compilation of template in SSR is done by server-render\r\n  if (__DEV__ && !Component.render && instance.render === NOOP && !isSSR) {\r\n    /* istanbul ignore if */\r\n    if (!compile && Component.template) {\r\n      warn(\r\n        `Component provided template option but ` +\r\n          `runtime compilation is not supported in this build of Vue.` +\r\n          (__ESM_BUNDLER__\r\n            ? ` Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".`\r\n            : __ESM_BROWSER__\r\n              ? ` Use \"vue.esm-browser.js\" instead.`\r\n              : __GLOBAL__\r\n                ? ` Use \"vue.global.js\" instead.`\r\n                : ``) /* should not happen */,\r\n      )\r\n    } else {\r\n      warn(`Component is missing template or render function.`)\r\n    }\r\n  }\r\n}\r\n\r\nfunction getAttrsProxy(instance: ComponentInternalInstance): Data {\r\n  return (\r\n    instance.attrsProxy ||\r\n    (instance.attrsProxy = new Proxy(\r\n      instance.attrs,\r\n      __DEV__\r\n        ? {\r\n            get(target, key: string) {\r\n              markAttrsAccessed()\r\n              track(instance, TrackOpTypes.GET, '$attrs')\r\n              return target[key]\r\n            },\r\n            set() {\r\n              warn(`setupContext.attrs is readonly.`)\r\n              return false\r\n            },\r\n            deleteProperty() {\r\n              warn(`setupContext.attrs is readonly.`)\r\n              return false\r\n            },\r\n          }\r\n        : {\r\n            get(target, key: string) {\r\n              track(instance, TrackOpTypes.GET, '$attrs')\r\n              return target[key]\r\n            },\r\n          },\r\n    ))\r\n  )\r\n}\r\n\r\n/**\r\n * Dev-only\r\n */\r\nfunction getSlotsProxy(instance: ComponentInternalInstance): Slots {\r\n  return (\r\n    instance.slotsProxy ||\r\n    (instance.slotsProxy = new Proxy(instance.slots, {\r\n      get(target, key: string) {\r\n        track(instance, TrackOpTypes.GET, '$slots')\r\n        return target[key]\r\n      },\r\n    }))\r\n  )\r\n}\r\n\r\nexport function createSetupContext(\r\n  instance: ComponentInternalInstance,\r\n): SetupContext {\r\n  const expose: SetupContext['expose'] = exposed => {\r\n    if (__DEV__) {\r\n      if (instance.exposed) {\r\n        warn(`expose() should be called only once per setup().`)\r\n      }\r\n      if (exposed != null) {\r\n        let exposedType: string = typeof exposed\r\n        if (exposedType === 'object') {\r\n          if (isArray(exposed)) {\r\n            exposedType = 'array'\r\n          } else if (isRef(exposed)) {\r\n            exposedType = 'ref'\r\n          }\r\n        }\r\n        if (exposedType !== 'object') {\r\n          warn(\r\n            `expose() should be passed a plain object, received ${exposedType}.`,\r\n          )\r\n        }\r\n      }\r\n    }\r\n    instance.exposed = exposed || {}\r\n  }\r\n\r\n  if (__DEV__) {\r\n    // We use getters in dev in case libs like test-utils overwrite instance\r\n    // properties (overwrites should not be done in prod)\r\n    return Object.freeze({\r\n      get attrs() {\r\n        return getAttrsProxy(instance)\r\n      },\r\n      get slots() {\r\n        return getSlotsProxy(instance)\r\n      },\r\n      get emit() {\r\n        return (event: string, ...args: any[]) => instance.emit(event, ...args)\r\n      },\r\n      expose,\r\n    })\r\n  } else {\r\n    return {\r\n      get attrs() {\r\n        return getAttrsProxy(instance)\r\n      },\r\n      slots: instance.slots,\r\n      emit: instance.emit,\r\n      expose,\r\n    }\r\n  }\r\n}\r\n\r\nexport function getExposeProxy(instance: ComponentInternalInstance) {\r\n  if (instance.exposed) {\r\n    return (\r\n      instance.exposeProxy ||\r\n      (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {\r\n        get(target, key: string) {\r\n          if (key in target) {\r\n            return target[key]\r\n          } else if (key in publicPropertiesMap) {\r\n            return publicPropertiesMap[key](instance)\r\n          }\r\n        },\r\n        has(target, key: string) {\r\n          return key in target || key in publicPropertiesMap\r\n        },\r\n      }))\r\n    )\r\n  }\r\n}\r\n\r\nconst classifyRE = /(?:^|[-_])(\\w)/g\r\nconst classify = (str: string): string =>\r\n  str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '')\r\n\r\nexport function getComponentName(\r\n  Component: ConcreteComponent,\r\n  includeInferred = true,\r\n): string | false | undefined {\r\n  return isFunction(Component)\r\n    ? Component.displayName || Component.name\r\n    : Component.name || (includeInferred && Component.__name)\r\n}\r\n\r\n/* istanbul ignore next */\r\nexport function formatComponentName(\r\n  instance: ComponentInternalInstance | null,\r\n  Component: ConcreteComponent,\r\n  isRoot = false,\r\n): string {\r\n  let name = getComponentName(Component)\r\n  if (!name && Component.__file) {\r\n    const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/)\r\n    if (match) {\r\n      name = match[1]\r\n    }\r\n  }\r\n\r\n  if (!name && instance && instance.parent) {\r\n    // try to infer the name based on reverse resolution\r\n    const inferFromRegistry = (registry: Record<string, any> | undefined) => {\r\n      for (const key in registry) {\r\n        if (registry[key] === Component) {\r\n          return key\r\n        }\r\n      }\r\n    }\r\n    name =\r\n      inferFromRegistry(\r\n        instance.components ||\r\n          (instance.parent.type as ComponentOptions).components,\r\n      ) || inferFromRegistry(instance.appContext.components)\r\n  }\r\n\r\n  return name ? classify(name) : isRoot ? `App` : `Anonymous`\r\n}\r\n\r\nexport function isClassComponent(value: unknown): value is ClassComponent {\r\n  return isFunction(value) && '__vccOpts' in value\r\n}\r\n","import { computed as _computed } from '@vue/reactivity'\r\nimport { isInSSRComponentSetup } from './component'\r\n\r\nexport const computed: typeof _computed = (\r\n  getterOrOptions: any,\r\n  debugOptions?: any,\r\n) => {\r\n  // @ts-expect-error\r\n  return _computed(getterOrOptions, debugOptions, isInSSRComponentSetup)\r\n}\r\n","// Core API ------------------------------------------------------------------\r\n\r\nexport const version = __VERSION__\r\nexport {\r\n  // core\r\n  reactive,\r\n  ref,\r\n  readonly,\r\n  // utilities\r\n  unref,\r\n  proxyRefs,\r\n  isRef,\r\n  toRef,\r\n  toValue,\r\n  toRefs,\r\n  isProxy,\r\n  isReactive,\r\n  isReadonly,\r\n  isShallow,\r\n  // advanced\r\n  customRef,\r\n  triggerRef,\r\n  shallowRef,\r\n  shallowReactive,\r\n  shallowReadonly,\r\n  markRaw,\r\n  toRaw,\r\n  // effect\r\n  effect,\r\n  stop,\r\n  ReactiveEffect,\r\n  // effect scope\r\n  effectScope,\r\n  EffectScope,\r\n  getCurrentScope,\r\n  onScopeDispose,\r\n} from '@vue/reactivity'\r\nexport { computed } from './apiComputed'\r\nexport {\r\n  watch,\r\n  watchEffect,\r\n  watchPostEffect,\r\n  watchSyncEffect,\r\n} from './apiWatch'\r\nexport {\r\n  onBeforeMount,\r\n  onMounted,\r\n  onBeforeUpdate,\r\n  onUpdated,\r\n  onBeforeUnmount,\r\n  onUnmounted,\r\n  onActivated,\r\n  onDeactivated,\r\n  onRenderTracked,\r\n  onRenderTriggered,\r\n  onErrorCaptured,\r\n  onServerPrefetch,\r\n} from './apiLifecycle'\r\nexport { provide, inject, hasInjectionContext } from './apiInject'\r\nexport { nextTick } from './scheduler'\r\nexport { defineComponent } from './apiDefineComponent'\r\nexport { defineAsyncComponent } from './apiAsyncComponent'\r\nexport { useAttrs, useSlots } from './apiSetupHelpers'\r\nexport { useModel } from './helpers/useModel'\r\n\r\n// <script setup> API ----------------------------------------------------------\r\n\r\nexport {\r\n  // macros runtime, for typing and warnings only\r\n  defineProps,\r\n  defineEmits,\r\n  defineExpose,\r\n  defineOptions,\r\n  defineSlots,\r\n  defineModel,\r\n  withDefaults,\r\n  type DefineProps,\r\n  type ModelRef,\r\n} from './apiSetupHelpers'\r\n\r\n/**\r\n * @internal\r\n */\r\nexport {\r\n  mergeDefaults,\r\n  mergeModels,\r\n  createPropsRestProxy,\r\n  withAsyncContext,\r\n} from './apiSetupHelpers'\r\n\r\n// Advanced API ----------------------------------------------------------------\r\n\r\n// For getting a hold of the internal instance in setup() - useful for advanced\r\n// plugins\r\nexport { getCurrentInstance } from './component'\r\n\r\n// For raw render function users\r\nexport { h } from './h'\r\n// Advanced render function utilities\r\nexport { createVNode, cloneVNode, mergeProps, isVNode } from './vnode'\r\n// VNode types\r\nexport { Fragment, Text, Comment, Static, type VNodeRef } from './vnode'\r\n// Built-in components\r\nexport { Teleport, type TeleportProps } from './components/Teleport'\r\nexport { Suspense, type SuspenseProps } from './components/Suspense'\r\nexport { KeepAlive, type KeepAliveProps } from './components/KeepAlive'\r\nexport {\r\n  BaseTransition,\r\n  BaseTransitionPropsValidators,\r\n  type BaseTransitionProps,\r\n} from './components/BaseTransition'\r\n// For using custom directives\r\nexport { withDirectives } from './directives'\r\n// SSR context\r\nexport { useSSRContext, ssrContextKey } from './helpers/useSsrContext'\r\n\r\n// Custom Renderer API ---------------------------------------------------------\r\n\r\nexport { createRenderer, createHydrationRenderer } from './renderer'\r\nexport { queuePostFlushCb } from './scheduler'\r\nimport { warn as _warn } from './warning'\r\nexport const warn = (__DEV__ ? _warn : NOOP) as typeof _warn\r\n\r\n/** @internal */\r\nexport { assertNumber } from './warning'\r\nexport {\r\n  handleError,\r\n  callWithErrorHandling,\r\n  callWithAsyncErrorHandling,\r\n  ErrorCodes,\r\n} from './errorHandling'\r\nexport {\r\n  resolveComponent,\r\n  resolveDirective,\r\n  resolveDynamicComponent,\r\n} from './helpers/resolveAssets'\r\n// For integration with runtime compiler\r\nexport { registerRuntimeCompiler, isRuntimeOnly } from './component'\r\nexport {\r\n  useTransitionState,\r\n  resolveTransitionHooks,\r\n  setTransitionHooks,\r\n  getTransitionRawChildren,\r\n} from './components/BaseTransition'\r\nexport { initCustomFormatter } from './customFormatter'\r\n\r\nimport { ErrorTypeStrings as _ErrorTypeStrings } from './errorHandling'\r\n/**\r\n * Runtime error messages. Only exposed in dev or esm builds.\r\n * @internal\r\n */\r\nexport const ErrorTypeStrings = (\r\n  __ESM_BUNDLER__ || __CJS__ || __DEV__ ? _ErrorTypeStrings : null\r\n) as typeof _ErrorTypeStrings\r\n\r\n// For devtools\r\nimport {\r\n  type DevtoolsHook,\r\n  devtools as _devtools,\r\n  setDevtoolsHook as _setDevtoolsHook,\r\n} from './devtools'\r\n\r\nexport const devtools = (\r\n  __DEV__ || __ESM_BUNDLER__ ? _devtools : undefined\r\n) as DevtoolsHook\r\nexport const setDevtoolsHook = (\r\n  __DEV__ || __ESM_BUNDLER__ ? _setDevtoolsHook : NOOP\r\n) as typeof _setDevtoolsHook\r\n\r\n// Types -----------------------------------------------------------------------\r\n\r\nimport type { VNode } from './vnode'\r\nimport type { ComponentInternalInstance } from './component'\r\n\r\n// Augment Ref unwrap bail types.\r\ndeclare module '@vue/reactivity' {\r\n  export interface RefUnwrapBailTypes {\r\n    runtimeCoreBailTypes:\r\n      | VNode\r\n      | {\r\n          // directly bailing on ComponentPublicInstance results in recursion\r\n          // so we use this as a bail hint\r\n          $: ComponentInternalInstance\r\n        }\r\n  }\r\n}\r\n\r\nexport { TrackOpTypes, TriggerOpTypes } from '@vue/reactivity'\r\nexport type {\r\n  Ref,\r\n  MaybeRef,\r\n  MaybeRefOrGetter,\r\n  ToRef,\r\n  ToRefs,\r\n  UnwrapRef,\r\n  ShallowRef,\r\n  ShallowUnwrapRef,\r\n  CustomRefFactory,\r\n  ReactiveFlags,\r\n  DeepReadonly,\r\n  ShallowReactive,\r\n  UnwrapNestedRefs,\r\n  ComputedRef,\r\n  WritableComputedRef,\r\n  WritableComputedOptions,\r\n  ComputedGetter,\r\n  ComputedSetter,\r\n  ReactiveEffectRunner,\r\n  ReactiveEffectOptions,\r\n  EffectScheduler,\r\n  DebuggerOptions,\r\n  DebuggerEvent,\r\n  DebuggerEventExtraInfo,\r\n  Raw,\r\n} from '@vue/reactivity'\r\nexport type {\r\n  WatchEffect,\r\n  WatchOptions,\r\n  WatchOptionsBase,\r\n  WatchCallback,\r\n  WatchSource,\r\n  WatchStopHandle,\r\n} from './apiWatch'\r\nexport type { InjectionKey } from './apiInject'\r\nexport type {\r\n  App,\r\n  AppConfig,\r\n  AppContext,\r\n  Plugin,\r\n  ObjectPlugin,\r\n  FunctionPlugin,\r\n  CreateAppFunction,\r\n  OptionMergeFunction,\r\n} from './apiCreateApp'\r\nexport type {\r\n  VNode,\r\n  VNodeChild,\r\n  VNodeTypes,\r\n  VNodeProps,\r\n  VNodeArrayChildren,\r\n  VNodeNormalizedChildren,\r\n} from './vnode'\r\nexport type {\r\n  Component,\r\n  ConcreteComponent,\r\n  FunctionalComponent,\r\n  ComponentInternalInstance,\r\n  SetupContext,\r\n  ComponentCustomProps,\r\n  AllowedComponentProps,\r\n  ComponentInstance,\r\n} from './component'\r\nexport type { DefineComponent, PublicProps } from './apiDefineComponent'\r\nexport type {\r\n  ComponentOptions,\r\n  ComponentOptionsMixin,\r\n  ComponentOptionsWithoutProps,\r\n  ComponentOptionsWithObjectProps,\r\n  ComponentOptionsWithArrayProps,\r\n  ComponentCustomOptions,\r\n  ComponentOptionsBase,\r\n  ComponentProvideOptions,\r\n  RenderFunction,\r\n  MethodOptions,\r\n  ComputedOptions,\r\n  RuntimeCompilerOptions,\r\n  ComponentInjectOptions,\r\n} from './componentOptions'\r\nexport type { EmitsOptions, ObjectEmitsOptions } from './componentEmits'\r\nexport type {\r\n  ComponentPublicInstance,\r\n  ComponentCustomProperties,\r\n  CreateComponentPublicInstance,\r\n} from './componentPublicInstance'\r\nexport type {\r\n  Renderer,\r\n  RendererNode,\r\n  RendererElement,\r\n  HydrationRenderer,\r\n  RendererOptions,\r\n  RootRenderFunction,\r\n  ElementNamespace,\r\n} from './renderer'\r\nexport type { RootHydrateFunction } from './hydration'\r\nexport type { Slot, Slots, SlotsType } from './componentSlots'\r\nexport type {\r\n  Prop,\r\n  PropType,\r\n  ComponentPropsOptions,\r\n  ComponentObjectPropsOptions,\r\n  ExtractPropTypes,\r\n  ExtractPublicPropTypes,\r\n  ExtractDefaultPropTypes,\r\n} from './componentProps'\r\nexport type {\r\n  Directive,\r\n  DirectiveBinding,\r\n  DirectiveHook,\r\n  ObjectDirective,\r\n  FunctionDirective,\r\n  DirectiveArguments,\r\n} from './directives'\r\nexport type { SuspenseBoundary } from './components/Suspense'\r\nexport type {\r\n  TransitionState,\r\n  TransitionHooks,\r\n} from './components/BaseTransition'\r\nexport type {\r\n  AsyncComponentOptions,\r\n  AsyncComponentLoader,\r\n} from './apiAsyncComponent'\r\nexport type { HMRRuntime } from './hmr'\r\n\r\n// Internal API ----------------------------------------------------------------\r\n\r\n// **IMPORTANT** Internal APIs may change without notice between versions and\r\n// user code should avoid relying on them.\r\n\r\n// For compiler generated code\r\n// should sync with '@vue/compiler-core/src/runtimeHelpers.ts'\r\nexport {\r\n  withCtx,\r\n  pushScopeId,\r\n  popScopeId,\r\n  withScopeId,\r\n} from './componentRenderContext'\r\nexport { renderList } from './helpers/renderList'\r\nexport { toHandlers } from './helpers/toHandlers'\r\nexport { renderSlot } from './helpers/renderSlot'\r\nexport { createSlots } from './helpers/createSlots'\r\nexport { withMemo, isMemoSame } from './helpers/withMemo'\r\nexport {\r\n  openBlock,\r\n  createBlock,\r\n  setBlockTracking,\r\n  createTextVNode,\r\n  createCommentVNode,\r\n  createStaticVNode,\r\n  createElementVNode,\r\n  createElementBlock,\r\n  guardReactiveProps,\r\n} from './vnode'\r\nexport {\r\n  toDisplayString,\r\n  camelize,\r\n  capitalize,\r\n  toHandlerKey,\r\n  normalizeProps,\r\n  normalizeClass,\r\n  normalizeStyle,\r\n} from '@vue/shared'\r\n\r\n// For test-utils\r\nexport { transformVNodeArgs } from './vnode'\r\n\r\n// SSR -------------------------------------------------------------------------\r\n\r\n// **IMPORTANT** These APIs are exposed solely for @vue/server-renderer and may\r\n// change without notice between versions. User code should never rely on them.\r\n\r\nimport { createComponentInstance, setupComponent } from './component'\r\nimport { renderComponentRoot } from './componentRenderUtils'\r\nimport { setCurrentRenderingInstance } from './componentRenderContext'\r\nimport { isVNode, normalizeVNode } from './vnode'\r\n\r\nconst _ssrUtils = {\r\n  createComponentInstance,\r\n  setupComponent,\r\n  renderComponentRoot,\r\n  setCurrentRenderingInstance,\r\n  isVNode,\r\n  normalizeVNode,\r\n}\r\n\r\n/**\r\n * SSR utils for \\@vue/server-renderer. Only exposed in ssr-possible builds.\r\n * @internal\r\n */\r\nexport const ssrUtils = (__SSR__ ? _ssrUtils : null) as typeof _ssrUtils\r\n\r\n// 2.x COMPAT ------------------------------------------------------------------\r\n\r\nimport { DeprecationTypes as _DeprecationTypes } from './compat/compatConfig'\r\nexport type { CompatVue } from './compat/global'\r\nexport type { LegacyConfig } from './compat/globalConfig'\r\n\r\nimport { warnDeprecation } from './compat/compatConfig'\r\nimport { createCompatVue } from './compat/global'\r\nimport {\r\n  checkCompatEnabled,\r\n  isCompatEnabled,\r\n  softAssertCompatEnabled,\r\n} from './compat/compatConfig'\r\nimport { resolveFilter as _resolveFilter } from './helpers/resolveAssets'\r\nimport { NOOP } from '@vue/shared'\r\n\r\n/**\r\n * @internal only exposed in compat builds\r\n */\r\nexport const resolveFilter = __COMPAT__ ? _resolveFilter : null\r\n\r\nconst _compatUtils = {\r\n  warnDeprecation,\r\n  createCompatVue,\r\n  isCompatEnabled,\r\n  checkCompatEnabled,\r\n  softAssertCompatEnabled,\r\n}\r\n\r\n/**\r\n * @internal only exposed in compat builds.\r\n */\r\nexport const compatUtils = (\r\n  __COMPAT__ ? _compatUtils : null\r\n) as typeof _compatUtils\r\n\r\nexport const DeprecationTypes = (\r\n  __COMPAT__ ? _DeprecationTypes : null\r\n) as typeof _DeprecationTypes\r\n","import type { RendererOptions } from '@vue/runtime-core'\r\n\r\nexport const svgNS = 'http://www.w3.org/2000/svg'\r\nexport const mathmlNS = 'http://www.w3.org/1998/Math/MathML'\r\n\r\nconst doc = (typeof document !== 'undefined' ? document : null) as Document\r\n\r\nconst templateContainer = doc && /*#__PURE__*/ doc.createElement('template')\r\n\r\nexport const nodeOps: Omit<RendererOptions<Node, Element>, 'patchProp'> = {\r\n  insert: (child, parent, anchor) => {\r\n    parent.insertBefore(child, anchor || null)\r\n  },\r\n\r\n  remove: child => {\r\n    const parent = child.parentNode\r\n    if (parent) {\r\n      parent.removeChild(child)\r\n    }\r\n  },\r\n\r\n  createElement: (tag, namespace, is, props): Element => {\r\n    const el =\r\n      namespace === 'svg'\r\n        ? doc.createElementNS(svgNS, tag)\r\n        : namespace === 'mathml'\r\n          ? doc.createElementNS(mathmlNS, tag)\r\n          : doc.createElement(tag, is ? { is } : undefined)\r\n\r\n    if (tag === 'select' && props && props.multiple != null) {\r\n      ;(el as HTMLSelectElement).setAttribute('multiple', props.multiple)\r\n    }\r\n\r\n    return el\r\n  },\r\n\r\n  createText: text => doc.createTextNode(text),\r\n\r\n  createComment: text => doc.createComment(text),\r\n\r\n  setText: (node, text) => {\r\n    node.nodeValue = text\r\n  },\r\n\r\n  setElementText: (el, text) => {\r\n    el.textContent = text\r\n  },\r\n\r\n  parentNode: node => node.parentNode as Element | null,\r\n\r\n  nextSibling: node => node.nextSibling,\r\n\r\n  querySelector: selector => doc.querySelector(selector),\r\n\r\n  setScopeId(el, id) {\r\n    el.setAttribute(id, '')\r\n  },\r\n\r\n  // __UNSAFE__\r\n  // Reason: innerHTML.\r\n  // Static content here can only come from compiled templates.\r\n  // As long as the user only uses trusted templates, this is safe.\r\n  insertStaticContent(content, parent, anchor, namespace, start, end) {\r\n    // <parent> before | first ... last | anchor </parent>\r\n    const before = anchor ? anchor.previousSibling : parent.lastChild\r\n    // #5308 can only take cached path if:\r\n    // - has a single root node\r\n    // - nextSibling info is still available\r\n    if (start && (start === end || start.nextSibling)) {\r\n      // cached\r\n      while (true) {\r\n        parent.insertBefore(start!.cloneNode(true), anchor)\r\n        if (start === end || !(start = start!.nextSibling)) break\r\n      }\r\n    } else {\r\n      // fresh insert\r\n      templateContainer.innerHTML =\r\n        namespace === 'svg'\r\n          ? `<svg>${content}</svg>`\r\n          : namespace === 'mathml'\r\n            ? `<math>${content}</math>`\r\n            : content\r\n\r\n      const template = templateContainer.content\r\n      if (namespace === 'svg' || namespace === 'mathml') {\r\n        // remove outer svg/math wrapper\r\n        const wrapper = template.firstChild!\r\n        while (wrapper.firstChild) {\r\n          template.appendChild(wrapper.firstChild)\r\n        }\r\n        template.removeChild(wrapper)\r\n      }\r\n      parent.insertBefore(template, anchor)\r\n    }\r\n    return [\r\n      // first\r\n      before ? before.nextSibling! : parent.firstChild!,\r\n      // last\r\n      anchor ? anchor.previousSibling! : parent.lastChild!,\r\n    ]\r\n  },\r\n}\r\n","import {\r\n  BaseTransition,\r\n  type BaseTransitionProps,\r\n  BaseTransitionPropsValidators,\r\n  DeprecationTypes,\r\n  type FunctionalComponent,\r\n  assertNumber,\r\n  compatUtils,\r\n  h,\r\n} from '@vue/runtime-core'\r\nimport { extend, isArray, isObject, toNumber } from '@vue/shared'\r\n\r\nconst TRANSITION = 'transition'\r\nconst ANIMATION = 'animation'\r\n\r\ntype AnimationTypes = typeof TRANSITION | typeof ANIMATION\r\n\r\nexport interface TransitionProps extends BaseTransitionProps<Element> {\r\n  name?: string\r\n  type?: AnimationTypes\r\n  css?: boolean\r\n  duration?: number | { enter: number; leave: number }\r\n  // custom transition classes\r\n  enterFromClass?: string\r\n  enterActiveClass?: string\r\n  enterToClass?: string\r\n  appearFromClass?: string\r\n  appearActiveClass?: string\r\n  appearToClass?: string\r\n  leaveFromClass?: string\r\n  leaveActiveClass?: string\r\n  leaveToClass?: string\r\n}\r\n\r\nexport const vtcKey = Symbol('_vtc')\r\n\r\nexport interface ElementWithTransition extends HTMLElement {\r\n  // _vtc = Vue Transition Classes.\r\n  // Store the temporarily-added transition classes on the element\r\n  // so that we can avoid overwriting them if the element's class is patched\r\n  // during the transition.\r\n  [vtcKey]?: Set<string>\r\n}\r\n\r\n// DOM Transition is a higher-order-component based on the platform-agnostic\r\n// base Transition component, with DOM-specific logic.\r\nexport const Transition: FunctionalComponent<TransitionProps> = (\r\n  props,\r\n  { slots },\r\n) => h(BaseTransition, resolveTransitionProps(props), slots)\r\n\r\nTransition.displayName = 'Transition'\r\n\r\nif (__COMPAT__) {\r\n  Transition.__isBuiltIn = true\r\n}\r\n\r\nconst DOMTransitionPropsValidators = {\r\n  name: String,\r\n  type: String,\r\n  css: {\r\n    type: Boolean,\r\n    default: true,\r\n  },\r\n  duration: [String, Number, Object],\r\n  enterFromClass: String,\r\n  enterActiveClass: String,\r\n  enterToClass: String,\r\n  appearFromClass: String,\r\n  appearActiveClass: String,\r\n  appearToClass: String,\r\n  leaveFromClass: String,\r\n  leaveActiveClass: String,\r\n  leaveToClass: String,\r\n}\r\n\r\nexport const TransitionPropsValidators = (Transition.props =\r\n  /*#__PURE__*/ extend(\r\n    {},\r\n    BaseTransitionPropsValidators as any,\r\n    DOMTransitionPropsValidators,\r\n  ))\r\n\r\n/**\r\n * #3227 Incoming hooks may be merged into arrays when wrapping Transition\r\n * with custom HOCs.\r\n */\r\nconst callHook = (\r\n  hook: Function | Function[] | undefined,\r\n  args: any[] = [],\r\n) => {\r\n  if (isArray(hook)) {\r\n    hook.forEach(h => h(...args))\r\n  } else if (hook) {\r\n    hook(...args)\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a hook expects a callback (2nd arg), which means the user\r\n * intends to explicitly control the end of the transition.\r\n */\r\nconst hasExplicitCallback = (\r\n  hook: Function | Function[] | undefined,\r\n): boolean => {\r\n  return hook\r\n    ? isArray(hook)\r\n      ? hook.some(h => h.length > 1)\r\n      : hook.length > 1\r\n    : false\r\n}\r\n\r\nexport function resolveTransitionProps(\r\n  rawProps: TransitionProps,\r\n): BaseTransitionProps<Element> {\r\n  const baseProps: BaseTransitionProps<Element> = {}\r\n  for (const key in rawProps) {\r\n    if (!(key in DOMTransitionPropsValidators)) {\r\n      ;(baseProps as any)[key] = (rawProps as any)[key]\r\n    }\r\n  }\r\n\r\n  if (rawProps.css === false) {\r\n    return baseProps\r\n  }\r\n\r\n  const {\r\n    name = 'v',\r\n    type,\r\n    duration,\r\n    enterFromClass = `${name}-enter-from`,\r\n    enterActiveClass = `${name}-enter-active`,\r\n    enterToClass = `${name}-enter-to`,\r\n    appearFromClass = enterFromClass,\r\n    appearActiveClass = enterActiveClass,\r\n    appearToClass = enterToClass,\r\n    leaveFromClass = `${name}-leave-from`,\r\n    leaveActiveClass = `${name}-leave-active`,\r\n    leaveToClass = `${name}-leave-to`,\r\n  } = rawProps\r\n\r\n  // legacy transition class compat\r\n  const legacyClassEnabled =\r\n    __COMPAT__ &&\r\n    compatUtils.isCompatEnabled(DeprecationTypes.TRANSITION_CLASSES, null)\r\n  let legacyEnterFromClass: string\r\n  let legacyAppearFromClass: string\r\n  let legacyLeaveFromClass: string\r\n  if (__COMPAT__ && legacyClassEnabled) {\r\n    const toLegacyClass = (cls: string) => cls.replace(/-from$/, '')\r\n    if (!rawProps.enterFromClass) {\r\n      legacyEnterFromClass = toLegacyClass(enterFromClass)\r\n    }\r\n    if (!rawProps.appearFromClass) {\r\n      legacyAppearFromClass = toLegacyClass(appearFromClass)\r\n    }\r\n    if (!rawProps.leaveFromClass) {\r\n      legacyLeaveFromClass = toLegacyClass(leaveFromClass)\r\n    }\r\n  }\r\n\r\n  const durations = normalizeDuration(duration)\r\n  const enterDuration = durations && durations[0]\r\n  const leaveDuration = durations && durations[1]\r\n  const {\r\n    onBeforeEnter,\r\n    onEnter,\r\n    onEnterCancelled,\r\n    onLeave,\r\n    onLeaveCancelled,\r\n    onBeforeAppear = onBeforeEnter,\r\n    onAppear = onEnter,\r\n    onAppearCancelled = onEnterCancelled,\r\n  } = baseProps\r\n\r\n  const finishEnter = (el: Element, isAppear: boolean, done?: () => void) => {\r\n    removeTransitionClass(el, isAppear ? appearToClass : enterToClass)\r\n    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass)\r\n    done && done()\r\n  }\r\n\r\n  const finishLeave = (\r\n    el: Element & { _isLeaving?: boolean },\r\n    done?: () => void,\r\n  ) => {\r\n    el._isLeaving = false\r\n    removeTransitionClass(el, leaveFromClass)\r\n    removeTransitionClass(el, leaveToClass)\r\n    removeTransitionClass(el, leaveActiveClass)\r\n    done && done()\r\n  }\r\n\r\n  const makeEnterHook = (isAppear: boolean) => {\r\n    return (el: Element, done: () => void) => {\r\n      const hook = isAppear ? onAppear : onEnter\r\n      const resolve = () => finishEnter(el, isAppear, done)\r\n      callHook(hook, [el, resolve])\r\n      nextFrame(() => {\r\n        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass)\r\n        if (__COMPAT__ && legacyClassEnabled) {\r\n          const legacyClass = isAppear\r\n            ? legacyAppearFromClass\r\n            : legacyEnterFromClass\r\n          if (legacyClass) {\r\n            removeTransitionClass(el, legacyClass)\r\n          }\r\n        }\r\n        addTransitionClass(el, isAppear ? appearToClass : enterToClass)\r\n        if (!hasExplicitCallback(hook)) {\r\n          whenTransitionEnds(el, type, enterDuration, resolve)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  return extend(baseProps, {\r\n    onBeforeEnter(el) {\r\n      callHook(onBeforeEnter, [el])\r\n      addTransitionClass(el, enterFromClass)\r\n      if (__COMPAT__ && legacyClassEnabled && legacyEnterFromClass) {\r\n        addTransitionClass(el, legacyEnterFromClass)\r\n      }\r\n      addTransitionClass(el, enterActiveClass)\r\n    },\r\n    onBeforeAppear(el) {\r\n      callHook(onBeforeAppear, [el])\r\n      addTransitionClass(el, appearFromClass)\r\n      if (__COMPAT__ && legacyClassEnabled && legacyAppearFromClass) {\r\n        addTransitionClass(el, legacyAppearFromClass)\r\n      }\r\n      addTransitionClass(el, appearActiveClass)\r\n    },\r\n    onEnter: makeEnterHook(false),\r\n    onAppear: makeEnterHook(true),\r\n    onLeave(el: Element & { _isLeaving?: boolean }, done) {\r\n      el._isLeaving = true\r\n      const resolve = () => finishLeave(el, done)\r\n      addTransitionClass(el, leaveFromClass)\r\n      if (__COMPAT__ && legacyClassEnabled && legacyLeaveFromClass) {\r\n        addTransitionClass(el, legacyLeaveFromClass)\r\n      }\r\n      // force reflow so *-leave-from classes immediately take effect (#2593)\r\n      forceReflow()\r\n      addTransitionClass(el, leaveActiveClass)\r\n      nextFrame(() => {\r\n        if (!el._isLeaving) {\r\n          // cancelled\r\n          return\r\n        }\r\n        removeTransitionClass(el, leaveFromClass)\r\n        if (__COMPAT__ && legacyClassEnabled && legacyLeaveFromClass) {\r\n          removeTransitionClass(el, legacyLeaveFromClass)\r\n        }\r\n        addTransitionClass(el, leaveToClass)\r\n        if (!hasExplicitCallback(onLeave)) {\r\n          whenTransitionEnds(el, type, leaveDuration, resolve)\r\n        }\r\n      })\r\n      callHook(onLeave, [el, resolve])\r\n    },\r\n    onEnterCancelled(el) {\r\n      finishEnter(el, false)\r\n      callHook(onEnterCancelled, [el])\r\n    },\r\n    onAppearCancelled(el) {\r\n      finishEnter(el, true)\r\n      callHook(onAppearCancelled, [el])\r\n    },\r\n    onLeaveCancelled(el) {\r\n      finishLeave(el)\r\n      callHook(onLeaveCancelled, [el])\r\n    },\r\n  } as BaseTransitionProps<Element>)\r\n}\r\n\r\nfunction normalizeDuration(\r\n  duration: TransitionProps['duration'],\r\n): [number, number] | null {\r\n  if (duration == null) {\r\n    return null\r\n  } else if (isObject(duration)) {\r\n    return [NumberOf(duration.enter), NumberOf(duration.leave)]\r\n  } else {\r\n    const n = NumberOf(duration)\r\n    return [n, n]\r\n  }\r\n}\r\n\r\nfunction NumberOf(val: unknown): number {\r\n  const res = toNumber(val)\r\n  if (__DEV__) {\r\n    assertNumber(res, '<transition> explicit duration')\r\n  }\r\n  return res\r\n}\r\n\r\nexport function addTransitionClass(el: Element, cls: string) {\r\n  cls.split(/\\s+/).forEach(c => c && el.classList.add(c))\r\n  ;(\r\n    (el as ElementWithTransition)[vtcKey] ||\r\n    ((el as ElementWithTransition)[vtcKey] = new Set())\r\n  ).add(cls)\r\n}\r\n\r\nexport function removeTransitionClass(el: Element, cls: string) {\r\n  cls.split(/\\s+/).forEach(c => c && el.classList.remove(c))\r\n  const _vtc = (el as ElementWithTransition)[vtcKey]\r\n  if (_vtc) {\r\n    _vtc.delete(cls)\r\n    if (!_vtc!.size) {\r\n      ;(el as ElementWithTransition)[vtcKey] = undefined\r\n    }\r\n  }\r\n}\r\n\r\nfunction nextFrame(cb: () => void) {\r\n  requestAnimationFrame(() => {\r\n    requestAnimationFrame(cb)\r\n  })\r\n}\r\n\r\nlet endId = 0\r\n\r\nfunction whenTransitionEnds(\r\n  el: Element & { _endId?: number },\r\n  expectedType: TransitionProps['type'] | undefined,\r\n  explicitTimeout: number | null,\r\n  resolve: () => void,\r\n) {\r\n  const id = (el._endId = ++endId)\r\n  const resolveIfNotStale = () => {\r\n    if (id === el._endId) {\r\n      resolve()\r\n    }\r\n  }\r\n\r\n  if (explicitTimeout) {\r\n    return setTimeout(resolveIfNotStale, explicitTimeout)\r\n  }\r\n\r\n  const { type, timeout, propCount } = getTransitionInfo(el, expectedType)\r\n  if (!type) {\r\n    return resolve()\r\n  }\r\n\r\n  const endEvent = type + 'end'\r\n  let ended = 0\r\n  const end = () => {\r\n    el.removeEventListener(endEvent, onEnd)\r\n    resolveIfNotStale()\r\n  }\r\n  const onEnd = (e: Event) => {\r\n    if (e.target === el && ++ended >= propCount) {\r\n      end()\r\n    }\r\n  }\r\n  setTimeout(() => {\r\n    if (ended < propCount) {\r\n      end()\r\n    }\r\n  }, timeout + 1)\r\n  el.addEventListener(endEvent, onEnd)\r\n}\r\n\r\ninterface CSSTransitionInfo {\r\n  type: AnimationTypes | null\r\n  propCount: number\r\n  timeout: number\r\n  hasTransform: boolean\r\n}\r\n\r\ntype AnimationProperties = 'Delay' | 'Duration'\r\ntype StylePropertiesKey =\r\n  | `${AnimationTypes}${AnimationProperties}`\r\n  | `${typeof TRANSITION}Property`\r\n\r\nexport function getTransitionInfo(\r\n  el: Element,\r\n  expectedType?: TransitionProps['type'],\r\n): CSSTransitionInfo {\r\n  const styles = window.getComputedStyle(el) as Pick<\r\n    CSSStyleDeclaration,\r\n    StylePropertiesKey\r\n  >\r\n  // JSDOM may return undefined for transition properties\r\n  const getStyleProperties = (key: StylePropertiesKey) =>\r\n    (styles[key] || '').split(', ')\r\n  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`)\r\n  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`)\r\n  const transitionTimeout = getTimeout(transitionDelays, transitionDurations)\r\n  const animationDelays = getStyleProperties(`${ANIMATION}Delay`)\r\n  const animationDurations = getStyleProperties(`${ANIMATION}Duration`)\r\n  const animationTimeout = getTimeout(animationDelays, animationDurations)\r\n\r\n  let type: CSSTransitionInfo['type'] = null\r\n  let timeout = 0\r\n  let propCount = 0\r\n  /* istanbul ignore if */\r\n  if (expectedType === TRANSITION) {\r\n    if (transitionTimeout > 0) {\r\n      type = TRANSITION\r\n      timeout = transitionTimeout\r\n      propCount = transitionDurations.length\r\n    }\r\n  } else if (expectedType === ANIMATION) {\r\n    if (animationTimeout > 0) {\r\n      type = ANIMATION\r\n      timeout = animationTimeout\r\n      propCount = animationDurations.length\r\n    }\r\n  } else {\r\n    timeout = Math.max(transitionTimeout, animationTimeout)\r\n    type =\r\n      timeout > 0\r\n        ? transitionTimeout > animationTimeout\r\n          ? TRANSITION\r\n          : ANIMATION\r\n        : null\r\n    propCount = type\r\n      ? type === TRANSITION\r\n        ? transitionDurations.length\r\n        : animationDurations.length\r\n      : 0\r\n  }\r\n  const hasTransform =\r\n    type === TRANSITION &&\r\n    /\\b(transform|all)(,|$)/.test(\r\n      getStyleProperties(`${TRANSITION}Property`).toString(),\r\n    )\r\n  return {\r\n    type,\r\n    timeout,\r\n    propCount,\r\n    hasTransform,\r\n  }\r\n}\r\n\r\nfunction getTimeout(delays: string[], durations: string[]): number {\r\n  while (delays.length < durations.length) {\r\n    delays = delays.concat(delays)\r\n  }\r\n  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])))\r\n}\r\n\r\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer\r\n// numbers in a locale-dependent way, using a comma instead of a dot.\r\n// If comma is not replaced with a dot, the input will be rounded down\r\n// (i.e. acting as a floor function) causing unexpected behaviors\r\nfunction toMs(s: string): number {\r\n  // #8409 default value for CSS durations can be 'auto'\r\n  if (s === 'auto') return 0\r\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000\r\n}\r\n\r\n// synchronously force layout to put elements into a certain state\r\nexport function forceReflow() {\r\n  return document.body.offsetHeight\r\n}\r\n","import type { ObjectDirective } from '@vue/runtime-core'\r\n\r\nexport const vShowOldKey = Symbol('_vod')\r\n\r\ninterface VShowElement extends HTMLElement {\r\n  // _vod = vue original display\r\n  [vShowOldKey]: string\r\n}\r\n\r\nexport const vShow: ObjectDirective<VShowElement> & { name?: 'show' } = {\r\n  beforeMount(el, { value }, { transition }) {\r\n    el[vShowOldKey] = el.style.display === 'none' ? '' : el.style.display\r\n    if (transition && value) {\r\n      transition.beforeEnter(el)\r\n    } else {\r\n      setDisplay(el, value)\r\n    }\r\n  },\r\n  mounted(el, { value }, { transition }) {\r\n    if (transition && value) {\r\n      transition.enter(el)\r\n    }\r\n  },\r\n  updated(el, { value, oldValue }, { transition }) {\r\n    if (!value === !oldValue) return\r\n    if (transition) {\r\n      if (value) {\r\n        transition.beforeEnter(el)\r\n        setDisplay(el, true)\r\n        transition.enter(el)\r\n      } else {\r\n        transition.leave(el, () => {\r\n          setDisplay(el, false)\r\n        })\r\n      }\r\n    } else {\r\n      setDisplay(el, value)\r\n    }\r\n  },\r\n  beforeUnmount(el, { value }) {\r\n    setDisplay(el, value)\r\n  },\r\n}\r\n\r\nif (__DEV__) {\r\n  vShow.name = 'show'\r\n}\r\n\r\nfunction setDisplay(el: VShowElement, value: unknown): void {\r\n  el.style.display = value ? el[vShowOldKey] : 'none'\r\n}\r\n\r\n// SSR vnode transforms, only used when user includes client-oriented render\r\n// function in SSR\r\nexport function initVShowForSSR() {\r\n  vShow.getSSRProps = ({ value }) => {\r\n    if (!value) {\r\n      return { style: { display: 'none' } }\r\n    }\r\n  }\r\n}\r\n","import {\r\n  Fragment,\r\n  Static,\r\n  type VNode,\r\n  getCurrentInstance,\r\n  onMounted,\r\n  onUnmounted,\r\n  warn,\r\n  watchPostEffect,\r\n} from '@vue/runtime-core'\r\nimport { ShapeFlags } from '@vue/shared'\r\n\r\nexport const CSS_VAR_TEXT = Symbol(__DEV__ ? 'CSS_VAR_TEXT' : '')\r\n/**\r\n * Runtime helper for SFC's CSS variable injection feature.\r\n * @private\r\n */\r\nexport function useCssVars(getter: (ctx: any) => Record<string, string>) {\r\n  if (!__BROWSER__ && !__TEST__) return\r\n\r\n  const instance = getCurrentInstance()\r\n  /* istanbul ignore next */\r\n  if (!instance) {\r\n    __DEV__ &&\r\n      warn(`useCssVars is called without current active component instance.`)\r\n    return\r\n  }\r\n\r\n  const updateTeleports = (instance.ut = (vars = getter(instance.proxy)) => {\r\n    Array.from(\r\n      document.querySelectorAll(`[data-v-owner=\"${instance.uid}\"]`),\r\n    ).forEach(node => setVarsOnNode(node, vars))\r\n  })\r\n\r\n  const setVars = () => {\r\n    const vars = getter(instance.proxy)\r\n    setVarsOnVNode(instance.subTree, vars)\r\n    updateTeleports(vars)\r\n  }\r\n\r\n  watchPostEffect(setVars)\r\n\r\n  onMounted(() => {\r\n    const ob = new MutationObserver(setVars)\r\n    ob.observe(instance.subTree.el!.parentNode, { childList: true })\r\n    onUnmounted(() => ob.disconnect())\r\n  })\r\n}\r\n\r\nfunction setVarsOnVNode(vnode: VNode, vars: Record<string, string>) {\r\n  if (__FEATURE_SUSPENSE__ && vnode.shapeFlag & ShapeFlags.SUSPENSE) {\r\n    const suspense = vnode.suspense!\r\n    vnode = suspense.activeBranch!\r\n    if (suspense.pendingBranch && !suspense.isHydrating) {\r\n      suspense.effects.push(() => {\r\n        setVarsOnVNode(suspense.activeBranch!, vars)\r\n      })\r\n    }\r\n  }\r\n\r\n  // drill down HOCs until it's a non-component vnode\r\n  while (vnode.component) {\r\n    vnode = vnode.component.subTree\r\n  }\r\n\r\n  if (vnode.shapeFlag & ShapeFlags.ELEMENT && vnode.el) {\r\n    setVarsOnNode(vnode.el as Node, vars)\r\n  } else if (vnode.type === Fragment) {\r\n    ;(vnode.children as VNode[]).forEach(c => setVarsOnVNode(c, vars))\r\n  } else if (vnode.type === Static) {\r\n    let { el, anchor } = vnode\r\n    while (el) {\r\n      setVarsOnNode(el as Node, vars)\r\n      if (el === anchor) break\r\n      el = el.nextSibling\r\n    }\r\n  }\r\n}\r\n\r\nfunction setVarsOnNode(el: Node, vars: Record<string, string>) {\r\n  if (el.nodeType === 1) {\r\n    const style = (el as HTMLElement).style\r\n    let cssText = ''\r\n    for (const key in vars) {\r\n      style.setProperty(`--${key}`, vars[key])\r\n      cssText += `--${key}: ${vars[key]};`\r\n    }\r\n    ;(style as any)[CSS_VAR_TEXT] = cssText\r\n  }\r\n}\r\n","import { capitalize, hyphenate, isArray, isString } from '@vue/shared'\r\nimport { camelize, warn } from '@vue/runtime-core'\r\nimport { vShowOldKey } from '../directives/vShow'\r\nimport { CSS_VAR_TEXT } from '../helpers/useCssVars'\r\n\r\ntype Style = string | Record<string, string | string[]> | null\r\n\r\nexport function patchStyle(el: Element, prev: Style, next: Style) {\r\n  const style = (el as HTMLElement).style\r\n  const currentDisplay = style.display\r\n  const isCssString = isString(next)\r\n  if (next && !isCssString) {\r\n    if (prev && !isString(prev)) {\r\n      for (const key in prev) {\r\n        if (next[key] == null) {\r\n          setStyle(style, key, '')\r\n        }\r\n      }\r\n    }\r\n    for (const key in next) {\r\n      setStyle(style, key, next[key])\r\n    }\r\n  } else {\r\n    if (isCssString) {\r\n      if (prev !== next) {\r\n        // #9821\r\n        const cssVarText = (style as any)[CSS_VAR_TEXT]\r\n        if (cssVarText) {\r\n          ;(next as string) += ';' + cssVarText\r\n        }\r\n        // 设置style也可以通过[Element].style.cssText = 'background: red'\r\n        style.cssText = next as string\r\n      }\r\n    } else if (prev) {\r\n      el.removeAttribute('style')\r\n    }\r\n  }\r\n  // indicates that the `display` of the element is controlled by `v-show`,\r\n  // so we always keep the current `display` value regardless of the `style`\r\n  // value, thus handing over control to `v-show`.\r\n  if (vShowOldKey in el) {\r\n    style.display = currentDisplay\r\n  }\r\n}\r\n\r\nconst semicolonRE = /[^\\\\];\\s*$/\r\nconst importantRE = /\\s*!important$/\r\n\r\nfunction setStyle(\r\n  style: CSSStyleDeclaration,\r\n  name: string,\r\n  val: string | string[],\r\n) {\r\n  if (isArray(val)) {\r\n    val.forEach(v => setStyle(style, name, v))\r\n  } else {\r\n    if (val == null) val = ''\r\n    if (__DEV__) {\r\n      if (semicolonRE.test(val)) {\r\n        warn(\r\n          `Unexpected semicolon at the end of '${name}' style value: '${val}'`,\r\n        )\r\n      }\r\n    }\r\n    if (name.startsWith('--')) {\r\n      // custom property definition\r\n      style.setProperty(name, val)\r\n    } else {\r\n      const prefixed = autoPrefix(style, name)\r\n      if (importantRE.test(val)) {\r\n        // !important 存在important的情况\r\n        style.setProperty(\r\n          hyphenate(prefixed),\r\n          val.replace(importantRE, ''),\r\n          'important',\r\n        )\r\n      } else {\r\n        style[prefixed as any] = val\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst prefixes = ['Webkit', 'Moz', 'ms']\r\nconst prefixCache: Record<string, string> = {}\r\n\r\nfunction autoPrefix(style: CSSStyleDeclaration, rawName: string): string {\r\n  const cached = prefixCache[rawName]\r\n  if (cached) {\r\n    return cached\r\n  }\r\n  let name = camelize(rawName)\r\n  if (name !== 'filter' && name in style) {\r\n    return (prefixCache[rawName] = name)\r\n  }\r\n  name = capitalize(name)\r\n  for (let i = 0; i < prefixes.length; i++) {\r\n    const prefixed = prefixes[i] + name\r\n    if (prefixed in style) {\r\n      return (prefixCache[rawName] = prefixed)\r\n    }\r\n  }\r\n  return rawName\r\n}\r\n","import {\r\n  NOOP,\r\n  includeBooleanAttr,\r\n  isSpecialBooleanAttr,\r\n  makeMap,\r\n} from '@vue/shared'\r\nimport {\r\n  type ComponentInternalInstance,\r\n  DeprecationTypes,\r\n  compatUtils,\r\n} from '@vue/runtime-core'\r\n\r\nexport const xlinkNS = 'http://www.w3.org/1999/xlink'\r\n\r\nexport function patchAttr(\r\n  el: Element,\r\n  key: string,\r\n  value: any,\r\n  isSVG: boolean,\r\n  instance?: ComponentInternalInstance | null,\r\n) {\r\n  if (isSVG && key.startsWith('xlink:')) {\r\n    if (value == null) {\r\n      el.removeAttributeNS(xlinkNS, key.slice(6, key.length))\r\n    } else {\r\n      el.setAttributeNS(xlinkNS, key, value)\r\n    }\r\n  } else {\r\n    if (__COMPAT__ && compatCoerceAttr(el, key, value, instance)) {\r\n      return\r\n    }\r\n\r\n    // note we are only checking boolean attributes that don't have a\r\n    // corresponding dom prop of the same name here.\r\n    const isBoolean = isSpecialBooleanAttr(key)\r\n    if (value == null || (isBoolean && !includeBooleanAttr(value))) {\r\n      el.removeAttribute(key)\r\n    } else {\r\n      el.setAttribute(key, isBoolean ? '' : value)\r\n    }\r\n  }\r\n}\r\n\r\n// 2.x compat\r\nconst isEnumeratedAttr = __COMPAT__\r\n  ? /*#__PURE__*/ makeMap('contenteditable,draggable,spellcheck')\r\n  : NOOP\r\n\r\nexport function compatCoerceAttr(\r\n  el: Element,\r\n  key: string,\r\n  value: unknown,\r\n  instance: ComponentInternalInstance | null = null,\r\n): boolean {\r\n  if (isEnumeratedAttr(key)) {\r\n    const v2CoercedValue =\r\n      value === null\r\n        ? 'false'\r\n        : typeof value !== 'boolean' && value !== undefined\r\n          ? 'true'\r\n          : null\r\n    if (\r\n      v2CoercedValue &&\r\n      compatUtils.softAssertCompatEnabled(\r\n        DeprecationTypes.ATTR_ENUMERATED_COERCION,\r\n        instance,\r\n        key,\r\n        value,\r\n        v2CoercedValue,\r\n      )\r\n    ) {\r\n      el.setAttribute(key, v2CoercedValue)\r\n      return true\r\n    }\r\n  } else if (\r\n    value === false &&\r\n    !isSpecialBooleanAttr(key) &&\r\n    compatUtils.softAssertCompatEnabled(\r\n      DeprecationTypes.ATTR_FALSE_VALUE,\r\n      instance,\r\n      key,\r\n    )\r\n  ) {\r\n    el.removeAttribute(key)\r\n    return true\r\n  }\r\n  return false\r\n}\r\n","import { hyphenate, isArray } from '@vue/shared'\r\nimport {\r\n  type ComponentInternalInstance,\r\n  ErrorCodes,\r\n  callWithAsyncErrorHandling,\r\n} from '@vue/runtime-core'\r\n\r\ninterface Invoker extends EventListener {\r\n  value: EventValue\r\n  attached: number\r\n}\r\n\r\ntype EventValue = Function | Function[]\r\n\r\nexport function addEventListener(\r\n  el: Element,\r\n  event: string,\r\n  handler: EventListener,\r\n  options?: EventListenerOptions,\r\n) {\r\n  el.addEventListener(event, handler, options)\r\n}\r\n\r\nexport function removeEventListener(\r\n  el: Element,\r\n  event: string,\r\n  handler: EventListener,\r\n  options?: EventListenerOptions,\r\n) {\r\n  el.removeEventListener(event, handler, options)\r\n}\r\n\r\nconst veiKey = Symbol('_vei')\r\n\r\nexport function patchEvent(\r\n  el: Element & { [veiKey]?: Record<string, Invoker | undefined> },\r\n  rawName: string,\r\n  prevValue: EventValue | null,\r\n  nextValue: EventValue | null,\r\n  instance: ComponentInternalInstance | null = null,\r\n) {\r\n  // vei = vue event invokers\r\n  const invokers = el[veiKey] || (el[veiKey] = {})\r\n  const existingInvoker = invokers[rawName]\r\n  if (nextValue && existingInvoker) {\r\n    // patch\r\n    existingInvoker.value = nextValue\r\n  } else {\r\n    const [name, options] = parseName(rawName)\r\n    if (nextValue) {\r\n      // add\r\n      const invoker = (invokers[rawName] = createInvoker(nextValue, instance))\r\n      addEventListener(el, name, invoker, options)\r\n    } else if (existingInvoker) {\r\n      // remove\r\n      removeEventListener(el, name, existingInvoker, options)\r\n      invokers[rawName] = undefined\r\n    }\r\n  }\r\n}\r\n\r\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/\r\n\r\nfunction parseName(name: string): [string, EventListenerOptions | undefined] {\r\n  let options: EventListenerOptions | undefined\r\n  if (optionsModifierRE.test(name)) {\r\n    options = {}\r\n    let m\r\n    while ((m = name.match(optionsModifierRE))) {\r\n      name = name.slice(0, name.length - m[0].length)\r\n      ;(options as any)[m[0].toLowerCase()] = true\r\n    }\r\n  }\r\n  const event = name[2] === ':' ? name.slice(3) : hyphenate(name.slice(2))\r\n  return [event, options]\r\n}\r\n\r\n// To avoid the overhead of repeatedly calling Date.now(), we cache\r\n// and use the same timestamp for all event listeners attached in the same tick.\r\nlet cachedNow: number = 0\r\nconst p = /*#__PURE__*/ Promise.resolve()\r\nconst getNow = () =>\r\n  cachedNow || (p.then(() => (cachedNow = 0)), (cachedNow = Date.now()))\r\n\r\nfunction createInvoker(\r\n  initialValue: EventValue,\r\n  instance: ComponentInternalInstance | null,\r\n) {\r\n  const invoker: Invoker = (e: Event & { _vts?: number }) => {\r\n    // async edge case vuejs/vue#6566\r\n    // inner click event triggers patch, event handler\r\n    // attached to outer element during patch, and triggered again. This\r\n    // happens because browsers fire microtask ticks between event propagation.\r\n    // this no longer happens for templates in Vue 3, but could still be\r\n    // theoretically possible for hand-written render functions.\r\n    // the solution: we save the timestamp when a handler is attached,\r\n    // and also attach the timestamp to any event that was handled by vue\r\n    // for the first time (to avoid inconsistent event timestamp implementations\r\n    // or events fired from iframes, e.g. #2513)\r\n    // The handler would only fire if the event passed to it was fired\r\n    // AFTER it was attached.\r\n    // 防止因为事件冒泡导致事件在子级产生的时间小于在父级绑定的时间\r\n    if (!e._vts) {\r\n      e._vts = Date.now()\r\n    } else if (e._vts <= invoker.attached) {\r\n      return\r\n    }\r\n    callWithAsyncErrorHandling(\r\n      patchStopImmediatePropagation(e, invoker.value),\r\n      instance,\r\n      ErrorCodes.NATIVE_EVENT_HANDLER,\r\n      [e],\r\n    )\r\n  }\r\n  invoker.value = initialValue\r\n  invoker.attached = getNow()\r\n  return invoker\r\n}\r\n\r\nfunction patchStopImmediatePropagation(\r\n  e: Event,\r\n  value: EventValue,\r\n): EventValue {\r\n  if (isArray(value)) {\r\n    const originalStop = e.stopImmediatePropagation\r\n    e.stopImmediatePropagation = () => {\r\n      originalStop.call(e)\r\n      ;(e as any)._stopped = true\r\n    }\r\n    return value.map(fn => (e: Event) => !(e as any)._stopped && fn && fn(e))\r\n  } else {\r\n    return value\r\n  }\r\n}\r\n","import { patchClass } from './modules/class'\r\nimport { patchStyle } from './modules/style'\r\nimport { patchAttr } from './modules/attrs'\r\nimport { patchDOMProp } from './modules/props'\r\nimport { patchEvent } from './modules/events'\r\nimport { isFunction, isModelListener, isOn, isString } from '@vue/shared'\r\nimport type { RendererOptions } from '@vue/runtime-core'\r\n\r\nconst isNativeOn = (key: string) =>\r\n  key.charCodeAt(0) === 111 /* o */ &&\r\n  key.charCodeAt(1) === 110 /* n */ &&\r\n  // lowercase letter\r\n  key.charCodeAt(2) > 96 &&\r\n  key.charCodeAt(2) < 123\r\n\r\ntype DOMRendererOptions = RendererOptions<Node, Element>\r\n\r\nexport const patchProp: DOMRendererOptions['patchProp'] = (\r\n  el,\r\n  key,\r\n  prevValue,\r\n  nextValue,\r\n  namespace,\r\n  prevChildren,\r\n  parentComponent,\r\n  parentSuspense,\r\n  unmountChildren,\r\n) => {\r\n  const isSVG = namespace === 'svg'\r\n  /**\r\n   * dom.setAttribute('class', 'redbg')  dom.className = 'redbg'\r\n   * 但是性能对比：className > classList > setAttribute\r\n   */\r\n  if (key === 'class') {\r\n    patchClass(el, nextValue, isSVG)\r\n  } else if (key === 'style') {\r\n    /**\r\n     * 设置style的方式有3种：\r\n     * （1）字符串（添加原有style）\r\n     * dom.sytle.color = 'red';\r\n     * dom.sytle.backgroundColor = 'yellow';\r\n     * (2) setProperty（叠加原有style）\r\n     * box.style.setProperty('color', 'pink')\r\n     * （3）cssText（直接覆盖，原有的style会失效）\r\n     * box.style.cssText = 'color: pink';\r\n     */\r\n    patchStyle(el, prevValue, nextValue)\r\n  } else if (isOn(key)) {\r\n    // on开头的事件，排除onUpdate双向绑定的\r\n    // ignore v-model listeners\r\n    if (!isModelListener(key)) {\r\n      patchEvent(el, key, prevValue, nextValue, parentComponent)\r\n    }\r\n  } else if (\r\n    key[0] === '.'\r\n      ? ((key = key.slice(1)), true)\r\n      : key[0] === '^'\r\n        ? ((key = key.slice(1)), false)\r\n        : shouldSetAsProp(el, key, nextValue, isSVG)\r\n  ) {\r\n    patchDOMProp(\r\n      el,\r\n      key,\r\n      nextValue,\r\n      prevChildren,\r\n      parentComponent,\r\n      parentSuspense,\r\n      unmountChildren,\r\n    )\r\n  } else {\r\n    // special case for <input v-model type=\"checkbox\"> with\r\n    // :true-value & :false-value\r\n    // store value as dom properties since non-string values will be\r\n    // stringified.\r\n    if (key === 'true-value') {\r\n      ;(el as any)._trueValue = nextValue\r\n    } else if (key === 'false-value') {\r\n      ;(el as any)._falseValue = nextValue\r\n    }\r\n    patchAttr(el, key, nextValue, isSVG, parentComponent)\r\n  }\r\n}\r\n\r\nfunction shouldSetAsProp(\r\n  el: Element,\r\n  key: string,\r\n  value: unknown,\r\n  isSVG: boolean,\r\n) {\r\n  if (isSVG) {\r\n    // most keys must be set as attribute on svg elements to work\r\n    // ...except innerHTML & textContent\r\n    if (key === 'innerHTML' || key === 'textContent') {\r\n      return true\r\n    }\r\n    // or native onclick with function values\r\n    if (key in el && isNativeOn(key) && isFunction(value)) {\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  // these are enumerated attrs, however their corresponding DOM properties\r\n  // are actually booleans - this leads to setting it with a string \"false\"\r\n  // value leading it to be coerced to `true`, so we need to always treat\r\n  // them as attributes.\r\n  // Note that `contentEditable` doesn't have this problem: its DOM\r\n  // property is also enumerated string values.\r\n  if (key === 'spellcheck' || key === 'draggable' || key === 'translate') {\r\n    return false\r\n  }\r\n\r\n  // #1787, #2840 form property on form elements is readonly and must be set as\r\n  // attribute.\r\n  if (key === 'form') {\r\n    return false\r\n  }\r\n\r\n  // #1526 <input list> must be set as attribute\r\n  if (key === 'list' && el.tagName === 'INPUT') {\r\n    return false\r\n  }\r\n\r\n  // #2766 <textarea type> must be set as attribute\r\n  if (key === 'type' && el.tagName === 'TEXTAREA') {\r\n    return false\r\n  }\r\n\r\n  // #8780 the width or height of embedded tags must be set as attribute\r\n  if (key === 'width' || key === 'height') {\r\n    const tag = el.tagName\r\n    if (\r\n      tag === 'IMG' ||\r\n      tag === 'VIDEO' ||\r\n      tag === 'CANVAS' ||\r\n      tag === 'SOURCE'\r\n    ) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  // native onclick with string value, must be set as attribute\r\n  if (isNativeOn(key) && isString(value)) {\r\n    return false\r\n  }\r\n\r\n  return key in el\r\n}\r\n","import {\r\n  type DirectiveBinding,\r\n  type DirectiveHook,\r\n  type ObjectDirective,\r\n  type VNode,\r\n  nextTick,\r\n  warn,\r\n} from '@vue/runtime-core'\r\nimport { addEventListener } from '../modules/events'\r\nimport {\r\n  invokeArrayFns,\r\n  isArray,\r\n  isSet,\r\n  looseEqual,\r\n  looseIndexOf,\r\n  looseToNumber,\r\n} from '@vue/shared'\r\n\r\ntype AssignerFn = (value: any) => void\r\n\r\nconst getModelAssigner = (vnode: VNode): AssignerFn => {\r\n  const fn =\r\n    vnode.props!['onUpdate:modelValue'] ||\r\n    (__COMPAT__ && vnode.props!['onModelCompat:input'])\r\n  return isArray(fn) ? value => invokeArrayFns(fn, value) : fn\r\n}\r\n\r\nfunction onCompositionStart(e: Event) {\r\n  ;(e.target as any).composing = true\r\n}\r\n\r\nfunction onCompositionEnd(e: Event) {\r\n  const target = e.target as any\r\n  if (target.composing) {\r\n    target.composing = false\r\n    target.dispatchEvent(new Event('input'))\r\n  }\r\n}\r\n\r\nconst assignKey = Symbol('_assign')\r\n\r\ntype ModelDirective<T> = ObjectDirective<\r\n  T & { [assignKey]: AssignerFn; _assigning?: boolean }\r\n>\r\n\r\n// We are exporting the v-model runtime directly as vnode hooks so that it can\r\n// be tree-shaken in case v-model is never used.\r\nexport const vModelText: ModelDirective<\r\n  HTMLInputElement | HTMLTextAreaElement\r\n> = {\r\n  created(el, { modifiers: { lazy, trim, number } }, vnode) {\r\n    el[assignKey] = getModelAssigner(vnode)\r\n    const castToNumber =\r\n      number || (vnode.props && vnode.props.type === 'number')\r\n    addEventListener(el, lazy ? 'change' : 'input', e => {\r\n      if ((e.target as any).composing) return\r\n      let domValue: string | number = el.value\r\n      if (trim) {\r\n        domValue = domValue.trim()\r\n      }\r\n      if (castToNumber) {\r\n        domValue = looseToNumber(domValue)\r\n      }\r\n      el[assignKey](domValue)\r\n    })\r\n    if (trim) {\r\n      addEventListener(el, 'change', () => {\r\n        el.value = el.value.trim()\r\n      })\r\n    }\r\n    if (!lazy) {\r\n      addEventListener(el, 'compositionstart', onCompositionStart)\r\n      addEventListener(el, 'compositionend', onCompositionEnd)\r\n      // Safari < 10.2 & UIWebView doesn't fire compositionend when\r\n      // switching focus before confirming composition choice\r\n      // this also fixes the issue where some browsers e.g. iOS Chrome\r\n      // fires \"change\" instead of \"input\" on autocomplete.\r\n      addEventListener(el, 'change', onCompositionEnd)\r\n    }\r\n  },\r\n  // set value on mounted so it's after min/max for type=\"range\"\r\n  mounted(el, { value }) {\r\n    el.value = value == null ? '' : value\r\n  },\r\n  beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {\r\n    el[assignKey] = getModelAssigner(vnode)\r\n    // avoid clearing unresolved text. #2302\r\n    if ((el as any).composing) return\r\n\r\n    const elValue =\r\n      number || el.type === 'number' ? looseToNumber(el.value) : el.value\r\n    const newValue = value == null ? '' : value\r\n\r\n    if (elValue === newValue) {\r\n      return\r\n    }\r\n\r\n    if (document.activeElement === el && el.type !== 'range') {\r\n      if (lazy) {\r\n        return\r\n      }\r\n      if (trim && el.value.trim() === newValue) {\r\n        return\r\n      }\r\n    }\r\n\r\n    el.value = newValue\r\n  },\r\n}\r\n\r\nexport const vModelCheckbox: ModelDirective<HTMLInputElement> = {\r\n  // #4096 array checkboxes need to be deep traversed\r\n  deep: true,\r\n  created(el, _, vnode) {\r\n    el[assignKey] = getModelAssigner(vnode)\r\n    addEventListener(el, 'change', () => {\r\n      const modelValue = (el as any)._modelValue\r\n      const elementValue = getValue(el)\r\n      const checked = el.checked\r\n      const assign = el[assignKey]\r\n      if (isArray(modelValue)) {\r\n        const index = looseIndexOf(modelValue, elementValue)\r\n        const found = index !== -1\r\n        if (checked && !found) {\r\n          assign(modelValue.concat(elementValue))\r\n        } else if (!checked && found) {\r\n          const filtered = [...modelValue]\r\n          filtered.splice(index, 1)\r\n          assign(filtered)\r\n        }\r\n      } else if (isSet(modelValue)) {\r\n        const cloned = new Set(modelValue)\r\n        if (checked) {\r\n          cloned.add(elementValue)\r\n        } else {\r\n          cloned.delete(elementValue)\r\n        }\r\n        assign(cloned)\r\n      } else {\r\n        assign(getCheckboxValue(el, checked))\r\n      }\r\n    })\r\n  },\r\n  // set initial checked on mount to wait for true-value/false-value\r\n  mounted: setChecked,\r\n  beforeUpdate(el, binding, vnode) {\r\n    el[assignKey] = getModelAssigner(vnode)\r\n    setChecked(el, binding, vnode)\r\n  },\r\n}\r\n\r\nfunction setChecked(\r\n  el: HTMLInputElement,\r\n  { value, oldValue }: DirectiveBinding,\r\n  vnode: VNode,\r\n) {\r\n  // store the v-model value on the element so it can be accessed by the\r\n  // change listener.\r\n  ;(el as any)._modelValue = value\r\n  if (isArray(value)) {\r\n    el.checked = looseIndexOf(value, vnode.props!.value) > -1\r\n  } else if (isSet(value)) {\r\n    el.checked = value.has(vnode.props!.value)\r\n  } else if (value !== oldValue) {\r\n    el.checked = looseEqual(value, getCheckboxValue(el, true))\r\n  }\r\n}\r\n\r\nexport const vModelRadio: ModelDirective<HTMLInputElement> = {\r\n  created(el, { value }, vnode) {\r\n    el.checked = looseEqual(value, vnode.props!.value)\r\n    el[assignKey] = getModelAssigner(vnode)\r\n    addEventListener(el, 'change', () => {\r\n      el[assignKey](getValue(el))\r\n    })\r\n  },\r\n  beforeUpdate(el, { value, oldValue }, vnode) {\r\n    el[assignKey] = getModelAssigner(vnode)\r\n    if (value !== oldValue) {\r\n      el.checked = looseEqual(value, vnode.props!.value)\r\n    }\r\n  },\r\n}\r\n\r\nexport const vModelSelect: ModelDirective<HTMLSelectElement> = {\r\n  // <select multiple> value need to be deep traversed\r\n  deep: true,\r\n  created(el, { value, modifiers: { number } }, vnode) {\r\n    const isSetModel = isSet(value)\r\n    addEventListener(el, 'change', () => {\r\n      const selectedVal = Array.prototype.filter\r\n        .call(el.options, (o: HTMLOptionElement) => o.selected)\r\n        .map((o: HTMLOptionElement) =>\r\n          number ? looseToNumber(getValue(o)) : getValue(o),\r\n        )\r\n      el[assignKey](\r\n        el.multiple\r\n          ? isSetModel\r\n            ? new Set(selectedVal)\r\n            : selectedVal\r\n          : selectedVal[0],\r\n      )\r\n      el._assigning = true\r\n      nextTick(() => {\r\n        el._assigning = false\r\n      })\r\n    })\r\n    el[assignKey] = getModelAssigner(vnode)\r\n  },\r\n  // set value in mounted & updated because <select> relies on its children\r\n  // <option>s.\r\n  mounted(el, { value, oldValue, modifiers: { number } }) {\r\n    setSelected(el, value, oldValue, number)\r\n  },\r\n  beforeUpdate(el, _binding, vnode) {\r\n    el[assignKey] = getModelAssigner(vnode)\r\n  },\r\n  updated(el, { value, oldValue, modifiers: { number } }) {\r\n    if (!el._assigning) {\r\n      setSelected(el, value, oldValue, number)\r\n    }\r\n  },\r\n}\r\n\r\nfunction setSelected(\r\n  el: HTMLSelectElement,\r\n  value: any,\r\n  oldValue: any,\r\n  number: boolean,\r\n) {\r\n  const isMultiple = el.multiple\r\n  const isArrayValue = isArray(value)\r\n  if (isMultiple && !isArrayValue && !isSet(value)) {\r\n    __DEV__ &&\r\n      warn(\r\n        `<select multiple v-model> expects an Array or Set value for its binding, ` +\r\n          `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`,\r\n      )\r\n    return\r\n  }\r\n\r\n  // fast path for updates triggered by other changes\r\n  if (isArrayValue && looseEqual(value, oldValue)) {\r\n    return\r\n  }\r\n\r\n  for (let i = 0, l = el.options.length; i < l; i++) {\r\n    const option = el.options[i]\r\n    const optionValue = getValue(option)\r\n    if (isMultiple) {\r\n      if (isArrayValue) {\r\n        const optionType = typeof optionValue\r\n        // fast path for string / number values\r\n        if (optionType === 'string' || optionType === 'number') {\r\n          option.selected = value.includes(\r\n            number ? looseToNumber(optionValue) : optionValue,\r\n          )\r\n        } else {\r\n          option.selected = looseIndexOf(value, optionValue) > -1\r\n        }\r\n      } else {\r\n        option.selected = value.has(optionValue)\r\n      }\r\n    } else {\r\n      if (looseEqual(getValue(option), value)) {\r\n        if (el.selectedIndex !== i) el.selectedIndex = i\r\n        return\r\n      }\r\n    }\r\n  }\r\n  if (!isMultiple && el.selectedIndex !== -1) {\r\n    el.selectedIndex = -1\r\n  }\r\n}\r\n\r\n// retrieve raw value set via :value bindings\r\nfunction getValue(el: HTMLOptionElement | HTMLInputElement) {\r\n  return '_value' in el ? (el as any)._value : el.value\r\n}\r\n\r\n// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings\r\nfunction getCheckboxValue(\r\n  el: HTMLInputElement & { _trueValue?: any; _falseValue?: any },\r\n  checked: boolean,\r\n) {\r\n  const key = checked ? '_trueValue' : '_falseValue'\r\n  return key in el ? el[key] : checked\r\n}\r\n\r\nexport const vModelDynamic: ObjectDirective<\r\n  HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement\r\n> = {\r\n  created(el, binding, vnode) {\r\n    callModelHook(el, binding, vnode, null, 'created')\r\n  },\r\n  mounted(el, binding, vnode) {\r\n    callModelHook(el, binding, vnode, null, 'mounted')\r\n  },\r\n  beforeUpdate(el, binding, vnode, prevVNode) {\r\n    callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate')\r\n  },\r\n  updated(el, binding, vnode, prevVNode) {\r\n    callModelHook(el, binding, vnode, prevVNode, 'updated')\r\n  },\r\n}\r\n\r\nfunction resolveDynamicModel(tagName: string, type: string | undefined) {\r\n  switch (tagName) {\r\n    case 'SELECT':\r\n      return vModelSelect\r\n    case 'TEXTAREA':\r\n      return vModelText\r\n    default:\r\n      switch (type) {\r\n        case 'checkbox':\r\n          return vModelCheckbox\r\n        case 'radio':\r\n          return vModelRadio\r\n        default:\r\n          return vModelText\r\n      }\r\n  }\r\n}\r\n\r\nfunction callModelHook(\r\n  el: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement,\r\n  binding: DirectiveBinding,\r\n  vnode: VNode,\r\n  prevVNode: VNode | null,\r\n  hook: keyof ObjectDirective,\r\n) {\r\n  const modelToUse = resolveDynamicModel(\r\n    el.tagName,\r\n    vnode.props && vnode.props.type,\r\n  )\r\n  const fn = modelToUse[hook] as DirectiveHook\r\n  fn && fn(el, binding, vnode, prevVNode)\r\n}\r\n\r\n// SSR vnode transforms, only used when user includes client-oriented render\r\n// function in SSR\r\nexport function initVModelForSSR() {\r\n  vModelText.getSSRProps = ({ value }) => ({ value })\r\n\r\n  vModelRadio.getSSRProps = ({ value }, vnode) => {\r\n    if (vnode.props && looseEqual(vnode.props.value, value)) {\r\n      return { checked: true }\r\n    }\r\n  }\r\n\r\n  vModelCheckbox.getSSRProps = ({ value }, vnode) => {\r\n    if (isArray(value)) {\r\n      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {\r\n        return { checked: true }\r\n      }\r\n    } else if (isSet(value)) {\r\n      if (vnode.props && value.has(vnode.props.value)) {\r\n        return { checked: true }\r\n      }\r\n    } else if (value) {\r\n      return { checked: true }\r\n    }\r\n  }\r\n\r\n  vModelDynamic.getSSRProps = (binding, vnode) => {\r\n    if (typeof vnode.type !== 'string') {\r\n      return\r\n    }\r\n    const modelToUse = resolveDynamicModel(\r\n      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase\r\n      vnode.type.toUpperCase(),\r\n      vnode.props && vnode.props.type,\r\n    )\r\n    if (modelToUse.getSSRProps) {\r\n      return modelToUse.getSSRProps(binding, vnode)\r\n    }\r\n  }\r\n}\r\n","import {\r\n  type App,\r\n  type CreateAppFunction,\r\n  DeprecationTypes,\r\n  type ElementNamespace,\r\n  type HydrationRenderer,\r\n  type Renderer,\r\n  type RootHydrateFunction,\r\n  type RootRenderFunction,\r\n  compatUtils,\r\n  createHydrationRenderer,\r\n  createRenderer,\r\n  isRuntimeOnly,\r\n  warn,\r\n} from '@vue/runtime-core'\r\nimport { nodeOps } from './nodeOps'\r\nimport { patchProp } from './patchProp'\r\n// Importing from the compiler, will be tree-shaken in prod\r\nimport {\r\n  NOOP,\r\n  extend,\r\n  isFunction,\r\n  isHTMLTag,\r\n  isMathMLTag,\r\n  isSVGTag,\r\n  isString,\r\n} from '@vue/shared'\r\n\r\ndeclare module '@vue/reactivity' {\r\n  export interface RefUnwrapBailTypes {\r\n    runtimeDOMBailTypes: Node | Window\r\n  }\r\n}\r\n\r\n//对dom的原生操作，添加、删除之类的\r\nconst rendererOptions = /*#__PURE__*/ extend({ patchProp }, nodeOps)\r\n\r\n// lazy create the renderer - this makes core renderer logic tree-shakable\r\n// in case the user only imports reactivity utilities from Vue.\r\nlet renderer: Renderer<Element | ShadowRoot> | HydrationRenderer\r\n\r\nlet enabledHydration = false\r\n\r\nfunction ensureRenderer() {\r\n  return (\r\n    renderer ||\r\n    (renderer = createRenderer<Node, Element | ShadowRoot>(rendererOptions))\r\n  )\r\n}\r\n\r\nfunction ensureHydrationRenderer() {\r\n  renderer = enabledHydration\r\n    ? renderer\r\n    : createHydrationRenderer(rendererOptions)\r\n  enabledHydration = true\r\n  return renderer as HydrationRenderer\r\n}\r\n\r\n// use explicit type casts here to avoid import() calls in rolled-up d.ts\r\nexport const render = ((...args) => {\r\n  ensureRenderer().render(...args)\r\n}) as RootRenderFunction<Element | ShadowRoot>\r\n\r\nexport const hydrate = ((...args) => {\r\n  ensureHydrationRenderer().hydrate(...args)\r\n}) as RootHydrateFunction\r\n\r\nexport const createApp = ((...args) => {\r\n  /**\r\n   * 先通过ensureRenderer方法创建一个具有render对象和createApp函数的对象\r\n   * 再调用createApp创建app，参数传入的是根组件\r\n   */\r\n  const app = ensureRenderer().createApp(...args)\r\n\r\n  if (__DEV__) {\r\n    // 检查元素是否是原生的标签\r\n    injectNativeTagCheck(app)\r\n    injectCompilerOptionsCheck(app)\r\n  }\r\n\r\n  // 重置了App对象中的mount方法\r\n  const { mount } = app\r\n  /**\r\n   * \r\n   * @param containerOrSelector 传入id/class或者dom元素均可以\r\n   * @returns \r\n   */\r\n  app.mount = (containerOrSelector: Element | ShadowRoot | string): any => {\r\n    const container = normalizeContainer(containerOrSelector)\r\n    if (!container) return\r\n\r\n    //App对象中的_component就是传入的根组件\r\n    // 如果根组件中不存在template或者render函数，就把容器的innerHtml内容复制给根组件的template\r\n    const component = app._component\r\n    if (!isFunction(component) && !component.render && !component.template) {\r\n      // __UNSAFE__\r\n      // Reason: potential execution of JS expressions in in-DOM template.\r\n      // The user must make sure the in-DOM template is trusted. If it's\r\n      // rendered by the server, the template should not contain any user data.\r\n      component.template = container.innerHTML\r\n      // 2.x compat check\r\n      if (__COMPAT__ && __DEV__) {\r\n        for (let i = 0; i < container.attributes.length; i++) {\r\n          const attr = container.attributes[i]\r\n          if (attr.name !== 'v-cloak' && /^(v-|:|@)/.test(attr.name)) {\r\n            compatUtils.warnDeprecation(\r\n              DeprecationTypes.GLOBAL_MOUNT_CONTAINER,\r\n              null,\r\n            )\r\n            break\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // clear content before mounting\r\n    container.innerHTML = ''\r\n    const proxy = mount(container, false, resolveRootNamespace(container))\r\n    if (container instanceof Element) {\r\n      container.removeAttribute('v-cloak')\r\n      container.setAttribute('data-v-app', '')\r\n    }\r\n    return proxy\r\n  }\r\n\r\n  return app\r\n}) as CreateAppFunction<Element>\r\n\r\nexport const createSSRApp = ((...args) => {\r\n  const app = ensureHydrationRenderer().createApp(...args)\r\n\r\n  if (__DEV__) {\r\n    injectNativeTagCheck(app)\r\n    injectCompilerOptionsCheck(app)\r\n  }\r\n\r\n  const { mount } = app\r\n  app.mount = (containerOrSelector: Element | ShadowRoot | string): any => {\r\n    const container = normalizeContainer(containerOrSelector)\r\n    if (container) {\r\n      return mount(container, true, resolveRootNamespace(container))\r\n    }\r\n  }\r\n\r\n  return app\r\n}) as CreateAppFunction<Element>\r\n\r\nfunction resolveRootNamespace(container: Element): ElementNamespace {\r\n  if (container instanceof SVGElement) {\r\n    return 'svg'\r\n  }\r\n  if (\r\n    typeof MathMLElement === 'function' &&\r\n    container instanceof MathMLElement\r\n  ) {\r\n    return 'mathml'\r\n  }\r\n}\r\n\r\nfunction injectNativeTagCheck(app: App) {\r\n  // Inject `isNativeTag`\r\n  // this is used for component name validation (dev only)\r\n  Object.defineProperty(app.config, 'isNativeTag', {\r\n    value: (tag: string) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),\r\n    writable: false,\r\n  })\r\n}\r\n\r\n// dev only\r\nfunction injectCompilerOptionsCheck(app: App) {\r\n  if (isRuntimeOnly()) {\r\n    const isCustomElement = app.config.isCustomElement\r\n    Object.defineProperty(app.config, 'isCustomElement', {\r\n      get() {\r\n        return isCustomElement\r\n      },\r\n      set() {\r\n        warn(\r\n          `The \\`isCustomElement\\` config option is deprecated. Use ` +\r\n            `\\`compilerOptions.isCustomElement\\` instead.`,\r\n        )\r\n      },\r\n    })\r\n\r\n    const compilerOptions = app.config.compilerOptions\r\n    const msg =\r\n      `The \\`compilerOptions\\` config option is only respected when using ` +\r\n      `a build of Vue.js that includes the runtime compiler (aka \"full build\"). ` +\r\n      `Since you are using the runtime-only build, \\`compilerOptions\\` ` +\r\n      `must be passed to \\`@vue/compiler-dom\\` in the build setup instead.\\n` +\r\n      `- For vue-loader: pass it via vue-loader's \\`compilerOptions\\` loader option.\\n` +\r\n      `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\\n` +\r\n      `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`\r\n\r\n    Object.defineProperty(app.config, 'compilerOptions', {\r\n      get() {\r\n        warn(msg)\r\n        return compilerOptions\r\n      },\r\n      set() {\r\n        warn(msg)\r\n      },\r\n    })\r\n  }\r\n}\r\n\r\nfunction normalizeContainer(\r\n  container: Element | ShadowRoot | string,\r\n): Element | null {\r\n  if (isString(container)) {\r\n    const res = document.querySelector(container)\r\n    if (__DEV__ && !res) {\r\n      warn(\r\n        `Failed to mount app: mount target selector \"${container}\" returned null.`,\r\n      )\r\n    }\r\n    return res\r\n  }\r\n  if (\r\n    __DEV__ &&\r\n    window.ShadowRoot &&\r\n    container instanceof window.ShadowRoot &&\r\n    container.mode === 'closed'\r\n  ) {\r\n    warn(\r\n      `mounting on a ShadowRoot with \\`{mode: \"closed\"}\\` may lead to unpredictable bugs`,\r\n    )\r\n  }\r\n  return container as any\r\n}\r\n\r\n// Custom element support\r\nexport {\r\n  defineCustomElement,\r\n  defineSSRCustomElement,\r\n  VueElement,\r\n  type VueElementConstructor,\r\n} from './apiCustomElement'\r\n\r\n// SFC CSS utilities\r\nexport { useCssModule } from './helpers/useCssModule'\r\nexport { useCssVars } from './helpers/useCssVars'\r\n\r\n// DOM-only components\r\nexport { Transition, type TransitionProps } from './components/Transition'\r\nexport {\r\n  TransitionGroup,\r\n  type TransitionGroupProps,\r\n} from './components/TransitionGroup'\r\n\r\n// **Internal** DOM-only runtime directive helpers\r\nexport {\r\n  vModelText,\r\n  vModelCheckbox,\r\n  vModelRadio,\r\n  vModelSelect,\r\n  vModelDynamic,\r\n} from './directives/vModel'\r\nexport { withModifiers, withKeys } from './directives/vOn'\r\nexport { vShow } from './directives/vShow'\r\n\r\nimport { initVModelForSSR } from './directives/vModel'\r\nimport { initVShowForSSR } from './directives/vShow'\r\n\r\nlet ssrDirectiveInitialized = false\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const initDirectivesForSSR = __SSR__\r\n  ? () => {\r\n      if (!ssrDirectiveInitialized) {\r\n        ssrDirectiveInitialized = true\r\n        initVModelForSSR()\r\n        initVShowForSSR()\r\n      }\r\n    }\r\n  : NOOP\r\n\r\n// re-export everything from core\r\n// h, Component, reactivity API, nextTick, flags & types\r\nexport * from '@vue/runtime-core'\r\n\r\nexport * from './jsx'\r\n","import { type ElementWithTransition, vtcKey } from '../components/Transition'\r\n\r\n// compiler should normalize class + :class bindings on the same element\r\n// into a single binding ['staticClass', dynamic]\r\nexport function patchClass(el: Element, value: string | null, isSVG: boolean) {\r\n  // directly setting className should be faster than setAttribute in theory\r\n  // if this is an element during a transition, take the temporary transition\r\n  // classes into account.\r\n  const transitionClasses = (el as ElementWithTransition)[vtcKey]\r\n  if (transitionClasses) {\r\n    value = (\r\n      value ? [value, ...transitionClasses] : [...transitionClasses]\r\n    ).join(' ')\r\n  }\r\n  if (value == null) {\r\n    el.removeAttribute('class')\r\n  } else if (isSVG) {\r\n    el.setAttribute('class', value)\r\n  } else {\r\n    el.className = value\r\n  }\r\n}\r\n","// __UNSAFE__\r\n// Reason: potentially setting innerHTML.\r\n// This can come from explicit usage of v-html or innerHTML as a prop in render\r\n\r\nimport { DeprecationTypes, compatUtils, warn } from '@vue/runtime-core'\r\nimport { includeBooleanAttr } from '@vue/shared'\r\n\r\n// functions. The user is responsible for using them with only trusted content.\r\nexport function patchDOMProp(\r\n  el: any,\r\n  key: string,\r\n  value: any,\r\n  // the following args are passed only due to potential innerHTML/textContent\r\n  // overriding existing VNodes, in which case the old tree must be properly\r\n  // unmounted.\r\n  prevChildren: any,\r\n  parentComponent: any,\r\n  parentSuspense: any,\r\n  unmountChildren: any,\r\n) {\r\n  if (key === 'innerHTML' || key === 'textContent') {\r\n    if (prevChildren) {\r\n      unmountChildren(prevChildren, parentComponent, parentSuspense)\r\n    }\r\n    el[key] = value == null ? '' : value\r\n    return\r\n  }\r\n\r\n  const tag = el.tagName\r\n\r\n  if (\r\n    key === 'value' &&\r\n    tag !== 'PROGRESS' &&\r\n    // custom elements may use _value internally\r\n    !tag.includes('-')\r\n  ) {\r\n    // store value as _value as well since\r\n    // non-string values will be stringified.\r\n    el._value = value\r\n    // #4956: <option> value will fallback to its text content so we need to\r\n    // compare against its attribute value instead.\r\n    const oldValue = tag === 'OPTION' ? el.getAttribute('value') : el.value\r\n    const newValue = value == null ? '' : value\r\n    if (oldValue !== newValue) {\r\n      el.value = newValue\r\n    }\r\n    if (value == null) {\r\n      el.removeAttribute(key)\r\n    }\r\n    return\r\n  }\r\n\r\n  let needRemove = false\r\n  if (value === '' || value == null) {\r\n    const type = typeof el[key]\r\n    if (type === 'boolean') {\r\n      // e.g. <select multiple> compiles to { multiple: '' }\r\n      value = includeBooleanAttr(value)\r\n    } else if (value == null && type === 'string') {\r\n      // e.g. <div :id=\"null\">\r\n      value = ''\r\n      needRemove = true\r\n    } else if (type === 'number') {\r\n      // e.g. <img :width=\"null\">\r\n      value = 0\r\n      needRemove = true\r\n    }\r\n  } else {\r\n    if (\r\n      __COMPAT__ &&\r\n      value === false &&\r\n      compatUtils.isCompatEnabled(\r\n        DeprecationTypes.ATTR_FALSE_VALUE,\r\n        parentComponent,\r\n      )\r\n    ) {\r\n      const type = typeof el[key]\r\n      if (type === 'string' || type === 'number') {\r\n        __DEV__ &&\r\n          compatUtils.warnDeprecation(\r\n            DeprecationTypes.ATTR_FALSE_VALUE,\r\n            parentComponent,\r\n            key,\r\n          )\r\n        value = type === 'number' ? 0 : ''\r\n        needRemove = true\r\n      }\r\n    }\r\n  }\r\n\r\n  // some properties perform value validation and throw,\r\n  // some properties has getter, no setter, will error in 'use strict'\r\n  // eg. <select :type=\"null\"></select> <select :willValidate=\"null\"></select>\r\n  try {\r\n    el[key] = value\r\n  } catch (e: any) {\r\n    // do not warn if value is auto-coerced from nullish values\r\n    if (__DEV__ && !needRemove) {\r\n      warn(\r\n        `Failed setting prop \"${key}\" on <${tag.toLowerCase()}>: ` +\r\n          `value ${value} is invalid.`,\r\n        e,\r\n      )\r\n    }\r\n  }\r\n  needRemove && el.removeAttribute(key)\r\n}\r\n","import {\r\n  escapeHtml,\r\n  isRenderableAttrValue,\r\n  isSVGTag,\r\n  stringifyStyle,\r\n} from '@vue/shared'\r\nimport {\r\n  includeBooleanAttr,\r\n  isBooleanAttr,\r\n  isOn,\r\n  isSSRSafeAttrName,\r\n  isString,\r\n  makeMap,\r\n  normalizeClass,\r\n  normalizeStyle,\r\n  propsToAttrMap,\r\n} from '@vue/shared'\r\n\r\n// leading comma for empty string \"\"\r\nconst shouldIgnoreProp = makeMap(\r\n  `,key,ref,innerHTML,textContent,ref_key,ref_for`,\r\n)\r\n\r\nexport function ssrRenderAttrs(\r\n  props: Record<string, unknown>,\r\n  tag?: string,\r\n): string {\r\n  let ret = ''\r\n  for (const key in props) {\r\n    if (\r\n      shouldIgnoreProp(key) ||\r\n      isOn(key) ||\r\n      (tag === 'textarea' && key === 'value')\r\n    ) {\r\n      continue\r\n    }\r\n    const value = props[key]\r\n    if (key === 'class') {\r\n      ret += ` class=\"${ssrRenderClass(value)}\"`\r\n    } else if (key === 'style') {\r\n      ret += ` style=\"${ssrRenderStyle(value)}\"`\r\n    } else {\r\n      ret += ssrRenderDynamicAttr(key, value, tag)\r\n    }\r\n  }\r\n  return ret\r\n}\r\n\r\n// render an attr with dynamic (unknown) key.\r\nexport function ssrRenderDynamicAttr(\r\n  key: string,\r\n  value: unknown,\r\n  tag?: string,\r\n): string {\r\n  if (!isRenderableAttrValue(value)) {\r\n    return ``\r\n  }\r\n  const attrKey =\r\n    tag && (tag.indexOf('-') > 0 || isSVGTag(tag))\r\n      ? key // preserve raw name on custom elements and svg\r\n      : propsToAttrMap[key] || key.toLowerCase()\r\n  if (isBooleanAttr(attrKey)) {\r\n    return includeBooleanAttr(value) ? ` ${attrKey}` : ``\r\n  } else if (isSSRSafeAttrName(attrKey)) {\r\n    return value === '' ? ` ${attrKey}` : ` ${attrKey}=\"${escapeHtml(value)}\"`\r\n  } else {\r\n    console.warn(\r\n      `[@vue/server-renderer] Skipped rendering unsafe attribute name: ${attrKey}`,\r\n    )\r\n    return ``\r\n  }\r\n}\r\n\r\n// Render a v-bind attr with static key. The key is pre-processed at compile\r\n// time and we only need to check and escape value.\r\nexport function ssrRenderAttr(key: string, value: unknown): string {\r\n  if (!isRenderableAttrValue(value)) {\r\n    return ``\r\n  }\r\n  return ` ${key}=\"${escapeHtml(value)}\"`\r\n}\r\n\r\nexport function ssrRenderClass(raw: unknown): string {\r\n  return escapeHtml(normalizeClass(raw))\r\n}\r\n\r\nexport function ssrRenderStyle(raw: unknown): string {\r\n  if (!raw) {\r\n    return ''\r\n  }\r\n  if (isString(raw)) {\r\n    return escapeHtml(raw)\r\n  }\r\n  const styles = normalizeStyle(raw)\r\n  return escapeHtml(stringifyStyle(styles))\r\n}\r\n","import {\r\n  type Component,\r\n  type ComponentInternalInstance,\r\n  type Slots,\r\n  createVNode,\r\n} from 'vue'\r\nimport { type Props, type SSRBuffer, renderComponentVNode } from '../render'\r\nimport type { SSRSlots } from './ssrRenderSlot'\r\n\r\nexport function ssrRenderComponent(\r\n  comp: Component,\r\n  props: Props | null = null,\r\n  children: Slots | SSRSlots | null = null,\r\n  parentComponent: ComponentInternalInstance | null = null,\r\n  slotScopeId?: string,\r\n): SSRBuffer | Promise<SSRBuffer> {\r\n  return renderComponentVNode(\r\n    createVNode(comp, props, children),\r\n    parentComponent,\r\n    slotScopeId,\r\n  )\r\n}\r\n","import type { ComponentInternalInstance, Slots } from 'vue'\r\nimport {\r\n  type Props,\r\n  type PushFn,\r\n  type SSRBufferItem,\r\n  renderVNodeChildren,\r\n} from '../render'\r\nimport { isArray } from '@vue/shared'\r\n\r\nexport type SSRSlots = Record<string, SSRSlot>\r\nexport type SSRSlot = (\r\n  props: Props,\r\n  push: PushFn,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  scopeId: string | null,\r\n) => void\r\n\r\nexport function ssrRenderSlot(\r\n  slots: Slots | SSRSlots,\r\n  slotName: string,\r\n  slotProps: Props,\r\n  fallbackRenderFn: (() => void) | null,\r\n  push: PushFn,\r\n  parentComponent: ComponentInternalInstance,\r\n  slotScopeId?: string,\r\n) {\r\n  // template-compiled slots are always rendered as fragments\r\n  push(`<!--[-->`)\r\n  ssrRenderSlotInner(\r\n    slots,\r\n    slotName,\r\n    slotProps,\r\n    fallbackRenderFn,\r\n    push,\r\n    parentComponent,\r\n    slotScopeId,\r\n  )\r\n  push(`<!--]-->`)\r\n}\r\n\r\nexport function ssrRenderSlotInner(\r\n  slots: Slots | SSRSlots,\r\n  slotName: string,\r\n  slotProps: Props,\r\n  fallbackRenderFn: (() => void) | null,\r\n  push: PushFn,\r\n  parentComponent: ComponentInternalInstance,\r\n  slotScopeId?: string,\r\n  transition?: boolean,\r\n) {\r\n  const slotFn = slots[slotName]\r\n  if (slotFn) {\r\n    const slotBuffer: SSRBufferItem[] = []\r\n    const bufferedPush = (item: SSRBufferItem) => {\r\n      slotBuffer.push(item)\r\n    }\r\n    const ret = slotFn(\r\n      slotProps,\r\n      bufferedPush,\r\n      parentComponent,\r\n      slotScopeId ? ' ' + slotScopeId : '',\r\n    )\r\n    if (isArray(ret)) {\r\n      // normal slot\r\n      renderVNodeChildren(push, ret, parentComponent, slotScopeId)\r\n    } else {\r\n      // ssr slot.\r\n      // check if the slot renders all comments, in which case use the fallback\r\n      let isEmptySlot = true\r\n      if (transition) {\r\n        isEmptySlot = false\r\n      } else {\r\n        for (let i = 0; i < slotBuffer.length; i++) {\r\n          if (!isComment(slotBuffer[i])) {\r\n            isEmptySlot = false\r\n            break\r\n          }\r\n        }\r\n      }\r\n      if (isEmptySlot) {\r\n        if (fallbackRenderFn) {\r\n          fallbackRenderFn()\r\n        }\r\n      } else {\r\n        // #9933\r\n        // Although we handle Transition/TransitionGroup in the transform stage\r\n        // without rendering it as a fragment, the content passed into the slot\r\n        // may still be a fragment.\r\n        // Therefore, here we need to avoid rendering it as a fragment again.\r\n        let start = 0\r\n        let end = slotBuffer.length\r\n        if (\r\n          transition &&\r\n          slotBuffer[0] === '<!--[-->' &&\r\n          slotBuffer[end - 1] === '<!--]-->'\r\n        ) {\r\n          start++\r\n          end--\r\n        }\r\n\r\n        for (let i = start; i < end; i++) {\r\n          push(slotBuffer[i])\r\n        }\r\n      }\r\n    }\r\n  } else if (fallbackRenderFn) {\r\n    fallbackRenderFn()\r\n  }\r\n}\r\n\r\nconst commentTestRE = /^<!--.*-->$/s\r\nconst commentRE = /<!--[^]*?-->/gm\r\nfunction isComment(item: SSRBufferItem) {\r\n  if (typeof item !== 'string' || !commentTestRE.test(item)) return false\r\n  // if item is '<!---->' or '<!--[-->' or '<!--]-->', return true directly\r\n  if (item.length <= 8) return true\r\n  return !item.replace(commentRE, '').trim()\r\n}\r\n","import { type ComponentInternalInstance, ssrContextKey } from 'vue'\r\nimport {\r\n  type PushFn,\r\n  type SSRBufferItem,\r\n  type SSRContext,\r\n  createBuffer,\r\n} from '../render'\r\n\r\nexport function ssrRenderTeleport(\r\n  parentPush: PushFn,\r\n  contentRenderFn: (push: PushFn) => void,\r\n  target: string,\r\n  disabled: boolean,\r\n  parentComponent: ComponentInternalInstance,\r\n) {\r\n  parentPush('<!--teleport start-->')\r\n\r\n  const context = parentComponent.appContext.provides[\r\n    ssrContextKey as any\r\n  ] as SSRContext\r\n  const teleportBuffers =\r\n    context.__teleportBuffers || (context.__teleportBuffers = {})\r\n  const targetBuffer = teleportBuffers[target] || (teleportBuffers[target] = [])\r\n  // record current index of the target buffer to handle nested teleports\r\n  // since the parent needs to be rendered before the child\r\n  const bufferIndex = targetBuffer.length\r\n\r\n  let teleportContent: SSRBufferItem\r\n\r\n  if (disabled) {\r\n    contentRenderFn(parentPush)\r\n    teleportContent = `<!--teleport anchor-->`\r\n  } else {\r\n    const { getBuffer, push } = createBuffer()\r\n    contentRenderFn(push)\r\n    push(`<!--teleport anchor-->`)\r\n    teleportContent = getBuffer()\r\n  }\r\n\r\n  targetBuffer.splice(bufferIndex, 0, teleportContent)\r\n  parentPush('<!--teleport end-->')\r\n}\r\n","import { escapeHtml, toDisplayString } from '@vue/shared'\r\n\r\nexport function ssrInterpolate(value: unknown): string {\r\n  return escapeHtml(toDisplayString(value))\r\n}\r\n","import { isArray, isObject, isString } from '@vue/shared'\r\nimport { warn } from '@vue/runtime-core'\r\n\r\nexport function ssrRenderList(\r\n  source: unknown,\r\n  renderItem: (value: unknown, key: string | number, index?: number) => void,\r\n) {\r\n  if (isArray(source) || isString(source)) {\r\n    for (let i = 0, l = source.length; i < l; i++) {\r\n      renderItem(source[i], i)\r\n    }\r\n  } else if (typeof source === 'number') {\r\n    if (__DEV__ && !Number.isInteger(source)) {\r\n      warn(`The v-for range expect an integer value but got ${source}.`)\r\n      return\r\n    }\r\n    for (let i = 0; i < source; i++) {\r\n      renderItem(i + 1, i)\r\n    }\r\n  } else if (isObject(source)) {\r\n    if (source[Symbol.iterator as any]) {\r\n      const arr = Array.from(source as Iterable<any>)\r\n      for (let i = 0, l = arr.length; i < l; i++) {\r\n        renderItem(arr[i], i)\r\n      }\r\n    } else {\r\n      const keys = Object.keys(source)\r\n      for (let i = 0, l = keys.length; i < l; i++) {\r\n        const key = keys[i]\r\n        renderItem(source[key], key, i)\r\n      }\r\n    }\r\n  }\r\n}\r\n","import type { PushFn } from '../render'\r\n\r\nexport async function ssrRenderSuspense(\r\n  push: PushFn,\r\n  { default: renderContent }: Record<string, (() => void) | undefined>,\r\n) {\r\n  if (renderContent) {\r\n    renderContent()\r\n  } else {\r\n    push(`<!---->`)\r\n  }\r\n}\r\n","import type { ComponentPublicInstance, Directive } from '@vue/runtime-core'\r\n\r\nexport function ssrGetDirectiveProps(\r\n  instance: ComponentPublicInstance,\r\n  dir: Directive,\r\n  value?: any,\r\n  arg?: string,\r\n  modifiers: Record<string, boolean> = {},\r\n): Record<string, any> {\r\n  if (typeof dir !== 'function' && dir.getSSRProps) {\r\n    return (\r\n      dir.getSSRProps(\r\n        {\r\n          dir,\r\n          instance,\r\n          value,\r\n          oldValue: undefined,\r\n          arg,\r\n          modifiers,\r\n        },\r\n        null as any,\r\n      ) || {}\r\n    )\r\n  }\r\n  return {}\r\n}\r\n","import { isArray, looseEqual, looseIndexOf } from '@vue/shared'\r\nimport { ssrRenderAttr } from './ssrRenderAttrs'\r\n\r\nexport const ssrLooseEqual = looseEqual as (a: unknown, b: unknown) => boolean\r\n\r\nexport function ssrLooseContain(arr: unknown[], value: unknown): boolean {\r\n  return looseIndexOf(arr, value) > -1\r\n}\r\n\r\n// for <input :type=\"type\" v-model=\"model\" value=\"value\">\r\nexport function ssrRenderDynamicModel(\r\n  type: unknown,\r\n  model: unknown,\r\n  value: unknown,\r\n) {\r\n  switch (type) {\r\n    case 'radio':\r\n      return looseEqual(model, value) ? ' checked' : ''\r\n    case 'checkbox':\r\n      return (isArray(model) ? ssrLooseContain(model, value) : model)\r\n        ? ' checked'\r\n        : ''\r\n    default:\r\n      // text types\r\n      return ssrRenderAttr('value', model)\r\n  }\r\n}\r\n\r\n// for <input v-bind=\"obj\" v-model=\"model\">\r\nexport function ssrGetDynamicModelProps(\r\n  existingProps: any = {},\r\n  model: unknown,\r\n) {\r\n  const { type, value } = existingProps\r\n  switch (type) {\r\n    case 'radio':\r\n      return looseEqual(model, value) ? { checked: true } : null\r\n    case 'checkbox':\r\n      return (isArray(model) ? ssrLooseContain(model, value) : model)\r\n        ? { checked: true }\r\n        : null\r\n    default:\r\n      // text types\r\n      return { value: model }\r\n  }\r\n}\r\n","import {\r\n  Comment,\r\n  type Component,\r\n  type ComponentInternalInstance,\r\n  type DirectiveBinding,\r\n  Fragment,\r\n  type FunctionalComponent,\r\n  Static,\r\n  Text,\r\n  type VNode,\r\n  type VNodeArrayChildren,\r\n  type VNodeProps,\r\n  mergeProps,\r\n  ssrUtils,\r\n  warn,\r\n} from 'vue'\r\nimport {\r\n  NOOP,\r\n  ShapeFlags,\r\n  escapeHtml,\r\n  escapeHtmlComment,\r\n  isArray,\r\n  isFunction,\r\n  isPromise,\r\n  isString,\r\n  isVoidTag,\r\n} from '@vue/shared'\r\nimport { ssrRenderAttrs } from './helpers/ssrRenderAttrs'\r\nimport { ssrCompile } from './helpers/ssrCompile'\r\nimport { ssrRenderTeleport } from './helpers/ssrRenderTeleport'\r\n\r\nconst {\r\n  createComponentInstance,\r\n  setCurrentRenderingInstance,\r\n  setupComponent,\r\n  renderComponentRoot,\r\n  normalizeVNode,\r\n} = ssrUtils\r\n\r\nexport type SSRBuffer = SSRBufferItem[] & { hasAsync?: boolean }\r\nexport type SSRBufferItem = string | SSRBuffer | Promise<SSRBuffer>\r\nexport type PushFn = (item: SSRBufferItem) => void\r\nexport type Props = Record<string, unknown>\r\n\r\nexport type SSRContext = {\r\n  [key: string]: any\r\n  teleports?: Record<string, string>\r\n  /**\r\n   * @internal\r\n   */\r\n  __teleportBuffers?: Record<string, SSRBuffer>\r\n  /**\r\n   * @internal\r\n   */\r\n  __watcherHandles?: (() => void)[]\r\n}\r\n\r\n// Each component has a buffer array.\r\n// A buffer array can contain one of the following:\r\n// - plain string\r\n// - A resolved buffer (recursive arrays of strings that can be unrolled\r\n//   synchronously)\r\n// - An async buffer (a Promise that resolves to a resolved buffer)\r\nexport function createBuffer() {\r\n  let appendable = false\r\n  const buffer: SSRBuffer = []\r\n  return {\r\n    getBuffer(): SSRBuffer {\r\n      // Return static buffer and await on items during unroll stage\r\n      return buffer\r\n    },\r\n    push(item: SSRBufferItem) {\r\n      const isStringItem = isString(item)\r\n      if (appendable && isStringItem) {\r\n        buffer[buffer.length - 1] += item as string\r\n      } else {\r\n        buffer.push(item)\r\n      }\r\n      appendable = isStringItem\r\n      if (isPromise(item) || (isArray(item) && item.hasAsync)) {\r\n        // promise, or child buffer with async, mark as async.\r\n        // this allows skipping unnecessary await ticks during unroll stage\r\n        buffer.hasAsync = true\r\n      }\r\n    },\r\n  }\r\n}\r\n\r\nexport function renderComponentVNode(\r\n  vnode: VNode,\r\n  parentComponent: ComponentInternalInstance | null = null,\r\n  slotScopeId?: string,\r\n): SSRBuffer | Promise<SSRBuffer> {\r\n  const instance = createComponentInstance(vnode, parentComponent, null)\r\n  const res = setupComponent(instance, true /* isSSR */)\r\n  const hasAsyncSetup = isPromise(res)\r\n  const prefetches = instance.sp /* LifecycleHooks.SERVER_PREFETCH */\r\n  if (hasAsyncSetup || prefetches) {\r\n    let p: Promise<unknown> = hasAsyncSetup\r\n      ? (res as Promise<void>)\r\n      : Promise.resolve()\r\n    if (prefetches) {\r\n      p = p\r\n        .then(() =>\r\n          Promise.all(\r\n            prefetches.map(prefetch => prefetch.call(instance.proxy)),\r\n          ),\r\n        )\r\n        // Note: error display is already done by the wrapped lifecycle hook function.\r\n        .catch(NOOP)\r\n    }\r\n    return p.then(() => renderComponentSubTree(instance, slotScopeId))\r\n  } else {\r\n    return renderComponentSubTree(instance, slotScopeId)\r\n  }\r\n}\r\n\r\nfunction renderComponentSubTree(\r\n  instance: ComponentInternalInstance,\r\n  slotScopeId?: string,\r\n): SSRBuffer | Promise<SSRBuffer> {\r\n  const comp = instance.type as Component\r\n  const { getBuffer, push } = createBuffer()\r\n  if (isFunction(comp)) {\r\n    let root = renderComponentRoot(instance)\r\n    // #5817 scope ID attrs not falling through if functional component doesn't\r\n    // have props\r\n    if (!(comp as FunctionalComponent).props) {\r\n      for (const key in instance.attrs) {\r\n        if (key.startsWith(`data-v-`)) {\r\n          ;(root.props || (root.props = {}))[key] = ``\r\n        }\r\n      }\r\n    }\r\n    renderVNode(push, (instance.subTree = root), instance, slotScopeId)\r\n  } else {\r\n    if (\r\n      (!instance.render || instance.render === NOOP) &&\r\n      !instance.ssrRender &&\r\n      !comp.ssrRender &&\r\n      isString(comp.template)\r\n    ) {\r\n      comp.ssrRender = ssrCompile(comp.template, instance)\r\n    }\r\n\r\n    // perf: enable caching of computed getters during render\r\n    // since there cannot be state mutations during render.\r\n    for (const e of instance.scope.effects) {\r\n      if (e.computed) {\r\n        e.computed._dirty = true\r\n        e.computed._cacheable = true\r\n      }\r\n    }\r\n\r\n    const ssrRender = instance.ssrRender || comp.ssrRender\r\n    if (ssrRender) {\r\n      // optimized\r\n      // resolve fallthrough attrs\r\n      let attrs = instance.inheritAttrs !== false ? instance.attrs : undefined\r\n      let hasCloned = false\r\n\r\n      let cur = instance\r\n      while (true) {\r\n        const scopeId = cur.vnode.scopeId\r\n        if (scopeId) {\r\n          if (!hasCloned) {\r\n            attrs = { ...attrs }\r\n            hasCloned = true\r\n          }\r\n          attrs![scopeId] = ''\r\n        }\r\n        const parent = cur.parent\r\n        if (parent && parent.subTree && parent.subTree === cur.vnode) {\r\n          // parent is a non-SSR compiled component and is rendering this\r\n          // component as root. inherit its scopeId if present.\r\n          cur = parent\r\n        } else {\r\n          break\r\n        }\r\n      }\r\n\r\n      if (slotScopeId) {\r\n        if (!hasCloned) attrs = { ...attrs }\r\n        attrs![slotScopeId.trim()] = ''\r\n      }\r\n\r\n      // set current rendering instance for asset resolution\r\n      const prev = setCurrentRenderingInstance(instance)\r\n      try {\r\n        ssrRender(\r\n          instance.proxy,\r\n          push,\r\n          instance,\r\n          attrs,\r\n          // compiler-optimized bindings\r\n          instance.props,\r\n          instance.setupState,\r\n          instance.data,\r\n          instance.ctx,\r\n        )\r\n      } finally {\r\n        setCurrentRenderingInstance(prev)\r\n      }\r\n    } else if (instance.render && instance.render !== NOOP) {\r\n      renderVNode(\r\n        push,\r\n        (instance.subTree = renderComponentRoot(instance)),\r\n        instance,\r\n        slotScopeId,\r\n      )\r\n    } else {\r\n      const componentName = comp.name || comp.__file || `<Anonymous>`\r\n      warn(`Component ${componentName} is missing template or render function.`)\r\n      push(`<!---->`)\r\n    }\r\n  }\r\n  return getBuffer()\r\n}\r\n\r\nexport function renderVNode(\r\n  push: PushFn,\r\n  vnode: VNode,\r\n  parentComponent: ComponentInternalInstance,\r\n  slotScopeId?: string,\r\n) {\r\n  const { type, shapeFlag, children } = vnode\r\n  switch (type) {\r\n    case Text:\r\n      push(escapeHtml(children as string))\r\n      break\r\n    case Comment:\r\n      push(\r\n        children\r\n          ? `<!--${escapeHtmlComment(children as string)}-->`\r\n          : `<!---->`,\r\n      )\r\n      break\r\n    case Static:\r\n      push(children as string)\r\n      break\r\n    case Fragment:\r\n      if (vnode.slotScopeIds) {\r\n        slotScopeId =\r\n          (slotScopeId ? slotScopeId + ' ' : '') + vnode.slotScopeIds.join(' ')\r\n      }\r\n      push(`<!--[-->`) // open\r\n      renderVNodeChildren(\r\n        push,\r\n        children as VNodeArrayChildren,\r\n        parentComponent,\r\n        slotScopeId,\r\n      )\r\n      push(`<!--]-->`) // close\r\n      break\r\n    default:\r\n      if (shapeFlag & ShapeFlags.ELEMENT) {\r\n        renderElementVNode(push, vnode, parentComponent, slotScopeId)\r\n      } else if (shapeFlag & ShapeFlags.COMPONENT) {\r\n        push(renderComponentVNode(vnode, parentComponent, slotScopeId))\r\n      } else if (shapeFlag & ShapeFlags.TELEPORT) {\r\n        renderTeleportVNode(push, vnode, parentComponent, slotScopeId)\r\n      } else if (shapeFlag & ShapeFlags.SUSPENSE) {\r\n        renderVNode(push, vnode.ssContent!, parentComponent, slotScopeId)\r\n      } else {\r\n        warn(\r\n          '[@vue/server-renderer] Invalid VNode type:',\r\n          type,\r\n          `(${typeof type})`,\r\n        )\r\n      }\r\n  }\r\n}\r\n\r\nexport function renderVNodeChildren(\r\n  push: PushFn,\r\n  children: VNodeArrayChildren,\r\n  parentComponent: ComponentInternalInstance,\r\n  slotScopeId: string | undefined,\r\n) {\r\n  for (let i = 0; i < children.length; i++) {\r\n    renderVNode(push, normalizeVNode(children[i]), parentComponent, slotScopeId)\r\n  }\r\n}\r\n\r\nfunction renderElementVNode(\r\n  push: PushFn,\r\n  vnode: VNode,\r\n  parentComponent: ComponentInternalInstance,\r\n  slotScopeId: string | undefined,\r\n) {\r\n  const tag = vnode.type as string\r\n  let { props, children, shapeFlag, scopeId, dirs } = vnode\r\n  let openTag = `<${tag}`\r\n\r\n  if (dirs) {\r\n    props = applySSRDirectives(vnode, props, dirs)\r\n  }\r\n\r\n  if (props) {\r\n    openTag += ssrRenderAttrs(props, tag)\r\n  }\r\n\r\n  if (scopeId) {\r\n    openTag += ` ${scopeId}`\r\n  }\r\n  // inherit parent chain scope id if this is the root node\r\n  let curParent: ComponentInternalInstance | null = parentComponent\r\n  let curVnode = vnode\r\n  while (curParent && curVnode === curParent.subTree) {\r\n    curVnode = curParent.vnode\r\n    if (curVnode.scopeId) {\r\n      openTag += ` ${curVnode.scopeId}`\r\n    }\r\n    curParent = curParent.parent\r\n  }\r\n  if (slotScopeId) {\r\n    openTag += ` ${slotScopeId}`\r\n  }\r\n\r\n  push(openTag + `>`)\r\n  if (!isVoidTag(tag)) {\r\n    let hasChildrenOverride = false\r\n    if (props) {\r\n      if (props.innerHTML) {\r\n        hasChildrenOverride = true\r\n        push(props.innerHTML)\r\n      } else if (props.textContent) {\r\n        hasChildrenOverride = true\r\n        push(escapeHtml(props.textContent))\r\n      } else if (tag === 'textarea' && props.value) {\r\n        hasChildrenOverride = true\r\n        push(escapeHtml(props.value))\r\n      }\r\n    }\r\n    if (!hasChildrenOverride) {\r\n      if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n        push(escapeHtml(children as string))\r\n      } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n        renderVNodeChildren(\r\n          push,\r\n          children as VNodeArrayChildren,\r\n          parentComponent,\r\n          slotScopeId,\r\n        )\r\n      }\r\n    }\r\n    push(`</${tag}>`)\r\n  }\r\n}\r\n\r\nfunction applySSRDirectives(\r\n  vnode: VNode,\r\n  rawProps: VNodeProps | null,\r\n  dirs: DirectiveBinding[],\r\n): VNodeProps {\r\n  const toMerge: VNodeProps[] = []\r\n  for (let i = 0; i < dirs.length; i++) {\r\n    const binding = dirs[i]\r\n    const {\r\n      dir: { getSSRProps },\r\n    } = binding\r\n    if (getSSRProps) {\r\n      const props = getSSRProps(binding, vnode)\r\n      if (props) toMerge.push(props)\r\n    }\r\n  }\r\n  return mergeProps(rawProps || {}, ...toMerge)\r\n}\r\n\r\nfunction renderTeleportVNode(\r\n  push: PushFn,\r\n  vnode: VNode,\r\n  parentComponent: ComponentInternalInstance,\r\n  slotScopeId: string | undefined,\r\n) {\r\n  const target = vnode.props && vnode.props.to\r\n  const disabled = vnode.props && vnode.props.disabled\r\n  if (!target) {\r\n    if (!disabled) {\r\n      warn(`[@vue/server-renderer] Teleport is missing target prop.`)\r\n    }\r\n    return []\r\n  }\r\n  if (!isString(target)) {\r\n    warn(\r\n      `[@vue/server-renderer] Teleport target must be a query selector string.`,\r\n    )\r\n    return []\r\n  }\r\n  ssrRenderTeleport(\r\n    push,\r\n    push => {\r\n      renderVNodeChildren(\r\n        push,\r\n        vnode.children as VNodeArrayChildren,\r\n        parentComponent,\r\n        slotScopeId,\r\n      )\r\n    },\r\n    target,\r\n    disabled || disabled === '',\r\n    parentComponent,\r\n  )\r\n}\r\n","import {\r\n  type ComponentInternalInstance,\r\n  type ComponentOptions,\r\n  warn,\r\n} from 'vue'\r\nimport { compile } from '@vue/compiler-ssr'\r\nimport { NO, extend, generateCodeFrame, isFunction } from '@vue/shared'\r\nimport type { CompilerError, CompilerOptions } from '@vue/compiler-core'\r\nimport type { PushFn } from '../render'\r\n\r\nimport * as Vue from 'vue'\r\nimport * as helpers from '../internal'\r\n\r\ntype SSRRenderFunction = (\r\n  context: any,\r\n  push: PushFn,\r\n  parentInstance: ComponentInternalInstance,\r\n) => void\r\n\r\nconst compileCache: Record<string, SSRRenderFunction> = Object.create(null)\r\n\r\nexport function ssrCompile(\r\n  template: string,\r\n  instance: ComponentInternalInstance,\r\n): SSRRenderFunction {\r\n  // TODO: this branch should now work in ESM builds, enable it in a minor\r\n  if (!__CJS__) {\r\n    throw new Error(\r\n      `On-the-fly template compilation is not supported in the ESM build of ` +\r\n        `@vue/server-renderer. All templates must be pre-compiled into ` +\r\n        `render functions.`,\r\n    )\r\n  }\r\n\r\n  // TODO: This is copied from runtime-core/src/component.ts and should probably be refactored\r\n  const Component = instance.type as ComponentOptions\r\n  const { isCustomElement, compilerOptions } = instance.appContext.config\r\n  const { delimiters, compilerOptions: componentCompilerOptions } = Component\r\n\r\n  const finalCompilerOptions: CompilerOptions = extend(\r\n    extend(\r\n      {\r\n        isCustomElement,\r\n        delimiters,\r\n      },\r\n      compilerOptions,\r\n    ),\r\n    componentCompilerOptions,\r\n  )\r\n\r\n  finalCompilerOptions.isCustomElement =\r\n    finalCompilerOptions.isCustomElement || NO\r\n  finalCompilerOptions.isNativeTag = finalCompilerOptions.isNativeTag || NO\r\n\r\n  const cacheKey = JSON.stringify(\r\n    {\r\n      template,\r\n      compilerOptions: finalCompilerOptions,\r\n    },\r\n    (key, value) => {\r\n      return isFunction(value) ? value.toString() : value\r\n    },\r\n  )\r\n\r\n  const cached = compileCache[cacheKey]\r\n  if (cached) {\r\n    return cached\r\n  }\r\n\r\n  finalCompilerOptions.onError = (err: CompilerError) => {\r\n    if (__DEV__) {\r\n      const message = `[@vue/server-renderer] Template compilation error: ${err.message}`\r\n      const codeFrame =\r\n        err.loc &&\r\n        generateCodeFrame(\r\n          template as string,\r\n          err.loc.start.offset,\r\n          err.loc.end.offset,\r\n        )\r\n      warn(codeFrame ? `${message}\\n${codeFrame}` : message)\r\n    } else {\r\n      throw err\r\n    }\r\n  }\r\n\r\n  const { code } = compile(template, finalCompilerOptions)\r\n  const requireMap = {\r\n    vue: Vue,\r\n    'vue/server-renderer': helpers,\r\n  }\r\n  const fakeRequire = (id: 'vue' | 'vue/server-renderer') => requireMap[id]\r\n  return (compileCache[cacheKey] = Function('require', code)(fakeRequire))\r\n}\r\n","import {\r\n  type App,\r\n  type VNode,\r\n  createApp,\r\n  createVNode,\r\n  ssrContextKey,\r\n  ssrUtils,\r\n} from 'vue'\r\nimport { isPromise, isString } from '@vue/shared'\r\nimport { type SSRBuffer, type SSRContext, renderComponentVNode } from './render'\r\n\r\nconst { isVNode } = ssrUtils\r\n\r\nasync function unrollBuffer(buffer: SSRBuffer): Promise<string> {\r\n  if (buffer.hasAsync) {\r\n    let ret = ''\r\n    for (let i = 0; i < buffer.length; i++) {\r\n      let item = buffer[i]\r\n      if (isPromise(item)) {\r\n        item = await item\r\n      }\r\n      if (isString(item)) {\r\n        ret += item\r\n      } else {\r\n        ret += await unrollBuffer(item)\r\n      }\r\n    }\r\n    return ret\r\n  } else {\r\n    // sync buffer can be more efficiently unrolled without unnecessary await\r\n    // ticks\r\n    return unrollBufferSync(buffer)\r\n  }\r\n}\r\n\r\nfunction unrollBufferSync(buffer: SSRBuffer): string {\r\n  let ret = ''\r\n  for (let i = 0; i < buffer.length; i++) {\r\n    let item = buffer[i]\r\n    if (isString(item)) {\r\n      ret += item\r\n    } else {\r\n      // since this is a sync buffer, child buffers are never promises\r\n      ret += unrollBufferSync(item as SSRBuffer)\r\n    }\r\n  }\r\n  return ret\r\n}\r\n\r\nexport async function renderToString(\r\n  input: App | VNode,\r\n  context: SSRContext = {},\r\n): Promise<string> {\r\n  if (isVNode(input)) {\r\n    // raw vnode, wrap with app (for context)\r\n    return renderToString(createApp({ render: () => input }), context)\r\n  }\r\n\r\n  // rendering an app\r\n  const vnode = createVNode(input._component, input._props)\r\n  vnode.appContext = input._context\r\n  // provide the ssr context to the tree\r\n  input.provide(ssrContextKey, context)\r\n  const buffer = await renderComponentVNode(vnode)\r\n\r\n  const result = await unrollBuffer(buffer as SSRBuffer)\r\n\r\n  await resolveTeleports(context)\r\n\r\n  if (context.__watcherHandles) {\r\n    for (const unwatch of context.__watcherHandles) {\r\n      unwatch()\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nexport async function resolveTeleports(context: SSRContext) {\r\n  if (context.__teleportBuffers) {\r\n    context.teleports = context.teleports || {}\r\n    for (const key in context.__teleportBuffers) {\r\n      // note: it's OK to await sequentially here because the Promises were\r\n      // created eagerly in parallel.\r\n      context.teleports[key] = await unrollBuffer(\r\n        await Promise.all([context.__teleportBuffers[key]]),\r\n      )\r\n    }\r\n  }\r\n}\r\n","import {\r\n  type App,\r\n  type VNode,\r\n  createApp,\r\n  createVNode,\r\n  ssrContextKey,\r\n  ssrUtils,\r\n} from 'vue'\r\nimport { isPromise, isString } from '@vue/shared'\r\nimport { type SSRBuffer, type SSRContext, renderComponentVNode } from './render'\r\nimport type { Readable, Writable } from 'node:stream'\r\nimport { resolveTeleports } from './renderToString'\r\n\r\nconst { isVNode } = ssrUtils\r\n\r\nexport interface SimpleReadable {\r\n  push(chunk: string | null): void\r\n  destroy(err: any): void\r\n}\r\n\r\nasync function unrollBuffer(\r\n  buffer: SSRBuffer,\r\n  stream: SimpleReadable,\r\n): Promise<void> {\r\n  if (buffer.hasAsync) {\r\n    for (let i = 0; i < buffer.length; i++) {\r\n      let item = buffer[i]\r\n      if (isPromise(item)) {\r\n        item = await item\r\n      }\r\n      if (isString(item)) {\r\n        stream.push(item)\r\n      } else {\r\n        await unrollBuffer(item, stream)\r\n      }\r\n    }\r\n  } else {\r\n    // sync buffer can be more efficiently unrolled without unnecessary await\r\n    // ticks\r\n    unrollBufferSync(buffer, stream)\r\n  }\r\n}\r\n\r\nfunction unrollBufferSync(buffer: SSRBuffer, stream: SimpleReadable) {\r\n  for (let i = 0; i < buffer.length; i++) {\r\n    let item = buffer[i]\r\n    if (isString(item)) {\r\n      stream.push(item)\r\n    } else {\r\n      // since this is a sync buffer, child buffers are never promises\r\n      unrollBufferSync(item as SSRBuffer, stream)\r\n    }\r\n  }\r\n}\r\n\r\nexport function renderToSimpleStream<T extends SimpleReadable>(\r\n  input: App | VNode,\r\n  context: SSRContext,\r\n  stream: T,\r\n): T {\r\n  if (isVNode(input)) {\r\n    // raw vnode, wrap with app (for context)\r\n    return renderToSimpleStream(\r\n      createApp({ render: () => input }),\r\n      context,\r\n      stream,\r\n    )\r\n  }\r\n\r\n  // rendering an app\r\n  const vnode = createVNode(input._component, input._props)\r\n  vnode.appContext = input._context\r\n  // provide the ssr context to the tree\r\n  input.provide(ssrContextKey, context)\r\n\r\n  Promise.resolve(renderComponentVNode(vnode))\r\n    .then(buffer => unrollBuffer(buffer, stream))\r\n    .then(() => resolveTeleports(context))\r\n    .then(() => {\r\n      if (context.__watcherHandles) {\r\n        for (const unwatch of context.__watcherHandles) {\r\n          unwatch()\r\n        }\r\n      }\r\n    })\r\n    .then(() => stream.push(null))\r\n    .catch(error => {\r\n      stream.destroy(error)\r\n    })\r\n\r\n  return stream\r\n}\r\n\r\n/**\r\n * @deprecated\r\n */\r\nexport function renderToStream(\r\n  input: App | VNode,\r\n  context: SSRContext = {},\r\n): Readable {\r\n  console.warn(\r\n    `[@vue/server-renderer] renderToStream is deprecated - use renderToNodeStream instead.`,\r\n  )\r\n  return renderToNodeStream(input, context)\r\n}\r\n\r\nexport function renderToNodeStream(\r\n  input: App | VNode,\r\n  context: SSRContext = {},\r\n): Readable {\r\n  const stream: Readable = __CJS__\r\n    ? new (require('node:stream').Readable)({ read() {} })\r\n    : null\r\n\r\n  if (!stream) {\r\n    throw new Error(\r\n      `ESM build of renderToStream() does not support renderToNodeStream(). ` +\r\n        `Use pipeToNodeWritable() with an existing Node.js Writable stream ` +\r\n        `instance instead.`,\r\n    )\r\n  }\r\n\r\n  return renderToSimpleStream(input, context, stream)\r\n}\r\n\r\nexport function pipeToNodeWritable(\r\n  input: App | VNode,\r\n  context: SSRContext = {},\r\n  writable: Writable,\r\n) {\r\n  renderToSimpleStream(input, context, {\r\n    push(content) {\r\n      if (content != null) {\r\n        writable.write(content)\r\n      } else {\r\n        writable.end()\r\n      }\r\n    },\r\n    destroy(err) {\r\n      writable.destroy(err)\r\n    },\r\n  })\r\n}\r\n\r\nexport function renderToWebStream(\r\n  input: App | VNode,\r\n  context: SSRContext = {},\r\n): ReadableStream {\r\n  if (typeof ReadableStream !== 'function') {\r\n    throw new Error(\r\n      `ReadableStream constructor is not available in the global scope. ` +\r\n        `If the target environment does support web streams, consider using ` +\r\n        `pipeToWebWritable() with an existing WritableStream instance instead.`,\r\n    )\r\n  }\r\n\r\n  const encoder = new TextEncoder()\r\n  let cancelled = false\r\n\r\n  return new ReadableStream({\r\n    start(controller) {\r\n      renderToSimpleStream(input, context, {\r\n        push(content) {\r\n          if (cancelled) return\r\n          if (content != null) {\r\n            controller.enqueue(encoder.encode(content))\r\n          } else {\r\n            controller.close()\r\n          }\r\n        },\r\n        destroy(err) {\r\n          controller.error(err)\r\n        },\r\n      })\r\n    },\r\n    cancel() {\r\n      cancelled = true\r\n    },\r\n  })\r\n}\r\n\r\nexport function pipeToWebWritable(\r\n  input: App | VNode,\r\n  context: SSRContext = {},\r\n  writable: WritableStream,\r\n): void {\r\n  const writer = writable.getWriter()\r\n  const encoder = new TextEncoder()\r\n\r\n  // #4287 CloudFlare workers do not implement `ready` property\r\n  let hasReady = false\r\n  try {\r\n    hasReady = isPromise(writer.ready)\r\n  } catch (e: any) {}\r\n\r\n  renderToSimpleStream(input, context, {\r\n    async push(content) {\r\n      if (hasReady) {\r\n        await writer.ready\r\n      }\r\n      if (content != null) {\r\n        return writer.write(encoder.encode(content))\r\n      } else {\r\n        return writer.close()\r\n      }\r\n    },\r\n    destroy(err) {\r\n      // TODO better error handling?\r\n      // eslint-disable-next-line no-console\r\n      console.log(err)\r\n      writer.close()\r\n    },\r\n  })\r\n}\r\n"],"names":["makeMap","str","expectsLowerCase","set","Set","split","val","has","toLowerCase","EMPTY_OBJ","EMPTY_ARR","NOOP","NO","isOn","key","charCodeAt","isModelListener","startsWith","extend","Object","assign","remove","arr","el","i","indexOf","splice","hasOwnProperty","prototype","hasOwn","call","isArray","Array","isMap","toTypeString","isSet","isDate","isFunction","isString","isSymbol","isObject","isPromise","then","catch","objectToString","toString","value","toRawType","slice","isPlainObject","isIntegerKey","parseInt","isReservedProp","cacheStringFunction","fn","cache","create","camelizeRE","camelize","replace","_","c","toUpperCase","hyphenateRE","hyphenate","capitalize","charAt","toHandlerKey","hasChanged","oldValue","is","invokeArrayFns","fns","arg","length","def","obj","defineProperty","configurable","enumerable","looseToNumber","n","parseFloat","isNaN","_globalThis","getGlobalThis","globalThis","self","window","global","normalizeStyle","res","item","normalized","parseStringStyle","listDelimiterRE","propertyDelimiterRE","styleCommentRE","cssText","ret","forEach","tmp","trim","normalizeClass","name","isSVGTag","isVoidTag","specialBooleanAttrs","isSpecialBooleanAttr","isBooleanAttr","includeBooleanAttr","unsafeAttrCharRE","attrValidationCache","propsToAttrMap","acceptCharset","className","htmlFor","httpEquiv","isRenderableAttrValue","type","escapeRE","escapeHtml","string","match","exec","escaped","index","html","lastIndex","commentStripRE","looseEqual","a","b","aValidType","bValidType","getTime","equal","looseCompareArrays","keys","aHasKey","bHasKey","String","replacer","_key","__v_isRef","size","entries","reduce","stringifySymbol","values","map","v","_a","description","activeEffectScope","EffectScope","constructor","detached","this","__publicField","parent","scopes","push","active","_active","run","currentEffectScope","on","off","stop","fromParent","l","effects","cleanups","last","pop","activeEffect","ReactiveEffect","trigger","scheduler","scope","effect","recordEffectScope","dirty","_dirtyLevel","pauseTracking","_depsLength","dep","deps","computed","triggerComputed","resetTracking","lastShouldTrack","shouldTrack","lastEffect","_runnings","preCleanupEffect","postCleanupEffect","onStop","_trackId","cleanupDepEffect","trackId","get","delete","cleanup","pauseScheduleStack","trackStack","pauseScheduling","resetScheduling","queueEffectSchedulers","shift","trackEffect","debuggerEventExtraInfo","oldDep","triggerEffects","dirtyLevel","lastDirtyLevel","_shouldSchedule","scheduleEffects","allowRecurse","createDep","Map","targetMap","WeakMap","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","track","target","depsMap","newValue","oldTarget","newLength","Number","isNonTrackableKeys","builtInSymbols","getOwnPropertyNames","filter","arrayInstrumentations","createArrayInstrumentations","instrumentations","args","toRaw","apply","BaseReactiveHandler","_isReadonly","_shallow","receiver","isReadonly","shallow","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","getPrototypeOf","targetIsArray","Reflect","isRef","readonly","reactive","MutableReactiveHandler","super","isOldValueReadonly","isShallow","hadKey","result","deleteProperty","ownKeys","ReadonlyReactiveHandler","mutableHandlers","readonlyHandlers","shallowReactiveHandlers","toShallow","getProto","rawTarget","rawKey","wrap","toReadonly","toReactive","add","deleteEntry","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","method","targetIsMap","isPair","iterator","isKeyOnly","innerIterator","next","done","createReadonlyMethod","createInstrumentations","mutableInstrumentations","shallowInstrumentations","readonlyInstrumentations","shallowReadonlyInstrumentations","createInstrumentationGetter","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","createReactiveObject","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","isExtensible","rawType","targetTypeMap","proxy","Proxy","isReactive","isProxy","raw","markRaw","ComputedRefImpl","getter","_setter","isSSR","_value","triggerRefValue","_cacheable","ref","_dirty","newVal","r","shallowUnwrapHandlers","unref","proxyRefs","objectWithRefs","callWithErrorHandling","instance","err","handleError","callWithAsyncErrorHandling","throwInDev","cur","exposedInstance","errorInfo","errorCapturedHooks","ec","appErrorHandler","appContext","config","errorHandler","contextVNode","console","error","logError","isFlushing","isFlushPending","queue","flushIndex","pendingPostFlushCbs","activePostFlushCbs","postFlushIndex","resolvedPromise","resolve","currentFlushPromise","nextTick","p","bind","queueJob","job","includes","id","start","end","middle","middleJob","middleJobId","getId","pre","findInsertionIndex","queueFlush","flushJobs","flushPreFlushCbs","seen","cb","uid","flushPostFlushCbs","deduped","sort","Infinity","comparator","diff","emit","event","rawArgs","isUnmounted","props","vnode","modelArg","modifiersKey","number","handlerName","handler","onceHandler","emitted","normalizeEmitsOptions","comp","asMixin","emitsCache","cached","emits","hasExtends","extendEmits","normalizedFromExtend","mixins","extends","isEmitListener","options","currentRenderingInstance","currentScopeId","setCurrentRenderingInstance","prev","__scopeId","renderComponentRoot","Component","withProxy","propsOptions","slots","attrs","render","renderCache","data","setupState","ctx","inheritAttrs","fallthroughAttrs","shapeFlag","proxyToUse","normalizeVNode","getFunctionalFallthrough","createVNode","Comment","root","some","filterModelListeners","cloneVNode","dirs","concat","transition","hasPropsChanged","prevProps","nextProps","emitsOptions","nextKeys","NULL_DYNAMIC_COMPONENT","for","ssrContextKey","useSSRContext","inject","INITIAL_WATCHER_VALUE","watch","source","doWatch","immediate","deep","flush","once","_cb","unwatch","currentInstance","reactiveGetter","traverse","forceTrigger","isMultiSource","s","onCleanup","baseGetter","ssrCleanup","isInSSRComponentSetup","__watcherHandles","fill","queuePostRenderEffect","suspense","instanceWatch","publicThis","createPathGetter","reset","setCurrentInstance","path","segments","depth","currentDepth","invokeDirectiveHook","prevVNode","bindings","oldBindings","binding","hook","dir","isAsyncWrapper","__asyncLoader","isKeepAlive","__isKeepAlive","onActivated","registerKeepAliveHook","onDeactivated","wrappedHook","__wdc","current","isDeactivated","injectHook","injectToKeepAliveRoot","keepAliveRoot","injected","onUnmounted","prepend","hooks","__weh","unshift","createHook","lifecycle","onBeforeMount","onMounted","onBeforeUpdate","onUpdated","onBeforeUnmount","onServerPrefetch","onRenderTriggered","onRenderTracked","onErrorCaptured","getPublicInstance","isStatefulComponent","getExposeProxy","publicPropertiesMap","$","$el","$data","$props","$attrs","$slots","$refs","refs","$parent","$root","$emit","$options","resolveMergedOptions","$forceUpdate","f","update","$nextTick","$watch","hasSetupBinding","state","__isScriptSetup","PublicInstanceProxyHandlers","accessCache","normalizedProps","shouldCacheAccess","publicGetter","cssModule","globalProperties","__cssModules","descriptor","normalizePropsOrEmits","applyOptions","beforeCreate","callHook","dataOptions","computedOptions","methods","watchOptions","provide","provideOptions","injectOptions","created","beforeMount","mounted","beforeUpdate","updated","activated","deactivated","beforeUnmount","unmounted","renderTracked","renderTriggered","errorCaptured","serverPrefetch","expose","components","directives","checkDuplicateProperties","normalizeInject","opt","from","default","resolveInjections","methodHandler","createWatcher","provides","parentProvides","registerLifecycleHook","register","_hook","exposed","h","base","extendsOptions","globalMixins","optionsCache","optionMergeStrategies","resolved","m","mergeOptions","to","strats","strat","internalOptionMergeStrats","mergeDataFn","mergeEmitsOrPropsOptions","mergeObjectOptions","mergeAsArray","beforeDestroy","destroyed","merged","createAppContext","app","isNativeTag","performance","warnHandler","compilerOptions","propsCache","createAppAPI","hydrate","rootComponent","rootProps","context","installedPlugins","WeakSet","isMounted","_uid","_component","_props","_container","_context","_instance","version","use","plugin","install","mixin","component","directive","mount","rootContainer","isHydrate","namespace","__vue_app__","unmount","runWithContext","currentApp","defaultValue","treatDefaultAsFactory","arguments","initProps","rawProps","isStateful","InternalObjectKey","propsDefaults","setFullProps","needCastKeys","rawCastValues","hasAttrsChanged","camelKey","rawCurrentProps","castValues","resolvePropValue","isAbsent","hasDefault","Function","skipFactory","normalizePropsOptions","extendProps","normalizedKey","validatePropName","prop","booleanIndex","getTypeIndex","Boolean","stringIndex","getType","ctor","isSameType","expectedTypes","findIndex","t","isInternalKey","normalizeSlotValue","normalizeSlot","rawSlot","_n","isNonScopedSlot","renderFnWithContext","_d","setBlockTracking","prevInstance","_c","withCtx","normalizeObjectSlots","rawSlots","_ctx","normalizeVNodeSlots","children","initSlots","updateSlots","optimized","needDeletionCheck","deletionComparisonTarget","$stable","setRef","rawRef","oldRawRef","parentSuspense","isUnmount","refValue","owner","oldRef","_isString","_isRef","isVFor","doSet","existing","k","pendingBranch","createRenderer","createHydrationFns","__VUE__","insert","hostInsert","hostRemove","patchProp","hostPatchProp","createElement","hostCreateElement","createText","hostCreateText","createComment","hostCreateComment","setText","hostSetText","setElementText","hostSetElementText","parentNode","hostParentNode","nextSibling","hostNextSibling","setScopeId","hostSetScopeId","insertStaticContent","hostInsertStaticContent","patch","n1","n2","container","anchor","parentComponent","slotScopeIds","dynamicChildren","isSameVNodeType","getNextHostNode","patchFlag","Text","processText","processCommentNode","Static","mountStaticNode","Fragment","processFragment","processElement","processComponent","process","internals","moveStaticNode","removeStaticNode","mountElement","patchElement","vnodeHook","mountChildren","resolveChildrenNamespace","scopeId","unmountChildren","onVnodeBeforeMount","invokeVNodeHook","needCallTransitionHooks","persisted","needTransition","beforeEnter","onVnodeMounted","enter","subTree","parentVNode","child","cloneIfMounted","oldProps","newProps","toggleRecurse","onVnodeBeforeUpdate","patchBlockChildren","patchChildren","patchProps","class","style","propsToUpdate","dynamicProps","onVnodeUpdated","oldChildren","newChildren","fallbackContainer","oldVNode","newVNode","fragmentStartAnchor","fragmentEndAnchor","fragmentSlotScopeIds","traverseStaticChildren","activate","mountComponent","updateComponent","initialVNode","createComponentInstance","renderer","setupComponent","asyncDep","registerDep","setupRenderEffect","placeholder","nextVNode","prevChildren","nextChildren","shouldUpdateComponent","asyncResolved","updateComponentPreRender","invalidateJob","componentUpdateFn","bu","u","nonHydratedAsyncRoot","locateNonHydratedAsyncRoot","originNext","nextTree","prevTree","activeBranch","updateHOCHostEl","bm","isAsyncWrapperVNode","hydrateNode","hydrateSubTree","scopedInitialVNode","rawPrevProps","kebabKey","camelizedKey","updateProps","c1","prevShapeFlag","c2","patchKeyedChildren","patchUnkeyedChildren","oldLength","commonLength","Math","min","nextChild","parentAnchor","l2","e1","e2","nextPos","s1","s2","keyToNewIndexMap","j","patched","toBePatched","moved","maxNewIndexSoFar","newIndexToOldIndexMap","prevChild","newIndex","increasingNewIndexSequence","len","arrI","getSequence","nextIndex","move","moveType","leave","delayLeave","afterLeave","performLeave","doRemove","deactivate","shouldInvokeDirs","shouldInvokeVnodeHook","onVnodeBeforeUnmount","unmountComponent","onVnodeUnmounted","removeFragment","performRemove","bum","um","suspenseId","pendingId","_vnode","mt","mc","pc","pbc","o","createApp","baseCreateRenderer","currentNamespace","encoding","allowed","ch1","ch2","subComponent","currentBlock","isBlockTreeEnabled","isVNode","__v_isVNode","normalizeKey","normalizeRef","ref_key","ref_for","isBlockNode","cloned","normalizeChildren","__vccOpts","guardReactiveProps","klass","__isSuspense","isSuspense","__isTeleport","isTeleport","needFullChildrenNormalization","__v_skip","ssContent","ssFallback","targetAnchor","staticCount","normalize","createBaseVNode","extraProps","mergeRef","mergedProps","mergeProps","ce","createTextVNode","text","flag","memo","slot","slotFlag","toMerge","incoming","emptyAppContext","exposeProxy","setupContext","attrsProxy","slotsProxy","bc","da","rtg","rtc","sp","internalSetCurrentInstance","setInSSRSetupState","g","registerGlobalSetter","setter","setters","unsetCurrentInstance","compile","setupResult","setup","getAttrsProxy","createSetupContext","resolvedResult","handleSetupResult","e","finishComponentSetup","setupStatefulComponent","__ssrInlineRender","ssrRender","skipOptions","template","isCustomElement","delimiters","componentCompilerOptions","finalCompilerOptions","getterOrOptions","debugOptions","onlyGetter","_computed","ssrUtils","doc","document","templateContainer","nodeOps","insertBefore","removeChild","tag","createElementNS","multiple","setAttribute","createTextNode","node","nodeValue","textContent","querySelector","selector","content","before","previousSibling","lastChild","cloneNode","innerHTML","wrapper","firstChild","appendChild","vtcKey","vShowOldKey","vShow","display","setDisplay","CSS_VAR_TEXT","importantRE","setStyle","setProperty","prefixed","rawName","prefixCache","prefixes","autoPrefix","test","xlinkNS","addEventListener","veiKey","patchEvent","prevValue","nextValue","invokers","existingInvoker","optionsModifierRE","parseName","invoker","initialValue","_vts","attached","Date","now","originalStop","stopImmediatePropagation","_stopped","patchStopImmediatePropagation","getNow","createInvoker","removeEventListener","cachedNow","isNativeOn","getModelAssigner","onCompositionStart","composing","onCompositionEnd","dispatchEvent","Event","assignKey","vModelText","modifiers","lazy","castToNumber","domValue","activeElement","rendererOptions","isSVG","transitionClasses","join","removeAttribute","patchClass","currentDisplay","isCssString","cssVarText","patchStyle","tagName","shouldSetAsProp","getAttribute","needRemove","patchDOMProp","_trueValue","_falseValue","removeAttributeNS","setAttributeNS","isBoolean","patchAttr","containerOrSelector","normalizeContainer","SVGElement","MathMLElement","resolveRootNamespace","Element","ssrDirectiveInitialized","shouldIgnoreProp","ssrRenderAttrs","ssrRenderClass","ssrRenderStyle","ssrRenderDynamicAttr","attrKey","isUnsafe","isSSRSafeAttrName","warn","ssrRenderAttr","styles","stringifyStyle","ssrRenderComponent","slotScopeId","renderComponentVNode","ssrRenderSlot","slotName","slotProps","fallbackRenderFn","ssrRenderSlotInner","slotFn","slotBuffer","renderVNodeChildren","isEmptySlot","isComment","commentTestRE","commentRE","ssrRenderTeleport","parentPush","contentRenderFn","disabled","teleportBuffers","__teleportBuffers","targetBuffer","bufferIndex","teleportContent","getBuffer","createBuffer","ssrInterpolate","JSON","stringify","ssrRenderList","renderItem","async","ssrRenderSuspense","renderContent","ssrGetDirectiveProps","getSSRProps","ssrLooseEqual","ssrLooseContain","looseIndexOf","ssrRenderDynamicModel","model","ssrGetDynamicModelProps","existingProps","checked","appendable","buffer","isStringItem","hasAsync","hasAsyncSetup","prefetches","Promise","all","prefetch","renderComponentSubTree","renderVNode","Error","ssrCompile","hasCloned","src","openTag","applySSRDirectives","curParent","curVnode","hasChildrenOverride","renderElementVNode","renderTeleportVNode","unrollBuffer","unrollBufferSync","renderToString","input","resolveTeleports","teleports","stream","renderToSimpleStream","destroy","renderToStream","renderToNodeStream","pipeToNodeWritable","writable","write","renderToWebStream","ReadableStream","encoder","TextEncoder","cancelled","controller","enqueue","encode","close","cancel","pipeToWebWritable","writer","getWriter","hasReady","ready","log"],"mappings":"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"}