{"version":3,"file":"compiler-ssr.cjs.js","sources":["../src/runtimeHelpers.ts","../src/transforms/ssrVIf.ts","../src/transforms/ssrVFor.ts","../src/transforms/ssrTransformSlotOutlet.ts","../src/errors.ts","../src/transforms/ssrTransformTeleport.ts","../src/transforms/ssrTransformSuspense.ts","../src/transforms/ssrTransformElement.ts","../src/transforms/ssrTransformTransitionGroup.ts","../src/transforms/ssrTransformTransition.ts","../src/transforms/ssrTransformComponent.ts","../src/ssrCodegenTransform.ts","../src/transforms/ssrVModel.ts","../src/transforms/ssrVShow.ts","../src/transforms/ssrInjectFallthroughAttrs.ts","../src/transforms/ssrInjectCssVars.ts","../src/index.ts"],"sourcesContent":["import { registerRuntimeHelpers } from '@vue/compiler-dom'\r\n\r\nexport const SSR_INTERPOLATE = Symbol(`ssrInterpolate`)\r\nexport const SSR_RENDER_VNODE = Symbol(`ssrRenderVNode`)\r\nexport const SSR_RENDER_COMPONENT = Symbol(`ssrRenderComponent`)\r\nexport const SSR_RENDER_SLOT = Symbol(`ssrRenderSlot`)\r\nexport const SSR_RENDER_SLOT_INNER = Symbol(`ssrRenderSlotInner`)\r\nexport const SSR_RENDER_CLASS = Symbol(`ssrRenderClass`)\r\nexport const SSR_RENDER_STYLE = Symbol(`ssrRenderStyle`)\r\nexport const SSR_RENDER_ATTRS = Symbol(`ssrRenderAttrs`)\r\nexport const SSR_RENDER_ATTR = Symbol(`ssrRenderAttr`)\r\nexport const SSR_RENDER_DYNAMIC_ATTR = Symbol(`ssrRenderDynamicAttr`)\r\nexport const SSR_RENDER_LIST = Symbol(`ssrRenderList`)\r\nexport const SSR_INCLUDE_BOOLEAN_ATTR = Symbol(`ssrIncludeBooleanAttr`)\r\nexport const SSR_LOOSE_EQUAL = Symbol(`ssrLooseEqual`)\r\nexport const SSR_LOOSE_CONTAIN = Symbol(`ssrLooseContain`)\r\nexport const SSR_RENDER_DYNAMIC_MODEL = Symbol(`ssrRenderDynamicModel`)\r\nexport const SSR_GET_DYNAMIC_MODEL_PROPS = Symbol(`ssrGetDynamicModelProps`)\r\nexport const SSR_RENDER_TELEPORT = Symbol(`ssrRenderTeleport`)\r\nexport const SSR_RENDER_SUSPENSE = Symbol(`ssrRenderSuspense`)\r\nexport const SSR_GET_DIRECTIVE_PROPS = Symbol(`ssrGetDirectiveProps`)\r\n\r\nexport const ssrHelpers = {\r\n  [SSR_INTERPOLATE]: `ssrInterpolate`,\r\n  [SSR_RENDER_VNODE]: `ssrRenderVNode`,\r\n  [SSR_RENDER_COMPONENT]: `ssrRenderComponent`,\r\n  [SSR_RENDER_SLOT]: `ssrRenderSlot`,\r\n  [SSR_RENDER_SLOT_INNER]: `ssrRenderSlotInner`,\r\n  [SSR_RENDER_CLASS]: `ssrRenderClass`,\r\n  [SSR_RENDER_STYLE]: `ssrRenderStyle`,\r\n  [SSR_RENDER_ATTRS]: `ssrRenderAttrs`,\r\n  [SSR_RENDER_ATTR]: `ssrRenderAttr`,\r\n  [SSR_RENDER_DYNAMIC_ATTR]: `ssrRenderDynamicAttr`,\r\n  [SSR_RENDER_LIST]: `ssrRenderList`,\r\n  [SSR_INCLUDE_BOOLEAN_ATTR]: `ssrIncludeBooleanAttr`,\r\n  [SSR_LOOSE_EQUAL]: `ssrLooseEqual`,\r\n  [SSR_LOOSE_CONTAIN]: `ssrLooseContain`,\r\n  [SSR_RENDER_DYNAMIC_MODEL]: `ssrRenderDynamicModel`,\r\n  [SSR_GET_DYNAMIC_MODEL_PROPS]: `ssrGetDynamicModelProps`,\r\n  [SSR_RENDER_TELEPORT]: `ssrRenderTeleport`,\r\n  [SSR_RENDER_SUSPENSE]: `ssrRenderSuspense`,\r\n  [SSR_GET_DIRECTIVE_PROPS]: `ssrGetDirectiveProps`,\r\n}\r\n\r\n// Note: these are helpers imported from @vue/server-renderer\r\n// make sure the names match!\r\nregisterRuntimeHelpers(ssrHelpers)\r\n","import {\r\n  type BlockStatement,\r\n  type IfBranchNode,\r\n  type IfNode,\r\n  NodeTypes,\r\n  createBlockStatement,\r\n  createCallExpression,\r\n  createIfStatement,\r\n  createStructuralDirectiveTransform,\r\n  processIf,\r\n} from '@vue/compiler-dom'\r\nimport {\r\n  type SSRTransformContext,\r\n  processChildrenAsStatement,\r\n} from '../ssrCodegenTransform'\r\n\r\n// Plugin for the first transform pass, which simply constructs the AST node\r\nexport const ssrTransformIf = createStructuralDirectiveTransform(\r\n  /^(if|else|else-if)$/,\r\n  processIf,\r\n)\r\n\r\n// This is called during the 2nd transform pass to construct the SSR-specific\r\n// codegen nodes.\r\nexport function ssrProcessIf(\r\n  node: IfNode,\r\n  context: SSRTransformContext,\r\n  disableNestedFragments = false,\r\n) {\r\n  const [rootBranch] = node.branches\r\n  const ifStatement = createIfStatement(\r\n    rootBranch.condition!,\r\n    processIfBranch(rootBranch, context, disableNestedFragments),\r\n  )\r\n  context.pushStatement(ifStatement)\r\n\r\n  let currentIf = ifStatement\r\n  for (let i = 1; i < node.branches.length; i++) {\r\n    const branch = node.branches[i]\r\n    const branchBlockStatement = processIfBranch(\r\n      branch,\r\n      context,\r\n      disableNestedFragments,\r\n    )\r\n    if (branch.condition) {\r\n      // else-if\r\n      currentIf = currentIf.alternate = createIfStatement(\r\n        branch.condition,\r\n        branchBlockStatement,\r\n      )\r\n    } else {\r\n      // else\r\n      currentIf.alternate = branchBlockStatement\r\n    }\r\n  }\r\n\r\n  if (!currentIf.alternate) {\r\n    currentIf.alternate = createBlockStatement([\r\n      createCallExpression(`_push`, ['`<!---->`']),\r\n    ])\r\n  }\r\n}\r\n\r\nfunction processIfBranch(\r\n  branch: IfBranchNode,\r\n  context: SSRTransformContext,\r\n  disableNestedFragments = false,\r\n): BlockStatement {\r\n  const { children } = branch\r\n  const needFragmentWrapper =\r\n    !disableNestedFragments &&\r\n    (children.length !== 1 || children[0].type !== NodeTypes.ELEMENT) &&\r\n    // optimize away nested fragments when the only child is a ForNode\r\n    !(children.length === 1 && children[0].type === NodeTypes.FOR)\r\n  return processChildrenAsStatement(branch, context, needFragmentWrapper)\r\n}\r\n","import {\r\n  type ForNode,\r\n  NodeTypes,\r\n  createCallExpression,\r\n  createForLoopParams,\r\n  createFunctionExpression,\r\n  createStructuralDirectiveTransform,\r\n  processFor,\r\n} from '@vue/compiler-dom'\r\nimport {\r\n  type SSRTransformContext,\r\n  processChildrenAsStatement,\r\n} from '../ssrCodegenTransform'\r\nimport { SSR_RENDER_LIST } from '../runtimeHelpers'\r\n\r\n// Plugin for the first transform pass, which simply constructs the AST node\r\nexport const ssrTransformFor = createStructuralDirectiveTransform(\r\n  'for',\r\n  processFor,\r\n)\r\n\r\n// This is called during the 2nd transform pass to construct the SSR-specific\r\n// codegen nodes.\r\nexport function ssrProcessFor(\r\n  node: ForNode,\r\n  context: SSRTransformContext,\r\n  disableNestedFragments = false,\r\n) {\r\n  const needFragmentWrapper =\r\n    !disableNestedFragments &&\r\n    (node.children.length !== 1 || node.children[0].type !== NodeTypes.ELEMENT)\r\n  const renderLoop = createFunctionExpression(\r\n    createForLoopParams(node.parseResult),\r\n  )\r\n  renderLoop.body = processChildrenAsStatement(\r\n    node,\r\n    context,\r\n    needFragmentWrapper,\r\n  )\r\n  // v-for always renders a fragment unless explicitly disabled\r\n  if (!disableNestedFragments) {\r\n    context.pushStringPart(`<!--[-->`)\r\n  }\r\n  context.pushStatement(\r\n    createCallExpression(context.helper(SSR_RENDER_LIST), [\r\n      node.source,\r\n      renderLoop,\r\n    ]),\r\n  )\r\n  if (!disableNestedFragments) {\r\n    context.pushStringPart(`<!--]-->`)\r\n  }\r\n}\r\n","import {\r\n  ElementTypes,\r\n  type NodeTransform,\r\n  NodeTypes,\r\n  type SlotOutletNode,\r\n  TRANSITION,\r\n  TRANSITION_GROUP,\r\n  createCallExpression,\r\n  createFunctionExpression,\r\n  isSlotOutlet,\r\n  processSlotOutlet,\r\n  resolveComponentType,\r\n} from '@vue/compiler-dom'\r\nimport { SSR_RENDER_SLOT, SSR_RENDER_SLOT_INNER } from '../runtimeHelpers'\r\nimport {\r\n  type SSRTransformContext,\r\n  processChildrenAsStatement,\r\n} from '../ssrCodegenTransform'\r\n\r\nexport const ssrTransformSlotOutlet: NodeTransform = (node, context) => {\r\n  if (isSlotOutlet(node)) {\r\n    const { slotName, slotProps } = processSlotOutlet(node, context)\r\n\r\n    const args = [\r\n      `_ctx.$slots`,\r\n      slotName,\r\n      slotProps || `{}`,\r\n      // fallback content placeholder. will be replaced in the process phase\r\n      `null`,\r\n      `_push`,\r\n      `_parent`,\r\n    ]\r\n\r\n    // inject slot scope id if current template uses :slotted\r\n    if (context.scopeId && context.slotted !== false) {\r\n      args.push(`\"${context.scopeId}-s\"`)\r\n    }\r\n\r\n    let method = SSR_RENDER_SLOT\r\n\r\n    // #3989, #9933\r\n    // check if this is a single slot inside a transition wrapper - since\r\n    // transition/transition-group will unwrap the slot fragment into vnode(s) at runtime,\r\n    // we need to avoid rendering the slot as a fragment.\r\n    const parent = context.parent\r\n    let componentType\r\n    if (\r\n      parent &&\r\n      parent.type === NodeTypes.ELEMENT &&\r\n      parent.tagType === ElementTypes.COMPONENT &&\r\n      ((componentType = resolveComponentType(parent, context, true)) ===\r\n        TRANSITION ||\r\n        componentType === TRANSITION_GROUP) &&\r\n      parent.children.filter(c => c.type === NodeTypes.ELEMENT).length === 1\r\n    ) {\r\n      method = SSR_RENDER_SLOT_INNER\r\n      if (!(context.scopeId && context.slotted !== false)) {\r\n        args.push('null')\r\n      }\r\n      args.push('true')\r\n    }\r\n\r\n    node.ssrCodegenNode = createCallExpression(context.helper(method), args)\r\n  }\r\n}\r\n\r\nexport function ssrProcessSlotOutlet(\r\n  node: SlotOutletNode,\r\n  context: SSRTransformContext,\r\n) {\r\n  const renderCall = node.ssrCodegenNode!\r\n\r\n  // has fallback content\r\n  if (node.children.length) {\r\n    const fallbackRenderFn = createFunctionExpression([])\r\n    fallbackRenderFn.body = processChildrenAsStatement(node, context)\r\n    // _renderSlot(slots, name, props, fallback, ...)\r\n    renderCall.arguments[3] = fallbackRenderFn\r\n  }\r\n\r\n  // Forwarded <slot/>. Merge slot scope ids\r\n  if (context.withSlotScopeId) {\r\n    const slotScopeId = renderCall.arguments[6]\r\n    renderCall.arguments[6] = slotScopeId\r\n      ? `${slotScopeId as string} + _scopeId`\r\n      : `_scopeId`\r\n  }\r\n\r\n  context.pushStatement(node.ssrCodegenNode!)\r\n}\r\n","import {\r\n  type CompilerError,\r\n  DOMErrorCodes,\r\n  type SourceLocation,\r\n  createCompilerError,\r\n} from '@vue/compiler-dom'\r\n\r\nexport interface SSRCompilerError extends CompilerError {\r\n  code: SSRErrorCodes\r\n}\r\n\r\nexport function createSSRCompilerError(\r\n  code: SSRErrorCodes,\r\n  loc?: SourceLocation,\r\n) {\r\n  return createCompilerError(code, loc, SSRErrorMessages) as SSRCompilerError\r\n}\r\n\r\nexport enum SSRErrorCodes {\r\n  X_SSR_UNSAFE_ATTR_NAME = 65 /* DOMErrorCodes.__EXTEND_POINT__ */,\r\n  X_SSR_NO_TELEPORT_TARGET,\r\n  X_SSR_INVALID_AST_NODE,\r\n}\r\n\r\nif (__TEST__) {\r\n  // esbuild cannot infer enum increments if first value is from another\r\n  // file, so we have to manually keep them in sync. this check ensures it\r\n  // errors out if there are collisions.\r\n  if (SSRErrorCodes.X_SSR_UNSAFE_ATTR_NAME < DOMErrorCodes.__EXTEND_POINT__) {\r\n    throw new Error(\r\n      `SSRErrorCodes need to be updated to ${\r\n        DOMErrorCodes.__EXTEND_POINT__ + 1\r\n      } to match extension point from core DOMErrorCodes.`,\r\n    )\r\n  }\r\n}\r\n\r\nexport const SSRErrorMessages: { [code: number]: string } = {\r\n  [SSRErrorCodes.X_SSR_UNSAFE_ATTR_NAME]: `Unsafe attribute name for SSR.`,\r\n  [SSRErrorCodes.X_SSR_NO_TELEPORT_TARGET]: `Missing the 'to' prop on teleport element.`,\r\n  [SSRErrorCodes.X_SSR_INVALID_AST_NODE]: `Invalid AST node during SSR transform.`,\r\n}\r\n","import {\r\n  type ComponentNode,\r\n  type ExpressionNode,\r\n  NodeTypes,\r\n  createCallExpression,\r\n  createFunctionExpression,\r\n  createSimpleExpression,\r\n  findProp,\r\n} from '@vue/compiler-dom'\r\nimport {\r\n  type SSRTransformContext,\r\n  processChildrenAsStatement,\r\n} from '../ssrCodegenTransform'\r\nimport { SSRErrorCodes, createSSRCompilerError } from '../errors'\r\nimport { SSR_RENDER_TELEPORT } from '../runtimeHelpers'\r\n\r\n// Note: this is a 2nd-pass codegen transform.\r\nexport function ssrProcessTeleport(\r\n  node: ComponentNode,\r\n  context: SSRTransformContext,\r\n) {\r\n  const targetProp = findProp(node, 'to')\r\n  if (!targetProp) {\r\n    context.onError(\r\n      createSSRCompilerError(SSRErrorCodes.X_SSR_NO_TELEPORT_TARGET, node.loc),\r\n    )\r\n    return\r\n  }\r\n\r\n  let target: ExpressionNode | undefined\r\n  if (targetProp.type === NodeTypes.ATTRIBUTE) {\r\n    target =\r\n      targetProp.value && createSimpleExpression(targetProp.value.content, true)\r\n  } else {\r\n    target = targetProp.exp\r\n  }\r\n  if (!target) {\r\n    context.onError(\r\n      createSSRCompilerError(\r\n        SSRErrorCodes.X_SSR_NO_TELEPORT_TARGET,\r\n        targetProp.loc,\r\n      ),\r\n    )\r\n    return\r\n  }\r\n\r\n  const disabledProp = findProp(node, 'disabled', false, true /* allow empty */)\r\n  const disabled = disabledProp\r\n    ? disabledProp.type === NodeTypes.ATTRIBUTE\r\n      ? `true`\r\n      : disabledProp.exp || `false`\r\n    : `false`\r\n\r\n  const contentRenderFn = createFunctionExpression(\r\n    [`_push`],\r\n    undefined, // Body is added later\r\n    true, // newline\r\n    false, // isSlot\r\n    node.loc,\r\n  )\r\n  contentRenderFn.body = processChildrenAsStatement(node, context)\r\n  context.pushStatement(\r\n    createCallExpression(context.helper(SSR_RENDER_TELEPORT), [\r\n      `_push`,\r\n      contentRenderFn,\r\n      target,\r\n      disabled,\r\n      `_parent`,\r\n    ]),\r\n  )\r\n}\r\n","import {\r\n  type ComponentNode,\r\n  type FunctionExpression,\r\n  type SlotsExpression,\r\n  type TemplateChildNode,\r\n  type TransformContext,\r\n  buildSlots,\r\n  createCallExpression,\r\n  createFunctionExpression,\r\n} from '@vue/compiler-dom'\r\nimport {\r\n  type SSRTransformContext,\r\n  processChildrenAsStatement,\r\n} from '../ssrCodegenTransform'\r\nimport { SSR_RENDER_SUSPENSE } from '../runtimeHelpers'\r\n\r\nconst wipMap = new WeakMap<ComponentNode, WIPEntry>()\r\n\r\ninterface WIPEntry {\r\n  slotsExp: SlotsExpression\r\n  wipSlots: Array<{\r\n    fn: FunctionExpression\r\n    children: TemplateChildNode[]\r\n  }>\r\n}\r\n\r\n// phase 1\r\nexport function ssrTransformSuspense(\r\n  node: ComponentNode,\r\n  context: TransformContext,\r\n) {\r\n  return () => {\r\n    if (node.children.length) {\r\n      const wipEntry: WIPEntry = {\r\n        slotsExp: null!, // to be immediately set\r\n        wipSlots: [],\r\n      }\r\n      wipMap.set(node, wipEntry)\r\n      wipEntry.slotsExp = buildSlots(\r\n        node,\r\n        context,\r\n        (_props, _vForExp, children, loc) => {\r\n          const fn = createFunctionExpression(\r\n            [],\r\n            undefined, // no return, assign body later\r\n            true, // newline\r\n            false, // suspense slots are not treated as normal slots\r\n            loc,\r\n          )\r\n          wipEntry.wipSlots.push({\r\n            fn,\r\n            children,\r\n          })\r\n          return fn\r\n        },\r\n      ).slots\r\n    }\r\n  }\r\n}\r\n\r\n// phase 2\r\nexport function ssrProcessSuspense(\r\n  node: ComponentNode,\r\n  context: SSRTransformContext,\r\n) {\r\n  // complete wip slots with ssr code\r\n  const wipEntry = wipMap.get(node)\r\n  if (!wipEntry) {\r\n    return\r\n  }\r\n  const { slotsExp, wipSlots } = wipEntry\r\n  for (let i = 0; i < wipSlots.length; i++) {\r\n    const slot = wipSlots[i]\r\n    slot.fn.body = processChildrenAsStatement(slot, context)\r\n  }\r\n  // _push(ssrRenderSuspense(slots))\r\n  context.pushStatement(\r\n    createCallExpression(context.helper(SSR_RENDER_SUSPENSE), [\r\n      `_push`,\r\n      slotsExp,\r\n    ]),\r\n  )\r\n}\r\n","import {\r\n  type ArrayExpression,\r\n  type AttributeNode,\r\n  type CallExpression,\r\n  type DirectiveNode,\r\n  ElementTypes,\r\n  ErrorCodes,\r\n  type ExpressionNode,\r\n  type InterpolationNode,\r\n  type JSChildNode,\r\n  MERGE_PROPS,\r\n  type NodeTransform,\r\n  NodeTypes,\r\n  type PlainElementNode,\r\n  type PropsExpression,\r\n  type TemplateLiteral,\r\n  type TextNode,\r\n  type TransformContext,\r\n  buildDirectiveArgs,\r\n  buildProps,\r\n  createArrayExpression,\r\n  createAssignmentExpression,\r\n  createCallExpression,\r\n  createCompilerError,\r\n  createConditionalExpression,\r\n  createInterpolation,\r\n  createSequenceExpression,\r\n  createSimpleExpression,\r\n  createTemplateLiteral,\r\n  hasDynamicKeyVBind,\r\n  isStaticArgOf,\r\n  isStaticExp,\r\n} from '@vue/compiler-dom'\r\nimport {\r\n  NO,\r\n  escapeHtml,\r\n  isBooleanAttr,\r\n  isBuiltInDirective,\r\n  isSSRSafeAttrName,\r\n  propsToAttrMap,\r\n} from '@vue/shared'\r\nimport { SSRErrorCodes, createSSRCompilerError } from '../errors'\r\nimport {\r\n  SSR_GET_DIRECTIVE_PROPS,\r\n  SSR_GET_DYNAMIC_MODEL_PROPS,\r\n  SSR_INCLUDE_BOOLEAN_ATTR,\r\n  SSR_INTERPOLATE,\r\n  SSR_RENDER_ATTR,\r\n  SSR_RENDER_ATTRS,\r\n  SSR_RENDER_CLASS,\r\n  SSR_RENDER_DYNAMIC_ATTR,\r\n  SSR_RENDER_STYLE,\r\n} from '../runtimeHelpers'\r\nimport {\r\n  type SSRTransformContext,\r\n  processChildren,\r\n} from '../ssrCodegenTransform'\r\n\r\n// for directives with children overwrite (e.g. v-html & v-text), we need to\r\n// store the raw children so that they can be added in the 2nd pass.\r\nconst rawChildrenMap = new WeakMap<\r\n  PlainElementNode,\r\n  TemplateLiteral['elements'][0]\r\n>()\r\n\r\nexport const ssrTransformElement: NodeTransform = (node, context) => {\r\n  if (\r\n    node.type !== NodeTypes.ELEMENT ||\r\n    node.tagType !== ElementTypes.ELEMENT\r\n  ) {\r\n    return\r\n  }\r\n\r\n  return function ssrPostTransformElement() {\r\n    // element\r\n    // generate the template literal representing the open tag.\r\n    const openTag: TemplateLiteral['elements'] = [`<${node.tag}`]\r\n    // some tags need to be passed to runtime for special checks\r\n    const needTagForRuntime =\r\n      node.tag === 'textarea' || node.tag.indexOf('-') > 0\r\n\r\n    // v-bind=\"obj\", v-bind:[key] and custom directives can potentially\r\n    // overwrite other static attrs and can affect final rendering result,\r\n    // so when they are present we need to bail out to full `renderAttrs`\r\n    const hasDynamicVBind = hasDynamicKeyVBind(node)\r\n    const hasCustomDir = node.props.some(\r\n      p => p.type === NodeTypes.DIRECTIVE && !isBuiltInDirective(p.name),\r\n    )\r\n    const needMergeProps = hasDynamicVBind || hasCustomDir\r\n    if (needMergeProps) {\r\n      const { props, directives } = buildProps(\r\n        node,\r\n        context,\r\n        node.props,\r\n        false /* isComponent */,\r\n        false /* isDynamicComponent */,\r\n        true /* ssr */,\r\n      )\r\n      if (props || directives.length) {\r\n        const mergedProps = buildSSRProps(props, directives, context)\r\n        const propsExp = createCallExpression(\r\n          context.helper(SSR_RENDER_ATTRS),\r\n          [mergedProps],\r\n        )\r\n\r\n        if (node.tag === 'textarea') {\r\n          const existingText = node.children[0] as\r\n            | TextNode\r\n            | InterpolationNode\r\n            | undefined\r\n          // If interpolation, this is dynamic <textarea> content, potentially\r\n          // injected by v-model and takes higher priority than v-bind value\r\n          if (!existingText || existingText.type !== NodeTypes.INTERPOLATION) {\r\n            // <textarea> with dynamic v-bind. We don't know if the final props\r\n            // will contain .value, so we will have to do something special:\r\n            // assign the merged props to a temp variable, and check whether\r\n            // it contains value (if yes, render is as children).\r\n            const tempId = `_temp${context.temps++}`\r\n            propsExp.arguments = [\r\n              createAssignmentExpression(\r\n                createSimpleExpression(tempId, false),\r\n                mergedProps,\r\n              ),\r\n            ]\r\n            rawChildrenMap.set(\r\n              node,\r\n              createCallExpression(context.helper(SSR_INTERPOLATE), [\r\n                createConditionalExpression(\r\n                  createSimpleExpression(`\"value\" in ${tempId}`, false),\r\n                  createSimpleExpression(`${tempId}.value`, false),\r\n                  createSimpleExpression(\r\n                    existingText ? existingText.content : ``,\r\n                    true,\r\n                  ),\r\n                  false,\r\n                ),\r\n              ]),\r\n            )\r\n          }\r\n        } else if (node.tag === 'input') {\r\n          // <input v-bind=\"obj\" v-model>\r\n          // we need to determine the props to render for the dynamic v-model\r\n          // and merge it with the v-bind expression.\r\n          const vModel = findVModel(node)\r\n          if (vModel) {\r\n            // 1. save the props (san v-model) in a temp variable\r\n            const tempId = `_temp${context.temps++}`\r\n            const tempExp = createSimpleExpression(tempId, false)\r\n            propsExp.arguments = [\r\n              createSequenceExpression([\r\n                createAssignmentExpression(tempExp, mergedProps),\r\n                createCallExpression(context.helper(MERGE_PROPS), [\r\n                  tempExp,\r\n                  createCallExpression(\r\n                    context.helper(SSR_GET_DYNAMIC_MODEL_PROPS),\r\n                    [\r\n                      tempExp, // existing props\r\n                      vModel.exp!, // model\r\n                    ],\r\n                  ),\r\n                ]),\r\n              ]),\r\n            ]\r\n          }\r\n        }\r\n\r\n        if (needTagForRuntime) {\r\n          propsExp.arguments.push(`\"${node.tag}\"`)\r\n        }\r\n\r\n        openTag.push(propsExp)\r\n      }\r\n    }\r\n\r\n    // book keeping static/dynamic class merging.\r\n    let dynamicClassBinding: CallExpression | undefined = undefined\r\n    let staticClassBinding: string | undefined = undefined\r\n    // all style bindings are converted to dynamic by transformStyle.\r\n    // but we need to make sure to merge them.\r\n    let dynamicStyleBinding: CallExpression | undefined = undefined\r\n\r\n    for (let i = 0; i < node.props.length; i++) {\r\n      const prop = node.props[i]\r\n      // ignore true-value/false-value on input\r\n      if (node.tag === 'input' && isTrueFalseValue(prop)) {\r\n        continue\r\n      }\r\n      // special cases with children override\r\n      if (prop.type === NodeTypes.DIRECTIVE) {\r\n        if (prop.name === 'html' && prop.exp) {\r\n          rawChildrenMap.set(node, prop.exp)\r\n        } else if (prop.name === 'text' && prop.exp) {\r\n          node.children = [createInterpolation(prop.exp, prop.loc)]\r\n        } else if (prop.name === 'slot') {\r\n          context.onError(\r\n            createCompilerError(ErrorCodes.X_V_SLOT_MISPLACED, prop.loc),\r\n          )\r\n        } else if (isTextareaWithValue(node, prop) && prop.exp) {\r\n          if (!needMergeProps) {\r\n            node.children = [createInterpolation(prop.exp, prop.loc)]\r\n          }\r\n        } else if (!needMergeProps && prop.name !== 'on') {\r\n          // Directive transforms.\r\n          const directiveTransform = context.directiveTransforms[prop.name]\r\n          if (directiveTransform) {\r\n            const { props, ssrTagParts } = directiveTransform(\r\n              prop,\r\n              node,\r\n              context,\r\n            )\r\n            if (ssrTagParts) {\r\n              openTag.push(...ssrTagParts)\r\n            }\r\n            for (let j = 0; j < props.length; j++) {\r\n              const { key, value } = props[j]\r\n              if (isStaticExp(key)) {\r\n                let attrName = key.content\r\n                // static key attr\r\n                if (attrName === 'key' || attrName === 'ref') {\r\n                  continue\r\n                }\r\n                if (attrName === 'class') {\r\n                  openTag.push(\r\n                    ` class=\"`,\r\n                    (dynamicClassBinding = createCallExpression(\r\n                      context.helper(SSR_RENDER_CLASS),\r\n                      [value],\r\n                    )),\r\n                    `\"`,\r\n                  )\r\n                } else if (attrName === 'style') {\r\n                  if (dynamicStyleBinding) {\r\n                    // already has style binding, merge into it.\r\n                    mergeCall(dynamicStyleBinding, value)\r\n                  } else {\r\n                    openTag.push(\r\n                      ` style=\"`,\r\n                      (dynamicStyleBinding = createCallExpression(\r\n                        context.helper(SSR_RENDER_STYLE),\r\n                        [value],\r\n                      )),\r\n                      `\"`,\r\n                    )\r\n                  }\r\n                } else {\r\n                  attrName =\r\n                    node.tag.indexOf('-') > 0\r\n                      ? attrName // preserve raw name on custom elements\r\n                      : propsToAttrMap[attrName] || attrName.toLowerCase()\r\n                  if (isBooleanAttr(attrName)) {\r\n                    openTag.push(\r\n                      createConditionalExpression(\r\n                        createCallExpression(\r\n                          context.helper(SSR_INCLUDE_BOOLEAN_ATTR),\r\n                          [value],\r\n                        ),\r\n                        createSimpleExpression(' ' + attrName, true),\r\n                        createSimpleExpression('', true),\r\n                        false /* no newline */,\r\n                      ),\r\n                    )\r\n                  } else if (isSSRSafeAttrName(attrName)) {\r\n                    openTag.push(\r\n                      createCallExpression(context.helper(SSR_RENDER_ATTR), [\r\n                        key,\r\n                        value,\r\n                      ]),\r\n                    )\r\n                  } else {\r\n                    context.onError(\r\n                      createSSRCompilerError(\r\n                        SSRErrorCodes.X_SSR_UNSAFE_ATTR_NAME,\r\n                        key.loc,\r\n                      ),\r\n                    )\r\n                  }\r\n                }\r\n              } else {\r\n                // dynamic key attr\r\n                // this branch is only encountered for custom directive\r\n                // transforms that returns properties with dynamic keys\r\n                const args: CallExpression['arguments'] = [key, value]\r\n                if (needTagForRuntime) {\r\n                  args.push(`\"${node.tag}\"`)\r\n                }\r\n                openTag.push(\r\n                  createCallExpression(\r\n                    context.helper(SSR_RENDER_DYNAMIC_ATTR),\r\n                    args,\r\n                  ),\r\n                )\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        // special case: value on <textarea>\r\n        const name = prop.name\r\n        if (node.tag === 'textarea' && name === 'value' && prop.value) {\r\n          rawChildrenMap.set(node, escapeHtml(prop.value.content))\r\n        } else if (!needMergeProps) {\r\n          if (name === 'key' || name === 'ref') {\r\n            continue\r\n          }\r\n          // static prop\r\n          if (name === 'class' && prop.value) {\r\n            staticClassBinding = JSON.stringify(prop.value.content)\r\n          }\r\n          openTag.push(\r\n            ` ${prop.name}` +\r\n              (prop.value ? `=\"${escapeHtml(prop.value.content)}\"` : ``),\r\n          )\r\n        }\r\n      }\r\n    }\r\n\r\n    // handle co-existence of dynamic + static class bindings\r\n    if (dynamicClassBinding && staticClassBinding) {\r\n      mergeCall(dynamicClassBinding, staticClassBinding)\r\n      removeStaticBinding(openTag, 'class')\r\n    }\r\n\r\n    if (context.scopeId) {\r\n      openTag.push(` ${context.scopeId}`)\r\n    }\r\n\r\n    node.ssrCodegenNode = createTemplateLiteral(openTag)\r\n  }\r\n}\r\n\r\nexport function buildSSRProps(\r\n  props: PropsExpression | undefined,\r\n  directives: DirectiveNode[],\r\n  context: TransformContext,\r\n): JSChildNode {\r\n  let mergePropsArgs: JSChildNode[] = []\r\n  if (props) {\r\n    if (props.type === NodeTypes.JS_CALL_EXPRESSION) {\r\n      // already a mergeProps call\r\n      mergePropsArgs = props.arguments as JSChildNode[]\r\n    } else {\r\n      mergePropsArgs.push(props)\r\n    }\r\n  }\r\n  if (directives.length) {\r\n    for (const dir of directives) {\r\n      mergePropsArgs.push(\r\n        createCallExpression(context.helper(SSR_GET_DIRECTIVE_PROPS), [\r\n          `_ctx`,\r\n          ...buildDirectiveArgs(dir, context).elements,\r\n        ] as JSChildNode[]),\r\n      )\r\n    }\r\n  }\r\n\r\n  return mergePropsArgs.length > 1\r\n    ? createCallExpression(context.helper(MERGE_PROPS), mergePropsArgs)\r\n    : mergePropsArgs[0]\r\n}\r\n\r\nfunction isTrueFalseValue(prop: DirectiveNode | AttributeNode) {\r\n  if (prop.type === NodeTypes.DIRECTIVE) {\r\n    return (\r\n      prop.name === 'bind' &&\r\n      prop.arg &&\r\n      isStaticExp(prop.arg) &&\r\n      (prop.arg.content === 'true-value' || prop.arg.content === 'false-value')\r\n    )\r\n  } else {\r\n    return prop.name === 'true-value' || prop.name === 'false-value'\r\n  }\r\n}\r\n\r\nfunction isTextareaWithValue(\r\n  node: PlainElementNode,\r\n  prop: DirectiveNode,\r\n): boolean {\r\n  return !!(\r\n    node.tag === 'textarea' &&\r\n    prop.name === 'bind' &&\r\n    isStaticArgOf(prop.arg, 'value')\r\n  )\r\n}\r\n\r\nfunction mergeCall(call: CallExpression, arg: string | JSChildNode) {\r\n  const existing = call.arguments[0] as ExpressionNode | ArrayExpression\r\n  if (existing.type === NodeTypes.JS_ARRAY_EXPRESSION) {\r\n    existing.elements.push(arg)\r\n  } else {\r\n    call.arguments[0] = createArrayExpression([existing, arg])\r\n  }\r\n}\r\n\r\nfunction removeStaticBinding(\r\n  tag: TemplateLiteral['elements'],\r\n  binding: string,\r\n) {\r\n  const regExp = new RegExp(`^ ${binding}=\".+\"$`)\r\n\r\n  const i = tag.findIndex(e => typeof e === 'string' && regExp.test(e))\r\n\r\n  if (i > -1) {\r\n    tag.splice(i, 1)\r\n  }\r\n}\r\n\r\nfunction findVModel(node: PlainElementNode): DirectiveNode | undefined {\r\n  return node.props.find(\r\n    p => p.type === NodeTypes.DIRECTIVE && p.name === 'model' && p.exp,\r\n  ) as DirectiveNode | undefined\r\n}\r\n\r\nexport function ssrProcessElement(\r\n  node: PlainElementNode,\r\n  context: SSRTransformContext,\r\n) {\r\n  const isVoidTag = context.options.isVoidTag || NO\r\n  const elementsToAdd = node.ssrCodegenNode!.elements\r\n  for (let j = 0; j < elementsToAdd.length; j++) {\r\n    context.pushStringPart(elementsToAdd[j])\r\n  }\r\n\r\n  // Handle slot scopeId\r\n  if (context.withSlotScopeId) {\r\n    context.pushStringPart(createSimpleExpression(`_scopeId`, false))\r\n  }\r\n\r\n  // close open tag\r\n  context.pushStringPart(`>`)\r\n\r\n  const rawChildren = rawChildrenMap.get(node)\r\n  if (rawChildren) {\r\n    context.pushStringPart(rawChildren)\r\n  } else if (node.children.length) {\r\n    processChildren(node, context)\r\n  }\r\n\r\n  if (!isVoidTag(node.tag)) {\r\n    // push closing tag\r\n    context.pushStringPart(`</${node.tag}>`)\r\n  }\r\n}\r\n","import {\r\n  type AttributeNode,\r\n  type ComponentNode,\r\n  type DirectiveNode,\r\n  type JSChildNode,\r\n  NodeTypes,\r\n  type TransformContext,\r\n  buildProps,\r\n  createCallExpression,\r\n  findProp,\r\n} from '@vue/compiler-dom'\r\nimport { SSR_RENDER_ATTRS } from '../runtimeHelpers'\r\nimport {\r\n  type SSRTransformContext,\r\n  processChildren,\r\n} from '../ssrCodegenTransform'\r\nimport { buildSSRProps } from './ssrTransformElement'\r\n\r\nconst wipMap = new WeakMap<ComponentNode, WIPEntry>()\r\n\r\ninterface WIPEntry {\r\n  tag: AttributeNode | DirectiveNode\r\n  propsExp: string | JSChildNode | null\r\n  scopeId: string | null\r\n}\r\n\r\n// phase 1: build props\r\nexport function ssrTransformTransitionGroup(\r\n  node: ComponentNode,\r\n  context: TransformContext,\r\n) {\r\n  return () => {\r\n    const tag = findProp(node, 'tag')\r\n    if (tag) {\r\n      const otherProps = node.props.filter(p => p !== tag)\r\n      const { props, directives } = buildProps(\r\n        node,\r\n        context,\r\n        otherProps,\r\n        true /* isComponent */,\r\n        false /* isDynamicComponent */,\r\n        true /* ssr (skip event listeners) */,\r\n      )\r\n      let propsExp = null\r\n      if (props || directives.length) {\r\n        propsExp = createCallExpression(context.helper(SSR_RENDER_ATTRS), [\r\n          buildSSRProps(props, directives, context),\r\n        ])\r\n      }\r\n      wipMap.set(node, {\r\n        tag,\r\n        propsExp,\r\n        scopeId: context.scopeId || null,\r\n      })\r\n    }\r\n  }\r\n}\r\n\r\n// phase 2: process children\r\nexport function ssrProcessTransitionGroup(\r\n  node: ComponentNode,\r\n  context: SSRTransformContext,\r\n) {\r\n  const entry = wipMap.get(node)\r\n  if (entry) {\r\n    const { tag, propsExp, scopeId } = entry\r\n    if (tag.type === NodeTypes.DIRECTIVE) {\r\n      // dynamic :tag\r\n      context.pushStringPart(`<`)\r\n      context.pushStringPart(tag.exp!)\r\n      if (propsExp) {\r\n        context.pushStringPart(propsExp)\r\n      }\r\n      if (scopeId) {\r\n        context.pushStringPart(` ${scopeId}`)\r\n      }\r\n      context.pushStringPart(`>`)\r\n\r\n      processChildren(\r\n        node,\r\n        context,\r\n        false,\r\n        /**\r\n         * TransitionGroup has the special runtime behavior of flattening and\r\n         * concatenating all children into a single fragment (in order for them to\r\n         * be patched using the same key map) so we need to account for that here\r\n         * by disabling nested fragment wrappers from being generated.\r\n         */\r\n        true,\r\n      )\r\n      context.pushStringPart(`</`)\r\n      context.pushStringPart(tag.exp!)\r\n      context.pushStringPart(`>`)\r\n    } else {\r\n      // static tag\r\n      context.pushStringPart(`<${tag.value!.content}`)\r\n      if (propsExp) {\r\n        context.pushStringPart(propsExp)\r\n      }\r\n      if (scopeId) {\r\n        context.pushStringPart(` ${scopeId}`)\r\n      }\r\n      context.pushStringPart(`>`)\r\n      processChildren(node, context, false, true)\r\n      context.pushStringPart(`</${tag.value!.content}>`)\r\n    }\r\n  } else {\r\n    // fragment\r\n    processChildren(node, context, true, true)\r\n  }\r\n}\r\n","import {\r\n  type ComponentNode,\r\n  NodeTypes,\r\n  type TransformContext,\r\n  findProp,\r\n} from '@vue/compiler-dom'\r\nimport {\r\n  type SSRTransformContext,\r\n  processChildren,\r\n} from '../ssrCodegenTransform'\r\n\r\nconst wipMap = new WeakMap<ComponentNode, Boolean>()\r\n\r\nexport function ssrTransformTransition(\r\n  node: ComponentNode,\r\n  context: TransformContext,\r\n) {\r\n  return () => {\r\n    const appear = findProp(node, 'appear', false, true)\r\n    wipMap.set(node, !!appear)\r\n  }\r\n}\r\n\r\nexport function ssrProcessTransition(\r\n  node: ComponentNode,\r\n  context: SSRTransformContext,\r\n) {\r\n  // #5351: filter out comment children inside transition\r\n  node.children = node.children.filter(c => c.type !== NodeTypes.COMMENT)\r\n\r\n  const appear = wipMap.get(node)\r\n  if (appear) {\r\n    context.pushStringPart(`<template>`)\r\n    processChildren(node, context, false, true)\r\n    context.pushStringPart(`</template>`)\r\n  } else {\r\n    processChildren(node, context, false, true)\r\n  }\r\n}\r\n","import {\r\n  CREATE_VNODE,\r\n  type CallExpression,\r\n  type CompilerOptions,\r\n  type ComponentNode,\r\n  DOMDirectiveTransforms,\r\n  DOMNodeTransforms,\r\n  type DirectiveNode,\r\n  ElementTypes,\r\n  type ExpressionNode,\r\n  type FunctionExpression,\r\n  type JSChildNode,\r\n  Namespaces,\r\n  type NodeTransform,\r\n  NodeTypes,\r\n  RESOLVE_DYNAMIC_COMPONENT,\r\n  type ReturnStatement,\r\n  type RootNode,\r\n  SUSPENSE,\r\n  type SlotFnBuilder,\r\n  TELEPORT,\r\n  TRANSITION,\r\n  TRANSITION_GROUP,\r\n  type TemplateChildNode,\r\n  type TemplateNode,\r\n  type TransformContext,\r\n  type TransformOptions,\r\n  buildProps,\r\n  buildSlots,\r\n  createCallExpression,\r\n  createFunctionExpression,\r\n  createIfStatement,\r\n  createReturnStatement,\r\n  createRoot,\r\n  createSimpleExpression,\r\n  createTransformContext,\r\n  getBaseTransformPreset,\r\n  locStub,\r\n  resolveComponentType,\r\n  stringifyExpression,\r\n  traverseNode,\r\n} from '@vue/compiler-dom'\r\nimport { SSR_RENDER_COMPONENT, SSR_RENDER_VNODE } from '../runtimeHelpers'\r\nimport {\r\n  type SSRTransformContext,\r\n  processChildren,\r\n  processChildrenAsStatement,\r\n} from '../ssrCodegenTransform'\r\nimport { ssrProcessTeleport } from './ssrTransformTeleport'\r\nimport {\r\n  ssrProcessSuspense,\r\n  ssrTransformSuspense,\r\n} from './ssrTransformSuspense'\r\nimport {\r\n  ssrProcessTransitionGroup,\r\n  ssrTransformTransitionGroup,\r\n} from './ssrTransformTransitionGroup'\r\nimport { extend, isArray, isObject, isPlainObject, isSymbol } from '@vue/shared'\r\nimport { buildSSRProps } from './ssrTransformElement'\r\nimport {\r\n  ssrProcessTransition,\r\n  ssrTransformTransition,\r\n} from './ssrTransformTransition'\r\n\r\n// We need to construct the slot functions in the 1st pass to ensure proper\r\n// scope tracking, but the children of each slot cannot be processed until\r\n// the 2nd pass, so we store the WIP slot functions in a weakMap during the 1st\r\n// pass and complete them in the 2nd pass.\r\nconst wipMap = new WeakMap<ComponentNode, WIPSlotEntry[]>()\r\n\r\nconst WIP_SLOT = Symbol()\r\n\r\ninterface WIPSlotEntry {\r\n  type: typeof WIP_SLOT\r\n  fn: FunctionExpression\r\n  children: TemplateChildNode[]\r\n  vnodeBranch: ReturnStatement\r\n}\r\n\r\nconst componentTypeMap = new WeakMap<\r\n  ComponentNode,\r\n  string | symbol | CallExpression\r\n>()\r\n\r\n// ssr component transform is done in two phases:\r\n// In phase 1. we use `buildSlot` to analyze the children of the component into\r\n// WIP slot functions (it must be done in phase 1 because `buildSlot` relies on\r\n// the core transform context).\r\n// In phase 2. we convert the WIP slots from phase 1 into ssr-specific codegen\r\n// nodes.\r\nexport const ssrTransformComponent: NodeTransform = (node, context) => {\r\n  if (\r\n    node.type !== NodeTypes.ELEMENT ||\r\n    node.tagType !== ElementTypes.COMPONENT\r\n  ) {\r\n    return\r\n  }\r\n\r\n  const component = resolveComponentType(node, context, true /* ssr */)\r\n  const isDynamicComponent =\r\n    isObject(component) && component.callee === RESOLVE_DYNAMIC_COMPONENT\r\n  componentTypeMap.set(node, component)\r\n\r\n  if (isSymbol(component)) {\r\n    if (component === SUSPENSE) {\r\n      return ssrTransformSuspense(node, context)\r\n    } else if (component === TRANSITION_GROUP) {\r\n      return ssrTransformTransitionGroup(node, context)\r\n    } else if (component === TRANSITION) {\r\n      return ssrTransformTransition(node, context)\r\n    }\r\n    return // other built-in components: fallthrough\r\n  }\r\n\r\n  // Build the fallback vnode-based branch for the component's slots.\r\n  // We need to clone the node into a fresh copy and use the buildSlots' logic\r\n  // to get access to the children of each slot. We then compile them with\r\n  // a child transform pipeline using vnode-based transforms (instead of ssr-\r\n  // based ones), and save the result branch (a ReturnStatement) in an array.\r\n  // The branch is retrieved when processing slots again in ssr mode.\r\n  const vnodeBranches: ReturnStatement[] = []\r\n  const clonedNode = clone(node)\r\n\r\n  return function ssrPostTransformComponent() {\r\n    // Using the cloned node, build the normal VNode-based branches (for\r\n    // fallback in case the child is render-fn based). Store them in an array\r\n    // for later use.\r\n    if (clonedNode.children.length) {\r\n      buildSlots(clonedNode, context, (props, vFor, children) => {\r\n        vnodeBranches.push(\r\n          createVNodeSlotBranch(props, vFor, children, context),\r\n        )\r\n        return createFunctionExpression(undefined)\r\n      })\r\n    }\r\n\r\n    let propsExp: string | JSChildNode = `null`\r\n    if (node.props.length) {\r\n      // note we are not passing ssr: true here because for components, v-on\r\n      // handlers should still be passed\r\n      const { props, directives } = buildProps(\r\n        node,\r\n        context,\r\n        undefined,\r\n        true,\r\n        isDynamicComponent,\r\n      )\r\n      if (props || directives.length) {\r\n        propsExp = buildSSRProps(props, directives, context)\r\n      }\r\n    }\r\n\r\n    const wipEntries: WIPSlotEntry[] = []\r\n    wipMap.set(node, wipEntries)\r\n\r\n    const buildSSRSlotFn: SlotFnBuilder = (props, _vForExp, children, loc) => {\r\n      const param0 = (props && stringifyExpression(props)) || `_`\r\n      const fn = createFunctionExpression(\r\n        [param0, `_push`, `_parent`, `_scopeId`],\r\n        undefined, // no return, assign body later\r\n        true, // newline\r\n        true, // isSlot\r\n        loc,\r\n      )\r\n      wipEntries.push({\r\n        type: WIP_SLOT,\r\n        fn,\r\n        children,\r\n        // also collect the corresponding vnode branch built earlier\r\n        vnodeBranch: vnodeBranches[wipEntries.length],\r\n      })\r\n      return fn\r\n    }\r\n\r\n    const slots = node.children.length\r\n      ? buildSlots(node, context, buildSSRSlotFn).slots\r\n      : `null`\r\n\r\n    if (typeof component !== 'string') {\r\n      // dynamic component that resolved to a `resolveDynamicComponent` call\r\n      // expression - since the resolved result may be a plain element (string)\r\n      // or a VNode, handle it with `renderVNode`.\r\n      node.ssrCodegenNode = createCallExpression(\r\n        context.helper(SSR_RENDER_VNODE),\r\n        [\r\n          `_push`,\r\n          createCallExpression(context.helper(CREATE_VNODE), [\r\n            component,\r\n            propsExp,\r\n            slots,\r\n          ]),\r\n          `_parent`,\r\n        ],\r\n      )\r\n    } else {\r\n      node.ssrCodegenNode = createCallExpression(\r\n        context.helper(SSR_RENDER_COMPONENT),\r\n        [component, propsExp, slots, `_parent`],\r\n      )\r\n    }\r\n  }\r\n}\r\n\r\nexport function ssrProcessComponent(\r\n  node: ComponentNode,\r\n  context: SSRTransformContext,\r\n  parent: { children: TemplateChildNode[] },\r\n) {\r\n  const component = componentTypeMap.get(node)!\r\n  if (!node.ssrCodegenNode) {\r\n    // this is a built-in component that fell-through.\r\n    if (component === TELEPORT) {\r\n      return ssrProcessTeleport(node, context)\r\n    } else if (component === SUSPENSE) {\r\n      return ssrProcessSuspense(node, context)\r\n    } else if (component === TRANSITION_GROUP) {\r\n      return ssrProcessTransitionGroup(node, context)\r\n    } else {\r\n      // real fall-through: Transition / KeepAlive\r\n      // just render its children.\r\n      // #5352: if is at root level of a slot, push an empty string.\r\n      // this does not affect the final output, but avoids all-comment slot\r\n      // content of being treated as empty by ssrRenderSlot().\r\n      if ((parent as WIPSlotEntry).type === WIP_SLOT) {\r\n        context.pushStringPart(``)\r\n      }\r\n      if (component === TRANSITION) {\r\n        return ssrProcessTransition(node, context)\r\n      }\r\n      processChildren(node, context)\r\n    }\r\n  } else {\r\n    // finish up slot function expressions from the 1st pass.\r\n    const wipEntries = wipMap.get(node) || []\r\n    for (let i = 0; i < wipEntries.length; i++) {\r\n      const { fn, vnodeBranch } = wipEntries[i]\r\n      // For each slot, we generate two branches: one SSR-optimized branch and\r\n      // one normal vnode-based branch. The branches are taken based on the\r\n      // presence of the 2nd `_push` argument (which is only present if the slot\r\n      // is called by `_ssrRenderSlot`.\r\n      fn.body = createIfStatement(\r\n        createSimpleExpression(`_push`, false),\r\n        processChildrenAsStatement(\r\n          wipEntries[i],\r\n          context,\r\n          false,\r\n          true /* withSlotScopeId */,\r\n        ),\r\n        vnodeBranch,\r\n      )\r\n    }\r\n\r\n    // component is inside a slot, inherit slot scope Id\r\n    if (context.withSlotScopeId) {\r\n      node.ssrCodegenNode.arguments.push(`_scopeId`)\r\n    }\r\n\r\n    if (typeof component === 'string') {\r\n      // static component\r\n      context.pushStatement(\r\n        createCallExpression(`_push`, [node.ssrCodegenNode]),\r\n      )\r\n    } else {\r\n      // dynamic component (`resolveDynamicComponent` call)\r\n      // the codegen node is a `renderVNode` call\r\n      context.pushStatement(node.ssrCodegenNode)\r\n    }\r\n  }\r\n}\r\n\r\nexport const rawOptionsMap = new WeakMap<RootNode, CompilerOptions>()\r\n\r\nconst [baseNodeTransforms, baseDirectiveTransforms] =\r\n  getBaseTransformPreset(true)\r\nconst vnodeNodeTransforms = [...baseNodeTransforms, ...DOMNodeTransforms]\r\nconst vnodeDirectiveTransforms = {\r\n  ...baseDirectiveTransforms,\r\n  ...DOMDirectiveTransforms,\r\n}\r\n\r\nfunction createVNodeSlotBranch(\r\n  slotProps: ExpressionNode | undefined,\r\n  vFor: DirectiveNode | undefined,\r\n  children: TemplateChildNode[],\r\n  parentContext: TransformContext,\r\n): ReturnStatement {\r\n  // apply a sub-transform using vnode-based transforms.\r\n  const rawOptions = rawOptionsMap.get(parentContext.root)!\r\n\r\n  const subOptions = {\r\n    ...rawOptions,\r\n    // overwrite with vnode-based transforms\r\n    nodeTransforms: [\r\n      ...vnodeNodeTransforms,\r\n      ...(rawOptions.nodeTransforms || []),\r\n    ],\r\n    directiveTransforms: {\r\n      ...vnodeDirectiveTransforms,\r\n      ...(rawOptions.directiveTransforms || {}),\r\n    },\r\n  }\r\n\r\n  // wrap the children with a wrapper template for proper children treatment.\r\n  // important: provide v-slot=\"props\" and v-for=\"exp\" on the wrapper for\r\n  // proper scope analysis\r\n  const wrapperProps: TemplateNode['props'] = []\r\n  if (slotProps) {\r\n    wrapperProps.push({\r\n      type: NodeTypes.DIRECTIVE,\r\n      name: 'slot',\r\n      exp: slotProps,\r\n      arg: undefined,\r\n      modifiers: [],\r\n      loc: locStub,\r\n    })\r\n  }\r\n  if (vFor) {\r\n    wrapperProps.push(extend({}, vFor))\r\n  }\r\n  const wrapperNode: TemplateNode = {\r\n    type: NodeTypes.ELEMENT,\r\n    ns: Namespaces.HTML,\r\n    tag: 'template',\r\n    tagType: ElementTypes.TEMPLATE,\r\n    props: wrapperProps,\r\n    children,\r\n    loc: locStub,\r\n    codegenNode: undefined,\r\n  }\r\n  subTransform(wrapperNode, subOptions, parentContext)\r\n  return createReturnStatement(children)\r\n}\r\n\r\nfunction subTransform(\r\n  node: TemplateChildNode,\r\n  options: TransformOptions,\r\n  parentContext: TransformContext,\r\n) {\r\n  const childRoot = createRoot([node])\r\n  const childContext = createTransformContext(childRoot, options)\r\n  // this sub transform is for vnode fallback branch so it should be handled\r\n  // like normal render functions\r\n  childContext.ssr = false\r\n  // inherit parent scope analysis state\r\n  childContext.scopes = { ...parentContext.scopes }\r\n  childContext.identifiers = { ...parentContext.identifiers }\r\n  childContext.imports = parentContext.imports\r\n  // traverse\r\n  traverseNode(childRoot, childContext)\r\n  // merge helpers/components/directives into parent context\r\n  ;(['helpers', 'components', 'directives'] as const).forEach(key => {\r\n    childContext[key].forEach((value: any, helperKey: any) => {\r\n      if (key === 'helpers') {\r\n        const parentCount = parentContext.helpers.get(helperKey)\r\n        if (parentCount === undefined) {\r\n          parentContext.helpers.set(helperKey, value)\r\n        } else {\r\n          parentContext.helpers.set(helperKey, value + parentCount)\r\n        }\r\n      } else {\r\n        ;(parentContext[key] as any).add(value)\r\n      }\r\n    })\r\n  })\r\n  // imports/hoists are not merged because:\r\n  // - imports are only used for asset urls and should be consistent between\r\n  //   node/client branches\r\n  // - hoists are not enabled for the client branch here\r\n}\r\n\r\nfunction clone(v: any): any {\r\n  if (isArray(v)) {\r\n    return v.map(clone)\r\n  } else if (isPlainObject(v)) {\r\n    const res: any = {}\r\n    for (const key in v) {\r\n      res[key] = clone(v[key as keyof typeof v])\r\n    }\r\n    return res\r\n  } else {\r\n    return v\r\n  }\r\n}\r\n","import {\r\n  type BlockStatement,\r\n  type CallExpression,\r\n  type CompilerOptions,\r\n  ElementTypes,\r\n  type IfStatement,\r\n  NodeTypes,\r\n  type RootNode,\r\n  type TemplateChildNode,\r\n  type TemplateLiteral,\r\n  createBlockStatement,\r\n  createCallExpression,\r\n  createCompoundExpression,\r\n  createRoot,\r\n  createSimpleExpression,\r\n  createTemplateLiteral,\r\n  createTransformContext,\r\n  isText,\r\n  processExpression,\r\n} from '@vue/compiler-dom'\r\nimport { escapeHtml, isString } from '@vue/shared'\r\nimport { SSR_INTERPOLATE, ssrHelpers } from './runtimeHelpers'\r\nimport { ssrProcessIf } from './transforms/ssrVIf'\r\nimport { ssrProcessFor } from './transforms/ssrVFor'\r\nimport { ssrProcessSlotOutlet } from './transforms/ssrTransformSlotOutlet'\r\nimport { ssrProcessComponent } from './transforms/ssrTransformComponent'\r\nimport { ssrProcessElement } from './transforms/ssrTransformElement'\r\nimport { SSRErrorCodes, createSSRCompilerError } from './errors'\r\n\r\n// Because SSR codegen output is completely different from client-side output\r\n// (e.g. multiple elements can be concatenated into a single template literal\r\n// instead of each getting a corresponding call), we need to apply an extra\r\n// transform pass to convert the template AST into a fresh JS AST before\r\n// passing it to codegen.\r\n\r\nexport function ssrCodegenTransform(ast: RootNode, options: CompilerOptions) {\r\n  const context = createSSRTransformContext(ast, options)\r\n\r\n  // inject SFC <style> CSS variables\r\n  // we do this instead of inlining the expression to ensure the vars are\r\n  // only resolved once per render\r\n  if (options.ssrCssVars) {\r\n    const cssContext = createTransformContext(createRoot([]), options)\r\n    const varsExp = processExpression(\r\n      createSimpleExpression(options.ssrCssVars, false),\r\n      cssContext,\r\n    )\r\n    context.body.push(\r\n      createCompoundExpression([`const _cssVars = { style: `, varsExp, `}`]),\r\n    )\r\n    Array.from(cssContext.helpers.keys()).forEach(helper => {\r\n      ast.helpers.add(helper)\r\n    })\r\n  }\r\n\r\n  const isFragment =\r\n    ast.children.length > 1 && ast.children.some(c => !isText(c))\r\n  processChildren(ast, context, isFragment)\r\n  ast.codegenNode = createBlockStatement(context.body)\r\n\r\n  // Finalize helpers.\r\n  // We need to separate helpers imported from 'vue' vs. '@vue/server-renderer'\r\n  ast.ssrHelpers = Array.from(\r\n    new Set([\r\n      ...Array.from(ast.helpers).filter(h => h in ssrHelpers),\r\n      ...context.helpers,\r\n    ]),\r\n  )\r\n\r\n  ast.helpers = new Set(Array.from(ast.helpers).filter(h => !(h in ssrHelpers)))\r\n}\r\n\r\nexport type SSRTransformContext = ReturnType<typeof createSSRTransformContext>\r\n\r\nfunction createSSRTransformContext(\r\n  root: RootNode,\r\n  options: CompilerOptions,\r\n  helpers: Set<symbol> = new Set(),\r\n  withSlotScopeId = false,\r\n) {\r\n  const body: BlockStatement['body'] = []\r\n  let currentString: TemplateLiteral | null = null\r\n\r\n  return {\r\n    root,\r\n    options,\r\n    body,\r\n    helpers,\r\n    withSlotScopeId,\r\n    onError:\r\n      options.onError ||\r\n      (e => {\r\n        throw e\r\n      }),\r\n    helper<T extends symbol>(name: T): T {\r\n      helpers.add(name)\r\n      return name\r\n    },\r\n    pushStringPart(part: TemplateLiteral['elements'][0]) {\r\n      if (!currentString) {\r\n        const currentCall = createCallExpression(`_push`)\r\n        body.push(currentCall)\r\n        currentString = createTemplateLiteral([])\r\n        currentCall.arguments.push(currentString)\r\n      }\r\n      const bufferedElements = currentString.elements\r\n      const lastItem = bufferedElements[bufferedElements.length - 1]\r\n      if (isString(part) && isString(lastItem)) {\r\n        bufferedElements[bufferedElements.length - 1] += part\r\n      } else {\r\n        bufferedElements.push(part)\r\n      }\r\n    },\r\n    pushStatement(statement: IfStatement | CallExpression) {\r\n      // close current string\r\n      currentString = null\r\n      body.push(statement)\r\n    },\r\n  }\r\n}\r\n\r\nfunction createChildContext(\r\n  parent: SSRTransformContext,\r\n  withSlotScopeId = parent.withSlotScopeId,\r\n): SSRTransformContext {\r\n  // ensure child inherits parent helpers\r\n  return createSSRTransformContext(\r\n    parent.root,\r\n    parent.options,\r\n    parent.helpers,\r\n    withSlotScopeId,\r\n  )\r\n}\r\n\r\ninterface Container {\r\n  children: TemplateChildNode[]\r\n}\r\n\r\nexport function processChildren(\r\n  parent: Container,\r\n  context: SSRTransformContext,\r\n  asFragment = false,\r\n  disableNestedFragments = false,\r\n) {\r\n  if (asFragment) {\r\n    context.pushStringPart(`<!--[-->`)\r\n  }\r\n  const { children } = parent\r\n  for (let i = 0; i < children.length; i++) {\r\n    const child = children[i]\r\n    switch (child.type) {\r\n      case NodeTypes.ELEMENT:\r\n        switch (child.tagType) {\r\n          case ElementTypes.ELEMENT:\r\n            ssrProcessElement(child, context)\r\n            break\r\n          case ElementTypes.COMPONENT:\r\n            ssrProcessComponent(child, context, parent)\r\n            break\r\n          case ElementTypes.SLOT:\r\n            ssrProcessSlotOutlet(child, context)\r\n            break\r\n          case ElementTypes.TEMPLATE:\r\n            // TODO\r\n            break\r\n          default:\r\n            context.onError(\r\n              createSSRCompilerError(\r\n                SSRErrorCodes.X_SSR_INVALID_AST_NODE,\r\n                (child as any).loc,\r\n              ),\r\n            )\r\n            // make sure we exhaust all possible types\r\n            const exhaustiveCheck: never = child\r\n            return exhaustiveCheck\r\n        }\r\n        break\r\n      case NodeTypes.TEXT:\r\n        context.pushStringPart(escapeHtml(child.content))\r\n        break\r\n      case NodeTypes.COMMENT:\r\n        // no need to escape comment here because the AST can only\r\n        // contain valid comments.\r\n        context.pushStringPart(`<!--${child.content}-->`)\r\n        break\r\n      case NodeTypes.INTERPOLATION:\r\n        context.pushStringPart(\r\n          createCallExpression(context.helper(SSR_INTERPOLATE), [\r\n            child.content,\r\n          ]),\r\n        )\r\n        break\r\n      case NodeTypes.IF:\r\n        ssrProcessIf(child, context, disableNestedFragments)\r\n        break\r\n      case NodeTypes.FOR:\r\n        ssrProcessFor(child, context, disableNestedFragments)\r\n        break\r\n      case NodeTypes.IF_BRANCH:\r\n        // no-op - handled by ssrProcessIf\r\n        break\r\n      case NodeTypes.TEXT_CALL:\r\n      case NodeTypes.COMPOUND_EXPRESSION:\r\n        // no-op - these two types can never appear as template child node since\r\n        // `transformText` is not used during SSR compile.\r\n        break\r\n      default:\r\n        context.onError(\r\n          createSSRCompilerError(\r\n            SSRErrorCodes.X_SSR_INVALID_AST_NODE,\r\n            (child as any).loc,\r\n          ),\r\n        )\r\n        // make sure we exhaust all possible types\r\n        const exhaustiveCheck: never = child\r\n        return exhaustiveCheck\r\n    }\r\n  }\r\n  if (asFragment) {\r\n    context.pushStringPart(`<!--]-->`)\r\n  }\r\n}\r\n\r\nexport function processChildrenAsStatement(\r\n  parent: Container,\r\n  parentContext: SSRTransformContext,\r\n  asFragment = false,\r\n  withSlotScopeId = parentContext.withSlotScopeId,\r\n): BlockStatement {\r\n  const childContext = createChildContext(parentContext, withSlotScopeId)\r\n  processChildren(parent, childContext, asFragment)\r\n  return createBlockStatement(childContext.body)\r\n}\r\n","import {\r\n  DOMErrorCodes,\r\n  type DirectiveTransform,\r\n  ElementTypes,\r\n  type ExpressionNode,\r\n  NodeTypes,\r\n  type PlainElementNode,\r\n  createCallExpression,\r\n  createConditionalExpression,\r\n  createDOMCompilerError,\r\n  createInterpolation,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  findProp,\r\n  hasDynamicKeyVBind,\r\n  transformModel,\r\n} from '@vue/compiler-dom'\r\nimport {\r\n  SSR_INCLUDE_BOOLEAN_ATTR,\r\n  SSR_LOOSE_CONTAIN,\r\n  SSR_LOOSE_EQUAL,\r\n  SSR_RENDER_DYNAMIC_MODEL,\r\n} from '../runtimeHelpers'\r\nimport type { DirectiveTransformResult } from 'packages/compiler-core/src/transform'\r\n\r\nexport const ssrTransformModel: DirectiveTransform = (dir, node, context) => {\r\n  const model = dir.exp!\r\n\r\n  function checkDuplicatedValue() {\r\n    const value = findProp(node, 'value')\r\n    if (value) {\r\n      context.onError(\r\n        createDOMCompilerError(\r\n          DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE,\r\n          value.loc,\r\n        ),\r\n      )\r\n    }\r\n  }\r\n\r\n  function processOption(plainNode: PlainElementNode) {\r\n    if (plainNode.tag === 'option') {\r\n      if (plainNode.props.findIndex(p => p.name === 'selected') === -1) {\r\n        const value = findValueBinding(plainNode)\r\n        plainNode.ssrCodegenNode!.elements.push(\r\n          createConditionalExpression(\r\n            createCallExpression(context.helper(SSR_INCLUDE_BOOLEAN_ATTR), [\r\n              createConditionalExpression(\r\n                createCallExpression(`Array.isArray`, [model]),\r\n                createCallExpression(context.helper(SSR_LOOSE_CONTAIN), [\r\n                  model,\r\n                  value,\r\n                ]),\r\n                createCallExpression(context.helper(SSR_LOOSE_EQUAL), [\r\n                  model,\r\n                  value,\r\n                ]),\r\n              ),\r\n            ]),\r\n            createSimpleExpression(' selected', true),\r\n            createSimpleExpression('', true),\r\n            false /* no newline */,\r\n          ),\r\n        )\r\n      }\r\n    } else if (plainNode.tag === 'optgroup') {\r\n      plainNode.children.forEach(option =>\r\n        processOption(option as PlainElementNode),\r\n      )\r\n    }\r\n  }\r\n\r\n  if (node.tagType === ElementTypes.ELEMENT) {\r\n    const res: DirectiveTransformResult = { props: [] }\r\n    const defaultProps = [\r\n      // default value binding for text type inputs\r\n      createObjectProperty(`value`, model),\r\n    ]\r\n    if (node.tag === 'input') {\r\n      const type = findProp(node, 'type')\r\n      if (type) {\r\n        const value = findValueBinding(node)\r\n        if (type.type === NodeTypes.DIRECTIVE) {\r\n          // dynamic type\r\n          res.ssrTagParts = [\r\n            createCallExpression(context.helper(SSR_RENDER_DYNAMIC_MODEL), [\r\n              type.exp!,\r\n              model,\r\n              value,\r\n            ]),\r\n          ]\r\n        } else if (type.value) {\r\n          // static type\r\n          switch (type.value.content) {\r\n            case 'radio':\r\n              res.props = [\r\n                createObjectProperty(\r\n                  `checked`,\r\n                  createCallExpression(context.helper(SSR_LOOSE_EQUAL), [\r\n                    model,\r\n                    value,\r\n                  ]),\r\n                ),\r\n              ]\r\n              break\r\n            case 'checkbox':\r\n              const trueValueBinding = findProp(node, 'true-value')\r\n              if (trueValueBinding) {\r\n                const trueValue =\r\n                  trueValueBinding.type === NodeTypes.ATTRIBUTE\r\n                    ? JSON.stringify(trueValueBinding.value!.content)\r\n                    : trueValueBinding.exp!\r\n                res.props = [\r\n                  createObjectProperty(\r\n                    `checked`,\r\n                    createCallExpression(context.helper(SSR_LOOSE_EQUAL), [\r\n                      model,\r\n                      trueValue,\r\n                    ]),\r\n                  ),\r\n                ]\r\n              } else {\r\n                res.props = [\r\n                  createObjectProperty(\r\n                    `checked`,\r\n                    createConditionalExpression(\r\n                      createCallExpression(`Array.isArray`, [model]),\r\n                      createCallExpression(context.helper(SSR_LOOSE_CONTAIN), [\r\n                        model,\r\n                        value,\r\n                      ]),\r\n                      model,\r\n                    ),\r\n                  ),\r\n                ]\r\n              }\r\n              break\r\n            case 'file':\r\n              context.onError(\r\n                createDOMCompilerError(\r\n                  DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT,\r\n                  dir.loc,\r\n                ),\r\n              )\r\n              break\r\n            default:\r\n              checkDuplicatedValue()\r\n              res.props = defaultProps\r\n              break\r\n          }\r\n        }\r\n      } else if (hasDynamicKeyVBind(node)) {\r\n        // dynamic type due to dynamic v-bind\r\n        // NOOP, handled in ssrTransformElement due to need to rewrite\r\n        // the entire props expression\r\n      } else {\r\n        // text type\r\n        checkDuplicatedValue()\r\n        res.props = defaultProps\r\n      }\r\n    } else if (node.tag === 'textarea') {\r\n      checkDuplicatedValue()\r\n      node.children = [createInterpolation(model, model.loc)]\r\n    } else if (node.tag === 'select') {\r\n      node.children.forEach(child => {\r\n        if (child.type === NodeTypes.ELEMENT) {\r\n          processOption(child as PlainElementNode)\r\n        }\r\n      })\r\n    } else {\r\n      context.onError(\r\n        createDOMCompilerError(\r\n          DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT,\r\n          dir.loc,\r\n        ),\r\n      )\r\n    }\r\n\r\n    return res\r\n  } else {\r\n    // component v-model\r\n    return transformModel(dir, node, context)\r\n  }\r\n}\r\n\r\nfunction findValueBinding(node: PlainElementNode): ExpressionNode {\r\n  const valueBinding = findProp(node, 'value')\r\n  return valueBinding\r\n    ? valueBinding.type === NodeTypes.DIRECTIVE\r\n      ? valueBinding.exp!\r\n      : createSimpleExpression(valueBinding.value!.content, true)\r\n    : createSimpleExpression(`null`, false)\r\n}\r\n","import {\r\n  DOMErrorCodes,\r\n  type DirectiveTransform,\r\n  createConditionalExpression,\r\n  createDOMCompilerError,\r\n  createObjectExpression,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n} from '@vue/compiler-dom'\r\n\r\nexport const ssrTransformShow: DirectiveTransform = (dir, node, context) => {\r\n  if (!dir.exp) {\r\n    context.onError(\r\n      createDOMCompilerError(DOMErrorCodes.X_V_SHOW_NO_EXPRESSION),\r\n    )\r\n  }\r\n  return {\r\n    props: [\r\n      createObjectProperty(\r\n        `style`,\r\n        createConditionalExpression(\r\n          dir.exp!,\r\n          createSimpleExpression(`null`, false),\r\n          createObjectExpression([\r\n            createObjectProperty(\r\n              `display`,\r\n              createSimpleExpression(`none`, true),\r\n            ),\r\n          ]),\r\n          false /* no newline */,\r\n        ),\r\n      ),\r\n    ],\r\n  }\r\n}\r\n","import {\r\n  ElementTypes,\r\n  type NodeTransform,\r\n  NodeTypes,\r\n  type ParentNode,\r\n  type RootNode,\r\n  type TemplateChildNode,\r\n  createSimpleExpression,\r\n  findDir,\r\n  locStub,\r\n} from '@vue/compiler-dom'\r\n\r\nconst filterChild = (node: ParentNode) =>\r\n  node.children.filter(n => n.type !== NodeTypes.COMMENT)\r\n\r\nconst hasSingleChild = (node: ParentNode): boolean =>\r\n  filterChild(node).length === 1\r\n\r\nexport const ssrInjectFallthroughAttrs: NodeTransform = (node, context) => {\r\n  // _attrs is provided as a function argument.\r\n  // mark it as a known identifier so that it doesn't get prefixed by\r\n  // transformExpression.\r\n  if (node.type === NodeTypes.ROOT) {\r\n    context.identifiers._attrs = 1\r\n  }\r\n\r\n  if (\r\n    node.type === NodeTypes.ELEMENT &&\r\n    node.tagType === ElementTypes.COMPONENT &&\r\n    (node.tag === 'transition' ||\r\n      node.tag === 'Transition' ||\r\n      node.tag === 'KeepAlive' ||\r\n      node.tag === 'keep-alive')\r\n  ) {\r\n    const rootChildren = filterChild(context.root)\r\n    if (rootChildren.length === 1 && rootChildren[0] === node) {\r\n      if (hasSingleChild(node)) {\r\n        injectFallthroughAttrs(node.children[0])\r\n      }\r\n      return\r\n    }\r\n  }\r\n\r\n  const parent = context.parent\r\n  if (!parent || parent.type !== NodeTypes.ROOT) {\r\n    return\r\n  }\r\n\r\n  if (node.type === NodeTypes.IF_BRANCH && hasSingleChild(node)) {\r\n    // detect cases where the parent v-if is not the only root level node\r\n    let hasEncounteredIf = false\r\n    for (const c of filterChild(parent)) {\r\n      if (\r\n        c.type === NodeTypes.IF ||\r\n        (c.type === NodeTypes.ELEMENT && findDir(c, 'if'))\r\n      ) {\r\n        // multiple root v-if\r\n        if (hasEncounteredIf) return\r\n        hasEncounteredIf = true\r\n      } else if (\r\n        // node before v-if\r\n        !hasEncounteredIf ||\r\n        // non else nodes\r\n        !(c.type === NodeTypes.ELEMENT && findDir(c, /else/, true))\r\n      ) {\r\n        return\r\n      }\r\n    }\r\n    injectFallthroughAttrs(node.children[0])\r\n  } else if (hasSingleChild(parent)) {\r\n    injectFallthroughAttrs(node)\r\n  }\r\n}\r\n\r\nfunction injectFallthroughAttrs(node: RootNode | TemplateChildNode) {\r\n  if (\r\n    node.type === NodeTypes.ELEMENT &&\r\n    (node.tagType === ElementTypes.ELEMENT ||\r\n      node.tagType === ElementTypes.COMPONENT) &&\r\n    !findDir(node, 'for')\r\n  ) {\r\n    node.props.push({\r\n      type: NodeTypes.DIRECTIVE,\r\n      name: 'bind',\r\n      arg: undefined,\r\n      exp: createSimpleExpression(`_attrs`, false),\r\n      modifiers: [],\r\n      loc: locStub,\r\n    })\r\n  }\r\n}\r\n","import {\r\n  ElementTypes,\r\n  type NodeTransform,\r\n  NodeTypes,\r\n  type RootNode,\r\n  type TemplateChildNode,\r\n  createSimpleExpression,\r\n  findDir,\r\n  locStub,\r\n} from '@vue/compiler-dom'\r\n\r\nexport const ssrInjectCssVars: NodeTransform = (node, context) => {\r\n  if (!context.ssrCssVars) {\r\n    return\r\n  }\r\n\r\n  // _cssVars is initialized once per render function\r\n  // the code is injected in ssrCodegenTransform when creating the\r\n  // ssr transform context\r\n  if (node.type === NodeTypes.ROOT) {\r\n    context.identifiers._cssVars = 1\r\n  }\r\n\r\n  const parent = context.parent\r\n  if (!parent || parent.type !== NodeTypes.ROOT) {\r\n    return\r\n  }\r\n\r\n  if (node.type === NodeTypes.IF_BRANCH) {\r\n    for (const child of node.children) {\r\n      injectCssVars(child)\r\n    }\r\n  } else {\r\n    injectCssVars(node)\r\n  }\r\n}\r\n\r\nfunction injectCssVars(node: RootNode | TemplateChildNode) {\r\n  if (\r\n    node.type === NodeTypes.ELEMENT &&\r\n    (node.tagType === ElementTypes.ELEMENT ||\r\n      node.tagType === ElementTypes.COMPONENT) &&\r\n    !findDir(node, 'for')\r\n  ) {\r\n    if (node.tag === 'suspense' || node.tag === 'Suspense') {\r\n      for (const child of node.children) {\r\n        if (\r\n          child.type === NodeTypes.ELEMENT &&\r\n          child.tagType === ElementTypes.TEMPLATE\r\n        ) {\r\n          // suspense slot\r\n          child.children.forEach(injectCssVars)\r\n        } else {\r\n          injectCssVars(child)\r\n        }\r\n      }\r\n    } else {\r\n      node.props.push({\r\n        type: NodeTypes.DIRECTIVE,\r\n        name: 'bind',\r\n        arg: undefined,\r\n        exp: createSimpleExpression(`_cssVars`, false),\r\n        modifiers: [],\r\n        loc: locStub,\r\n      })\r\n    }\r\n  }\r\n}\r\n","import {\r\n  type CodegenResult,\r\n  type CompilerOptions,\r\n  type RootNode,\r\n  baseParse,\r\n  generate,\r\n  noopDirectiveTransform,\r\n  parserOptions,\r\n  trackSlotScopes,\r\n  trackVForSlotScopes,\r\n  transform,\r\n  transformBind,\r\n  transformExpression,\r\n  transformOn,\r\n  transformStyle,\r\n} from '@vue/compiler-dom'\r\nimport { ssrCodegenTransform } from './ssrCodegenTransform'\r\nimport { ssrTransformElement } from './transforms/ssrTransformElement'\r\nimport {\r\n  rawOptionsMap,\r\n  ssrTransformComponent,\r\n} from './transforms/ssrTransformComponent'\r\nimport { ssrTransformSlotOutlet } from './transforms/ssrTransformSlotOutlet'\r\nimport { ssrTransformIf } from './transforms/ssrVIf'\r\nimport { ssrTransformFor } from './transforms/ssrVFor'\r\nimport { ssrTransformModel } from './transforms/ssrVModel'\r\nimport { ssrTransformShow } from './transforms/ssrVShow'\r\nimport { ssrInjectFallthroughAttrs } from './transforms/ssrInjectFallthroughAttrs'\r\nimport { ssrInjectCssVars } from './transforms/ssrInjectCssVars'\r\n\r\nexport function compile(\r\n  source: string | RootNode,\r\n  options: CompilerOptions = {},\r\n): CodegenResult {\r\n  options = {\r\n    ...options,\r\n    ...parserOptions,\r\n    ssr: true,\r\n    inSSR: true,\r\n    scopeId: options.mode === 'function' ? null : options.scopeId,\r\n    // always prefix since compiler-ssr doesn't have size concern\r\n    prefixIdentifiers: true,\r\n    // disable optimizations that are unnecessary for ssr\r\n    cacheHandlers: false,\r\n    hoistStatic: false,\r\n  }\r\n\r\n  const ast = typeof source === 'string' ? baseParse(source, options) : source\r\n\r\n  // Save raw options for AST. This is needed when performing sub-transforms\r\n  // on slot vnode branches.\r\n  rawOptionsMap.set(ast, options)\r\n\r\n  transform(ast, {\r\n    ...options,\r\n    hoistStatic: false,\r\n    nodeTransforms: [\r\n      ssrTransformIf,\r\n      ssrTransformFor,\r\n      trackVForSlotScopes,\r\n      transformExpression,\r\n      ssrTransformSlotOutlet,\r\n      ssrInjectFallthroughAttrs,\r\n      ssrInjectCssVars,\r\n      ssrTransformElement,\r\n      ssrTransformComponent,\r\n      trackSlotScopes,\r\n      transformStyle,\r\n      ...(options.nodeTransforms || []), // user transforms\r\n    ],\r\n    directiveTransforms: {\r\n      // reusing core v-bind\r\n      bind: transformBind,\r\n      on: transformOn,\r\n      // model and show have dedicated SSR handling\r\n      model: ssrTransformModel,\r\n      show: ssrTransformShow,\r\n      // the following are ignored during SSR\r\n      // on: noopDirectiveTransform,\r\n      cloak: noopDirectiveTransform,\r\n      once: noopDirectiveTransform,\r\n      memo: noopDirectiveTransform,\r\n      ...(options.directiveTransforms || {}), // user transforms\r\n    },\r\n  })\r\n\r\n  // traverse the template AST and convert into SSR codegen AST\r\n  // by replacing ast.codegenNode.\r\n  ssrCodegenTransform(ast, options)\r\n\r\n  return generate(ast, options)\r\n}\r\n"],"names":["registerRuntimeHelpers","createStructuralDirectiveTransform","processIf","createIfStatement","createBlockStatement","createCallExpression","processFor","createFunctionExpression","createForLoopParams","isSlotOutlet","processSlotOutlet","resolveComponentType","TRANSITION","TRANSITION_GROUP","createCompilerError","findProp","createSimpleExpression","wipMap","buildSlots","hasDynamicKeyVBind","isBuiltInDirective","buildProps","createAssignmentExpression","createConditionalExpression","createSequenceExpression","MERGE_PROPS","createInterpolation","isStaticExp","propsToAttrMap","isBooleanAttr","isSSRSafeAttrName","escapeHtml","createTemplateLiteral","buildDirectiveArgs","isStaticArgOf","createArrayExpression","NO","isObject","RESOLVE_DYNAMIC_COMPONENT","isSymbol","SUSPENSE","stringifyExpression","CREATE_VNODE","TELEPORT","getBaseTransformPreset","DOMNodeTransforms","DOMDirectiveTransforms","locStub","extend","createReturnStatement","createRoot","createTransformContext","traverseNode","isArray","isPlainObject","processExpression","createCompoundExpression","isText","isString","exhaustiveCheck","createDOMCompilerError","createObjectProperty","transformModel","createObjectExpression","findDir","parserOptions","baseParse","transform","trackVForSlotScopes","transformExpression","trackSlotScopes","transformStyle","transformBind","transformOn","noopDirectiveTransform","generate"],"mappings":"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"}